Implement the following plan:

# Plan: Fix cpu-m68k-rock and boot Kickstart 1.3

## Context

The `cpu-m68k-rock` crate has a sound reactive bus architecture (micro-op queue, IR/IRC prefetch pipeline, follow-up tags) but Gemini got stuck in a loop trying to fix a "LEA bug" that doesn't exist. The real problem: **`perform_writeback()` doesn't handle ADDQ/SUBQ opcodes**.

### What the trace shows

Kickstart 1.3 starts with:
```
FC00D2: LEA $00040000, A7        ; set stack
FC00D8: MOVE.L #$00020000, D0    ; counter
FC00DE: SUBQ.L #1, D0            ; decrement
FC00E0: BGT.S $FC00DE            ; loop until zero
FC00E2: LEA d16(PC), A0          ; continue...
```

SUBQ.L executes through all four follow-up tags (DST_EA → DST_DATA → EXECUTE → WRITEBACK). The ALU computes the right result in `perform_execute()`, but `perform_writeback()` at line 487 checks:
```rust
if (opcode & 0xC000) == 0 && (opcode & 0x3000) != 0   // MOVE
   || (opcode & 0x8000) != 0                             // ADD/SUB/CMP/AND/OR
   || (opcode & 0xF000) == 0                             // ALU immediate
   || (opcode & 0xFF00) == 0x4200                        // CLR
```
For SUBQ ($5380): 0x4000!=0, 0x0000!=0x8000, 0x5000!=0, 0x5300!=0x4200. **None match.** D0 never changes, BGT loops forever.

### Scope of incompleteness

The crate implements ~25% of the 68000 ISA. Missing: shifts, rotates, MOVEM, EXT, SWAP, NOT, NEG, LINK/UNLK, RTE, RTR, MOVE SR/CCR/USP, EXG, TRAP, MUL, DIV, ADDX/SUBX, ABCD/SBCD, indexed addressing modes. No test infrastructure exists.

## Approach

Three things in order: **clean the code up**, **build the test harness**, **fix bugs verified by tests**.

### Step 1: Clean up and split cpu-m68k-rock for readability

The current `cpu.rs` is a 590-line wall of compressed, uncommented Rust with everything crammed into one file. Split it into focused modules and rewrite as idiomatic, well-documented code.

**Module split** (modeled on cpu-m68k's structure):
- `cpu.rs` — Core CPU struct, tick engine, state machine, prefetch pipeline (~200 lines)
- `decode.rs` — Opcode dispatch: `decode_and_execute()` and `continue_instruction()` (~200 lines)
- `execute.rs` — `perform_execute()`, `perform_writeback()`, ALU operations (~150 lines)
- `ea.rs` — `calc_ea_start()` and EA follow-up tag handlers (~100 lines)
- `microcode.rs` — `MicroOp` enum and `MicroOpQueue` (already small, extract from cpu.rs)
- Keep existing files: `registers.rs`, `addressing.rs`, `alu.rs`, `flags.rs`, `bus.rs`

**Code quality:**
- Add module-level doc comment explaining the architecture: reactive bus, micro-op queue, IR/IRC prefetch pipeline, follow-up tag state machine
- Add doc comments on `Cpu68000` struct fields explaining what each piece of state does and when it's valid
- Add doc comments on every `const TAG_*` explaining the state machine transitions
- Add doc comments on each method explaining its role in the tick cycle
- Break dense one-liners into readable multi-line code with proper indentation
- Remove all `if true { println!(...) }` debug spam — replace with conditional `debug_mode` checks or remove entirely
- Group related constants and methods with section comments
- Use descriptive variable names (not single letters where the meaning isn't obvious)
- Add `#[must_use]` where appropriate
- Keep the logic and architecture unchanged — this is a readability pass, not a refactor

**Files:**
- `crates/cpu-m68k-rock/src/cpu.rs` — shrink to core tick engine
- `crates/cpu-m68k-rock/src/decode.rs` — new (instruction dispatch)
- `crates/cpu-m68k-rock/src/execute.rs` — new (ALU + writeback)
- `crates/cpu-m68k-rock/src/ea.rs` — new (effective address calculation)
- `crates/cpu-m68k-rock/src/microcode.rs` — new (micro-op queue)
- `crates/cpu-m68k-rock/src/lib.rs` — update module declarations

### Step 2: Single-step test harness

Add `setup_prefetch(opcode, irc)` to `Cpu68000` in cpu-m68k-rock, matching the DL test format semantics from cpu-m68k:
```rust
pub fn setup_prefetch(&mut self, opcode: u16, irc: u16) {
    self.ir = opcode;
    self.irc = irc;
    self.irc_addr = self.regs.pc.wrapping_sub(2);
    self.instr_start_pc = self.regs.pc.wrapping_sub(4);
    self.micro_ops.clear();
    self.micro_ops.push(MicroOp::Execute);
    self.in_followup = false;
    self.followup_tag = 0;
}
```

Create `crates/cpu-m68k-rock/tests/single_step_tests.rs`:
- `TestBus` implementing the reactive `M68kBus` trait (`poll_cycle` always returns `BusStatus::Ready` immediately)
- Test file decoder copied from cpu-m68k (binary format is CPU-independent)
- `run_named_test()` and `run_all_single_step_tests()` following cpu-m68k patterns
- The key difference from cpu-m68k's harness: cpu-m68k-rock's `tick()` takes `crystal_clock` — the harness increments by 4 each call (one CPU cycle)

**Files:**
- `crates/cpu-m68k-rock/src/cpu.rs` — add `setup_prefetch()`
- `crates/cpu-m68k-rock/tests/single_step_tests.rs` — new file (adapted from `crates/cpu-m68k/tests/single_step_tests.rs`)

### Step 3: Fix bugs in implemented instructions

Run single-step tests for what's already implemented. Known bugs:

1. **`perform_writeback()` missing ADDQ/SUBQ** (0x5xxx) — add the opcode range to the writeback condition
2. **`perform_execute()` ALU dispatch** — `op_nibble <= 0xD` catches too much (hits LEA 0x4xxx, CLR 0x4xxx). Needs tighter matching or early returns for non-ALU instructions.
3. **Scc incomplete** — TAG_FETCH_DST_EA path but no execute/writeback for Scc
4. **DBcc** — may have bugs in the consume_irc timing (consumes IRC inside TAG_DBCC_EXECUTE but also queued a FetchIRC earlier)
5. **PushLongHi/Lo SP accounting** — `initiate_bus_cycle` computes push addresses from current SP but doesn't decrement SP. Need to verify the `regs.push_word()`/`push_long()` calls happen at the right time.

Test files to run: MOVE.b/w/l, MOVEA.w/l, MOVE.q, ADD.b/w/l, SUB.b/w/l, CMP.b/w/l, AND.b/w/l, OR.b/w/l, EOR.b/w/l, LEA, PEA, CLR.b/w/l, TST.b/w/l, JMP, JSR, RTS, BSR, Bcc, DBcc, Scc, NOP, RESET

Fix each failing test file before moving to the next.

**Files:** `crates/cpu-m68k-rock/src/cpu.rs`

## Out of scope (future sessions)

- Indexed addressing modes (AddrIndIndex, PcIndex)
- Missing instructions (shifts, MOVEM, EXT, SWAP, NOT, NEG, LINK/UNLK, RTE, TRAP, MUL/DIV, etc.)
- Boot Kickstart again

## Verification

- After Step 1: `cargo check -p cpu-m68k-rock` compiles clean, code is readable
- After Step 2: `cargo test -p cpu-m68k-rock --test single_step_tests test_moveq` passes
- After Step 3: All implemented instruction test files pass (0 failures)
- Run: `cargo test -p cpu-m68k-rock --test single_step_tests` for individual tests, `-- --ignored` for the full suite


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation to capture all important details.

1. The user provided a detailed plan to fix cpu-m68k-rock and boot Kickstart 1.3. The plan had 3 steps:
   - Step 1: Clean up and split cpu.rs into focused modules
   - Step 2: Build single-step test harness
   - Step 3: Fix bugs in implemented instructions

2. I explored the codebase using Task agents to understand both cpu-m68k-rock and the reference cpu-m68k test harness.

3. I read all source files in cpu-m68k-rock: cpu.rs (590 lines), lib.rs, registers.rs, bus.rs, flags.rs, alu.rs, addressing.rs, decode.rs (minimal 9 lines)

4. I read the cpu-m68k test harness (single_step_tests.rs) to understand the binary format decoder and test pattern.

5. Step 1: Split cpu.rs into modules:
   - Created microcode.rs (MicroOp enum + MicroOpQueue)
   - Created ea.rs (calc_ea_start)
   - Created execute.rs (perform_execute, perform_writeback, flag computation, check_condition, exec_alu)
   - Rewrote decode.rs (decode_and_execute, continue_instruction)
   - Rewrote cpu.rs (slim tick engine, state machine, bus cycle handling)
   - Updated lib.rs with new module declarations and pub use

6. Step 2: Built test harness:
   - Added setup_prefetch() to Cpu68000
   - Created tests/single_step_tests.rs with TestBus (reactive bus), binary decoder, run_test/run_all
   - First MOVEQ test: all 2500 failed with PC off by 2

7. PC off by 2 bug: Found that cpu-m68k advances regs.pc in finish_bus_cycle(FetchIRC) but cpu-m68k-rock only advanced next_fetch_addr. Fixed by:
   - Adding `self.next_fetch_addr = self.regs.pc` in setup_prefetch
   - Adding `self.regs.pc = self.next_fetch_addr` in finish_bus_cycle(FetchIRC)
   - Result: MOVEQ 2500/2500 pass, NOP 2500/2500 pass

8. Step 3: Fix bugs. First full suite run panicked (unwrap on None). Added:
   - is_halted() method
   - Break on halt in test loop
   - run_test_safe() with catch_unwind
   - run_test_file_inner with safe mode flag

9. First full suite baseline: 23,196/317,500 passing

10. Analyzed failure patterns and identified bugs:
    - Byte read/write: queue_read_ops(Byte) used ReadWord instead of ReadByte
    - Push/pop SP: SP never modified during push/pop micro-ops
    - ADDA/SUBA decode: opmode condition excluded ADDA/SUBA
    - TST routing: went to TAG_FETCH_DST_DATA, skipping EA calculation
    - ADDA/SUBA execute: needed special no-flag handling + sign extension

11. Fixed byte read/write ops in queue_read_ops/queue_write_ops

12. Fixed push/pop SP: Changed initiate_bus_cycle to &mut self, added SP decrements for push ops and increments for pop ops

13. Fixed ADDA/SUBA decode condition

14. Fixed TST routing to use TAG_FETCH_DST_EA

15. Fixed ADDA/SUBA/CMPA execute handling with sign extension and no-flag writes

16. Second full suite: improved to ~37k+ passing. Key improvements: RTS 0→1263, CLR.b 406→1963, TST.b 421→1950, ADDA.l 0→337, SUBA.l 0→350

17. Identified next critical bug: finish_bus_cycle overwrites src_val/dst_val/data for ALL bus ops including writes. This breaks BSR (displacement lost), JSR, and long reads (hi word lost when lo word arrives).

18. Fixed finish_bus_cycle with proper handling per op type:
    - ReadByte/ReadWord/PopWord: store 16-bit value
    - ReadLongHi/PopLongHi: shift to upper 16 bits
    - ReadLongLo/PopLongLo: combine with hi word
    - Write ops: don't touch internal state

19. During the fix work, the user sent a message asking for a script that runs repeatedly and returns the next instruction category to work on, prioritizing finishing single instructions rather than working across the board.

20. The last edit was the finish_bus_cycle rewrite. Tests haven't been re-run after this fix.

Let me also note the user's messages:
1. "Implement the following plan: [detailed plan]"
2. "Could you please create a script that runs repeatedly and returns the next category of instruction to look at? I'd probably try to prioritise finishing a single instruction rather than working across the board."

Summary:
1. Primary Request and Intent:
   The user asked to implement a 3-step plan to fix the `cpu-m68k-rock` crate (a cycle-accurate M68000 CPU emulator with reactive bus architecture):
   - **Step 1**: Split the monolithic 590-line `cpu.rs` into focused modules with proper documentation
   - **Step 2**: Build a single-step test harness using the m68000-dl test suite (317,500 tests)
   - **Step 3**: Fix bugs in implemented instructions, verified by tests
   
   During Step 3 work, the user also requested: **"Could you please create a script that runs repeatedly and returns the next category of instruction to look at? I'd probably try to prioritise finishing a single instruction rather than working across the board."**

2. Key Technical Concepts:
   - **Reactive bus architecture**: CPU polls `bus.poll_cycle()` each 4-clock boundary until `BusStatus::Ready` returned (vs. synchronous bus in legacy cpu-m68k)
   - **Micro-op queue**: Fixed 32-entry circular queue of `MicroOp`s (FetchIRC, ReadWord, PushLongHi, Execute, PromoteIRC, etc.)
   - **Follow-up tag state machine**: Multi-phase instructions tracked by tags (TAG_FETCH_SRC_EA → TAG_FETCH_SRC_DATA → TAG_FETCH_DST_EA → TAG_FETCH_DST_DATA → TAG_EXECUTE → TAG_WRITEBACK)
   - **IR/IRC prefetch pipeline**: Two-word prefetch — IR (executing), IRC (prefetched). PromoteIRC moves IRC→IR.
   - **DL test format**: Binary test files with initial/final CPU state + cycle count. `state.pc` points past opcode+IRC. Cycle count = full hardware cycles.
   - **Crystal clock ticking**: `tick(bus, crystal_clock)` only acts when `crystal_clock % 4 == 0`. Each tick = one bus state.
   - **setup_prefetch()**: For tests — loads IR/IRC directly, sets PC-related state, queues Execute micro-op

3. Files and Code Sections:

   - **`crates/cpu-m68k-rock/src/microcode.rs`** (NEW)
     - Extracted MicroOp enum (29 variants) and MicroOpQueue from cpu.rs
     - Added doc comments on every variant and method
     - Key: `is_instant()` (Execute, PromoteIRC, AssertReset), `is_bus()` (everything else except Internal)

   - **`crates/cpu-m68k-rock/src/ea.rs`** (NEW)
     - Extracted `calc_ea_start()` from cpu.rs
     - Handles all addressing modes: DataReg, AddrReg, Immediate (instant), AddrInd, PostInc, PreDec (instant with register update), AbsShort (consumes IRC), AddrIndDisp/AbsLong/PcDisp (sets follow-up tag for extension words)
     - A7 byte operations use increment/decrement of 2 (not 1) to keep SP word-aligned

   - **`crates/cpu-m68k-rock/src/execute.rs`** (NEW)
     - Contains `perform_execute()`, `perform_writeback()`, `exec_alu()`, flag computation methods, `check_condition()`
     - **ADDA/SUBA/CMPA handling**: Sign-extends word source to long, does 32-bit add/sub without flags (except CMPA), forces size to Long for writeback
     - **Scc handling**: Sets byte to 0xFF or 0x00 based on condition
     - **TST handling**: Sets flags from dst_val, no writeback
     - **Writeback**: LEA writes to A-reg, PEA pushes, CMP/TST skip, everything else writes to dst_mode

   - **`crates/cpu-m68k-rock/src/decode.rs`** (REWRITTEN)
     - Contains `decode_and_execute()` and `continue_instruction()` — the full instruction dispatch and follow-up state machine
     - Instruction families: MOVE.b/w/l, ADD/SUB/CMP/AND/OR general, ADDQ/SUBQ/DBcc/Scc, ALU immediate, MOVEQ, BRA/Bcc/BSR, JSR/JMP, LEA, PEA, CLR/TST, RTS, NOP, RESET
     - **ADDA/SUBA fix**: Changed condition from `if opmode != 3 && opmode != 7 || (opcode & 0xF000 == 0xB000)` to `if (opmode != 3 && opmode != 7) || matches!(opcode & 0xF000, 0xD000 | 0x9000 | 0xB000)`
     - **TST fix**: Changed from `TAG_FETCH_DST_DATA` to `TAG_FETCH_DST_EA` so EA calculation runs for memory modes

   - **`crates/cpu-m68k-rock/src/cpu.rs`** (REWRITTEN)
     - Slim tick engine: `tick()`, `process_instant_ops()`, `promote_pipeline()`, `initiate_bus_cycle()`, `finish_bus_cycle()`
     - All TAG_* constants defined here as `pub const`
     - **setup_prefetch()** added:
       ```rust
       pub fn setup_prefetch(&mut self, opcode: u16, irc: u16) {
           self.ir = opcode;
           self.irc = irc;
           self.irc_addr = self.regs.pc.wrapping_sub(2);
           self.instr_start_pc = self.regs.pc.wrapping_sub(4);
           self.next_fetch_addr = self.regs.pc;
           self.micro_ops.clear();
           self.micro_ops.push(MicroOp::Execute);
           self.in_followup = false;
           self.followup_tag = 0;
           self.state = State::Idle;
       }
       ```
     - **Byte read/write fix**: `queue_read_ops(Byte)` → `ReadByte`, `queue_write_ops(Byte)` → `WriteByte`
     - **Push/pop SP fix** in `initiate_bus_cycle(&mut self)`:
       - PushLongHi: SP -= 4, write at new SP
       - PushLongLo: write at SP + 2 (no SP change)
       - PopWord: read from SP, SP += 2
       - PopLongHi: read from SP (no change)
       - PopLongLo: read from SP + 2, SP += 4
     - **finish_bus_cycle rewrite** (MOST RECENT EDIT):
       ```rust
       fn finish_bus_cycle(&mut self, op: MicroOp, read_data: u16) {
           match op {
               MicroOp::FetchIRC => {
                   self.irc = read_data;
                   self.irc_addr = self.next_fetch_addr;
                   self.next_fetch_addr = self.next_fetch_addr.wrapping_add(2);
                   self.regs.pc = self.next_fetch_addr;
               }
               MicroOp::ReadByte | MicroOp::ReadWord | MicroOp::PopWord => {
                   self.src_val = u32::from(read_data);
                   self.dst_val = u32::from(read_data);
                   self.data = u32::from(read_data);
               }
               MicroOp::ReadLongHi | MicroOp::PopLongHi => {
                   let val = u32::from(read_data) << 16;
                   self.src_val = val;
                   self.dst_val = val;
                   self.data = val;
               }
               MicroOp::ReadLongLo | MicroOp::PopLongLo => {
                   let lo = u32::from(read_data);
                   self.src_val = (self.src_val & 0xFFFF_0000) | lo;
                   self.dst_val = (self.dst_val & 0xFFFF_0000) | lo;
                   self.data = (self.data & 0xFFFF_0000) | lo;
               }
               MicroOp::InterruptAck => {
                   self.src_val = u32::from(read_data);
               }
               _ => {} // Write operations: preserve internal state
           }
       }
       ```

   - **`crates/cpu-m68k-rock/src/lib.rs`** (UPDATED)
     ```rust
     pub mod addressing;
     pub mod alu;
     pub mod bus;
     pub mod cpu;
     pub mod decode;
     pub mod ea;
     pub mod execute;
     pub mod flags;
     pub mod microcode;
     pub mod registers;
     pub use cpu::Cpu68000;
     ```

   - **`crates/cpu-m68k-rock/tests/single_step_tests.rs`** (NEW)
     - TestBus implementing reactive M68kBus with instant DTACK, 16MB address space
     - Binary format decoder (copied from cpu-m68k): decode_file, decode_test, read_name, read_state, read_transactions
     - setup_cpu, compare_state (checks D0-D7, A0-A6, USP, SSP, SR, PC, RAM)
     - run_test (with halt detection), run_test_safe (with catch_unwind), run_test_file/run_test_file_inner
     - Test tick loop: `for i in 0..cycles_to_run { cpu.tick(&mut mem, u64::from(i) * 4); }`
     - Individual tests: test_moveq, test_nop
     - Full suite: run_all_single_step_tests (ignored, uses safe mode)

   - **Other files read but not modified**: registers.rs, bus.rs, flags.rs, alu.rs, addressing.rs, Cargo.toml — all unchanged

4. Errors and Fixes:
   - **PC off by 2 for all instructions**: `regs.pc` not advancing on FetchIRC completion. Fixed by adding `self.regs.pc = self.next_fetch_addr` in finish_bus_cycle(FetchIRC) and `self.next_fetch_addr = self.regs.pc` in setup_prefetch.
   - **Panic on unwrap for unimplemented instructions**: First full suite run panicked on ABCD test. Fixed by adding `is_halted()` check, `break` on halt in test loop, and `run_test_safe()` with `catch_unwind`.
   - **Byte operations clobbering adjacent memory**: `queue_read_ops(Byte)` and `queue_write_ops(Byte)` used ReadWord/WriteWord instead of ReadByte/WriteByte. Fixed by splitting the match arm.
   - **Push/pop SP never modified**: initiate_bus_cycle for PushLongHi/Lo and PopLongHi/Lo computed addresses from SP but never updated SP. Fixed by changing to `&mut self` and adding SP decrements/increments.
   - **ADDA/SUBA not decoded**: Operator precedence in condition `opmode != 3 && opmode != 7 || ...` excluded ADDA/SUBA. Fixed by adding parentheses and including 0xD000/0x9000 explicitly.
   - **TST skipped EA calculation**: TST went directly to TAG_FETCH_DST_DATA, missing calc_ea_start for memory modes (no predecrement, wrong address). Fixed by routing to TAG_FETCH_DST_EA.
   - **ADDA/SUBA set flags incorrectly**: Added special-case in perform_execute for AddrReg destinations — sign-extend word source, do flagless add/sub, force Size::Long for writeback.
   - **finish_bus_cycle overwrote state on writes** (MOST RECENT FIX): Write bus ops (PushLongHi/Lo, WriteWord, etc.) reset src_val/dst_val/data to 0, destroying displacement values for BSR and hi-word data for long reads. Fixed by only updating registers for read-type operations, with proper long hi/lo word handling.

5. Problem Solving:
   - **Solved**: Module split (Step 1) — clean compile, emu-amiga-rock still builds
   - **Solved**: Test harness (Step 2) — MOVEQ 2500/2500, NOP 2500/2500
   - **In progress**: Bug fixes (Step 3) — went from 23,196 to ~37k+ passing after round 1 of fixes. Round 2 fix (finish_bus_cycle rewrite) has been coded but NOT YET TESTED.
   - **Known remaining issues**: 
     - Unimplemented addressing modes (AddrIndIndex/PcIndex) cause halts → many tests still fail
     - `unwrap()` and `unreachable!()` calls in decode.rs can panic when random next-instruction opcodes are decoded
     - DBcc still at 0% (some tests panic from next-instruction decode)
     - BSR/JSR at 0% (should improve after finish_bus_cycle fix)
     - ADDA.w/SUBA.w at 0% (needs investigation — ADDA.l improved to 337)

6. All User Messages:
   - **Message 1**: "Implement the following plan: [detailed 3-step plan to fix cpu-m68k-rock and boot Kickstart 1.3, including context about SUBQ writeback bug, scope of incompleteness, module split approach, test harness design, and known bugs to fix]"
   - **Message 2** (sent while working): "Could you please create a script that runs repeatedly and returns the next category of instruction to look at? I'd probably try to prioritise finishing a single instruction rather than working across the board."

7. Pending Tasks:
   - **Run tests after finish_bus_cycle fix** to measure improvement
   - **Create the prioritization script** the user requested — should run tests and suggest the next instruction to focus on, prioritizing completing individual instructions over broad fixes
   - Continue fixing remaining instruction bugs (DBcc, BSR, JSR, ADDA.w, etc.)

8. Current Work:
   I was in the middle of Step 3 (fixing bugs found by single-step tests). The most recent edit was rewriting `finish_bus_cycle` in `cpu.rs` to properly handle different bus operation types — specifically to NOT overwrite `src_val`/`dst_val`/`data` for write operations, and to properly handle ReadLongHi (shift to upper 16 bits) and ReadLongLo (combine with hi word). This fix has been written but **tests have not been re-run yet**.

   The second test suite run (after round 1 fixes) showed:
   - 100%: NOP, MOVE.q (5,000 total)
   - Partially passing (~40-80%): CLR.b (1963), TST.b (1950), Scc (1923), RTS (1263), CLR.w (1217), etc.
   - Still 0%: JSR, BSR, DBcc, PEA, ADDA.w, SUBA.w, and all unimplemented instructions

   During this work, the user sent a message asking for a prioritization script.

9. Optional Next Step:
   Two immediate tasks:
   1. **Run tests** to verify the finish_bus_cycle fix improves BSR, JSR, MOVE.l, and other long-read instructions
   2. **Create the prioritization script** per the user's request: "Could you please create a script that runs repeatedly and returns the next category of instruction to look at? I'd probably try to prioritise finishing a single instruction rather than working across the board."
   
   The script should be addressed first since the user explicitly asked for it. It should run the test suite, parse results, and suggest which single instruction to focus on next (e.g., the one closest to 100% that has the most tests still failing).

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation to capture all important details.

1. This session is a continuation from a previous conversation that ran out of context. A detailed summary was provided at the start.

2. The previous session had completed Steps 1 and 2 of a plan (split cpu.rs into modules, build test harness) and was partway through Step 3 (fix bugs). The last edit in the previous session was a finish_bus_cycle rewrite.

3. In this session, I:
   - Ran the full test suite: 38,075/317,500 passing
   - Read cpu.rs, decode.rs, and single_step_tests.rs to refresh context
   - Identified multiple bugs from test results

4. First round of fixes:
   - **TAG_RTS_PC_HI double-shift**: finish_bus_cycle stores hi-word reads pre-shifted (read_data << 16), but TAG_RTS_PC_HI shifted again. Fixed by using self.data directly.
   - **TAG_EXC_STACK_PC_HI**: Used PopLongLo instead of PushLongLo. Fixed.
   - **TAG_EXC_STACK_PC_LO**: Set self.src_val instead of self.data, but PushWord reads from self.data. Fixed.
   - **TAG_EXC_FETCH_VECTOR**: Used self.src_val but InterruptAck writes to self.data. Fixed.
   - **TAG_EXC_FINISH**: Used self.src_val but ReadLongHi/Lo writes to self.data. Fixed.
   - **Branch 16-bit displacement**: IRC displacement was overwritten by FetchIRC before being read. Fixed by saving IRC at decode time.
   - **DBcc displacement**: Same IRC overwrite issue. Fixed.
   - **finish_bus_cycle clobbers src_val**: Changed to only write to self.data. Added copy-to-src_val in TAG_FETCH_DST_EA and copy-to-dst_val in TAG_EXECUTE for memory modes.
   - **Removed TAG_BCC_FETCH_DISP**: No longer needed since displacement saved at decode time.
   - Result: 48,205/317,500

5. Created prioritization script (scripts/rock_next_instruction.sh)
   - Runs full suite, parses results, groups by instruction
   - Shows completed (100%), almost done (>50%), partial, not started
   - Recommends next instruction to focus on

6. Implemented indexed addressing modes (AddrIndIndex, PcIndex) in ea.rs
   - Parse brief extension word: D/A bit, register number, W/L bit, 8-bit displacement
   - Compute address: base + sign_extend(d8) + index_register
   - Result: 53,832/317,500

7. Fixed LEA ea_reg collision
   - ea_reg was used for both destination A-register AND displacement base register
   - calc_ea_start for AddrIndDisp overwrote ea_reg
   - Fixed by storing LEA destination in dst_mode = Some(AddrMode::AddrReg(reg))
   - Updated writeback to use dst_mode instead of ea_reg

8. User asked for the script to be improved (single-file mode was re-running full suite)
   - Added run_single_file test with ROCK_TEST_FILE env var
   - Updated script with --analyze mode (cached results) and single-file mode
   - run_named_test changed to use safe mode (catch_unwind)

9. Investigated remaining failures in TST.b (88%)
   - Found that next instruction was executing within test window, corrupting state
   - Root cause: CPU completes instruction early because it doesn't model sub-4-clock internal delays (like 2-clock predecrement)
   - DL cycle count includes these internal delays, so extra ticks execute the next instruction

10. First tried subtracting cycles, then tried debug_cycles test to understand DL format
    - MOVEQ: cycles=4, passes with exactly 4 ticks
    - TST.b Dn: cycles=4, same
    - TST.b -(A6): cycles=10, needs 8 ticks for bus cycles + 2 for internal predecrement
    - Each DL "cycle" = 1 of our ticks (4 crystal clocks in our model)

11. Implemented instruction-boundary detection in test runner
    - Instead of running for DL cycle count, detect when instruction completes
    - Stop when: !in_followup && state == Idle && micro_ops.front() == Execute
    - This prevents the next instruction from executing
    - Added is_idle() to Cpu68000
    - Result: 71,782/317,500 with 12 instructions at 100%

12. User asked: "Can we fix that?" referring to sub-4-clock internal delays
    - User wants proper timing, not just a test workaround
    - I was investigating changing tick resolution from 4 clocks to 2 clocks
    - Checked Amiga integration to see how tick() is called
    - Found cpu.tick() is called with self.master_clock in emu-amiga-rock/src/lib.rs

The conversation was cut off while I was investigating the tick resolution change to properly model 2-clock internal delays.

Key user messages:
1. "Implement the following plan" (from previous session)
2. "Could you please create a script that runs repeatedly and returns the next category of instruction to look at?" (from previous session)
3. "I think the fact that you need to run a separate cargo test command each time might point to our script needing something extra"
4. "Can we fix that?" (about sub-4-clock internal delays)

The most recent work was investigating how to change the CPU's tick resolution from 4 crystal clocks to 2 crystal clocks to properly model sub-4-clock internal delays like the 2-clock predecrement.

Summary:
1. Primary Request and Intent:
   The user's original request (from the previous session) was to implement a 3-step plan to fix the `cpu-m68k-rock` crate:
   - Step 1: Split monolithic cpu.rs into focused modules (COMPLETED in previous session)
   - Step 2: Build single-step test harness (COMPLETED in previous session)
   - Step 3: Fix bugs in implemented instructions (IN PROGRESS)
   
   During Step 3, the user additionally requested:
   - A prioritization script that runs repeatedly and suggests the next instruction to work on, prioritizing finishing individual instructions over broad coverage
   - Improvement to the script so single-file testing doesn't re-run the full suite
   - **Most recently**: The user asked to properly fix sub-4-clock internal delays in the CPU timing model rather than working around it in the test harness. Quote: "Can we fix that?" in response to the explanation about predecrement taking 2 clocks that our 4-clock tick resolution can't model.

2. Key Technical Concepts:
   - **Reactive bus architecture**: CPU polls `bus.poll_cycle()` each tick until `BusStatus::Ready`
   - **Micro-op queue**: Fixed 32-entry circular queue of `MicroOp`s driving bus state machine
   - **Follow-up tag state machine**: Multi-phase instructions tracked by tags (TAG_FETCH_SRC_EA → SRC_DATA → DST_EA → DST_DATA → EXECUTE → WRITEBACK)
   - **IR/IRC prefetch pipeline**: Two-word prefetch — IR (executing), IRC (prefetched)
   - **DL test format**: Binary test files with initial/final CPU state + cycle count. Cycle count = total clock cycles including opcode+IRC fetch
   - **Crystal clock ticking**: `tick(bus, crystal_clock)` only acts when `crystal_clock % 4 == 0`. Each tick = 4 crystal clocks = one bus cycle slot
   - **DL cycle count interpretation**: Each DL cycle = 1 of our ticks = 4 crystal clocks. MOVEQ=4 cycles, TST.b Dn=4, TST.b -(An)=10
   - **Sub-4-clock internal delays**: Predecrement adds 2 clocks (half a tick). Current model can't represent this, causing CPU to complete 2 ticks early
   - **Indexed addressing mode**: Brief extension word format — bit 15: D/A, bits 14-12: register, bit 11: W/L, bits 7-0: signed displacement
   - **Instruction-boundary detection**: Stop test when `!in_followup && is_idle() && front() == Execute` to prevent next-instruction execution

3. Files and Code Sections:

   - **`crates/cpu-m68k-rock/src/cpu.rs`** (MODIFIED)
     - Core tick engine, state machine, bus cycle handling
     - **finish_bus_cycle rewrite**: Changed to only write to `self.data` (not src_val/dst_val) to prevent source operand clobbering during destination reads:
     ```rust
     fn finish_bus_cycle(&mut self, op: MicroOp, read_data: u16) {
         match op {
             MicroOp::FetchIRC => {
                 self.irc = read_data;
                 self.irc_addr = self.next_fetch_addr;
                 self.next_fetch_addr = self.next_fetch_addr.wrapping_add(2);
                 self.regs.pc = self.next_fetch_addr;
             }
             MicroOp::ReadByte | MicroOp::ReadWord | MicroOp::PopWord => {
                 self.data = u32::from(read_data);
             }
             MicroOp::ReadLongHi | MicroOp::PopLongHi => {
                 self.data = u32::from(read_data) << 16;
             }
             MicroOp::ReadLongLo | MicroOp::PopLongLo => {
                 self.data = (self.data & 0xFFFF_0000) | u32::from(read_data);
             }
             MicroOp::InterruptAck => {
                 self.data = u32::from(read_data);
             }
             _ => {} // Write operations: preserve internal state
         }
     }
     ```
     - **Added `is_idle()`**:
     ```rust
     pub fn is_idle(&self) -> bool {
         matches!(self.state, State::Idle)
     }
     ```
     - Current tick resolution: `crystal_clock % 4 != 0` → skip. Bus cycle completes at `cycle_count >= 4`.

   - **`crates/cpu-m68k-rock/src/decode.rs`** (HEAVILY MODIFIED)
     - Instruction decoding and follow-up state machine
     - **TAG_FETCH_DST_EA**: Added src_val copy from data for memory source modes:
     ```rust
     TAG_FETCH_DST_EA => {
         if let Some(mode) = self.src_mode {
             if !matches!(mode, AddrMode::DataReg(_) | AddrMode::AddrReg(_) | AddrMode::Immediate) {
                 self.src_val = self.data;
             }
         }
         // ... existing code
     }
     ```
     - **TAG_EXECUTE**: Added dst_val copy from data for memory dest modes:
     ```rust
     TAG_EXECUTE => {
         if let Some(mode) = self.dst_mode {
             if !matches!(mode, AddrMode::DataReg(_) | AddrMode::AddrReg(_)) {
                 self.dst_val = self.data;
             }
         }
         self.perform_execute();
         // ...
     }
     ```
     - **Branch 16-bit displacement fix**: Read displacement from IRC at decode time:
     ```rust
     if disp8 == 0 {
         self.src_val = u32::from(self.irc);
         self.micro_ops.push(MicroOp::FetchIRC);
         // followup_tag stays as TAG_BCC_EXECUTE / TAG_BSR_EXECUTE
     }
     ```
     - **Removed TAG_BCC_FETCH_DISP**: No longer needed
     - **DBcc fix**: Save displacement at decode time, use in TAG_DBCC_EXECUTE:
     ```rust
     // Decode:
     self.src_val = u32::from(self.irc);
     // TAG_DBCC_EXECUTE:
     let disp = self.src_val as i16 as i32; // was: self.consume_irc()
     ```
     - **TAG_RTS_PC_HI/LO fix**: Use self.data instead of src_val:
     ```rust
     TAG_RTS_PC_HI => {
         self.followup_tag = TAG_RTS_PC_LO;
         self.micro_ops.push(MicroOp::PopLongLo);
         self.micro_ops.push(MicroOp::Execute);
     }
     TAG_RTS_PC_LO => {
         self.regs.pc = self.data; // was: self.regs.pc |= self.src_val & 0xFFFF
         // ...
     }
     ```
     - **TAG_EXC_STACK_PC_HI**: Fixed PopLongLo → PushLongLo
     - **TAG_EXC_STACK_PC_LO**: Changed `self.src_val = u32::from(self.regs.sr)` to `self.data = u32::from(self.regs.sr)` (PushWord reads from data)
     - **TAG_EXC_FETCH_VECTOR**: `self.src_val as u8` → `self.data as u8`
     - **TAG_EXC_FINISH**: `self.regs.pc = self.src_val` → `self.regs.pc = self.data`
     - **LEA decode fix**: Store destination register in dst_mode instead of ea_reg:
     ```rust
     self.dst_mode = Some(AddrMode::AddrReg(reg)); // was: self.ea_reg = reg
     ```

   - **`crates/cpu-m68k-rock/src/ea.rs`** (MODIFIED)
     - Added indexed addressing modes:
     ```rust
     AddrMode::AddrIndIndex(r) => {
         let ext = self.consume_irc();
         let base = self.regs.a(r as usize);
         let disp = (ext & 0xFF) as i8 as i32;
         let idx_reg = ((ext >> 12) & 7) as usize;
         let idx_val = if ext & 0x8000 != 0 {
             self.regs.a(idx_reg)
         } else {
             self.regs.d[idx_reg]
         };
         let idx = if ext & 0x0800 != 0 {
             idx_val
         } else {
             idx_val as i16 as i32 as u32
         };
         self.addr = base.wrapping_add(disp as u32).wrapping_add(idx);
         true
     }
     AddrMode::PcIndex => {
         let ext = self.consume_irc();
         let base = self.instr_start_pc.wrapping_add(2);
         // ... same index parsing ...
         self.addr = base.wrapping_add(disp as u32).wrapping_add(idx);
         true
     }
     ```
     - Removed unreachable wildcard pattern (all modes now covered)

   - **`crates/cpu-m68k-rock/src/execute.rs`** (MODIFIED)
     - LEA writeback: use dst_mode instead of ea_reg:
     ```rust
     if (opcode & 0xF1C0) == 0x41C0 {
         if let Some(AddrMode::AddrReg(r)) = self.dst_mode {
             self.regs.set_a(r as usize, self.src_val);
         }
         return;
     }
     ```

   - **`crates/cpu-m68k-rock/tests/single_step_tests.rs`** (MODIFIED)
     - Added `run_single_file` test with ROCK_TEST_FILE env var for fast single-file testing
     - Changed `run_named_test` to use safe mode (catch_unwind)
     - **Instruction-boundary detection** in run_test:
     ```rust
     fn run_test(test: &TestCase) -> Result<(), Vec<String>> {
         let mut cpu = Cpu68000::new();
         let mut mem = TestBus::new();
         setup_cpu(&mut cpu, &mut mem, &test.initial);
         let max_ticks = test.cycles.max(8) * 2;
         for i in 0..max_ticks {
             cpu.tick(&mut mem, u64::from(i) * 4);
             if cpu.is_halted() { break; }
             if i > 0
                 && !cpu.in_followup
                 && cpu.is_idle()
                 && cpu.micro_ops.front().map_or(false, |op| {
                     matches!(op, cpu_m68k_rock::microcode::MicroOp::Execute)
                 })
             { break; }
         }
         let errors = compare_state(&cpu, &mem, &test.final_state, &test.name);
         if errors.is_empty() { Ok(()) } else { Err(errors) }
     }
     ```
     - Removed `run_test_file` (unused after refactoring)

   - **`scripts/rock_next_instruction.sh`** (CREATED)
     - Full report: runs suite, caches to test_output.log, shows prioritized results
     - `--analyze`: re-analyzes cached results without re-running cargo test
     - Single file: `./scripts/rock_next_instruction.sh TST.b` uses ROCK_TEST_FILE env var (runs in ~0.36s vs 45s for full suite)
     - `--errors`: shows sample errors for recommended instruction

   - **`crates/cpu-m68k-rock/src/lib.rs`**, **`crates/cpu-m68k-rock/src/microcode.rs`**, **`crates/cpu-m68k-rock/src/addressing.rs`**, **`crates/cpu-m68k-rock/src/registers.rs`**, **`crates/cpu-m68k-rock/src/bus.rs`**, **`crates/cpu-m68k-rock/src/flags.rs`**, **`crates/cpu-m68k-rock/src/alu.rs`** — Read for context, not modified in this session.

   - **`crates/emu-amiga-rock/src/lib.rs`** — Checked for tick() call: `self.cpu.tick(&mut bus, self.master_clock)` at line 142. Important for understanding impact of tick resolution change.

4. Errors and fixes:
   - **RTS regression (1263→0)**: finish_bus_cycle rewrite stored PopLongHi result pre-shifted (data = read_data << 16), but TAG_RTS_PC_HI did `u32::from(self.src_val) << 16` (double shift). Also, finish_bus_cycle only writes to self.data now, not src_val. Fixed by having TAG_RTS_PC_HI do nothing and TAG_RTS_PC_LO use `self.regs.pc = self.data`.
   - **Exception handler PushLongLo bug**: TAG_EXC_STACK_PC_HI queued PopLongLo instead of PushLongLo. Fixed by changing to PushLongLo.
   - **Exception handler SR push**: TAG_EXC_STACK_PC_LO set src_val = SR, but PushWord reads from data. Fixed to set self.data.
   - **Branch/BSR/DBcc 16-bit displacement lost**: FetchIRC queued in decode phase overwrote IRC before the displacement tag could read it. Fixed by saving `self.irc` into `self.src_val` at decode time, eliminating TAG_BCC_FETCH_DISP.
   - **src_val clobbered by dst read**: finish_bus_cycle wrote to src_val/dst_val/data for all reads. When TAG_FETCH_DST_DATA did a memory read, it overwrote src_val set by TAG_FETCH_SRC_DATA. Broke ADDI to memory and MOVE memory-to-memory. Fixed by only writing to self.data in finish_bus_cycle, with explicit copies in TAG_FETCH_DST_EA and TAG_EXECUTE.
   - **LEA ea_reg collision**: ea_reg stored both destination A-register number and displacement base register. calc_ea_start for displacement modes overwrote ea_reg, causing LEA to write to wrong register. Fixed by storing destination in dst_mode = AddrMode::AddrReg(reg).
   - **Indexed addressing modes not implemented**: AddrIndIndex and PcIndex caused CPU to halt. Implemented in ea.rs with brief extension word parsing.
   - **Next instruction corrupting test state**: DL cycle count includes sub-4-clock internal delays (e.g., 2-clock predecrement) that our CPU doesn't model. CPU completed early, remaining ticks executed the next instruction from random test memory. Initially fixed with instruction-boundary detection in test runner. User then asked to fix the root cause (proper sub-4-clock timing).
   - **Script single-file mode ran full suite**: The original script's single-file mode ran the full test suite and grepped for one file. Fixed by adding ROCK_TEST_FILE env var + run_single_file test function.
   - **run_named_test panicked on unimplemented instructions**: Safe mode (catch_unwind) was only used in the full suite, not run_named_test. Fixed by changing to use run_test_file_inner with safe=true.

5. Problem Solving:
   - **Solved**: finish_bus_cycle data flow — redesigned to only write self.data, with follow-up handlers copying to src_val/dst_val at appropriate times
   - **Solved**: Branch displacement preservation — save from IRC at decode time before FetchIRC overwrites it
   - **Solved**: LEA register collision — use dst_mode for destination register
   - **Solved**: Indexed addressing modes — full implementation of AddrIndIndex and PcIndex
   - **Solved (workaround)**: Next-instruction corruption — instruction-boundary detection stops test at correct point
   - **In progress**: Sub-4-clock internal delays — user wants proper fix, not just test workaround. Currently investigating changing tick resolution from 4 clocks to 2 clocks.

   Test progression this session: 38,075 → 48,205 → 53,832 → 71,782/317,500 (12 instructions at 100%)

6. All user messages:
   - (From previous session, preserved in summary): "Implement the following plan: [detailed plan]"
   - (From previous session, preserved in summary): "Could you please create a script that runs repeatedly and returns the next category of instruction to look at? I'd probably try to prioritise finishing a single instruction rather than working across the board."
   - "I think the fact that you need to run a separate cargo test command each time might point to our script needing something extra"
   - "Hmm. > The problem is that our CPU doesn't model sub-4-clock internal delays (like the 2-clock predecrement). This means the instruction completes early and the remaining DL ticks execute the next instruction. Let me fix the test runner to stop at the instruction boundary. Can we fix that?"

7. Pending Tasks:
   - **Fix sub-4-clock internal delays** (user's most recent request) — change tick resolution from 4 crystal clocks to 2 crystal clocks so the CPU can model 2-clock internal delays like predecrement. This would make the instruction-boundary detection workaround in the test runner unnecessary.
   - Continue fixing remaining instruction bugs (Step 3 of plan) — next priority per script: DBcc (74%), Bcc (72%)
   - Eventually remove the instruction-boundary detection workaround once proper timing is implemented

8. Current Work:
   I was investigating how to change the CPU's tick resolution from 4 crystal clocks to 2 crystal clocks to properly model sub-4-clock internal delays. The user's quote was: "Can we fix that?" referring to my explanation that "The problem is that our CPU doesn't model sub-4-clock internal delays (like the 2-clock predecrement)."

   I had just checked how the Amiga integration calls tick() — found `self.cpu.tick(&mut bus, self.master_clock)` in `crates/emu-amiga-rock/src/lib.rs:142`. The changes needed:
   1. Change `crystal_clock % 4` to `crystal_clock % 2` in tick()
   2. Change `cycle_count >= 4` to `cycle_count >= 2` (bus cycle = 4 clocks = 2 ticks at 2-clock resolution)
   3. Internal(n) counts in 2-clock units instead of 4-clock units
   4. Test harness: tick at `u64::from(i) * 2` instead of `* 4`
   5. Add Internal(1) = 2 clocks for predecrement in ea.rs
   6. Update RESET timing and any other Internal() values
   7. Update Amiga integration if needed

9. Optional Next Step:
   Implement the tick resolution change from 4 to 2 crystal clocks as described above, per the user's request "Can we fix that?" This involves changes to cpu.rs (tick function, BusCycle threshold), ea.rs (add Internal delays for predecrement), the test harness (tick interval), and potentially emu-amiga-rock (if its master_clock increments need adjusting).

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.