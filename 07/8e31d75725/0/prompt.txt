Implement the following plan:

# New Amiga Emulator — emu-amiga2

## Context

The existing `emu-amiga` crate doesn't boot Kickstart and has accumulated workarounds (ExecBase checksum patches, library vector patches, reset-loop skips, `FORCE_CPU` env var) that mask fundamental architectural problems:

1. **Wrong CPU crate.** Uses `emu-68000` with byte-level `Bus` trait. The 68000 has a 16-bit data bus with function codes. The CPU never reads `ReadResult.wait` — there's no mechanism for bus contention.
2. **Binary DMA gating.** The tick loop skips CPU ticks entirely when Agnus owns the bus. On real hardware, the CPU stretches its S4 wait state when /DTACK is withheld — it doesn't stop ticking. This matters because the CPU can be mid-instruction when DMA arrives.
3. **No variant support.** Hardcoded for PAL OCS A500 with no chipset abstraction.

The plan is to create a fresh crate (`emu-amiga2`) that fixes all three problems, targeting KS 1.0 on A1000 first.

---

## Prerequisite: emu-m68k wait cycle consumption

`emu-m68k`'s `Cpu68000` accumulates `wait_cycles` from `BusResult` (lines 254, 262, 278, 285 of `mod.rs`) but never consumes them. The `tick()` method at line 2046 must burn these cycles before processing micro-ops, matching the Z80's pattern:

**File:** `crates/emu-m68k/src/m68000/mod.rs` — add to `tick()` after `self.total_cycles += 1`:

```rust
if self.wait_cycles > 0 {
    self.wait_cycles -= 1;
    return;
}
```

---

## Crate structure

```
crates/emu-amiga2/
├── Cargo.toml          (depends on emu-core, emu-m68k)
├── src/
│   ├── lib.rs          # Crate root, re-exports
│   ├── amiga.rs        # System struct, tick loop, frame loop
│   ├── config.rs       # AmigaModel, AmigaConfig, presets
│   ├── bus.rs          # AmigaBus implementing M68kBus — the centrepiece
│   ├── memory.rs       # Chip RAM, Fast RAM, ROM, WCS, overlay
│   ├── agnus/
│   │   ├── mod.rs      # Agnus struct, variant dispatch
│   │   ├── beam.rs     # Beam counter (VPOS/HPOS), interlace
│   │   └── dma.rs      # DMA slot schedule, chip_ram_contention()
│   ├── denise/
│   │   ├── mod.rs      # Denise struct, variant dispatch
│   │   └── video.rs    # Bitplane shift registers, palette, framebuffer
│   ├── paula.rs        # Interrupt controller (port from emu-amiga, strip env traces)
│   ├── copper.rs       # Copper coprocessor (port from emu-amiga as-is)
│   ├── blitter.rs      # Stub (always not-busy, sets BLTDONE immediately)
│   ├── cia.rs          # CIA 8520 (port from emu-amiga as-is)
│   ├── custom_regs.rs  # Register offsets, set_clr_write (port from emu-amiga)
│   ├── keyboard.rs     # Keyboard handshake protocol (clean rewrite)
│   ├── input.rs        # Input queue, scripted key injection
│   ├── main.rs         # Binary, CLI, windowed/headless modes
│   └── mcp.rs          # MCP server (later phase)
```

---

## Key architectural decisions

### 1. Variant dispatch: enum inside component, not trait objects

Most OCS/ECS/AGA behaviour is identical. The differences are narrow:
- Agnus: chip RAM address range (18-bit / 19-bit / 21-bit)
- Denise: colour depth (12-bit / 12-bit+EHB / 24-bit), HAM modes, sprite width
- Paula: identical across all chipsets

Each component stores its variant as an enum field and dispatches at the few points where behaviour differs. No trait objects, no generic type parameters on the system struct.

### 2. Agnus as bus arbiter, CPU always ticks

The tick loop follows the Spectrum pattern: crystal drives everything, components fire on their divisor boundaries. The CPU **always ticks** — it is never gated. Chip RAM contention is returned as `wait_cycles` via `BusResult`, consumed by the CPU as idle ticks.

```
Crystal:      |0|1|2|3|4|5|6|7|  28.375 MHz (PAL)
CPU clock:    |*|.|.|.|*|.|.|.|  ÷4 = 7.09 MHz
Colour clock: |*|.|.|.|.|.|.|.|  ÷8 = 3.55 MHz (DMA slot reference)
CIA E-clock:  every 40th crystal tick
```

### 3. DMA happens at system level, not inside Agnus

To avoid borrow checker conflicts (Agnus needs memory access while bus owns both), the system-level `tick()` in `amiga.rs` handles DMA:
1. Agnus advances beam and determines slot owner
2. System reads slot owner and performs DMA using mutable access to all components
3. This matches the existing emu-amiga pattern (lines 271-309 of amiga.rs)

### 4. Configuration presets with full overridability

```rust
pub enum AmigaModel { A1000, A500, A500Plus, A600, A2000, A3000, A1200, A4000, Custom }
pub enum Chipset { Ocs, Ecs, Aga }
pub enum AgnusVariant { Agnus8361, FatAgnus8367, Agnus8372, SuperAgnus, Alice }
pub enum CpuVariant { M68000, M68020, M68030, M68040 }
pub enum Region { Pal, Ntsc }
pub enum KickstartSource { Rom(Vec<u8>), Wcs(Vec<u8>) }
```

`AmigaConfig::preset(AmigaModel::A1000, ks_data)` fills defaults; every field is overridable for accelerator configs.

### 5. Components ported from emu-amiga

These are clean, tested, and hardware-correct:
- **CIA** (`cia.rs`): 305 lines, 5 tests. Port as-is.
- **Copper** (`copper.rs`): 267 lines, 5 tests. Port as-is.
- **Paula** (`paula.rs`): 239 lines, 8 tests. Port with env var traces stripped.
- **custom_regs** (`custom_regs.rs`): Register constants + `set_clr_write`. Port as-is.

---

## Implementation phases

### Phase 1: KS 1.0 boot on A1000

**Goal:** CPU executes KS 1.0 from WCS RAM. Beam counter works. Custom register writes take effect. Basic display visible.

**Steps:**
1. Fix emu-m68k wait cycle consumption (prerequisite)
2. Create crate with Cargo.toml (depends on emu-core, emu-m68k)
3. `config.rs` — AmigaModel::A1000 preset (OCS, 68000, 256K chip, WCS)
4. `memory.rs` — chip RAM (256K), WCS RAM (pre-loaded with KS 1.0), overlay, word-level access
5. `agnus/beam.rs` — beam counter (VPOS/HPOS, wrap at 312×227 PAL), VPOSR/VHPOSR reads
6. `agnus/dma.rs` — DMA slot table (fixed: refresh/disk/audio/sprite; variable: bitplane/copper/CPU), `chip_ram_contention()` returns 2 when DMA active
7. `bus.rs` — `AmigaBus` implements `M68kBus`, routes chip RAM (with contention), custom regs, CIAs, ROM
8. Port CIA, Copper, Paula, custom_regs from emu-amiga
9. `denise/video.rs` — framebuffer, bitplane-to-pixel conversion, palette
10. `blitter.rs` — stub (BLTDONE always set)
11. `amiga.rs` — tick loop (crystal → CCK/CPU/CIA divisors), frame loop, DMA at system level
12. `main.rs` — headless mode with `--screenshot`

**Minimum custom registers needed:**
- Reads: VPOSR, VHPOSR, DMACONR, INTENAR, INTREQR, SERDATR, POTGOR, JOY0DAT, JOY1DAT
- Writes: DMACON, INTENA, INTREQ, BPLCON0, COLOR00-31, COP1LCH/L, COPJMP1, DIWSTRT, DIWSTOP, DDFSTRT, DDFSTOP, BPLxPTH/L, BPL1MOD, BPL2MOD, SERDAT, SERPER, COPCON

**Verification:**
```
cargo run -p emu-amiga2 -- --model a1000 --kickstart ks10.rom --headless --frames 200 --screenshot ks10-boot.png
```

### Phase 2: KS 1.2/1.3 on A500

**Goal:** Full Kickstart 1.3 boot to hand/insert-floppy screen.

- A500 memory map (512K chip + 512K slow RAM)
- CIA overlay control (PRA bit 0)
- Keyboard handshake (CIA-A serial, boot codes 0xFD/0xFE)
- Refined DMA contention (look-ahead to next free slot)
- Copper-driven colour bars (KS 1.3 gradient)
- Sprite DMA (hand pointer)

### Phase 3: Workbench boot

- Floppy disk controller (MFM DMA, ADF loading)
- Blitter (area copy, line draw, fill)
- Full sprite handling
- Audio DMA (basic playback)

### Phase 4: ECS/AGA variants

- ECS Agnus (2MB DMA range), ECS Denise (EHB, productivity modes)
- AGA Alice (64-bit fetch), Lisa (256 colours, HAM8)
- 68020/030/040 CPU variants (when emu-m68k adds support)
- KS 2.x/3.x

---

## Verification approach

Each phase has a concrete boot test:
- **Phase 1**: KS 1.0 executes and writes to custom registers (trace first 1000 instructions, verify DMACON/INTENA are written)
- **Phase 2**: Headless screenshot matches KS 1.3 gradient screen
- **Phase 3**: Workbench desktop renders with icons
- **Phase 4**: KS 3.1 boots on A1200 config

Use existing trace_boot test pattern from `crates/emu-amiga/tests/trace_boot.rs` as template.


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation:

1. The user provided a detailed implementation plan for creating a new `emu-amiga2` crate to replace the existing `emu-amiga` crate. The plan addresses three fundamental architectural problems:
   - Wrong CPU crate (emu-68000 with byte-level Bus trait instead of emu-m68k with word-level M68kBus)
   - Binary DMA gating (CPU stops ticking instead of stretching wait states)
   - No variant support (hardcoded for PAL OCS A500)

2. I read extensively from existing codebase files to understand patterns before writing code.

3. I created task tracking for all implementation steps.

4. Key files read:
   - emu-m68k/src/m68000/mod.rs (tick method, wait_cycles field)
   - emu-m68k/src/bus.rs (M68kBus trait, BusResult, FunctionCode)
   - emu-amiga/src/{cia.rs, paula.rs, copper.rs, custom_regs.rs, agnus.rs, denise.rs, blitter.rs, memory.rs, bus.rs, amiga.rs, main.rs, lib.rs, input.rs, capture.rs, keyboard_map.rs, config.rs}

5. Implementation steps completed:
   - Fixed emu-m68k wait cycle consumption (prerequisite)
   - Created emu-amiga2 crate with all source files
   - Fixed pre-existing emu-m68k compilation errors (flags reimport, RECIPE_MAX_OPS private re-export)
   - Fixed A7/SSP register access (a[7] vs regs.ssp)
   - Fixed beam timing test assertions (566,592 not 566,208)
   - Fixed unused import warnings

6. User message during work: "If we need to throw away emu-m68k and rebuild it - do it" - this was in response to emu-m68k compilation errors. I fixed the errors instead of rebuilding since they were minor.

7. Final state: All 55 tests pass, binary builds and shows help correctly.

Let me catalog all the files created and modified with their key code sections.

Summary:
1. Primary Request and Intent:
   The user provided a comprehensive implementation plan to create a new `emu-amiga2` crate (Phase 1: KS 1.0 boot on A1000). The plan addresses three fundamental architectural problems in the existing `emu-amiga`:
   - **Wrong CPU crate**: Uses `emu-68000` with byte-level `Bus` trait; should use `emu-m68k` with word-level `M68kBus` trait supporting function codes and wait states
   - **Binary DMA gating**: CPU stops ticking when DMA owns bus; should always tick with contention via `wait_cycles` in `BusResult`
   - **No variant support**: Hardcoded PAL OCS A500; should support A1000, A500, A500+, A600, A1200 etc. via enum-based variant dispatch
   
   The plan specified 4 phases; only Phase 1 was requested for implementation. Phase 1 targets KS 1.0 executing from WCS RAM on an A1000 with basic display output.

2. Key Technical Concepts:
   - **M68kBus trait**: Word-level bus interface with `FunctionCode` (supervisor/user, program/data) and `BusResult` (data + wait_cycles)
   - **Bus contention via wait_cycles**: CPU always ticks; chip RAM DMA contention returns wait_cycles via BusResult, consumed as idle CPU ticks (matching Z80/Spectrum pattern)
   - **Crystal-driven tick loop**: 28.375160 MHz PAL crystal; CPU ÷4, CCK ÷8, CIA E-clock ÷40
   - **DMA at system level**: Agnus determines slot owner, system-level tick() performs DMA to avoid borrow checker conflicts
   - **Variant dispatch via enum fields**: Each component stores variant as enum, dispatches at difference points (no trait objects)
   - **WCS (Writable Control Store)**: A1000 loads Kickstart from floppy into writable RAM, unlike A500+ which uses ROM
   - **Keyboard handshake**: CIA-A PRA bit toggle detection, boot codes 0xFD/0xFE injection

3. Files and Code Sections:

   **MODIFIED - `/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/m68000/mod.rs`**
   - Prerequisite fix: Added wait_cycles consumption to tick() method
   - Fixed pre-existing compilation errors (flags reimport, RECIPE_MAX_OPS)
   - Changes made:
     ```rust
     // Added to tick() after total_cycles increment:
     if self.wait_cycles > 0 {
         self.wait_cycles -= 1;
         return;
     }
     ```
     ```rust
     // Fixed imports (removed duplicate flags import, removed RECIPE_MAX_OPS from pub use):
     use crate::bus::{FunctionCode, M68kBus};
     use crate::common::flags::{Status, C, N, S, V, X, Z};
     // ...
     pub use recipe::{EaSide, RecipeAlu, RecipeOp, RecipeUnary};
     use recipe::RECIPE_MAX_OPS;
     pub(crate) use crate::common::flags;
     ```

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/Cargo.toml`**
   - Crate manifest depending on emu-core and emu-m68k (NOT emu-68000)
   - Binary + library targets, winit/pixels/png dependencies

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/lib.rs`**
   - Crate root re-exporting Amiga, AmigaBus, AmigaConfig
   - Public modules: agnus, capture, config, denise, input

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/config.rs`**
   - Full variant system: AmigaModel, Chipset, AgnusVariant, DeniseVariant, CpuVariant, Region, KickstartSource enums
   - `AmigaConfig::preset(model, kickstart)` factory method with defaults for A1000, A500, A500+, A600, A2000, A1200
   - A1000 uses KickstartSource::Wcs, A500+ use KickstartSource::Rom

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/memory.rs`**
   - Variable chip RAM size (power of two, configurable), slow RAM at $C00000, kickstart at $F80000
   - WCS (writable) vs ROM (read-only) kickstart support
   - Word-level chip RAM access for DMA: `read_chip_word()`, `write_chip_word()`
   - Overlay mechanism for reset vectors

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/agnus/mod.rs`**
   - Agnus with variant (AgnusVariant) and region (Region) fields
   - VPOSR reads include Agnus ID bits (OCS=$00, ECS=$20, AGA=$22)
   - `lines_per_frame()` varies by region (PAL=312, NTSC=262)

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/agnus/beam.rs`**
   - `ticks_per_frame(region)` and `crystal_hz(region)` const functions
   - PAL: 566,592 ticks/frame, NTSC: 475,792 ticks/frame

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/agnus/dma.rs`**
   - `allocate_slot()` function determining slot owner per HPOS
   - `chip_ram_contention()` returns 0 (CPU owns bus) or 2 (DMA active, one CCK = 2 CPU clocks)
   - Fixed slots: refresh ($01-$03,$1B), disk ($04-$06), audio ($07-$0A), sprites ($0B-$1A)
   - Variable region ($1C-$E2): bitplane, copper (even CCKs), CPU

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/denise/mod.rs`**
   - Denise with DeniseVariant field
   - 32-colour palette, 6 bitplane shift registers, ARGB32 framebuffer (360×284)

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/denise/video.rs`**
   - `rgb12_to_argb32()` conversion, FB_WIDTH/FB_HEIGHT constants

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/bus.rs`**
   - **The centrepiece**: `AmigaBus` implementing `M68kBus` trait (word-level, function codes, wait states)
   - `read_word`/`write_word`/`read_byte`/`write_byte` all return `BusResult` with wait_cycles for chip RAM
   - CIA routing: CIA-A at odd bytes ($BFE001), CIA-B at even bytes ($BFD000)
   - Custom register dispatch via `write_custom_reg()` and `read_custom_reg()`
   - CIA-A PRA controls overlay (bit 0) and keyboard handshake (bit 1 toggle)
   - No ExecBase patching, no env var traces, no FORCE_CPU - clean implementation

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/amiga.rs`**
   - System tick loop: CPU **always ticks** (every 4 crystal ticks), never gated
   - CCK boundary (every 8): beam advance, DMA slot allocation, bitplane DMA, copper, pixel output
   - CIA E-clock (every 40): CIA tick, keyboard pump, CIA IRQ → Paula
   - IPL computed from Paula and set on CPU every CPU tick
   - Uses `Cpu68000` from emu-m68k (not `M68000` from emu-68000)

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/keyboard.rs`**
   - Clean rewrite of keyboard handshake (was spread across bus.rs in emu-amiga)
   - `cia_pra_written()` detects bit 1 toggle, returns next byte to inject
   - Boot codes (0xFD/0xFE) queued on first handshake

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/input.rs`**
   - Simplified version of emu-amiga's input.rs (no keyboard_map dependency, no auto-boot scripts)

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/{cia.rs, paula.rs, copper.rs, custom_regs.rs, blitter.rs, capture.rs}`**
   - Clean ports from emu-amiga with env var traces stripped

   **CREATED - `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/main.rs`**
   - CLI binary with --model, --kickstart, --headless, --frames, --screenshot
   - Windowed mode (winit + pixels) and headless mode
   - No MCP server (deferred to later phase)

   **READ (for reference) - Key existing files:**
   - `emu-m68k/src/bus.rs`: M68kBus trait definition with FunctionCode, BusResult
   - `emu-m68k/src/m68000/mod.rs`: Cpu68000 struct, tick() method, wait_cycles field, Registers struct (a[0..6], ssp, usp, pc, sr)
   - `emu-amiga/src/*.rs`: All source files read for porting reference

4. Errors and Fixes:
   - **emu-m68k `flags` reimport error (E0252)**: `use crate::common::flags::{self, ...}` conflicted with `pub(crate) use crate::common::flags`. Fixed by removing `self` from the first import.
   - **emu-m68k `RECIPE_MAX_OPS` private re-export (E0364)**: Was `pub(super)` in recipe.rs but `pub use` tried to export it publicly. Fixed by changing to `use recipe::RECIPE_MAX_OPS` (private import).
   - **`regs.a[7]` index out of bounds**: Registers struct has `a: [u32; 7]` (A0-A6) with A7 stored as `ssp`/`usp` separately. Fixed: `regs.a[7] = ssp` → `regs.ssp = ssp`.
   - **Beam timing test assertions wrong**: Tests expected 566,208 (PAL) and 475,856 (NTSC) but actual computation is 312×227×8=566,592 and 262×227×8=475,792. Fixed test assertions.
   - **Unused import warnings**: Cleaned up `BusResult`, `self`, `AgnusVariant`, `DeniseVariant`, `KickstartSource` unused imports.
   - User feedback during emu-m68k errors: "If we need to throw away emu-m68k and rebuild it - do it" — resolved by fixing the minor pre-existing issues instead.

5. Problem Solving:
   - All 55 unit tests pass across all modules
   - Binary builds and runs (`--help` verified)
   - emu-m68k existing tests still pass with the wait_cycles change
   - The 64 warnings from emu-m68k are pre-existing in the WIP recipe module (missing docs on struct fields), not introduced by this work

6. All User Messages:
   - First message: "Implement the following plan: [detailed plan for emu-amiga2 crate]" with reference to plan transcript at `/Users/stevehill/.REDACTED.jsonl`
   - Second message (during emu-m68k build errors): "If we need to throw away emu-m68k and rebuild it - do it"

7. Pending Tasks:
   - All 11 tasks marked completed. No explicitly pending tasks remain.
   - Phase 2-4 from the plan are future work (not requested yet):
     - Phase 2: KS 1.2/1.3 on A500 (keyboard handshake, refined DMA, sprite DMA)
     - Phase 3: Workbench boot (floppy controller, blitter, audio DMA)
     - Phase 4: ECS/AGA variants

8. Current Work:
   Phase 1 implementation is complete. The `emu-amiga2` crate has been created with all source files, compiles cleanly, and all 55 tests pass. The binary runs and shows help output. The implementation follows the plan exactly:
   - Uses `emu-m68k` (not `emu-68000`) with word-level M68kBus trait
   - CPU always ticks, contention via wait_cycles in BusResult
   - Full variant support via enum fields in each component
   - Clean ports of CIA, Paula, Copper, custom_regs from emu-amiga (env var traces stripped)
   - No ExecBase patching, no FORCE_CPU, no workarounds

9. Optional Next Step:
   The plan specifies verification for Phase 1: "CPU executes KS 1.0 and writes to custom registers (trace first 1000 instructions, verify DMACON/INTENA are written)". Testing with an actual Kickstart 1.0 ROM would be the natural next step, but this requires a ROM file the user would need to provide. No explicit next step was requested by the user beyond "Implement the following plan" which focused on Phase 1.

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom.

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation:

1. **Context from previous session**: The user had a plan to create `emu-amiga2` crate. Phase 1 was completed - all source files created, 55 tests passing, binary builds. The previous session created the full crate structure.

2. **User's first request**: "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom." - asking to run the headless boot test with the real KS 1.0 ROM.

3. **First run**: PC stuck at $00FC00D0 across all 200 frames, black screenshot. CPU not making progress.

4. **Diagnosis - WCS vector issue**: The ROM starts with `$1111` (Kickstart magic) + `JMP $FC00CE`, not standard 68K reset vectors. A1000 WCS images don't have vector tables at offset 0 - the bootstrap ROM provides those. SSP was $11114EF9 (garbage), PC was $00FC00CE (happened to be correct entry point).

5. **Fix applied to amiga.rs**: Added detection of $1111 KS magic at offset 0. When detected, parse the JMP target for PC, set SSP to top of chip RAM. Otherwise use standard 68K vectors.

6. **Second run**: SSP now correct ($00040000), PC reaches $00010002 but stack rapidly consumed - exception loop.

7. **Overlay investigation**: Checked the CIA-A PRA bit 0 overlay logic in bus.rs. Noted it might be inverted but then focused on the real problem.

8. **Root cause discovery**: Read `decode.rs` which was a STUB:
```rust
pub(super) fn decode_and_execute(&mut self) {
    // Phase 1 stub: all opcodes are illegal
    self.illegal_instruction();
}
```
Every single opcode triggers an illegal instruction exception!

9. **Found execute.rs**: The monolithic legacy execute.rs (9,070 lines) exists but isn't included in mod.rs. It has the full instruction set from emu-68000.

10. **Attempted to swap decode.rs for execute.rs**: Got build errors - InstrPhase missing, duplicate methods between execute.rs and exceptions.rs/timing.rs/execute_shift.rs.

11. **USER CRITICAL FEEDBACK**: "Claude. I _do_ NOT want to use the emu-68000 execute path." - User explicitly rejected using the legacy execute.rs.

12. **Reverted mod.rs** back to `mod decode;`

13. **Studied the recipe system**: Read recipe.rs (1,387 lines) which has ALL RecipeOp handlers implemented in tick_recipe_step(). Read microcode.rs for MicroOp definitions. Read ea.rs for effective address calculation. Read mod.rs for helper methods.

14. **Wrote comprehensive decode.rs**: A full 68000 instruction decoder (~1,393 lines) that builds recipe sequences. Covers all 16 opcode groups:
- Group 0: ORI, ANDI, SUBI, ADDI, EORI, CMPI, BTST/BCHG/BCLR/BSET
- Groups 1/2/3: MOVE, MOVEA
- Group 4: CLR, NEG, NOT, NEGX, TST, LEA, PEA, JSR, JMP, RTS, RTE, RTR, TRAP, LINK, UNLK, MOVEM, MOVE to/from SR/CCR, NOP, STOP, RESET, SWAP, EXT
- Group 5: ADDQ, SUBQ, Scc, DBcc
- Group 6: Bcc, BRA, BSR
- Group 7: MOVEQ
- Group 8: OR, DIVU, DIVS, SBCD
- Group 9: SUB, SUBA, SUBX
- Group B: CMP, CMPA, EOR, CMPM
- Group C: AND, MULU, MULS, ABCD, EXG
- Group D: ADD, ADDA, ADDX
- Group E: Shift/Rotate
- Groups A/F: illegal instruction

The decode.rs was NOT yet compiled or tested when the summary was requested.

Key files modified:
- `crates/emu-amiga2/src/amiga.rs` - WCS $1111 magic detection for A1000 reset vectors
- `crates/emu-amiga2/src/main.rs` - Added diagnostic output (Initial state, per-frame CPU state)
- `crates/emu-m68k/src/m68000/decode.rs` - COMPLETE REWRITE from stub to full decoder
- `crates/emu-m68k/src/m68000/mod.rs` - briefly changed mod decode to mod execute then reverted

The overlay logic in bus.rs (PRA bit 0 = 1 → set_overlay, bit 0 = 0 → clear_overlay) was identified as potentially inverted but NOT yet fixed.

Also noted but not fixed: the bus.rs overlay control is inverted. On real Amiga hardware:
- PRA bit 0 = 0 → overlay ON (ROM at $000000)
- PRA bit 0 = 1 → overlay OFF (chip RAM at $000000)
But the code does the opposite.

Summary:
1. Primary Request and Intent:
   The user asked to run the emu-amiga2 headless boot test with Kickstart 1.0 ROM (`roms/kick10.rom`). This is Phase 1 verification of the emu-amiga2 crate created in a previous session. The goal is to get KS 1.0 executing on an emulated A1000. During debugging, the user explicitly stated: **"Claude. I _do_ NOT want to use the emu-68000 execute path."** — meaning the recipe-based system in emu-m68k must be the execution path, NOT the legacy monolithic execute.rs from emu-68000.

2. Key Technical Concepts:
   - **A1000 WCS (Writable Control Store)**: Unlike A500+ ROMs with standard 68K reset vectors at offset 0, A1000 WCS images start with `$1111` magic + `JMP <entry>`. The bootstrap ROM provides real reset vectors.
   - **Recipe-based instruction execution**: emu-m68k uses RecipeOp sequences (recipe.rs) that expand into MicroOps (microcode.rs) for cycle-accurate execution. The decoder (decode.rs) maps opcodes → recipe sequences.
   - **Overlay inversion bug**: CIA-A PRA bit 0 controls /OVL. Current code has inverted logic (bit 0 = 1 → overlay ON, should be overlay OFF). Identified but NOT yet fixed.
   - **decode.rs was a stub**: Every opcode triggered illegal instruction exception, causing the CPU to be trapped in an exception loop.
   - **execute.rs exists but must NOT be used**: The monolithic legacy execute.rs (9,070 lines) from emu-68000 is present in the crate but user explicitly rejected using it. It has duplicate methods with exceptions.rs, timing.rs, execute_shift.rs, and needs InstrPhase which doesn't exist in mod.rs.

3. Files and Code Sections:
   - **`crates/emu-amiga2/src/amiga.rs`** (lines 65-95)
     - Modified to detect A1000 WCS `$1111` magic at kickstart offset 0
     - When detected, parses JMP target from offset 2 for entry PC, sets SSP = chip_ram_size
     - When not detected, reads standard 68K reset vectors from offset 0-7
     ```rust
     let magic = bus.read_word(0x000000, fc).data;
     let (ssp, pc) = if magic == 0x1111 {
         let opcode = bus.read_word(0x000002, fc).data;
         if opcode != 0x4EF9 {
             return Err(format!(
                 "KS WCS image has $1111 magic but no JMP at offset 2 (got ${opcode:04X})"
             ));
         }
         let pc_hi = bus.read_word(0x000004, fc).data;
         let pc_lo = bus.read_word(0x000006, fc).data;
         let entry_pc = u32::from(pc_hi) << 16 | u32::from(pc_lo);
         let ssp = config.chip_ram_size as u32;
         (ssp, entry_pc)
     } else {
         // Standard ROM: 68K reset vectors at offset 0
         let ssp_lo = bus.read_word(0x000002, fc).data;
         let ssp = u32::from(magic) << 16 | u32::from(ssp_lo);
         let pc_hi = bus.read_word(0x000004, fc).data;
         let pc_lo = bus.read_word(0x000006, fc).data;
         let pc = u32::from(pc_hi) << 16 | u32::from(pc_lo);
         (ssp, pc)
     };
     ```

   - **`crates/emu-amiga2/src/main.rs`** (lines 110-128)
     - Added diagnostic tracing to headless mode: prints initial CPU state, per-frame PC/SR/stopped/halted/D0/A7
     ```rust
     // Diagnostic: dump initial CPU state
     {
         let regs = amiga.cpu().registers();
         eprintln!("Initial: PC=${:08X} SSP=${:08X} SR=${:04X}", regs.pc, regs.ssp, regs.sr);
         eprintln!("Stopped={} Halted={}", amiga.cpu().is_stopped(), amiga.cpu().is_halted());
     }
     ```

   - **`crates/emu-m68k/src/m68000/decode.rs`** — COMPLETE REWRITE (1,393 lines)
     - Was a 23-line stub treating all opcodes as illegal instruction
     - Now contains full 68000 instruction decoder building recipe sequences
     - Covers all 16 opcode groups (0-F), all major instructions
     - Uses recipe_begin/recipe_push/recipe_commit pattern
     - Missing: MOVEP, TAS, NBCD, CHK (marked as TODO/illegal)
     - Key pattern example (SUBQ):
     ```rust
     self.recipe_imm = quick_val;
     let alu_op = if is_sub { RecipeAlu::Sub } else { RecipeAlu::Add };
     self.recipe_begin();
     if ext > 0 { self.recipe_push(RecipeOp::FetchExtWords(ext)); }
     self.recipe_push(RecipeOp::LoadImm);
     self.recipe_push(RecipeOp::CalcEa(EaSide::Dst));
     if is_reg {
         self.recipe_push(RecipeOp::AluReg { op: alu_op, reg });
         if self.size == Size::Long { self.recipe_push(RecipeOp::Internal(4)); }
     } else {
         self.recipe_push(RecipeOp::ReadEa(EaSide::Dst));
         self.recipe_push(RecipeOp::AluMem { op: alu_op });
         self.recipe_push(RecipeOp::WriteEa(EaSide::Dst));
     }
     self.recipe_commit();
     ```

   - **`crates/emu-m68k/src/m68000/mod.rs`** — briefly changed `mod decode` to `mod execute` then reverted back to `mod decode`

   - **`crates/emu-m68k/src/m68000/recipe.rs`** (1,387 lines) — READ for understanding
     - Contains all RecipeOp handler implementations in tick_recipe_step()
     - Recipe engine is complete and functional
     - Handles: FetchExtWords, CalcEa, ReadEa, WriteEa, LoadImm, SetFlagsMove, Internal, AluReg, AluMem, CmpReg, AddrArith, Branch, Jsr, Jmp, RtsPop/Finish, Div, Mul, all MOVEM, LINK/UNLK, etc.

   - **`crates/emu-m68k/src/m68000/microcode.rs`** — READ for understanding MicroOp definitions
   - **`crates/emu-m68k/src/m68000/ea.rs`** — READ for understanding EA calculation helpers
   - **`crates/emu-m68k/src/m68000/execute.rs`** — READ but NOT used (user rejected legacy path)
   - **`crates/emu-amiga2/src/bus.rs`** — READ, contains overlay logic (inverted, not yet fixed)
   - **`crates/emu-amiga2/src/memory.rs`** — READ for understanding memory map

   - **`roms/kick10.rom`** — 262K KS 1.0 ROM file
     - Header: `1111 4ef9 00fc 00ce` = $1111 magic + JMP $00FC00CE
     - Entry point code at offset $CE: `LEA $20000,A7` then delay loop then hardware init

4. Errors and Fixes:
   - **Wrong SSP from WCS image**: First 4 bytes of KS 1.0 ($11114EF9) interpreted as SSP vector but are actually magic+JMP opcode. Fixed by detecting $1111 magic and parsing JMP target instead.
   - **CPU stuck in exception loop at $10002**: Every opcode decoded as illegal instruction because decode.rs was a stub. Fixed by writing a complete decoder.
   - **Attempted mod execute swap**: Switching from `mod decode` to `mod execute` caused E0432 (missing InstrPhase), E0592 (duplicate methods). Reverted because user said "I do NOT want to use the emu-68000 execute path."
   - **Overlay inversion in bus.rs**: CIA-A PRA bit 0 logic is inverted (PRA=1 should mean overlay OFF but code sets overlay ON). Identified but NOT yet fixed.

5. Problem Solving:
   - Diagnosed black screen + stuck PC via hex dump of ROM header revealing WCS format
   - Diagnosed exception loop via CPU state tracing (stack shrinking rapidly, PC stuck)
   - Traced root cause to decode.rs stub by reading the actual code
   - Explored execute.rs as potential fix, then pivoted to writing recipe-based decoder per user direction
   - Wrote comprehensive decode.rs covering the full 68000 instruction set

6. All User Messages:
   - "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom."
   - "Claude. I _do_ NOT want to use the emu-68000 execute path."

7. Pending Tasks:
   - Compile and test the new decode.rs (just written, not yet compiled)
   - Fix the overlay inversion in bus.rs (PRA bit 0 logic is backwards)
   - Re-run the headless KS 1.0 boot test to verify CPU execution
   - Task #12 is in_progress: "Fill in emu-m68k decode.rs with recipe-based instruction dispatch"
   - Task #11 is in_progress: "Build, fix errors, verify compilation"

8. Current Work:
   Just finished writing the complete `crates/emu-m68k/src/m68000/decode.rs` (1,393 lines) — a full 68000 instruction decoder that builds recipe sequences for all opcode groups. This file replaces the stub that was causing every instruction to trigger an illegal instruction exception. The file has been written but NOT yet compiled or tested.

9. Optional Next Step:
   Build emu-m68k with the new decode.rs and fix any compilation errors. Then re-run the headless KS 1.0 boot test:
   ```
   cargo run -p emu-amiga2 -- --model a1000 --kickstart roms/kick10.rom --headless --frames 200 --screenshot ks10-boot.png
   ```
   Also need to fix the overlay inversion in `crates/emu-amiga2/src/bus.rs` (lines 273-277) where PRA bit 0 = 1 incorrectly calls `set_overlay()` instead of `clear_overlay()`.
   
   The user's original request was: "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom." — the goal is to get this headless boot working.

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation, which continues from a previous session that ran out of context.

**Previous Session Context (from summary):**
- User asked to run headless KS 1.0 boot test with `roms/kick10.rom`
- decode.rs was a STUB (every opcode triggered illegal instruction)
- User explicitly said: "Claude. I _do_ NOT want to use the emu-68000 execute path."
- A complete decode.rs was written (~1,393 lines) with recipe-based instruction dispatch
- Overlay inversion in bus.rs was identified but NOT fixed
- A1000 WCS $1111 magic detection was added to amiga.rs

**This Session:**

1. Started by building emu-m68k - compiled with warnings only, no errors
2. Built emu-amiga2 - no errors
3. Fixed overlay inversion in bus.rs (PRA bit 0 = 1 → overlay OFF, not ON)
4. Fixed the overlay test to match corrected logic
5. All 55 tests passed
6. First headless run with KS 1.0: CPU executing, green left half of screen
7. Diagnosed display issue: each CCK = 2 lores pixels, but only writing 1 pixel per CCK
8. Fixed beam_to_fb to multiply by 2, adjusted DISPLAY_HSTART_CCK from 0x40 to 0x2E
9. Fixed tick loop to output 2 pixels per CCK
10. Second run: full green screen
11. User said "See, this is why I was tempted to start fully clean" (frustration about legacy issues)
12. Ran 1000 frames - CPU stuck in keyboard handshake loop, restarts
13. Diagnosed: RESET instruction sets overlay back ON, JMP ($0004) reads ROM, loops forever
14. Fixed: removed `self.memory.set_overlay()` from bus.reset() - overlay should NOT be re-asserted on software RESET (A500 has /OVL pull-up)
15. User said "Let's just make sure we don't get into the same silly loop that Codex got into"
16. Tried KS 1.3 on A500 - same green screen, same loop pattern
17. Added custom register trace - found writes DO happen: INTENA=$7FFF, INTREQ=$7FFF, DMACON=$7FFF, COLOR00=$00C0
18. Added RESET trace - ExecBase@$0004 = $00000000, never initialized
19. Added illegal instruction trace - only 1 illegal at PC=$0000000A
20. Added instruction trace with unique-PC HashSet to trace the full init flow
21. Got complete init flow trace (129 unique PCs)
22. Identified RAM test failing immediately - BNE taken at first aliasing check
23. Was about to investigate DMACON set/clear handling when context ran out

**Key Discovery:** The RAM test writes 0 to base address, advances A0 by $1000, writes test pattern, then checks if base still has 0. BNE is taken (base ≠ 0), meaning RAM test detects aliasing on the very first iteration. This could be:
- DMA writing to chip RAM (but DMACON should have disabled it)
- DMACON set/clear not handled correctly (bit 15 = 0 means CLEAR, but the write_custom_reg might not implement this)
- Some other bus or memory issue

The conversation was cut off while investigating whether DMACON set/clear semantics are correctly implemented in write_custom_reg.

Summary:
1. Primary Request and Intent:
   The user's original request was: "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom." — asking to run the emu-amiga2 headless boot test with a real Kickstart ROM to verify Phase 1 of the new Amiga emulator crate. The goal is to get Kickstart executing on the emulated Amiga. The user explicitly stated in the prior session: **"Claude. I _do_ NOT want to use the emu-68000 execute path."** — the recipe-based system in emu-m68k must be the execution path. The user expressed frustration about legacy issues ("See, this is why I was tempted to start fully clean") and warned about not getting into debugging loops ("Let's just make sure we don't get into the same silly loop that Codex got into").

2. Key Technical Concepts:
   - **A1000 WCS (Writable Control Store)**: KS images start with `$1111` magic + `JMP <entry>`, not standard 68K reset vectors
   - **Recipe-based instruction execution**: emu-m68k uses RecipeOp sequences (recipe.rs) that expand into MicroOps for cycle-accurate execution
   - **Overlay mechanism**: CIA-A PRA bit 0 controls /OVL. Bit 0 = 1 → overlay OFF (chip RAM at $0), bit 0 = 0 → overlay ON (ROM at $0). On A500, external pull-up keeps overlay OFF after CIA reset.
   - **RESET instruction behavior**: 68000 RESET asserts external reset pin, resets CIAs. On A500, /OVL pull-up keeps overlay OFF after RESET (NOT re-asserted). Only cold boot forces overlay ON.
   - **CCK-to-pixel mapping**: Each color clock (CCK) = 2 lores pixels. Framebuffer is 360×284 (lores pixels).
   - **DMACON set/clear semantics**: Bit 15 = 1 means SET bits, bit 15 = 0 means CLEAR bits. Writing $7FFF should CLEAR all DMA enables.
   - **KS 1.3 init flow**: Delay loop → CIA setup → disable INTENA/INTREQ/DMACON → set colors → fill exception vectors → ExecBase check → RAM detection → RAM test → keyboard handshake → RESET → JMP (ExecBase)

3. Files and Code Sections:
   - **`crates/emu-amiga2/src/bus.rs`**
     - Central bus implementation. Multiple fixes applied.
     - **Overlay inversion fix** (line 272-277): Changed from `bit 0 = 1 → set_overlay` to `bit 0 = 1 → clear_overlay` (correct Amiga behavior)
     - **RESET overlay fix** (line 464-479): Removed `self.memory.set_overlay()` from `reset()` method. On A500, overlay stays OFF after software RESET due to external pull-up.
     - **Debug tracing added**: trace_count field, custom register write logging, RESET ExecBase logging
     - Key code for overlay control:
     ```rust
     // Overlay control: PRA bit 0 = 1 → overlay OFF (chip RAM at $0)
     //                  PRA bit 0 = 0 → overlay ON  (ROM at $0)
     if output & 0x01 != 0 {
         self.memory.clear_overlay();
     } else {
         self.memory.set_overlay();
     }
     ```
     - Key code for reset (after fix):
     ```rust
     fn reset(&mut self) {
         // RESET trace added here (debug_assertions)
         self.cia_a.reset();
         self.cia_b.reset();
         self.agnus = Agnus::new(self.agnus.variant(), self.agnus.region());
         self.denise = Denise::new(crate::config::DeniseVariant::Denise8362);
         self.paula = Paula::new();
         self.copper = Copper::new();
         self.blitter = Blitter::new();
         self.keyboard.reset();
         // NOTE: Overlay is NOT re-asserted here.
     }
     ```
     - **CURRENT INVESTIGATION**: Need to check DMACON write handler — the `write_custom_reg` may not implement set/clear semantics correctly for DMACON (offset $0096). Writing $7FFF with bit 15 = 0 should CLEAR bits 0-14.

   - **`crates/emu-amiga2/src/amiga.rs`**
     - System tick loop and frame management
     - **WCS magic detection** (lines 76-102): Detects `$1111` at ROM offset 0, parses JMP target for PC, sets SSP = chip_ram_size
     - **Display HSTART fix**: Changed `DISPLAY_HSTART_CCK` from `0x40` to `0x2E` to fill 360-pixel framebuffer
     - **2-pixel-per-CCK fix**: `beam_to_fb` now returns lores pixel coordinates (`cck_offset * 2`), and tick loop outputs 2 pixels per CCK
     ```rust
     fn beam_to_fb(&self, vpos: u16, hpos_cck: u16) -> Option<(u32, u32)> {
         let fb_y = vpos.wrapping_sub(DISPLAY_VSTART);
         if fb_y >= denise::FB_HEIGHT as u16 { return None; }
         let cck_offset = hpos_cck.wrapping_sub(DISPLAY_HSTART_CCK);
         let fb_x = u32::from(cck_offset) * 2;
         if fb_x + 1 >= denise::FB_WIDTH { return None; }
         Some((fb_x, u32::from(fb_y)))
     }
     ```

   - **`crates/emu-amiga2/src/main.rs`**
     - Headless mode with diagnostic output: PC, SR, D0, A7, overlay status per frame
     - Frame logging at frames 0-4, 15-30, and every 50th frame

   - **`crates/emu-m68k/src/m68000/decode.rs`**
     - Full 68000 instruction decoder (~1,393 lines) built in previous session, replacing the stub
     - **Debug tracing added**: Illegal instruction trace (logs opcode and PC), unique-PC instruction trace using HashSet
     - Current trace code:
     ```rust
     #[cfg(debug_assertions)]
     {
         static TRACE_COUNT: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(0);
         static SEEN: std::sync::Mutex<Option<std::collections::HashSet<u32>>> = std::sync::Mutex::new(None);
         let pc = self.instr_start_pc.wrapping_sub(2);
         let mut seen = SEEN.lock().unwrap();
         let set = seen.get_or_insert_with(std::collections::HashSet::new);
         if pc >= 0x00FC0000 && set.insert(pc) {
             let n = TRACE_COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
             if n < 500 {
                 eprintln!("  TRACE[{n:3}]: PC=${pc:08X} op=${op:04X}");
             }
         }
     }
     ```

   - **`crates/emu-amiga2/src/memory.rs`** — Chip RAM with variable size, mirroring via mask, WCS/ROM, overlay. Chip RAM mask = `(size - 1)`.

   - **`crates/emu-amiga2/src/config.rs`** — A500 preset: 512K chip RAM, 512K slow RAM, OCS chipset, `KickstartSource::Rom`

   - **`crates/emu-amiga2/src/denise/video.rs`** — FB_WIDTH=360, FB_HEIGHT=284, rgb12_to_argb32 conversion

4. Errors and Fixes:
   - **Overlay inversion**: PRA bit 0 logic was backwards (bit 0 = 1 meant overlay ON, should be OFF). Fixed by swapping set_overlay/clear_overlay in the CIA-A PRA write handler. Also fixed the corresponding test.
   - **Half-screen display**: Only left ~45% of framebuffer was filled green. Root cause: 1 CCK = 2 lores pixels but only 1 pixel was output per CCK. Fixed by multiplying CCK offset by 2 in beam_to_fb and outputting 2 pixels per CCK in the tick loop. Also adjusted DISPLAY_HSTART_CCK from 0x40 to 0x2E.
   - **Boot loop with KS 1.0**: After RESET instruction, bus.reset() forced overlay ON, causing JMP ($0004) to read ROM vectors and restart boot. Fixed by removing set_overlay() from reset() — on real A500, /OVL pull-up keeps overlay OFF after CIA reset.
   - **Illegal instruction trace field name**: Used `self.current_opcode` which doesn't exist; correct field is `self.opcode`.
   - **Trace loop detection failures**: Multiple attempts at filtering delay/keyboard loops from CPU trace. Forward-only PC detection and loop detection both failed to filter the 131K-iteration delay loop. Final solution: HashSet of unique PCs.
   - **ExecBase never initialized**: After overlay fix, MOVEA.L $0004.W reads chip RAM which contains $00000000. The KS init code's RAM test is failing on the very first iteration, causing it to skip ExecBase creation and go straight to keyboard handshake.

5. Problem Solving:
   - **Solved**: Display pipeline working end-to-end (crystal tick → CCK → Denise → framebuffer → PNG screenshot)
   - **Solved**: CPU executing KS init code correctly through delay loop, CIA setup, custom register writes
   - **Solved**: Overlay logic corrected for both CIA writes and software RESET
   - **Ongoing**: RAM test fails immediately — at $FC05A8 (TST.L (A2)), the base address shows non-zero after writing 0 there, then writing test pattern to A0+$1000. This causes BCS at $FC0220 → skip ExecBase setup → go to keyboard handshake → RESET → JMP ($0004) → ExecBase=0 → crash at $000000.
   - **Suspected root cause**: DMACON set/clear write semantics may not be implemented — writing $7FFF to DMACON should CLEAR all DMA bits (bit 15=0 = clear mode), but if the handler doesn't implement set/clear, DMA might still be active and writing to chip RAM during the RAM test.

6. All user messages:
   - (From previous session): "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom."
   - (From previous session): "Claude. I _do_ NOT want to use the emu-68000 execute path."
   - "See, this is why I was tempted to start fully clean"
   - "Let's just make sure we don't get into the same silly loop that Codex got into."

7. Pending Tasks:
   - Investigate why KS RAM test fails on first iteration (TST.L (A2) returns non-zero at base address)
   - Check DMACON set/clear semantics in write_custom_reg (offset $0096) — likely missing set/clear bit 15 logic
   - Check INTENA and INTREQ set/clear handling too
   - Once RAM test passes, ExecBase should be written to $0004, enabling successful RESET+JMP boot cycle
   - Remove all debug tracing (TRACE, ILLEGAL, CUSTOM, RESET traces) once boot works
   - Goal: KS 1.3 on A500 boots to green/gradient screen

8. Current Work:
   Was investigating why ExecBase ($0004) is never written during KS 1.3 init on A500. Traced the full init flow using unique-PC HashSet and found:
   - KS init runs: delay → CIA → custom regs → exception vectors → memory detection → RAM test
   - RAM test at $FC0592-$FC05B2 fails immediately: writes 0 to base, advances A0 by $1000, writes pattern, then TST.L at base shows non-zero (BNE taken at $FC05AA)
   - This causes the init to skip ExecBase creation and go straight to keyboard handshake → RESET → JMP ($0004 = 0) → crash
   - Was about to check DMACON write handler in bus.rs write_custom_reg when the conversation ended

9. Optional Next Step:
   Check and fix DMACON/INTENA/INTREQ set/clear write semantics in `crates/emu-amiga2/src/bus.rs` `write_custom_reg()`. The KS code writes `$7FFF` to DMACON (bit 15 = 0 = CLEAR mode), which should disable all DMA. If the handler doesn't implement set/clear semantics (using the `set_clr_write` helper from custom_regs), DMA may still be running and corrupting the RAM test. This is the most likely root cause of the failed RAM test and the ExecBase never being written.

   Relevant quotes from the investigation:
   - "ExecBase at $0004 is $00000000! The init code never wrote ExecBase to $0004."
   - Custom register trace showed: "CUSTOM: DMACON=$7FFF (write #2)"
   - RAM test trace showed BNE taken at first aliasing check ($FC05AA)
   - Was actively looking at: "is DMACON set/clear handling correct? The code writes $7FFF to DMACON which should CLEAR all DMA bits"

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation, which continues from a previous session that ran out of context.

**Previous Session Context (from summary):**
- User asked to run headless KS 1.0 boot test with `roms/kick10.rom`
- decode.rs was a STUB (every opcode triggered illegal instruction)
- User explicitly said: "Claude. I _do_ NOT want to use the emu-68000 execute path."
- A complete decode.rs was written (~1,393 lines) with recipe-based instruction dispatch
- Overlay inversion in bus.rs was identified but the "fix" was actually wrong (inverted the correct polarity)
- A1000 WCS $1111 magic detection was added to amiga.rs
- Many fixes applied: display pipeline, 2-pixel-per-CCK, RESET overlay behavior
- RAM test was failing - was about to investigate DMACON set/clear when context ran out

**This Session:**

The session continues from where the previous one left off. The user's message is a system continuation message asking to continue the last task.

1. **Read key files to understand state**: Read bus.rs, custom_regs.rs, memory.rs to check DMACON set/clear handling
   - Found that `set_clr_write` in custom_regs.rs is correct
   - Found that agnus.write_dmacon(), paula.write_intena(), paula.write_intreq() all correctly use set_clr_write
   - So DMACON/INTENA/INTREQ set/clear is NOT the bug

2. **Read config.rs and agnus/mod.rs**: Verified A500 preset (512K chip, 512K slow, OCS), checked Agnus beam counter

3. **Read agnus/dma.rs and paula.rs**: Verified DMA slot allocation and interrupt handling are correct

4. **Read cia.rs**: Verified CIA 8520 implementation, reset behavior

5. **Added memory read trace**: Added debug trace to memory.rs for reads from addresses 0-7 when overlay is active

6. **Added overlay state change trace**: Added logging when overlay transitions ON→OFF or OFF→ON

7. **First diagnostic run (5 frames)**: CPU in delay loop, overlay still ON, no useful overlay data yet

8. **200 frame run**: Got the full trace showing:
   - CUSTOM writes: INTENA=$7FFF, INTREQ=$7FFF, DMACON=$7FFF
   - Then RAM test writes to $000000 with overlay=true
   - Then COLOR00=$00C0
   - Then OVERLAY: ON→OFF
   - MISSING: BPLCON0=$0200 write

9. **Got full TRACE entries** (122 unique PCs): Traced complete KS 1.3 init flow

10. **Decoded ROM bytes**: Found exact init sequence addresses:
    - LEA $0000.W, A0 (base of RAM test = $000000)
    - LEA $200000.L, A1 (end address)
    - LEA $1000(A0), A0 (step = $1000)
    - MOVE.L #$F2D4B698, D0 (test pattern)

11. **Added bus read/write traces for address 0**: Found RAM test writes at PC=$FC0594 going to $000000 with overlay=true

12. **Added CPU-level write trace**: Confirmed writes come from the RAM test instruction

13. **Key discovery - SkipExt bug in decode_move**: 
    - BPLCON0=$0200 write was MISSING from custom register trace
    - COLOR00 showed wrong value ($00C0 instead of $0444)
    - Root cause: `SkipExt(src_ext)` in decode_move double-advances ext_idx
    - For MOVE.W #imm, d16(An): ReadEa consumes ext_words[0] (immediate), then SkipExt advances past ext_words[1] (displacement), causing CalcEa(Dst) to get displacement=0
    - Fix: Removed the SkipExt line from decode_move

14. **Key discovery - Overlay polarity was INVERTED**:
    - Previous session "fixed" overlay to: bit 0 = 1 → OFF, bit 0 = 0 → ON
    - But actual A500 hardware: OVL (PRA bit 0) = 1 → overlay ACTIVE (ROM at $0), OVL = 0 → overlay INACTIVE (chip RAM at $0)
    - KS 1.3 writes PRA=$02 (bit 0=0) to TURN OFF overlay, exposing chip RAM
    - Fix: Swapped set_overlay/clear_overlay back to original polarity
    - Also fixed the unit test

15. **After both fixes**: 
    - Overlay correctly turns OFF when KS writes PRA bit 0 = 0
    - BPLCON0=$0200 and COLOR00=$0444 now appear in custom reg trace
    - RAM test at $000000 now reads from chip RAM (not ROM)
    - RAM test PASSES (base address stays $0000)
    - CPU proceeds to chip RAM fill loop

16. **Running more frames**: CPU is in a long fill loop at $FC060E-$FC0614, filling chip RAM with zeros. By frame 700, overlay turns back ON briefly. Still filling at frame 1000.

The conversation was about to see what happens after the fill completes — whether KS 1.3 continues through to the keyboard handshake, ExecBase setup, and eventually to a boot screen.

Key bugs fixed:
1. **SkipExt in decode_move**: Removed unnecessary SkipExt that double-advanced ext_idx, causing wrong displacement for MOVE with both immediate source and displacement destination
2. **Overlay polarity**: Corrected to match A500 hardware: OVL=1 → overlay active (ROM at $0), OVL=0 → overlay inactive (chip RAM at $0)

Debug traces added (still present):
- Memory reads from addresses 0-7 when overlay active
- Overlay state transitions
- Custom register writes (DMACON, INTENA, INTREQ, BPLCON0, COLOR00)
- CPU WRITE_WORD for addresses < 8
- BUS WRITE_WORD for addresses < 8
- BUS READ_WORD for addresses < 8 when overlay off
- RESET trace showing ExecBase
- Instruction trace with unique-PC HashSet in decode.rs

All user messages:
- The only user message is the continuation/summary request at the end. The session started with a system continuation message that said "Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on."

Summary:
1. Primary Request and Intent:
   The user's original request (from prior sessions) was: "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom." — to run the emu-amiga2 headless boot test with real Kickstart ROMs to verify Phase 1 of the new Amiga emulator crate. The user explicitly stated: **"Claude. I _do_ NOT want to use the emu-68000 execute path."** — the recipe-based system in emu-m68k must be the execution path. This session continued automatically from a context overflow, investigating why the KS RAM test fails on the first iteration.

2. Key Technical Concepts:
   - **Recipe-based 68000 execution**: emu-m68k uses RecipeOp sequences that expand into MicroOps for cycle-accurate execution. Extension words are pre-fetched and consumed via `ext_idx`/`ext_words[]` array.
   - **MOVE decode extension word flow**: `FetchExtWords(N)` pre-fetches N words. `CalcEa`/`ReadEa` consume them via `next_ext_word()` which increments `ext_idx`. The `SkipExt` op was incorrectly used to advance past source ext words that were already consumed.
   - **Amiga OVL (overlay) signal**: CIA-A PRA bit 0 directly controls OVL. OVL=1 → overlay ACTIVE (ROM mapped at $0). OVL=0 → overlay INACTIVE (chip RAM at $0). At power-on, external pull-up holds OVL HIGH (overlay active for reset vectors). KS clears bit 0 to expose chip RAM.
   - **DMACON/INTENA/INTREQ SET/CLR semantics**: Bit 15 = 1 means SET bits 0-14; bit 15 = 0 means CLEAR bits 0-14. Implemented correctly via `set_clr_write()`.
   - **KS 1.3 init flow**: Delay loop → CIA DDR/PRA setup (overlay off) → INTENA/INTREQ/DMACON clear → BPLCON0/COLOR00 → exception vector fill → ExecBase check → memory detection → RAM fill → RAM test → ExecBase creation → keyboard handshake → RESET cycle.
   - **A500 config**: 512K chip RAM (mask=$7FFFF), 512K slow RAM, OCS chipset, Agnus8361, Denise8362, KS as ROM (not WCS).

3. Files and Code Sections:

   - **`crates/emu-m68k/src/m68000/decode.rs`**
     - Central instruction decoder for emu-m68k. Contains the SkipExt bug that was fixed.
     - **Fix applied**: Removed `SkipExt(src_ext)` from `decode_move()` — it double-advanced ext_idx past destination extension words.
     ```rust
     // Before (buggy):
     if dst_ext > 0 { self.recipe_push(RecipeOp::SkipExt(src_ext)); }
     
     // After (fixed):
     // No SkipExt needed: CalcEa/ReadEa for Src already consume src ext
     // words via next_ext_word(), advancing ext_idx to the dst position.
     ```
     - Still contains debug tracing (unique-PC HashSet trace, illegal instruction trace).

   - **`crates/emu-amiga2/src/bus.rs`**
     - Central bus implementation routing CPU memory accesses. Contains overlay polarity fix.
     - **Overlay polarity fix** (the critical change):
     ```rust
     // Overlay control: OVL (PRA bit 0) directly maps ROM to $0.
     // OVL = 1 → overlay ACTIVE (ROM at $0)
     // OVL = 0 → overlay INACTIVE (chip RAM at $0)
     // At power-on, pull-up holds OVL=1 (overlay active for reset vectors).
     // KS clears bit 0 to expose chip RAM.
     if output & 0x01 != 0 {
         self.memory.set_overlay();
     } else {
         self.memory.clear_overlay();
     }
     ```
     - **Test also fixed** to match correct polarity:
     ```rust
     // Write PRA bit 0 = 1 → OVL HIGH → overlay ACTIVE (ROM at $0)
     bus.write_byte(0xBFE001, 0x01, fc);
     assert!(bus.memory.overlay);
     // Write PRA bit 0 = 0 → OVL LOW → overlay INACTIVE (chip RAM at $0)
     bus.write_byte(0xBFE001, 0x00, fc);
     assert!(!bus.memory.overlay);
     ```
     - Debug traces added: CPU WRITE_WORD for addr<8, BUS WRITE_WORD for addr<8, BUS READ_WORD for addr<8 when overlay off, custom register write logging, RESET ExecBase trace.
     - `chip_ram_mask` field on Memory made `pub(crate)` for bus trace access.

   - **`crates/emu-amiga2/src/memory.rs`**
     - Chip RAM, WCS/ROM, overlay mechanism.
     - Debug traces added: overlay state transitions, ROM reads at addr<8 when overlay active.
     - `chip_ram_mask` changed from private to `pub(crate)`.

   - **`crates/emu-m68k/src/m68000/mod.rs`**
     - CPU write_word method — debug trace added for writes to addr<8.

   - **`crates/emu-m68k/src/m68000/recipe.rs`**
     - Contains RecipeOp execution including CalcEa, ReadEa, WriteEa, SkipExt, FetchExtWords.
     - SkipExt advances `ext_idx` by count; the issue was it was called after ReadEa already consumed the source ext words.

   - **`crates/emu-m68k/src/m68000/ea.rs`**
     - `next_ext_word()` reads from `ext_words[ext_idx]` and increments `ext_idx`. Returns 0 if past end.
     - `calc_ea()` for `AddrIndDisp(r)` calls `next_ext_word()` for displacement.

   - **`crates/emu-amiga2/src/custom_regs.rs`** — Correct `set_clr_write()` helper, register offset constants.
   - **`crates/emu-amiga2/src/agnus/mod.rs`** — Correct `write_dmacon()` using `set_clr_write`.
   - **`crates/emu-amiga2/src/agnus/dma.rs`** — DMA slot allocation, chip RAM contention.
   - **`crates/emu-amiga2/src/paula.rs`** — Correct `write_intena()`/`write_intreq()` using `set_clr_write`.
   - **`crates/emu-amiga2/src/cia.rs`** — CIA 8520 with correct reset, DDR/PRA handling.
   - **`crates/emu-amiga2/src/config.rs`** — A500 preset: 512K chip, 512K slow, OCS.
   - **`crates/emu-amiga2/src/amiga.rs`** — Tick loop, WCS $1111 magic detection, beam-to-framebuffer mapping.
   - **`crates/emu-amiga2/src/main.rs`** — Headless mode with per-frame diagnostic output.

4. Errors and Fixes:
   - **SkipExt double-advance in decode_move**:
     - For `MOVE.W #imm, d16(An)`: FetchExtWords(2) stores [imm, disp]. ReadEa(Src) for #imm consumes ext_words[0] via next_ext_word(), advancing ext_idx to 1. Then SkipExt(1) advances ext_idx to 2. CalcEa(Dst) calls next_ext_word() but ext_idx(2) >= ext_count(2) → returns 0 → displacement=0 → wrong register address.
     - Symptom: BPLCON0=$0200 write to $DFF100 instead wrote to $DFF000 (fell through to `_ => {}` in custom reg handler), completely silently lost. COLOR00 also wrote wrong values.
     - Fix: Removed `if dst_ext > 0 { self.recipe_push(RecipeOp::SkipExt(src_ext)); }` from decode_move.
   
   - **Overlay polarity inverted (from previous session's incorrect "fix")**:
     - Previous session changed overlay to: bit 0=1 → OFF, bit 0=0 → ON
     - Correct A500 hardware: OVL (PRA bit 0) = 1 → overlay ACTIVE (ROM at $0), = 0 → overlay INACTIVE
     - KS 1.3 writes PRA=$02 (bit 0=0) to turn overlay OFF and expose chip RAM
     - With wrong polarity: overlay stayed ON during RAM test → TST.L (A2) read ROM ($1111...) not chip RAM ($0000) → test always failed
     - Fix: Swapped set_overlay/clear_overlay to match correct A500 OVL semantics. Also fixed unit test.

   - **Build error for private field access**: `chip_ram_mask` was private, needed for bus trace. Changed to `pub(crate)`.

5. Problem Solving:
   - **Solved**: SkipExt bug in MOVE decode causing wrong displacement for instructions like `MOVE.W #imm, d16(An)`. This affected ALL custom register writes via displacement addressing (BPLCON0, BPL1DAT, COLOR00, etc.).
   - **Solved**: Overlay polarity — corrected to match A500 hardware where OVL=1 means overlay active.
   - **Solved**: RAM test now passes — chip RAM reads return $0000 at base address while test patterns are written at higher offsets.
   - **Ongoing**: KS 1.3 is now in the chip RAM fill loop (filling large amount of RAM with zeros). Need more frames to get past it. At frame 700, overlay briefly turns back ON (possibly from RESET instruction in the init flow). Still filling at frame 1000.

6. All user messages:
   - (From the continuation system message): "Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on."
   - (From prior sessions, preserved in summary): "Run that for me. You'll find a Kickstart 1.0 ROM file in roms/kick10.rom."
   - (From prior sessions): "Claude. I _do_ NOT want to use the emu-68000 execute path."
   - (From prior sessions): "See, this is why I was tempted to start fully clean"
   - (From prior sessions): "Let's just make sure we don't get into the same silly loop that Codex got into."

7. Pending Tasks:
   - Run enough frames to get past the chip RAM fill loop and see if KS 1.3 continues to boot
   - Remove all debug tracing (TRACE, OVERLAY, CUSTOM, CPU WRITE, BUS READ/WRITE traces) once boot works
   - Verify KS 1.3 boots to the gradient/insert-floppy screen
   - Take a headless screenshot to verify display output
   - Test with KS 1.0 on A1000 as well

8. Current Work:
   After fixing two critical bugs (SkipExt in decode_move and overlay polarity), KS 1.3 on A500 now gets past the RAM test and enters a long chip RAM fill loop. The last run was 1000 frames of headless execution:
   ```
   Frame 700: PC=$00FC0610 SR=$2704 D0=$0001A211 A7=$0003FFF8 ovl=false
     OVERLAY: OFF → ON
   Frame 750: PC=$00FC060E SR=$2704 D0=$000125A2 A7=$0003FFF8 ovl=true
   Frame 850: PC=$00FC060E SR=$2704 D0=$00012CC6 A7=$0003FFF8 ovl=true
   ```
   The CPU is still in the fill loop at $FC060E-$FC0614 (MOVE.L D2,(A0)+/DBRA). At frame 700, overlay turned back ON (probably from a RESET instruction in the init flow). The fill is very large and taking many frames to complete.

9. Optional Next Step:
   Run more frames (2000+) to get past the fill loop and see what KS 1.3 does next. If the CPU gets past the fill and proceeds through ExecBase creation, keyboard handshake, and eventually reaches the gradient boot screen, the core boot is working. If it stalls again, investigate the new stall point. The overlay turning back ON at frame 700 is concerning and may need investigation — it could indicate a second RESET cycle or a bug in the overlay handling during the fill.

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

Ok. You didn't address my concern.

---

Kill emu-68000. Then tell me exactly how you'll rewrite decode.rs; I think we need an on-disk plan to prevent us from any further context loss.

---

I think it might also be a good idea to write up our plan for dealing with all of the different Amiga variants that we discussed, or did you lose that too?

---

Ok. That seems reasonable for now. I believe your plans make sense.

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation:

1. **Session Start**: This is a continuation from a previous conversation that ran out of context. The summary from the previous session describes extensive work on emu-amiga2 (a new Amiga emulator crate) with emu-m68k as the CPU. Key bugs were fixed: SkipExt double-advance in decode_move, and overlay polarity inversion. KS 1.3 was in a chip RAM fill loop at frame 1000.

2. **First action**: Ran KS 1.3 headless for 3000 frames - still stuck in fill loop at $FC060E-$FC0614. Overlay went ON at frame 700 and stayed ON. Custom register writes of $0000 appeared repeatedly.

3. **Investigation of RESET handling**: Explored how RESET instruction interacts with bus/CIAs/overlay. Found that bus.rs `reset()` resets CIA-A but doesn't re-evaluate overlay state. After CIA reset, port_a_output() returns 0xFF (all bits high due to DDR=0 inputs with pull-ups), but overlay check only runs on PRA/DDRA writes.

4. **Timing investigation**: Checked CPU tick rate - confirmed 141,648 CPU ticks per frame (correct). Each fill loop iteration takes ~31 cycles. For 512K fill, should take ~28 frames, not 3000+.

5. **ROM disassembly**: Decoded the fill routine at $FC0602-$FC0618:
   - MOVEQ #0,D2 (fill value)
   - SUB.L A0,D0 (size = end - start)
   - LSR.L #2,D0 (longword count)
   - MOVE.L D0,D1 / SWAP D1 (double-loop setup)
   - MOVE.L D2,(A0)+ / DBRA D0 / DBRA D1 / JMP (A5)

6. **Key discovery**: D1=$0001FFD0 at frame 21, which means D1.w=$FFD0 = 65488 outer iterations. Each outer iteration does 65536 inner iterations. Total: ~4.3 billion iterations = would take ~936,000 frames. The fill is trying to fill way more than 512K.

7. **SWAP investigation**: Checked SwapReg implementation in recipe.rs - it's correct: `(value >> 16) | (value << 16)`. So SWAP itself isn't buggy. The wrong D1 value must come from somewhere else in the memory detection code.

8. **User frustration message**: User said "I have a feeling some of our discussion around this approach was lost in the context crash. I'm very close to saying 'let's scrap both emu-68000 and emu-m68k and re-implement from scratch'."

9. **My initial response** tried to give options (debug, rewrite, or other). User said "Ok. You didn't address my concern." - meaning I dodged the question of whether scrapping makes sense.

10. **Direct response**: I addressed it directly - emu-68000 should go (wrong bus architecture). emu-m68k's engine is sound but decode.rs should be rewritten methodically with incremental testing.

11. **User directive**: "Kill emu-68000. Then tell me exactly how you'll rewrite decode.rs; I think we need an on-disk plan to prevent us from any further context loss."

12. **Killed emu-68000**: Added `exclude = ["crates/emu-68000", "crates/emu-amiga"]` to workspace Cargo.toml. Verified workspace builds without them.

13. **Wrote decode rewrite plan**: Created `docs/decode-rewrite-plan.md` with 13 phases (0-12), each covering instruction groups verified against single-step tests.

14. **User asked about variant plan**: "I think it might also be a good idea to write up our plan for dealing with all of the different Amiga variants that we discussed, or did you lose that too?"

15. **Wrote variant plan**: Read config.rs, agnus/mod.rs, denise/mod.rs to understand current state. Created `docs/amiga-variants-plan.md` covering variant axes (Agnus, Denise, Paula, CIA, CPU, Memory), what's implemented vs TODO, phased rollout (OCS→ECS→AGA).

16. **User approval**: "Ok. That seems reasonable for now. I believe your plans make sense."

Key files modified:
- `/Users/stevehill/Projects/Emu198x/Cargo.toml` - Added exclude for emu-68000 and emu-amiga
- `/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/main.rs` - Added D1, A0, cpu_ticks to frame diagnostic output
- `/Users/stevehill/Projects/Emu198x/docs/decode-rewrite-plan.md` - NEW: 13-phase decode.rs rewrite plan
- `/Users/stevehill/Projects/Emu198x/docs/amiga-variants-plan.md` - NEW: Amiga variant strategy document

Key files read (important for context):
- `crates/emu-m68k/src/m68000/decode.rs` - Full 1,421-line file read, contains all instruction decode logic
- `crates/emu-m68k/src/m68000/mod.rs` - CPU tick method, wait cycle consumption, micro-op dispatch
- `crates/emu-m68k/src/m68000/recipe.rs` - SwapReg implementation verified correct
- `crates/emu-amiga2/src/bus.rs` - Full bus implementation with overlay control, reset handling
- `crates/emu-amiga2/src/amiga.rs` - System tick loop, crystal-driven timing
- `crates/emu-amiga2/src/agnus/dma.rs` - DMA slot allocation and chip_ram_contention
- `crates/emu-amiga2/src/agnus/mod.rs` - Agnus with variant enum dispatch
- `crates/emu-amiga2/src/denise/mod.rs` - Denise with variant field (unused)
- `crates/emu-amiga2/src/memory.rs` - Memory subsystem with overlay
- `crates/emu-amiga2/src/config.rs` - Model presets
- `crates/emu-amiga2/src/main.rs` - CLI and headless mode

The immediate next step per the plan would be Phase 0 of the decode.rs rewrite: strip it to a skeleton. The user approved the plans.

Summary:
1. Primary Request and Intent:
   The session continues from a previous context crash. The original task was booting KS 1.3 on the emu-amiga2 emulator using emu-m68k as the CPU. After discovering the fill loop was running 150x slower than expected (3000+ frames instead of ~28), and that D1 had an incorrect value suggesting a bug somewhere in the instruction decode layer, the user expressed frustration and considered scrapping both CPU crates. The user's explicit requests were:
   - **Kill emu-68000** — remove it from the workspace entirely
   - **Write a detailed on-disk plan for rewriting decode.rs** to prevent context loss
   - **Write up the Amiga variant plan** that was discussed but lost in context crashes
   - The user explicitly stated in a prior session: **"I do NOT want to use the emu-68000 execute path"** — emu-m68k's recipe-based system is the only path forward
   - The user approved both plans: "Ok. That seems reasonable for now. I believe your plans make sense."

2. Key Technical Concepts:
   - **Recipe-based 68000 execution**: emu-m68k decodes opcodes into RecipeOp sequences that expand into cycle-accurate MicroOps
   - **Extension word flow**: FetchExtWords pre-fetches N words; CalcEa/ReadEa consume them via next_ext_word() incrementing ext_idx
   - **Crystal-driven tick loop**: 28.375 MHz PAL crystal, CPU ticks every 4 crystal ticks (7.09 MHz), CCK every 8 crystal ticks
   - **DMA contention via wait_cycles**: chip RAM accesses return BusResult with wait_cycles, consumed by CPU as idle ticks
   - **Amiga variant dispatch**: enum inside component (not trait objects), dispatch at leaf methods where behaviour differs
   - **Single-step tests**: 127 test files in test-data/m68000-dl/v1/ covering every 68000 instruction, 317,500 total tests, currently 77,972 pass
   - **DBRA double-loop fill**: KS 1.3 uses MOVE.L D2,(A0)+/DBRA D0/DBRA D1 for memory clearing, with D1=SWAP(D0) for outer loop count
   - **Overlay mechanism**: CIA-A PRA bit 0 controls OVL. OVL=1 → overlay active (ROM at $0), OVL=0 → chip RAM at $0

3. Files and Code Sections:

   - **`Cargo.toml`** (workspace root)
     - Modified to exclude emu-68000 and emu-amiga from workspace
     ```toml
     [workspace]
     resolver = "2"
     members = ["crates/*"]
     exclude = ["crates/emu-68000", "crates/emu-amiga"]
     ```

   - **`docs/decode-rewrite-plan.md`** (NEW)
     - 13-phase incremental decode.rs rewrite plan, verified against single-step tests at each phase
     - Phase 0: Strip to skeleton. Phase 1: MOVE/MOVEA/MOVEQ/LEA. Phase 2: BRA/Bcc/BSR/JMP/JSR/RTS/DBcc. Phases 3-12: remaining instruction groups
     - Rules: never write more than one phase without testing, each phase gets its own commit, 0 failures before moving on

   - **`docs/amiga-variants-plan.md`** (NEW)
     - Variant strategy: enum dispatch inside components, not trait objects
     - Five variant axes: Agnus (DMA range), Denise (colour depth), CPU, Memory config, Region
     - Phased rollout: A (OCS A500 KS 1.3), B (OCS A1000 KS 1.0), C (Floppy/Workbench), D (ECS), E (AGA)
     - Documents what's implemented vs TODO for each component

   - **`crates/emu-amiga2/src/main.rs`**
     - Added D1, A0, cpu_ticks to frame diagnostic output for debugging
     - Changed frame display range to include frames 15-55 for fill loop visibility
     ```rust
     let cpu_ticks = amiga.cpu().total_cycles().0;
     eprintln!(
         "Frame {i}: PC=${:08X} SR=${:04X} D0=${:08X} D1=${:08X} A0=${:08X} A7=${:08X} ovl={overlay} ticks={cpu_ticks}",
         regs.pc, regs.sr, regs.d[0], regs.d[1], regs.a[0], regs.ssp,
     );
     ```

   - **`crates/emu-m68k/src/m68000/decode.rs`** (1,421 lines, full read)
     - Current decode with all instruction groups implemented (except MOVEP, TAS, NBCD, CHK as stubs/missing)
     - Contains debug trace machinery (HashSet for unique PCs) that should be removed
     - SWAP decode at lines 601-608 dispatches to RecipeOp::SwapReg — verified correct
     - MOVE decode at lines 357-408 — previous SkipExt bug was fixed (removed unnecessary SkipExt)
     - This file is the target of the Phase 0-12 rewrite plan

   - **`crates/emu-m68k/src/m68000/recipe.rs`** (SwapReg at lines 1193-1198)
     - SwapReg implementation verified correct:
     ```rust
     RecipeOp::SwapReg { reg } => {
         let value = self.regs.d[reg as usize];
         let swapped = (value >> 16) | (value << 16);
         self.regs.d[reg as usize] = swapped;
         self.set_flags_move(swapped, Size::Long);
     }
     ```

   - **`crates/emu-m68k/src/m68000/mod.rs`**
     - tick() method at line 2051: burns wait_cycles before processing micro-ops (working correctly)
     - tick_internal() at line 355: instant vs timed micro-op dispatch loop
     - write_word() at line 283: accumulates wait_cycles from BusResult via saturating_add
     - Each timed micro-op takes exactly 4 CPU cycles (cycles 0,1,2,3)

   - **`crates/emu-amiga2/src/bus.rs`** (584 lines, full read)
     - AmigaBus implements M68kBus trait
     - reset() at line 481: resets all CIAs and chips but does NOT re-evaluate overlay
     - write_cia_a() at line 289: overlay check only on PRA/DDRA writes
     - chip_ram_wait() returns dma::chip_ram_contention() for CPU bus contention
     - Debug traces still present: BUS READ/WRITE for addresses <8, CUSTOM register writes, RESET ExecBase trace

   - **`crates/emu-amiga2/src/amiga.rs`** (422 lines)
     - Crystal-driven tick loop: CCK every 8 ticks, CPU every 4, CIA every 40
     - ticks_per_frame = 566,592 (PAL: 312 lines × 227 CCKs × 8)
     - CPU ticks per frame = 141,648 (confirmed by diagnostic output)
     - A1000 WCS $1111 magic detection in Amiga::new()

   - **`crates/emu-amiga2/src/agnus/dma.rs`** (145 lines)
     - chip_ram_contention() returns 0 when CPU owns slot, 2 when DMA active
     - Refresh slots (HPOS 1-3, 0x1B) always allocated regardless of DMACON

   - **`crates/emu-amiga2/src/agnus/mod.rs`** (222 lines)
     - Stores AgnusVariant enum, dispatches in read_vposr() for Agnus ID
     - Beam counter correct for PAL/NTSC

   - **`crates/emu-amiga2/src/denise/mod.rs`** (131 lines)
     - Stores DeniseVariant but unused (#[allow(dead_code)])
     - 32-entry 12-bit palette, 6-bitplane shift register output

   - **`crates/emu-amiga2/src/config.rs`** (215 lines)
     - Presets for A1000, A500, A500+, A600, A2000, A1200
     - A500: 512K chip + 512K slow, OCS, Agnus8361, Denise8362, KickstartSource::Rom

   - **`crates/emu-amiga2/src/memory.rs`** (273 lines)
     - Variable chip RAM with power-of-two masking, slow RAM, WCS/ROM, overlay
     - Debug traces for overlay transitions and ROM reads at addr<8

   - **`crates/emu-m68k/tests/single_step_tests.rs`**
     - run_test_file() runs all tests in a .bin file, returns (passed, failed, errors)
     - run_all_single_step_tests() iterates all 127 test files
     - Verification command: `cargo test -p emu-m68k --test single_step_tests -- SWAP --nocapture`

4. Errors and fixes:
   - **Fill loop taking 3000+ frames instead of ~28**:
     - Root cause investigation: D1 has wrong value ($0001FFD0 instead of expected $F51D0001 after SWAP). This makes the outer loop counter ~65K instead of ~2, turning a 512K fill into a ~17GB fill.
     - SWAP itself is implemented correctly in recipe.rs. The bug is elsewhere in the instruction decode — likely another instruction in the memory detection path at $FC061A+ is producing wrong results.
     - NOT YET FIXED — this is why the decode.rs rewrite plan was created
   - **User feedback: "Ok. You didn't address my concern."**
     - I initially gave the user a menu of 3 options instead of directly addressing whether scrapping both CPU crates made sense
     - Fixed by being direct: emu-68000 should go (wrong architecture), emu-m68k engine is sound but decode.rs needs methodical rewrite

5. Problem Solving:
   - **Solved**: Confirmed CPU tick rate is correct (141,648 per frame = 566,592/4)
   - **Solved**: Confirmed SWAP implementation is correct
   - **Solved**: Identified that D1's wrong value causes fill loop to run ~936K frames instead of ~28
   - **Solved**: Killed emu-68000 from workspace
   - **Solved**: Created on-disk plans to survive context crashes
   - **Unsolved**: The actual instruction bug causing wrong D1 value — deferred to the decode.rs rewrite which will catch it through incremental testing
   - **Unsolved**: bus.rs reset() not re-evaluating overlay after CIA reset
   - **Unsolved**: Debug traces still present in bus.rs, memory.rs, mod.rs, decode.rs

6. All user messages:
   - (Continuation message): "Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on."
   - "I have a feeling some of our discussion around this approach was lost in the context crash. I'm very close to saying 'let's scrap both emu-68000 and emu-m68k and re-implement from scratch'."
   - "Ok. You didn't address my concern."
   - "Kill emu-68000. Then tell me exactly how you'll rewrite decode.rs; I think we need an on-disk plan to prevent us from any further context loss."
   - "I think it might also be a good idea to write up our plan for dealing with all of the different Amiga variants that we discussed, or did you lose that too?"
   - "Ok. That seems reasonable for now. I believe your plans make sense."

7. Pending Tasks:
   - Execute Phase 0 of decode.rs rewrite: strip to skeleton (user approved the plan)
   - Execute Phases 1-12 of decode.rs rewrite incrementally with single-step test verification
   - Fix bus.rs reset() to re-evaluate overlay after CIA reset
   - Remove all debug traces from bus.rs, memory.rs, mod.rs, decode.rs (after boot works)
   - Boot KS 1.3 to "insert disk" screen (Phase A of variant plan)

8. Current Work:
   Both on-disk plans have been written and approved by the user. The workspace has been modified to exclude emu-68000 and emu-amiga. The decode.rs rewrite plan is ready for execution starting with Phase 0 (strip decode.rs to skeleton). The full current decode.rs (1,421 lines) has been read and is documented above for reference during the rewrite.

9. Optional Next Step:
   Begin Phase 0 of the decode.rs rewrite per `docs/decode-rewrite-plan.md`: "Delete the body of `decode_and_execute()`. Replace with a single `self.illegal_instruction()` fallback. Every instruction triggers illegal exception." Then proceed to Phase 1 (MOVE.b/w/l, MOVEA.w/l, MOVEQ, LEA) with single-step test verification. The user approved: "Ok. That seems reasonable for now. I believe your plans make sense."

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

[Request interrupted by user]

---

Ok, before you move on. We previously established that the single-step tests expect the first opcode to be prefetched

---

I don't think we had a solid approach; our first attempt in emu-68000 seemed to involve hacking a "prefetch_only" flag into every sodding method

---

[Request interrupted by user]

---

I'm not sure I trust `next_ext_word`
I'm honestly not sure I trust _any_ of the CPU code

---

Scrap emu-m68k as well. And I think - in a change to the previous name - we should be explicit and name it cpu-m68k

---

This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.

Analysis:
Let me chronologically analyze the conversation:

1. **Session Start**: This is a continuation from a previous conversation that ran out of context. The summary describes extensive work on emu-amiga2 (a new Amiga emulator crate) with emu-m68k as the CPU. Key issues: KS 1.3 stuck in a fill loop, D1 had wrong value causing ~936K frames instead of ~28, SWAP verified correct, the bug is elsewhere in decode.rs.

2. **Previous session decisions**: 
   - Killed emu-68000 from workspace
   - Created docs/decode-rewrite-plan.md (13 phases for decode.rs rewrite)
   - Created docs/amiga-variants-plan.md (Amiga variant strategy)
   - User approved both plans

3. **Current session begins**: The system loaded the previous plan file and context docs. The assistant continued with Phase 0 of the decode.rs rewrite.

4. **Phase 0 execution**: Stripped decode.rs to skeleton (just `self.illegal_instruction()`), kept helper methods (decode_ea, ext_count_for, ea_internal, build_alu_to_reg/mem). Compiled successfully.

5. **Phase 1 execution**: Added MOVE.b/w/l, MOVEA.w/l, MOVEQ, LEA decoders. Compiled successfully.

6. **Test attempt**: Tried running single-step tests but test names didn't match filter. Discovered tests use specific function names (test_movea_w, run_all_single_step_tests, etc.), not file-based filtering.

7. **First test results**: MOVEA.w: 62 passed, 2438 failed. PC consistently off by 2.

8. **User intervention**: "Ok, before you move on. We previously established that the single-step tests expect the first opcode to be prefetched"

9. **Investigation of prefetch handling**: Found setup_prefetch puts CPU in Execute state with opcode pre-loaded. DL test format has PC past opcode+IRC.

10. **Bug discovery #1**: `tick_internal` returns after queue_fetch(), wasting a tick. The 68000 should immediately start the next opcode fetch.

11. **User clarification**: "I don't think we had a solid approach; our first attempt in emu-68000 seemed to involve hacking a 'prefetch_only' flag into every sodding method"

12. **Bug discovery #2**: `Internal(0)` in tick_internal_cycles takes 1 tick instead of 0 (increments cycle to 1, checks 1>=0, advances — but that's 1 tick consumed).

13. **Fixes applied**:
    - Changed `return` to `continue` after queue_fetch() in tick_internal
    - Added Internal(0) short-circuit in recipe.rs tick_recipe_step

14. **Test results after fixes**: MOVEA.w improved from 62/2500 to 1065/2500. But remaining failures show ext word handling is broken — A2 values completely wrong for (d16,An) modes, PC still off by 2 for ext-word instructions.

15. **Deep investigation of ext word bug**: recipe_commit() resets ext_count=0, destroying pre-loaded ext_words. FetchExtWords then re-reads from memory at wrong position (PC points past IRC, not at it).

16. **User expresses distrust**: "I'm not sure I trust `next_ext_word`. I'm honestly not sure I trust _any_ of the CPU code"

17. **Assistant acknowledges**: The engine has bugs at every layer — queue_fetch, Internal(0), ext word pipeline. All written without incremental testing.

18. **User decision**: "Scrap emu-m68k as well. And I think - in a change to the previous name - we should be explicit and name it cpu-m68k"

19. **Workspace cleanup**: Added emu-m68k and emu-amiga2 to exclude list in Cargo.toml.

20. **Plan mode entered**: For designing cpu-m68k from scratch.

21. **User provides reference info**: "I've got guides for the 68000 family on disk under ~/Projects/Reference/docs/cpus/68000.md and a PDF under ~/Projects/Reference/docs/cpus/references/M68000_Family_Reference_1988.pdf"

22. **Exploration phase**: 
    - Agent 1: Explored emu-z80 architecture (100% tests pass) — per-T-state ticking, wait states, micro-op queue, Execute is instant
    - Agent 2: Failed (500 error)
    - Agent 3: Explored emu-m68k internals — comprehensive list of RecipeOps, EA calculation, exceptions, ALU, etc.

23. **Direct exploration**: Read M68kBus trait from emu-m68k/src/bus.rs, 68000.md reference, emu-amiga2/Cargo.toml, and emu-amiga2 imports from emu-m68k.

24. **Current state**: In plan mode, gathering information to design cpu-m68k. Have explored Z80 patterns, M68kBus interface, test format, reference docs, and emu-amiga2's dependencies. Need to write the plan file.

Key files modified:
- Cargo.toml: exclude list now includes emu-68000, emu-amiga, emu-m68k, emu-amiga2
- decode.rs: was rewritten to Phase 1 skeleton but now scrapped with emu-m68k
- mod.rs: queue_fetch fix (return→continue) but now scrapped
- recipe.rs: Internal(0) fix but now scrapped

Key architectural insights for cpu-m68k:
- Model the 68000 prefetch pipeline (IR + IRC) explicitly
- Follow Z80 pattern: per-cycle ticking, micro-op queue, instant Execute
- No recipe layer — direct micro-op queuing from decode
- Extension words come from IRC, replacement fetches are real bus cycles
- Staged decode (like Z80's in_followup) for multi-ext-word instructions
- Reuse: M68kBus trait, ALU/flag computations, AddrMode enum, Size, registers, shift algorithms, DIVU/DIVS timing, BCD
- Rewrite: tick loop, micro-op dispatch, decode, ext word handling, prefetch

Summary:
1. Primary Request and Intent:
   The user has decided to **scrap the emu-m68k crate entirely** and create a new 68000 CPU crate called **`cpu-m68k`**, built from scratch with incremental verification against single-step tests. This decision was reached after discovering multiple engine-level bugs in emu-m68k (not just decode bugs): wasted ticks in queue_fetch, Internal(0) burning a cycle, and fundamentally broken extension word handling where recipe_commit destroys pre-loaded ext_words. The user explicitly does NOT want the "prefetch_only flag hacked into every method" approach used in emu-68000. The naming change from `emu-m68k` to `cpu-m68k` is intentional — it's a CPU core, not a full emulator.

   The user also provided reference documentation locations:
   - `~/Projects/Reference/docs/cpus/68000.md` — 68000 CPU reference guide
   - `~/Projects/Reference/docs/cpus/references/M68000_Family_Reference_1988.pdf` — Motorola M68000 Family Reference Manual

2. Key Technical Concepts:
   - **68000 Prefetch Pipeline**: The 68000 has IR (Instruction Register = current opcode) and IRC (Instruction Register Cache = next prefetched word). The DL test format exposes this: `state.pc` points past both, IRC in `prefetch[1]`.
   - **DL Test Format**: `state.pc` past opcode+IRC, cycle count is FULL hardware count (including opcode+IRC fetch time). Extension words come from IRC first, then memory.
   - **Per-cycle ticking**: Following the Z80 pattern (which passes 100% tests) — each `tick()` = one CPU clock cycle, micro-ops have internal cycle counters, Execute is instant (zero-cost).
   - **Wait state pattern**: Bus operations return wait_cycles via BusResult. CPU accumulates and burns them before next micro-op. Same pattern as working Z80.
   - **M68kBus trait**: Word-level bus with function codes (FC pins), BusResult with wait_cycles. Clean interface, should be reused.
   - **Staged decode**: Instead of building a recipe and committing it, instruction decode happens in stages separated by timed operations (like Z80's in_followup pattern). Extension words consumed from IRC → queue FetchNextWord → continue decode in next Execute.
   - **Single-step tests**: 317,500 tests in `test-data/m68000-dl/v1/`, 127 instruction files × 2,500 tests each.

3. Files and Code Sections:
   - **`/Users/stevehill/Projects/Emu198x/Cargo.toml`** (MODIFIED)
     - Workspace root, controls which crates are included
     - Now excludes all dead crates: emu-68000, emu-amiga, emu-m68k, emu-amiga2
     ```toml
     [workspace]
     resolver = "2"
     members = ["crates/*"]
     exclude = ["crates/emu-68000", "crates/emu-amiga", "crates/emu-m68k", "crates/emu-amiga2"]
     ```

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/bus.rs`** (READ — to reuse in cpu-m68k)
     - The M68kBus trait, BusResult, and FunctionCode — clean and correct, should be ported to cpu-m68k
     ```rust
     pub trait M68kBus {
         fn read_word(&mut self, addr: u32, fc: FunctionCode) -> BusResult;
         fn write_word(&mut self, addr: u32, value: u16, fc: FunctionCode) -> BusResult;
         fn read_byte(&mut self, addr: u32, fc: FunctionCode) -> BusResult;
         fn write_byte(&mut self, addr: u32, value: u8, fc: FunctionCode) -> BusResult;
         fn reset(&mut self) {}
         fn bus_error(&self, _addr: u32, _fc: FunctionCode) -> bool { false }
         fn interrupt_ack(&mut self, level: u8) -> u8 { 24 + level }
     }
     
     pub struct BusResult {
         pub data: u16,
         pub wait_cycles: u8,
     }
     
     pub enum FunctionCode {
         UserData = 1, UserProgram = 2,
         SupervisorData = 5, SupervisorProgram = 6,
         InterruptAck = 7,
     }
     ```

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/m68000/mod.rs`** (READ + MODIFIED then scrapped)
     - Contains the tick loop, micro-op dispatch, setup_prefetch, queue_fetch
     - **Bug found at line 357-360**: `queue_fetch()` followed by `return` wastes a tick
     - **Bug found**: `tick_internal_cycles()` makes Internal(0) take 1 tick
     - **setup_prefetch** (line 224-237): Sets CPU to Execute state with opcode and ext_words pre-loaded, `instr_start_pc = self.regs.pc`
     - **tick_fetch_opcode** (line 441-464): 4-cycle opcode fetch, reads at PC, advances PC by 2
     - **tick_fetch_ext_word** (line 467-490): 4-cycle ext word fetch, reads at PC into ext_words[ext_count], advances PC by 2

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/m68000/recipe.rs`** (READ + MODIFIED then scrapped)
     - **recipe_commit()** at line 228: Resets ext_count=0, ext_idx=0 — this destroys pre-loaded ext_words
     - **tick_recipe_step()**: Processes recipe ops; FetchExtWords pushes FetchExtWord micro-ops
     - **Bug found**: Internal(0) not treated as instant

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/m68000/ea.rs`** (READ)
     - **next_ext_word()** (line 97-105): Reads ext_words[ext_idx], depends on ext_count being correct
     - calc_ea(), read_immediate(), ext_words_for_mode() — EA calculation helpers

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/src/m68000/decode.rs`** (REWRITTEN then scrapped)
     - Was rewritten to Phase 1 skeleton with MOVE/MOVEA/MOVEQ/LEA, now obsolete

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-m68k/tests/single_step_tests.rs`** (READ)
     - Test harness structure: TestBus implements M68kBus directly, setup_cpu loads initial state, run_test ticks for test.cycles times, compare_state checks final state
     - **setup_cpu** (line 324-359): Loads RAM, sets registers, builds ext_words array from IRC + memory, calls setup_prefetch
     - **run_test** (line 430-450): Creates CPU, loads state, ticks for cycle count, compares
     - Key test function names: `test_movea_w`, `run_all_single_step_tests` (ignored), various `diagnose_*`

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/Cargo.toml`** (READ)
     - Depends on `emu-m68k = { path = "../emu-m68k" }` — will need to change to `cpu-m68k`

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/bus.rs`** (READ — imports)
     - `use emu_m68k::bus::{BusResult, FunctionCode, M68kBus};`

   - **`/Users/stevehill/Projects/Emu198x/crates/emu-amiga2/src/amiga.rs`** (READ — imports)
     - `use emu_m68k::{Cpu68000, M68kBus, FunctionCode};`

   - **`/Users/stevehill/Projects/Reference/docs/cpus/68000.md`** (READ — reference)
     - Comprehensive 68000 reference with register set, addressing modes, EA timing tables, instruction set overview

   - **`/Users/stevehill/Projects/Emu198x/docs/decode-rewrite-plan.md`** (EXISTS — now obsolete)
     - 13-phase decode.rs rewrite plan, superseded by cpu-m68k from-scratch rewrite

   - **`/Users/stevehill/Projects/Emu198x/docs/amiga-variants-plan.md`** (EXISTS — still relevant)
     - Amiga variant strategy document, phased rollout plan

   - **Z80 architecture** (explored via agent — key patterns for cpu-m68k):
     - Per-T-state ticking with `tick(&mut bus)` advancing exactly one T-state
     - MicroOp queue (fixed-size 16 ops): FetchOpcode(4T), ReadImm8(3T), ReadMem(3T), WriteMem(3T), Internal(n), Execute(0T instant)
     - Wait states: `read()` accumulates from bus, `tick()` burns before processing
     - Execute is instant and runs within the final T-state of preceding timed op
     - in_followup pattern for multi-stage instructions
     - 100% pass rate on 1,604,000 single-step tests

4. Errors and fixes:
   - **queue_fetch wasted tick** (`mod.rs` line 357-360):
     - `tick_internal` had `return` after `queue_fetch()`, meaning one tick consumed doing nothing
     - Fixed by changing `return` to `continue` so FetchOpcode starts in the same tick
     - This is correct: the 68000 never idles between instructions
   - **Internal(0) burning a cycle** (`recipe.rs` line 376 and `mod.rs` tick_internal_cycles):
     - `tick_internal_cycles` increments cycle to 1, checks 1>=0, advances — always takes 1 tick minimum
     - Fixed by adding `if cycles == 0 { continue; }` in tick_recipe_step before queuing MicroOp::Internal
   - **Extension word pipeline fundamentally broken**:
     - `recipe_commit()` resets ext_count=0, ext_idx=0, destroying pre-loaded ext_words from setup_prefetch
     - `FetchExtWords` then re-reads from memory at PC, but PC points past IRC, so it reads wrong data
     - This was NOT fixed — it's unfixable without either modeling prefetch properly or significant hacks
     - User feedback: "I'm not sure I trust `next_ext_word`. I'm honestly not sure I trust _any_ of the CPU code"
     - Resolution: User decided to scrap emu-m68k entirely
   - **Test filtering**: Tests use specific function names (test_movea_w), not file-based. `run_all_single_step_tests` is `#[ignore]`d.
   - **MOVEA.w test results progression**: 62/2500 → 1065/2500 after queue_fetch + Internal(0) fixes, but remaining 1435 failures are ext word pipeline issues.

5. Problem Solving:
   - **Solved**: Identified three engine-level bugs in emu-m68k (queue_fetch, Internal(0), ext_word pipeline)
   - **Solved**: Excluded emu-m68k and emu-amiga2 from workspace, workspace builds clean
   - **Solved**: Explored Z80 architecture for proven patterns to follow in cpu-m68k
   - **In progress**: Designing cpu-m68k architecture in plan mode, gathering information from Z80 patterns, M68kBus interface, test format, and reference docs
   - **Key design decisions being formed**:
     - Model 68000 prefetch pipeline (IR + IRC) explicitly
     - Follow Z80 per-cycle ticking pattern
     - No recipe layer — direct micro-op queuing
     - Staged decode with in_followup pattern for extension words
     - Reuse: M68kBus, ALU/flags, AddrMode, Size, registers, shift algorithms, DIVU/DIVS timing, BCD

6. All user messages:
   - "Ok, before you move on. We previously established that the single-step tests expect the first opcode to be prefetched"
   - "I don't think we had a solid approach; our first attempt in emu-68000 seemed to involve hacking a 'prefetch_only' flag into every sodding method"
   - "I'm not sure I trust `next_ext_word`. I'm honestly not sure I trust _any_ of the CPU code"
   - "Scrap emu-m68k as well. And I think - in a change to the previous name - we should be explicit and name it cpu-m68k"
   - "It might be worth noting that I've got guides for the 68000 family on disk under ~/Projects/Reference/docs/cpus/68000.md and a PDF under ~/Projects/Reference/docs/cpus/references/M68000_Family_Reference_1988.pdf"

7. Pending Tasks:
   - Complete the cpu-m68k plan (currently in plan mode, Phase 1-2 of planning)
   - Write the plan to the plan file at `/Users/stevehill/.claude/plans/squishy-bouncing-wozniak.md`
   - Get user approval via ExitPlanMode
   - Implement cpu-m68k from scratch per the approved plan
   - Rewire emu-amiga2 to depend on cpu-m68k instead of emu-m68k
   - Update docs/decode-rewrite-plan.md (now obsolete, needs replacement)
   - Boot KS 1.3 to "insert disk" screen (long-term goal)

8. Current Work:
   In **plan mode** designing the cpu-m68k crate. Three explore agents were launched:
   - Agent 1 (Z80 architecture): Completed successfully with comprehensive Z80 architecture analysis
   - Agent 2 (M68kBus + test format): Failed with 500 error, key files read manually instead
   - Agent 3 (emu-m68k internals): Completed with detailed inventory of reusable components

   Key files have been read directly:
   - M68kBus trait from emu-m68k/src/bus.rs
   - 68000.md reference from ~/Projects/Reference/docs/cpus/
   - emu-amiga2/Cargo.toml and its imports from emu-m68k

   The assistant was about to synthesize all exploration results into a plan document for cpu-m68k. The plan needs to cover:
   - Crate structure
   - Prefetch pipeline model (IR + IRC)
   - Tick model (per-cycle, micro-ops)
   - Extension word handling (consume IRC, replacement fetches)
   - What to reuse vs rewrite
   - Incremental verification strategy
   - Test harness design

9. Optional Next Step:
   Write the cpu-m68k plan to the plan file at `/Users/stevehill/.claude/plans/squishy-bouncing-wozniak.md` and call ExitPlanMode for user approval. The user's most recent explicit request was: "Scrap emu-m68k as well. And I think - in a change to the previous name - we should be explicit and name it cpu-m68k" — followed by entering plan mode to design this new crate. The user also noted reference docs: "I've got guides for the 68000 family on disk under ~/Projects/Reference/docs/cpus/68000.md and a PDF under ~/Projects/Reference/docs/cpus/references/M68000_Family_Reference_1988.pdf"

If you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/stevehill/.REDACTED.jsonl
Please continue the conversation from where we left off without asking the user any further questions. Continue with the last task that you were asked to work on.

---

[Request interrupted by user for tool use]