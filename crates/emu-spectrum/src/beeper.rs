//! ZX Spectrum 1-bit beeper audio.
//!
//! The beeper is controlled by bit 4 of port $FE. The ULA doesn't have a DAC;
//! it simply drives the speaker cone in or out. Audio is generated by
//! toggling this bit at the desired frequency.
//!
//! # Sampling
//!
//! The beeper level is sampled at the CPU rate (3.5 MHz) and downsampled to
//! the output rate (typically 48 kHz) by accumulating samples and averaging.

#![allow(clippy::cast_precision_loss)] // Intentional: u32→f32 precision loss is acceptable for audio.

/// 1-bit beeper state.
pub struct BeeperState {
    /// Current beeper level (0 or 1).
    level: u8,
    /// Accumulated sample value for downsampling.
    accumulator: f32,
    /// Number of CPU ticks accumulated.
    sample_count: u32,
    /// CPU ticks per output sample (e.g., 3,500,000 / 48,000 ≈ 72.9).
    ticks_per_sample: f32,
    /// Output audio buffer (mono f32 samples, -1.0 to 1.0).
    buffer: Vec<f32>,
}

impl BeeperState {
    /// Create a new beeper with the given output sample rate.
    #[must_use]
    pub fn new(cpu_frequency: u32, output_sample_rate: u32) -> Self {
        Self {
            level: 0,
            accumulator: 0.0,
            sample_count: 0,
            ticks_per_sample: cpu_frequency as f32 / output_sample_rate as f32,
            buffer: Vec::with_capacity(output_sample_rate as usize / 50 + 1), // ~1 frame
        }
    }

    /// Set the beeper level (bit 4 of port $FE: 0 or 1).
    pub fn set_level(&mut self, level: u8) {
        self.level = level & 1;
    }

    /// Sample the beeper at CPU rate. Call once per CPU T-state.
    pub fn sample(&mut self) {
        // Convert 0/1 to -1.0/+1.0 range
        let sample = if self.level != 0 { 1.0 } else { -1.0 };
        self.accumulator += sample;
        self.sample_count += 1;

        if self.sample_count as f32 >= self.ticks_per_sample {
            // Average the accumulated samples and emit one output sample
            let avg = self.accumulator / self.sample_count as f32;
            self.buffer.push(avg);
            self.accumulator = 0.0;
            self.sample_count = 0;
        }
    }

    /// Take the audio buffer (drains it).
    pub fn take_buffer(&mut self) -> Vec<f32> {
        std::mem::take(&mut self.buffer)
    }

    /// Current beeper level (0 or 1).
    #[must_use]
    pub fn level(&self) -> u8 {
        self.level
    }

    /// Number of samples in the output buffer.
    #[must_use]
    pub fn buffer_len(&self) -> usize {
        self.buffer.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn initial_state() {
        let beeper = BeeperState::new(3_500_000, 48_000);
        assert_eq!(beeper.level(), 0);
        assert_eq!(beeper.buffer_len(), 0);
    }

    #[test]
    fn generates_samples() {
        let mut beeper = BeeperState::new(3_500_000, 48_000);
        // Run enough ticks to produce at least one sample (~73 ticks)
        for _ in 0..100 {
            beeper.sample();
        }
        assert!(beeper.buffer_len() >= 1);
    }

    #[test]
    fn level_toggle_produces_waveform() {
        let mut beeper = BeeperState::new(3_500_000, 48_000);

        // Toggle every 50 ticks for a few hundred ticks
        for i in 0..500 {
            if i % 50 == 0 {
                beeper.set_level(if beeper.level() == 0 { 1 } else { 0 });
            }
            beeper.sample();
        }

        let buf = beeper.take_buffer();
        assert!(!buf.is_empty());
        // Should have both positive and negative samples
        let has_positive = buf.iter().any(|&s| s > 0.0);
        let has_negative = buf.iter().any(|&s| s < 0.0);
        assert!(has_positive && has_negative);
    }

    #[test]
    fn take_buffer_drains() {
        let mut beeper = BeeperState::new(3_500_000, 48_000);
        for _ in 0..200 {
            beeper.sample();
        }
        let buf = beeper.take_buffer();
        assert!(!buf.is_empty());
        assert_eq!(beeper.buffer_len(), 0);
    }
}
