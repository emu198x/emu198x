Skip to main content
 
Texts
 
Video
 
Audio
 
Software
 
Images
Sign up for free
Log in
 Search metadata
 Search text contents
 Search TV news captions
 Search radio transcripts
 Search archived web sites
Advanced Search
About Blog Events Projects Help Donate  Contact Jobs Volunteer
Full text of "Amiga ROM Kernal Reference Manual Includes And Autodocs"
See other formats
AMIGA ROM KERNEL 


REFERENCE MANUAL: 


INCLUDES & AUTODOCS 
REVISED & UPDATED 






JORE-AMIGA, 
INCORPORATED 





Amiga 
ROM Kernel Reference Manual: 


Includes and Autodocs 





Amiga 
ROM Kernel Reference Manual: 


Includes and Autodocs 


Commodore-Amiga, Incorporated 


Amiga Technical Reference Series 


A 
vv 
Addison-Wesley Publishing Company, Inc. 
Reading, Massachusetts Menlo Park, California New York 


Don Mills, Ontario Wokingham, England Amsterdam Bonn 
Sydney Singapore Tokyo Madrid San Juan 


This manual corresponds to the V1.3 system software release. 


Material written by: 
Steve Beats, David Berezowski, Robert Burns, Eric Cotton, Sam Dicker, Andy Finkel, Larry Hilden- 
brand, Randell Jesup, Neil Katin, Dale Luck, Jim Mackraz, R.J. Mical, Bryce Nesbitt, Bob Pariseau, 
Rob Peck, Tom Pohorsky, Carl Sassenrath, Carolyn Scheppner, Stan Shepard, and Bart Whitebrook 


Manual compiled by: 
Bryce Nesbitt, Robert Burns, Carolyn Scheppner, and Nancy Rains. C cross-reference created by 
John Toebes using Lattice C Version 5.0 by Lattice, Inc. 


This book is dedicated to all those ‘“‘busy guys’? who made Amiga and who are Amiga. 


Copyright © 1989 by Commodore-Amiga, Incorporated 


Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear 
in this book and Addison-Wesley was aware of a trademark claim, the designations have been printed in initial caps. Amiga is a registered trademark 
of Commodore-Amiga, Incorporated and is used herein with their permission. Amiga 500, Amiga 1000, Amiga 2000, AmigaDOS, Amiga Workbench, 
Amiga Kickstart, AUTOCONFIG, the Boing! and rainbow Checkmark logos are trademarks of Commodore-Amiga, Inc. 68000, 68020, 68030, 68040 
and Motorola are trademarks of Motorola, Inc. CBM, Commodore, the Commodore logo, and Amiga are registered trademarks. Alphacom is a 
registered trademark and Alphapro is trademark of Alphacom, Inc. Aztec C and Manx are trademarks of Manx Software Systems. Brother is a 
registered trademark of Brother Industries, Ltd. Canon is a registered trademark of Canon USA Inc. CAPE and Inovatronics are trademarks of Inova- 
tronics, Inc. Centronics is a registered trademark of Centronics Data Computer Corp. ColorMaster is a trademark of CalComp. Diablo is a registered 
trademark of Xerox Corporation. Reading legal mush can turn your brain to guacamole! Epson is registered trademark of Epson America, Inc. Hisoft 
and Devpac Amiga are trademarks of HiSoft. IBM is a registered trademark and Proprinter is a trademark of International Business Machines Corp. 
Imagewriter and Apple II are trademarks of Apple Computer, Inc. LaserJet and PaintJet are trademarks of the Hewlett Packard Company. Lattice is 
a registered trademark of Lattice, Inc. LetterPro 20 is a trademark of Qume Corporation. NEC is a registered trademark of NEC Information Sys- 
tems. Okidata is a registered trademark of Okidata, a division of Oki America, Inc. Okimate 20 is a trademark of Okidata, a division of Oki America, 
Inc. Pinwriter is a registered trademark of NEC Information Systems. UNIX is a registered trademark of AT&T. 


All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, elec- 
tronic, mechanical, photocopying, recording, or otherwise, without the prior written permission of the copyright holder. Printed in the United States of 
America from camera-ready mechanicals supplied by the authors. Published simultaneously in Canada. 


Commodore item number: 327271-06 


ISBN 0-201-18177-0 
ABCDEFG-AL-909 
First printing, January 1989 


WARNING: The information described in this manual may contain errors or bugs, and may not function as described. An attempt has been made to 
warn software developers via the use of the BUGS field of such documents, however, not all bugs will be so marked. All information is subject to 
enhancement or upgrade for any reason including to fix bugs, add features or change performance. As with all software upgrades, full compatibility, 
although a goal, cannot be guaranteed, and is in fact unlikely. 


DISCLAIMER: COMMODORE-AMIGA, INC., (“COMMODORE”) MAKES NO WARRANTIES, EITHER EXPRESSED OR IMPLIED, WITH 
RESPECT TO THE INFORMATION DESCRIBED HEREIN, IT’S QUALITY, PERFORMANCE, MERCHANTABILITY, OR FITNESS FOR ANY 
PARTICULAR PURPOSE. SUCH INFORMATION IS PROVIDED ON AN “AS IS” BASIS. THE ENTIRE RISK AS TO THEIR QUALITY AND 
PERFORMANCE IS WITH THE USER. SHOULD THE INFORMATION PROVE DEFECTIVE, THE USER (AND NOT THE CREATOR, COM- 
MODORE, THEIR DISTRIBUTORS NOR THEIR RETAILERS) ASSUMES THE ENTIRE COST OF ALL NECESSARY DAMAGES. IN NO EVENT 
WILL COMMODORE BE LIABLE FOR DIRECT, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES RESULTING FROM ANY 
DEFECT IN THE INFORMATION EVEN IF IT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. SOME LAWS DO NOT 
ALLOW THE EXCLUSION OR LIMITATION OF IMPLIED WARRANTIES OR LIABILITIES FOR INCIDENTAL OR CONSEQUENTIAL DAM- 
AGES, SO THE ABOVE LIMITATION OR EXCLUSION MAY NOT APPLY. 





TABLE OF CONTENTS 


Introduction 

Library SummarieS ou... eesecesee sees eeeee A 
Device SuMMarleS —......c.ceceecececeeneceeeeeees B 
Resource SUMMALIES oo... eceseeeeceececeeeeeees C 
C Include Files - ‘‘.h” Files ow... D 
Assembly Include Files - ‘'.i”’ Files ..... E 
Linker LibrarieS ........cccececeecececeseeceeeeeees F 
Sample Device, Sample Library _.......... G 
Reference Charts  ....c.ceccececsececsseeceeeeeees H 
IFF - Interchange File Format _........... I 


Function [Index  ...ccescesc cccccceccescescceeececs J 





Error Reports 


In a complex technical manual, errors are often found after publication. When er- 
rors in this manual are found, they will be corrected in the following printing. Up- 
dates will be published in the AmigaMail technical support publication. 


Bug reports can be sent to Commodore electronically or by mail. Submitted reports 
must be clear, complete, and concise. Reports must include a telephone number and 
enough information so that the bug can be quickly verified from your report. (Le. 
please describe the bug and the steps that preceded it.) 


Amiga Software Engineering Group 
ATTN: BUG REPORTS 
Commodore Business Machines 
1200 Wilson Drive 

West Chester, PA 19380 

USA 


BIX: afinkel 
USENET: bugs@commodore.COM or uunet!cbmvax!bugs 





About this book 


The Amiga Technical Reference Series is the official guide to programming the 
Commodore-Amiga computers. This revised edition has been updated for version 1.3 of 
the Amiga operating system and the new Amiga computer systems. The series has been 
reorganized into three volumes. This volume, the Amiga ROM Kernel Reference 
Manual: Includes and Autodocs, contains alphabetically organized autodoc function sum- 
maries, listings of the Amiga system include files, and the IFF Interchange File Format 
specifications and listings. This is the essential quick reference for all Amiga program- 
mers. 


The other manuals in this series are the Amiga ROM Kernel Reference Manual: 
Libraries and Devices, with tutorial-style chapters on the use of each Amiga system 
library and device, and the Amiga Hardware Reference Manual, a guide to hardware 
level programming of the Amiga custom and peripheral chips. 


This manual! contains: 


e Summaries for system library functions 

e Summaries for system device commands 

e Summaries for system resource calls 

e C Language Include Files 

e Assembly Language Include Files 

e Documentation on ‘“‘Amiga.lib”’ and reference source code 

e Updated sample library and device 

e Handy Charts designed to ease debugging and exploring 

e Documentation on the Interchange File Format standard (IFF) 


The manual is a perfect companion for programming the Amiga. 


About the examples 


Except as noted, 68000 assembly language examples have been assembled under the 
Metacomco assembler V11.0, the Inovatronics CAPE assembler V2.0, and the HiSoft 
Devpac assembler V1.2. No substantial changes should be required to switch between 
assemblers. 


C examples have been compiled under Lattice C, version 4.01 and Manx Aztec C68K, 
version 3.6a. Default compiler options are used in both cases. All the C examples 
assume that the automatic CTRL-C feature of the compiler has been disabled. With the 
exception of those examples in Section A, this code must be added to each example to 
complete it: 


Introduction-1 





For Aztec C 
Compile with: cc <filename>.c 
In <filename.o> -le 


/* Add this near the top */ 
#include ”functions.h” 


/* Add this before main() */ 
extern int Enable_Abort; /* reference abort enable */ 


/* Add this after main(), as the first active line in the program */ 
Enable_Abort=0; /* turn off CTRL-C */ 


For Lattice C revisions 4.0 and greater 
Compile with: lc -L <filename>.c 


/* Add this function before main(). This overrides the default 
* Lattice CTRL-C trap. If this function returns zero, then the 
* CTRL-C event will be ignored */ 
int CXBRK() 


{ 
5 


return(0); 


General Amiga Development Guidelines 


The environment of the Amiga computer is quite different than that of many older 
computers. The Amiga is multitasking, which means multiple programs must 
share the same machine without interfering with each other. It also means that 
certain guidelines must be followed during programming. 


e Always make sure you actually GET what you ask for. This applies to 
memory allocations, windows, screens, file handles, libraries, devices, ports, etc. 
Where an error value or return is possible, ensure that there is a reasonable 
failure path. Many poorly written programs will appear to be reliable, until 
some error condition (such as memory full or a disk problem) causes the pro- 
gram to continue with an invalid or null pointer, or branch to untested error 
handling code. 


e Always clean up after yourself. This applies for both normal program exit and 
program termination due to error conditions. Anything that was opened must 
be closed, anything allocated must be deallocated. It is generally correct to do 
closes and deallocations in reverse order of the opens and allocations. Be sure 
to check your development language manual and startup code; some items 
may be closed or deallocated automatically, especially in abort conditions. If 


Introduction-2 





you write in the C language, make sure that when CTRL-C is pressed, your 
program gracefully closes down and exits. 


Remember that memory, peripheral configurations, and ROMs differ between 
models and between individual systems. Do not make assumptions about 
memory address ranges, storage device names, or the locations of system struc- 
tures or code. Do not jump into the ROM directly. Do not assume library 
bases or structures will exist at any particular memory location. The only 
absolute in the system is address 0x00000004, which contains a pointer to the 
exec.library base. 


Do not assume that programs can access hardware resources directly. Most 
hardware is controlled by system software and resources that will not respond 
well to interference. Shared hardware requires programs to use the proper 
sharing protocols. Using the defined interface enhances the probability that 
your software will continue to operate on future Amiga computers. 


Do not access shared data structures directly without the proper mutual exclu- 
sion (locking). Remember that other tasks may be accessing the same struc- 
tures. 


The system does not monitor the size of a program’s stack. Take care that 
your program does not cause stack overflow, and provide enough leeway for 
the possibility that future revisions of system functions might require addi- 
tional stack space. 


If your program waits for external events like menu selection or key-strokes, 
do not bog down the multitasking system by busy-waiting in a loop. Instead, 
let your task go to sleep by Wait()ing on its signal bits. For example: 


signals = (ULONG)Wait((1< <windowPtr->UserPort->mp_SigBit) | 
(1<<consoleMsgPortPtr->mp_SigBit) ); 


This turns the signal bit number for each port into a mask, then combines 
them as the argument for the exec.library/Wait() function. When your task is 
awakened, handle all of the messages at each port where the SigBit is set. 
There may be more than one message per port, or no messages at the port. 
Make sure that you ReplyMsg() to all messages that are not replies themselves. 


Tasks (and Processes) execute in 68000 processor user mode, Supervisor mode 
is reserved for interrupts, traps, and task dispatching. Take extreme care if 
your code executes in supervisor mode. Exceptions while in supervisor mode 
are deadly. 


Most system functions require a particular execution environment. All DOS 


functions and any functions that might call DOS (such as the opening of a 
disk-resident library, font, or device) can only be executed from a process. A 


Introduction-3 





task is not sufficient. Most other ROM Kernel functions may be executed 
from tasks. Only a few may be executed from interrupts. 


Do not disable interrupts or multitasking for long periods. If you use Forbid() 
or Disable(), you should be aware that execution of any system function that 
WAITS will temporarily suspend the Forbidden or Disabled state, and allow 
multitasking and interrupts to occur. Such functions include almost all forms 
of DOS and device IO, including common “‘stdio” functions like “printf”’. 


Do not tie up system resources unless it is absolutely necessary. For example, 
if your program does not require constant use of the printer, open the 
printer.device only when you need it. This will allow other tasks to use the 
printer while your program is running. You must provide a reasonable error 
response if a resource is not available when you need it. 


Check for memory loss. Operate your program, then exit. Write down the 
amount of free memory. Repeat the operation of your program and exit. The 
amount of free memory remaining should be exactly the same. Any difference 
may signal some serious problem in your cleanup. A useful tool for memory 
testing is the ““LoadWB -debug”’ command; this will start the Workbench tool 
with a special invisible debug menu. The ‘“‘flushlibs” option of this menu can 
cause unused libraries and devices to be flushed out of memory. (The ‘“‘debug” 
option invokes the ROM debugger, RomWack, on the serial port at 9600 
baud.) 


All data for the custom chips must reside in CHIP type memory. This 
includes bitplanes, sound samples, trackdisk buffers, and images for sprites, 
bobs, pointers, and gadgets. The AllocMem() call takes a flag for specifying 
CHIP type memory. 


On machines with expansion (FAST) memory, the default location for memory 
allocations is FAST memory. A developer with only CHIP memory may fail to 
notice the memory was incorrectly specified. (On the current generation of 
machines, CHIP memory is the lowest 512KK of memory in the system.) 


Most compilers have options to mark specific data structures or object 
modules so that they will load into CHIP ram. Some older compilers provide 
the Atom utility for marking object modules. If this method is unacceptable, 
use the AllocMem() call to dynamically allocate CHIP memory, and copy your 
data there. 


Do not use software delay loops! Under the multitasking operating system, 
the time spent in a loop can be better used by other tasks. Even ignoring the 
effect of multitasking, timing loops are inaccurate and will wait varying 
amounts of time depending on the specific model of computer. The 
timer.device provides precision timing for use under the multitasking system. 
The AmigaDOS Delay() function provides a simple interface for longer delays. 


Introduction-4 





The 8520 I/O chips provide timers for developers who are bypassing the 
operating system (see the Amiga Hardware Reference Manual for more infor- 
mation). 


Obey structure conventions! 
- All non-byte fields must be word aligned. 


- All address pointers should be 32 bits (not 24 bits), The upper byte must 
never be used for data. 


- Fields that are not defined to contain particular initial values must be initial- 
ized to zero. This includes pointer fields. 


- All reserved or unused fields must be initialized to zero for future compatibil- 
ity. 
- Data structures to be accessed by the custom chips, public data structures 


(such as a task control block), and structures which must be longword 
aligned must NOT be allocated on a program’s stack. 


- Dynamic allocation of structures with AllocMem provides longword aligned 
memory of a specified type with optional initialization to zero, which is use- 
ful in the allocation of structures. 


Additional Assembler Development Guidelines 


Do not use the “TAS” instruction on the Amiga. System DMA can conflict with 
this instruction’s special indivisible read-modify-write cycle . 


System functions must be called with A6 containing the library or device base. 
Libraries and devices assume A6 is valid at the time of any function call. Even if 
a particular function does not currently require its base register, you must pro- 
vide it for compatibility with future system software releases. 


Except as noted, system library functions use registers DO, D1, AO, and Al as 
scratch registers and you must consider their former contents to be lost after a 
system library call. The contents of all other registers will be preserved. System 
functions which provide a result will return the result in DO. 


System functions that return a result may not necessarily affect the processor 
condition codes. The caller must test the returned value before acting on a con- 


dition code. This is usually done with a TST or MOVE instruction. 


For 68010/68020/68030/68040 compatibility: 


Introduction-5 











Do not use the “MOVE SR....” instruction! This 68000 instruction acts 
differently on other members of the 68000 family. If you wish a copy of the 
processor condition codes, use the exec.library/GetCC() function. 


Do not use the upper 8 bits of a pointer for storing unrelated information. 
The 68020 uses all 32 bits for addressing. 


Do not use signed variables or signed math for addresses. 
Do not execute code on your stack. 


The stack frame used for exceptions is different on each member of the 68000 
family. The type identification in the frame must be checked! 


Do not use self modifying code. 


Commodore-Amiga Technical Support (CATS) 


Commodore maintains a technical support group dedicated to helping developers 
achieve their goals with the Amiga. Available technical support programs are 
tailored both to the needs of smaller independent developers and larger corpora- 
tions. Subscription to the support publication AmigaMail is available to anyone 
with an interest in the latest news, Commodore software and hardware changes, 
and tips for developers. 


To request an application for the Commodore-Amiga Developer Programs, lists 
of CATS technical publications, or information regarding electronic developer 
support, send a self-addressed, stamped, 9” x 12” envelope to: 


CATS-Information 
1200 West Wilson Drive 
West Chester, PA 19380-4231 


Introduction-6 








Section A 


Library Summaries 


This section contains summaries for the shared library routines that are built into the 
Amiga operating system software. These documents have been automatically extracted 
from the original source code and are often called autodocs. 


Most of the Amiga operating system is divided into functional groups called libraries. 
Libraries may exist in the Kickstart ROM or on disk. Each library may be individually 
opened and closed. When a library is open, any of its functions may be called. When all 
openers of a library have closed, the library becomes a candidate for purging from the 
system memory. 


These documentation files are organized alphabetically by library, one document per 
function call. Tutorial information for each of the libraries and a description of the 
library mechanism is available in the Amiga ROM Kernel Manual: Libraries and Devices. 
Only a brief introduction will be given here. 





The “exec.library” is the system’s master library and is always open. This library con- 
trols the lowest levels of the multitasking operating system. One of exec’s functions, 
OpenLibrary(), is used to open the other libraries. Usage is as follows: 


struct LibBase *LibBase; 
LibBase = OpenLibrary(” library.name” ,version); 


library .name 
is a string that describes the name of the library you wish to open. 


version 

should be set to the earliest acceptable library version. A value of 0 matches any 
version. A value of 33, for example, means you require version 33 of the library 
or a later version if 33 is not available. For the system libraries, the following 
table applies: 

O = Any version 

30 = Kickstart V1.0 (obsolete) 

31 = Kickstart V1.1 (NTSC only - obsolete) 

32 = Kickstart V1.1 (PAL only - obsolete) 

33 = Kickstart V1.2 (the oldest revision still in use) 

34 = Kickstart V1.3 (adds autoboot to Kickstart V1.2) 


If you specify a higher version number than is installed in the system, the open 
will fail. Except as noted, all functions documented in this manual will work 
with Kickstart V33 and greater. Since V34 Kickstart is nearly identical to V33, 
it is generally NOT wise to require it. 


If the library is disk-resident, it is loaded and initialized. The OpenLibrary() function 
returns the address of the library base, which you must assign to a specific variable. 
(Case is important.) This base is used to access the functions of the library. Zero is 
returned if something goes wrong with the open. 


Library bases represent a midpoint in the library. Below the base are the function vec- 
tors, above the base is a data area: 






Lower address — Function n 


Function 2 
Function | 


Data area 






+ Library Base Pointer 
Higher address —> 


The names of the libraries that are currently part of the Amiga software and associated 
library base pointer names are as follows: 





Library Name 


diskfont. library 
dos.library 

exec. library 
graphics.library 

icon. library 
intuition.library 
layers.library 
mathffp.library 
mathtrans.library 
mathieeedoubbas. library 
mathieeedoubtrans. library 
romboot.library 
translator. library 
version. library 


Library Base Pointer Name 


DiskfontBase 
DOSBaset t 

SysBaset 

GfxBase 

IconBase 

Intuition Base 
LayersBase 

MathBase 

Math TransBase 
MathleeeDoubBasBase 
MathlIeeeDoubTransBase 
(V1.3 system private) 
TranslatorBase 
(system private) 


tAutomatically opened by the standard C startup module 
t dos library is documented in the AmtgaDOS Manual 


All Amiga libraries accept parameters in registers, and return the result in data register 
DO. All routines return a full 32 bit longword, even if fewer bits are significant. This 
allows programs and functions that are written in assembler to communicate quickly. It 
also eliminates the dependence on the stack frame conventions of any particular 
language. Some C language compilers for the Amiga can generate parameters directly 
into registers, others translate any Amiga library call into a stub routine that moves 
parameters from the stack to registers. See the “‘amiga.lib” appendix for more details. 


Complete examples follow: 








A complete ready-to-compile example of library use. 
The library is opened, checked, used and closed. 

See the intuition.library document for a description 
of what the DisplayBeep() function does. 


HE OE 


* 
struct Library *OpenLibrary(); /* declare return type */ 


struct IntuitionBase *IntuitionBase; /* get storage for base */ 
void main() 
IntuitionBase=(struct IntuitionBase *) 
OpenLibrary("intuition.library",33L); 
if(!IntuitionBase) /* check if it actually opened */ 
exit(20); 
DisplayBeep(OL); /* use the library function */ 


CloseLibrary(IntuitionBase) ; 


KREKKKKKEK KKK KKK KKK KKK RK KEK KK KK KK KK KK KKK KKK KK KK KKK KKK KEK KKK KK KKKKKKKKKKK 


*x 
* A complete ready-to-assemble example of library use. The intuition 
* library is opened, checked, used, and closed. ' See the intuition 
* document for a description of what the DisplayBeep() function does. 
x 
* When calling an Amiga library, the base pointer *must* be in 
* A6... the library is free to depend on this. Registers DO,D1,A0 
* and Al may be destroyed by the library, all others will be preserved. 
*x 
* Normally the constants _AbsExecBase, _LVOOpenLibrary, 
* _LvOCloseLibrary, and LVODisplayBeep would be resolved by the linker 
* from the file "“amiga.lib". For this minimal example we define them 
* explicitly. 
* 
_AbsExecBase EQU 4 iWhere exec's library base is 
_LVOOpenLibrary EQU -552 ;Offset from base for OpenLibrary 
_LVOCloseLibrary EQU —414 ; 
_LVODisplayBeep EQU —-96 ; " 
move.1 _AbsExecBase, a6 iMove exec.library base to a6 
lea.1 iIntuiName(pc),al iPointer to "intuition. library" 
moveq #33,d0 ; Version 
jsr LVOOpenLibrary (a6) ;Call exec's OpenLibrary( ) 
tst.1 do 
bne.s open ok 
moveq #20,d0 ;Set failure code 
rts iFailed exit 
open_ok move.1l d0,a6 ;Put IntuitionBase in a6. 
suba.l1 a0,a0 jLoad zero into a0 
jsr _LVODisplayBeep (a6) ;Call intuition's DisplayBeep( ) 
move.1l a6,al iPut IntuitionBase into al 
move.l _AbsExecBase, a6 
jsr _LVOCloseLibrary(a6) iCall exec's CloseLibrary() 
moveq #0,d0 ;Set return code 
rts 
IntuiName: dc.b 'intuition.library',0 


END 








TABLE OF CONTENTS TABLE OF CONTENTS 


diskfont.doc A-1 diskfont.library/AvailFonts 
exec. doc a-4 diskfont. library/DisposeFontContents 
expansion .doc A-52 diskfont. library/NewFontContents 
graphics.doc A-64 diskfont. library/OpenDiskFont 
icon.doc A-119 

intuition .doc A-124 

layers .doc A-166 

mathffp.doc A-197 

mathieeedoubbas .doc A-196 

mathieeedoubtrans.doc A-193 

mathtrans.doc A~202 


translator.doc A-211 

















diskfont. library/AvailFonts diskfont.library/AvailFonts 
NAME 
AvailFonts — build an array of all fonts in memory / on disk 


SYNOPSIS 
error = AvailFonts(buffer, bufBytes, types); 
AO D DL 


FUNCTION 
AvailFonts fills a user supplied buffer with the structure, 
described below, that contains information about all the 
fonts available in memory and/or on disk. Those fonts 
available on disk need to be loaded into memory and opened 
via OpenDiskFont, those already in memory are accessed via 
OpenFont. The TextAttr structure required by the open calls 
is part of the information AvailFonts supplies. 


When AvailFonts fails, it returns the number of extra bytes 
it needed to complete the command. Add this number to your 
current buffer size, allocate a new buffer, and try again. 
If the second AvailFonts call fails, abort the operation. 


INPUTS 

buffer ~ memory to be filled with struct AvailFontsHeader 
followed by an array of AvailFonts elements, which 
contains entries for the available fonts and their 
names. 

bufBytes - the number of bytes in the buffer 

types — AFF_MEMORY is set to search memory for fonts to fill 
the structure, AFF_DISK is set to search the disk for 
fonts to fill the structure. Both can be specified. 


RESULTS 
buffer - filled with struct AvailFontsHeader followed by the 
AvailFonts elements, There will be duplicate entries 
for fonts found both in memory and on disk, differing 
only by type. The existance of a disk font in the 
buffer indicates that it exists as an entry in a font 


contents file -- the underlying font file has not been 
checked for validity, thus an OpenDiskFont of it may 
fail. 


error - if non-zero, this indicates the number of bytes needed 
for AvailFonts in addition to those supplied. Thus 
structure elements were not returned because of 
insufficient bufBytes. 





diskfont .library/DisposeFontContents 


NAME 
DisposeFontContents - free the result from NewFontContents 
SYNOPSIS 
DisposeFontContents({fontContentsHeader) 
Al 
FUNCTION 
This function frees the array of FontContents entries 
returned by NewFontContents. 
INPUTS 
fontContentsHeader - a struct FontContentsHeader pointer 
returned by NewFontContents. 
EXCEPTIONS 
This command was first made available as of version 34. 
A fontContentsHeader other than one acquired by a call 
NewFontContents will crash. 
SEE ALSO 


NewFontContents to get structure freed here. 


iil 











diskfont. library/NewFontContents 








diskfont.library/NewFontContents 


NAME: 
NewFontContents — create a FontContents structs for a font 
SYNOPSIS 
fontContentsHeader = NewFontContents(fontsLock, fontName) 
DO AQ Al 
FUNCTION 


This function creates a new array of FontContents entries 
that describe all the fonts associated with the fontName, 
specifically, all those in the font directory, whose name 
is that of the font sans the ".font" suffix. 


INPUTS 
fontsLock ~ a DOS lock on the FONTS: directory (or other 
directory where the font contents file and associated 
font directory resides) . 
fontName ~- the font name, with the ".font" suffix, which 
is also the name of the font contents file. 


RESULT 
fontContentsHeader — a struct FontContentsHeader pointer. 


EXCEPTIONS 
This command was first made available as of version 34. 


pO is zero if the fontName is does not have a ".font" suffix, 
or a DOS error occurred, or memory could net be allocated for 
the fontContentsHeader. 


SEE ALSO 
DisposeFontContents to free the structure acquired here. 


diskfont.library/OpenDiskFont 








diskfont. library/OpenDiskFont 


NAME 

OpenDiskFont. — load and get a pointer to a disk font. 
SYNOPSIS 

font = OpenDiskFont (textAttr) 

DO AO 
FUNCTION 


This function finds the font with. the specified textAttr on 
disk, loads it into memory, and returns a pointer to the font 
that can be used in subsequent SetFont and CloseFont calls. 
It is important to match this call with a corresponding 
CloseFont call for effective management of font memory. 


if the font is already in memory, the copy in memory is used. 
The disk copy is not reloaded. 


INPUTS 
textAttr -— a TextAttr structure that describes the text font 
attributes desired. 


RESULTS 
pO is zero if the desired font cannot be found. 


BUGS “ 

This routine will not work well with font names whose file 
name components are longer than. the maximum allowed 
(30 characters). 








[TABLE OF CONTENTS 


exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec 
exec 
exec. 
exec. 
exec. 
exec. 
exec 
exec, 
exec. 
exec. 
exec. 
GXec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec 
exec 
exec. 
exec. 
exec. 
exec. 
exec 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 
exec. 





library/Abort IO 
library/AddDevice 


. library/AddHead 


library/AddIntServer 
library/AddLibrary 
library/AddMemList 
library/AddPort 


. Library/AddResource 
. Library/AddSemaphore 


library/AddTail 
library/AddTask 
library/Alert 
library/AllocAbs 


. library/Allocate 


library/AllocEntry 
library/AllocMem 
library/Allocsignal 
library/AllocTrap 
library/AttemptSemaphore 


. library/AvailMem 


library/Cause 
library/CheckIo 
library/CloseDevice 
library/CloseLibrary 
library/CopyMem 


. library/CopyMemQuick 


library/Deal locate 
library/Debug 
library/Disable 


library/DoIO 
library/Enable 


. Library/Enqueue 


library/FindName 
library/FindPort 
library/FindResident 
library/FindSemaphore 
library/FindTask 


. library/Forbid 


library/FreeEntry 
library/FreeMem 
library/FfreeSignal 
library/FreeTrap 
library/Getcc 


.library/GetMsg 


library/InitCode 
library/InitResident 
library/InitSemaphore 
library/Initstruct 


-library/Insert 
-library/MakeFunctions 


library/MakeLibrary 
library/ObtainSemaphore 
library/ObtainSemaphoreList 
library/OldOpenLibrary 


. library/OpenDevice 


library/OpenLibrary 
library /OpenResource 
library/Permit 
library/Procure 
library/PutMsg 
library/RawDoFmt 
library/ReleaseSemaphore 
library/ReleaseSemaphoreList 
library/RemDevice 
library/RemHead 
library/RemIntServer 
library/RemLibrary 
library/Remove 
library/RemPort 
library/RemResource 








. Library/RemSemaphore 
-library/RemTail 

. library/RemTask 
.library/ReplyMsg 

>. library/SendIo 
.library/SetExcept 
.library/SetFunction 
.library/SetIntVector 
. library/SetSignal 

. library/SetsR 

. library/SetTaskPri 
.library/Signal 
.library/SumKickData 
. Library/SumLibrary 
. library/SuperState 
. library/TypeofMem 

. library/UserState 

. library/Vacate 
.library/Wait 
.library/WaitIo 
.library/WaitPort 

















exec. library/AbortIo exec. library/AbortIo 


NAME 

AbortIO — attempt to abort an in-progress I/O request 
SYNOPSIS 

error = Abort IO(iORequest ) 

bo Al 


BYTE Abort IO(struct IORequest *); 


FUNCTION 
Ask a device to abort a previously started IORequest. This is done 
by calling the device's ABORTIO vector, with your given IORequest. 


AbortIO is a request that device that may or may not grant. If 
successful, the device will stop processing the IORequest, and 
reply to it earlier than it would otherwise have done. 


NOTE 
AbortIO() does NOT remove the IORequest from your ReplyPort, OR 
wait for it to complete. After an AbortIO() you must wait normally 
for the reply message before actually reusing the request [see 
WaitIO()]. , 


If a request has already completed when AbortIO() is called, no 
action is taken. 


EXAMPLE 

Abort IO(timer_request) ; 

WaitIOo (timer_request); 

/* Message is free to be reused */ 
RESULTS 


error ~ Depending on the device and the state of the request, it 
may not be possible to abort a given I/O request. If for 
some reason the device cannot abort the request, it should 
return an error code in DO. 


INPUTS 
iORequest — pointer to an I/O request block. 


RESULTS 
error ~ zero if successful, else an error is returned 


SEE ALSO 
WaitIo, DoIO, SendIO, CheckIO 





exec. Library/AddDevice 


NAME 
AddDevice ~- add a device to the system 
SYNOPSIS 
AddDevice (device) 
Al 
void AddDevice(struct Device *); 
FUNCTION 
This function adds a new device to the system device list, making 
it available to other programs. The device must be ready to be 
opened at this time. 
INPUTS 
device - pointer to a properly initialized device node 
SEE ALSO 


RemDevice, OpenDevice, CloseDevice, MakeLibrary 


exec. library/AddDevice 








Tl 





fexec. library /AddHead exec. library/AddHead 


NAME, 
AddHead -~- insert node at the head of a list 
SYNOPSIS 
AddHead(list, node) 
AO Al 
void AddHead(struct List *, struct Node *) 
FUNCTION 
Add a node to the head of a doubly linked list. Assembly 
programmers may prefer to use the ADDHEAD macro from 
"exec/lists.i". 
WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 
INPUTS 


list - a pointer to the target list header 
node ~ the node to insert at head 


SEE ALSO 
AddTail, Enqueue, Insert, Remove, RemHead, RemTail 











exec. library/AddIntServer 





exec. library/AddIntServer 


NAME 
AddintServer -- add an interrupt server to the system 
SYNOPSIS 
AddIntServer(intNum, interrupt) 
DO-0:4 AL 
void AddIntServer(ULONG, struct Interrupt *); 
FUNCTION 
This function adds a new interrupt server to a given server chain. 
The node is located on the chain in a priority dependent position. 
If this is the first server on a particular chain, interrupts will 
be enabled for that chain. 
Each link in the chain will be called in priority order until the 
chain ends or one of the servers returns with the 68000's 2 
condition code clear (indicating non-zero). Servers on the chain 
should return with the Z flag clear if the interrupt was 
specifically for that server, and no one else. VERTB servers 
should always return 2 set. (Take care with High Level 
Language servers, the language may not have a mechanism for 
reliably setting the 2 flag on exit). 
Servers are called with the following register conventions: 
DO — scratch 
Di ~- scratch 
AQ — seratch 
Al — server is Data pointer (scratch) 
A5 ~ jump vector register (scratch) 
A6 — scratch 
all other registers ~ must be preserved 
INPUTS 
intNum — the Portia interrupt bit number (0 through 14). Processor 
level seven interrupts (NMI) are encoded as intNum 15. 
The PORTS, VERTB, COPER and EXTER and NMI interrupts are 
set up as server chains. 
interrupt - pointer to an interrupt server node 
BUGS 
The graphics library's VBLANK server incorrectly assumes that 
address register AO will contain a pointer to the custom chips. If 
you add a server at a priority of 10 or greater, you must 
compensate for this by providing the expected value ($DFF000). 
SEE ALSO 


RemIntServer, SetIntVector, hardware/intbits.h 














exec. library/AddLibrary exec. library/AddLibrary 


NAME | 
AddLibrary -~ add a library to the system 
SYNOPSIS 
AddLibrary(library) 
Al 


void AddLibrary(struct Library *); 


FUNCTION 
This function adds a new library to the system, making it available 
to other programs. The library should be ready to be opened at 
this time. It will be added to the system library name list, and 
the checksum on the library entries will be calculated. 


INPUTS 
library - pointer to a properly initialized library structure 


SEE ALSO 
RemLibrary, CloseLibrary, OpenLibrary, MakeLibrary 








exec. library/AddMemList . exec. Library/AddMemList 
NAME 
AddMemList ~ add memory to the system free pool 
SYNOPSIS 
AddMemList( size, attributes, pri, base, name ) 
DO D2 AO Al 


void AddMemList(ULONG, ULONG, LONG, APTR, char *); 


FUNCTION 
Add.a new region of memory to the system free pool. The first few 
bytes will be used to hold the MemHeader structure. The remainder 
will be made available to the rest of the world. 


INPUTS 

size - the size (in bytes) of the memory area 

attributes - the attributes word that the memory pool will have 

pri -~ the priority for this memory. CHIP memory has a pri of ~10, 
16 bit expansion memory has a priority of 0. The higher the 
priority, the closer to the head of the memory list it will 
be placed. 

base - the base of the new memory area 

name — the name that will be used in the memory header, or NULL 
if no name is to be provided. This name is not copied, so it 
must remain valid for.as long as the memory header is in the 
system. 


SEE ALSO 
AllocMem, exec/memory.h 








Ih 

















exec. library/AddPort. exec. library/AddPort 


NAME 
AddPort -~ add a public message port to the system 


SYNOPSIS 
AddPort (port) 
Al 


void AddPort(struct MsgPort *); 


FUNCTION 
This function attaches a message port structure to the system's 
public message port list, where it can be found by the FindPort() 
function. The name and priority fields of the port structure must 
be initialized prior to calling this function. If the user does 
not require the priority field, it should be initialized to zero. 


Only ports that will be searched for with FindPort() need to 

be added to the system list.. In addition, adding ports is often 
useful during debugging. If the port will be searched for, 

the priority field should be at least 1 (to avoid the large number 
of inactive ports at priority zero). . If the port will be searched 
for often, set the proritiry in the 50-100 range (so it will be 
before other less used ports). 


Once a port has been added to the naming list, you must be careful 
to remove the port from the list (via RemPort) before deallocating 
its memory. 


NOTE 
A point of confusion is that clearing a MsgPort structure to all 
zeros is not enough to prepare it for use. As mentioned in the 
Exec chapter of the ROM Kernel Manual, the List for: the MsgPort 
must be initialized. This is automatically handled by AddPort(), 
and amiga.lib/CreatePort. This initialization can be done manually 
with amiga.lib/NewList or the assembly NEWLIST macro. 


INPUTS 
port - pointer to a message port 


SEE ALSO 
RemPort, FindPort, amiga.lib/CreatePort, amiga.lib/NewList 





exec. library/AddResource exec. Library/AddResource 


NAME 
AddResource ~~ add a resource to the system 


SYNOPSIS 
AddResource( resource) 
Al 
void AddResource( APTR) ; 


FUNCTION 
This function adds a new resource to the system and makes it 
available to other. users. The resource must be ready to be called 
at this time. 


Resources currently have no system-imposed structure, other than 
starting with a standard Exec node or Library structure. 


INPUTS oe, , 
resource — pointer an initialized resource node 


SEE ALSO 
RemResource, OpenResource 





! 











exec. library/AddSemaphore 








exec. library/AddSemaphore 


NAME 
AddSemaphore ~~ add a signal semaphore to the system 


SYNOPSIS 
AddSemaphore (signal Semaphore) 
Al 


void AddSemaphore(struct SignalSemaphore *); 


FUNCTION 
This function attaches a signal semaphore structure to the system's 
public signal semaphore list. The name and priority fields of the 
semaphore structure must be initialized prior to calling this 
function. If you do not want to let others rendezvous with this 
semaphore, use InitSemaphore() instead. 


If a semaphore has been added to the naming list, you must be 
careful to remove the semaphore from the list (via RemSemaphore ) 
before deallocating its memory. 


Semaphores that. are linked together in an allocation list (which 
ObtainSemaphoreList() would use) may not be added to the system 
naming list, because the facilities use the link field of the 
signal semaphore in incompatible ways 


INPUTS 
signalSemaphore -- an signal semaphore structure 


BUGS 
Does not work in Kickstart V33/34. Instead use this code: 


#include "exec/execbase.h" 


void AddSemaphore(s) 

struct SignalSemaphore *s; 

{ 
InitSemaphore(s) ; 
Forbid(); 
Enqueue(&SysBase->SemaphoreList,,s); 
Permit(); 


SEE ALSO 
RemSemaphore, FindSemaphore, InitSemaphore 


exec. library/AddTail 





exec. library/AddTail 


NAME . 
AddTail -~- append node to tail of a list 
SYNOPSIS 
AddTail(list, node) 
AO Al 
void AddTail(struct List *, struct Node *); 
FUNCTION . . 
Add a node to the tail of a doubly linked list. Assembly 
programmers may prefer to use the ADDTAIL macro from 
"exec/lists.i". 
WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 
INPUTS . 
list — a pointer to the target list header _ 
node - a pointer to the node to insert at tail of the list 
SEE ALSO 


AddHead, Enqueue, Insert, Remove, RemHead, RemTail 








Wi 


OT - ¥ 

















exec. library/AddTask exec. Library/AddTask 
NAME 
AddTask -- add a task to the system 


SYNOPSIS 
AddTask(task, initialPc, finalPC) 
Al A2 A 
void AddTask(struct Task *, APTR, APTR); 


FUNCTION 
Add a task to the system. A reschedule will be run; the task with 
the highest priority in the system will start to execute (this may 
or may not be the new task). 


Certain fields of the task control block must be initialized and a 
stack allocated prior to calling this function. The absolute 
smallest stack that is allowable is something in the range of 100 
bytes, but in general the stack size is dependent on what 
subsystems are called. In general 256 bytes is sufficient if only 
Exec is called, and 4K will do if anything in the system is called. 
DO NOT UNDERESTIMATE. If you use a stack sniffing utility, 

leave a healthy pad above the minimum value. 


This function will temporarily use space from the new task's stack 
for the task's initial set of registers. This space is allocated 
starting at the SPREG location specified in the task control block 
(not from SPUPPER). This means that a task's stack may contain 
static data put there prior to its execution. This is useful for 
providing initialized global variables or some tasks may want to 
use this space for passing the task its initial arguments. 


A task's initial registers are set to zero (except the PC). 


The TC_MEMENTRY field of the task structure may be extended by 

‘the user to hold additional MemLists (as returned by Allockntry()). 
These will be automatically be deallocated at RemTask() time. 
If the code you have used to start the task has already added 
something to the MEMENTRY list, simply use AddHead to add your 
new Membists in. If no initializaticn has been done, a NewList will 
need to be performed. 


NOTE 
AddTask clears out TC_FLAGS. 


INPUTS 
task - pointer to the task control block (TCB) 
initialpc - the initial entry point's address 
finalec — the finalization code entry point's address. If zero, 
the system will use a general finalizer. This pointer is 
placed on the stack as if it were the outermost return 
address. 


WARNING 
Tasks are a low-level building block, and are unable to call 
dos. library, or any system routine that might call dos. library. 
See the AmigaDOS CreateProc() for information on Processes. 


SEE ALSO 
RemTask, FindTask, amiga.lib/CreateTask, dos/CreateProc, 
amiga. lib/NewList 


exec. Library/Alert exec. library/Alert 


NAME 
Alert -- alert the user of an error 
SYNOPSIS 
Alert(alertNum, parameters) 
_ D? A5 


void Alert(ULONG, APTR); 


FUNCTION 
Alerts the user of a serious system problem. This function will 
bring the system to a grinding halt, and do whatever is necessary 
to present the user with a message stating what happened. 
Interrupts are disabled, and an attempt to post the alert is made. 
If that fails, the system is reset. When the system comes up 
again, Exec notices the cause of the failure and tries again to 
post the alert. 


If the Alert is a recoverable type, this call MAY return. 
This call may be made at any time, including interrupts. 


INPUT 
alertNum - a number indicating the particular alert 
parameters — currently points to the number that forms the 
second part of a "Guru meditation" message. Typically 
this is a pointer to the task that was active at the 
time of the problem. 


NOTE 
Much more needs to be said about this function and its implications. 


SEE ALSO 
exec/alerts.h 














Tl -wW 








fexec. Library/AllocAbs exec. library/AllocAbs 


NAME 
AllocAbs -- allocate at a given location 
SYNOPSIS 
memoryBlock = AllocAbs(byteSize, location) 
DO DO Al 


void *AllocAbs(ULONG, APTR); 


FUNCTION 
This function attempts to allocate memory at a given absolute 
memory location. Often this is used by boot~surviving entities 
such as recoverable ram-disks. If the memory is already being 
used, or if there is not enough memory to satisfy the request, 
AllocAbs will return NULL. 


This block may not be exactly the same as the requested block 
because of rounding, but if the return value is non-zero, the block 
is guaranteed to contain the requested range. 


INPUTS 
byteSize - the size of the desired block in bytes 
This number is rounded up to the next larger 
block size for the actual allocation. 
location ~ the address where the memory MUST be. 


RESULT 
memoryBlock - a pointer to the newly allocated memory block, or 
NULL if failed. 


NOTE 
If the free list is corrupt, the system will panic with alert 
AN MemCorrupt, $81000005. 


SEE ALSO 
AllocMem, FPreeMem 


exec. Library/Allocate 


NAME 


exec. library/Allocate 


Allocate ~ allocate a block of memory 


SYNOPSIS 


memoryBlock=Allocate(MemHeader, byteSize) 
DO AO DO 
void *Allocate(struct. MemHeader *, ULONG); 


FUNCTION 


This function is used to allocate blocks of memory from a given 
private free memory pool (as specified by a MemHeader and its 
Memory chunk list). Allocate will return the first free block that 
is greater than or equal to the requested size. 


All biocks, whether free or allocated, will be block aligned; 
hence, all allocation sizes are rounded up to the next block even 
value (e.g. the minimum allocation resolution is currently 8 
bytes). 


This function can be used to manage an application's internal data 


memory. Note that no arbitration of the MemHeader and associated 
free chunk list is done. You must be the owner before calling 
Allocate. 

INPUTS 


freeList -— points to the memory list header 
byteSize - the size of the desired block in bytes 


RESULT 


memoryBlock ~— a pointer to the just allocated free block. 
If there are no free regions large enough to satisfy the 
request, return zero. 


EXAMPLE 


#include "exec/types.h" 

#include "exec/memory.h" 

void *AllocMem(); 

#define BLOCKSIZE 4000L /* Or whatever you want */ 


void main() 


struct MemHeader *mh; 


struct MemChunk *mc; 
APTR blockl; 
APTR block2; 


/* Get the MemHeader needed to keep track of our new block */ 
mh = (struct MemHeader *) / 

AlloecMem( (long)sizecf(struct MemHeader), MEMF_ CLEAR ); 
if( !mh ) 

exit(10); 


/* Get the actual block the above MemHeader will manage */ 
Mc = (struct MemChunk *)AllocMem( BLOCKSIZE, OL ); 
if( tme ) 





FreeMem( mh, (long)sizeof(struct MemHeader) ); exit(10); 


mh->mh_Node.1n_Type = NT_MEMORY; 
mh->mh_Node.1n_ Name = "myname"; 

mh-~>mh_First = me; 

mh~>mh_Lower = (APTR) mc; 

mh~>mh_Upper = (APTR) ( BLOCKSIZE + (ULONG) me ); 
mh->mh_Free = BLOCKSIZE; 


/* Set up first chunk in the freelist */ 
mc~>me_Next NULL; 
mc—>me_Bytes BLOCKSIZE; 


Ho 








{ll 


CT - ¥ 





blockl = (APTR) Allocate( mh, 20L ); 

block2 = (APTR) Allocate( mh, 3141 ); 

printf ("mh=$%1x me=$%1lx\n" ,mh,mc) ; 

printf ("Block1=$%1x, Block2=$%1x\n" , block], block2; ; 


FreeMem( mh, (long)sizeof(struct MemHeader) ); 
FreeMem( mc, BLOCKSIZE ); 


NOTE 
If the free list is corrupt, the system will panic with alert 
AN MemCorrupt, $81000005. 

SEE ALSO 


Deallocate 


exec. library/AllocEntry 


exec. library/AllocEntry 


NAME 

AllocEntry ~- allocate many regions of memory 
SYNOPSIS 

memList = AllocEntry(memList) 

bo AO 


struct MemList *AllocEntry(struct MemList *); 


FUNCTION 
This routine takes a memList structure and allocates enough memory 
to hold the required memory as well as a MemList structure to keep 
track of it. 


These MemList structures may be linked together in a task control 
block to keep track of the total memory usage of this task. (See 
the description of TC_MEMENTRY under RemTask). 


INPUTS 
memList -- A MemList structure filled in with MemEntry structures. 


RESULTS 
memList -- A different MemList filled in with the actual memory 
allocated in the me_Addr field, and their sizes in me_Length. 
If enough memory cannot be obtained, then the requirements of 
the allocation that failed is returned and bit 31 is set. 


EXAMPLES 
The user wants five regions of 2, 4, 8, 16, and 32 bytes in size 
with requirements of MEMF_CLEAR, MEMF_PUBLIC, MEMF_CHIP!MEMF CLEAR, 
MEMF FAST!MEMF CLEAR, and MEMF_PUBLIC!MEMF CLEAR respectively. The 
following code fragment would do that: 


MemListDecl: 
DS.B LN_SIZE * reserve space for list node 
DC.W 5 * number of entries 
DC.L MEMF_ CLEAR * entry #0 
De.L 2 
p.u MEMF_PUBLIC * entry #1 
DCe.L 4 
DC. L MEMP_CHIP!MEMF_CLEAR * entry #2 
pe. 8 
DC.L MEMF FAST !MEMF CLEAR * entry #3 
Dbe.L 16 
pe. L MEMF_PUBLIC!MEMF_CLEAR * entry #4 
be. L 32 

start: 
LEA. L MemListDecl (PC) ,A0 
JSR LVOA1 locEntry (a6) 


BCLR.L #31,D0 
BEQ.S success 


no Type of memory that we failed on is in DO 


BUGS 
If any one of the allocations fails, this function fails to back 
out fully. This is fixed by the "SetPatch" program on V1.3 
Workbench disks. 


SEE ALSO 
exec/memory .h 








an 








€T - ¥ 








exec. Library/AllocMem 


exec. library/AllocMem 





NAME 

AllocMem -- allocate memory given certain requirements 
SYNOPSIS 

memoryBlock = AllocMem(byteSize, attributes) 

DO DO Dl 


void *AllocMem(ULONG, ULONG) ; 


FUNCTION 
This is the memory allocator to’ be used by system code and 
applications. It provides a means of specifying that the allocation 
should be made in a memory area accessible to the chips, or 
accessible to shared system code. 


Memory is allocated based on requirements and options. An 
“ryequirement" must be met by a memory allocation, any "option" will 
be applied to the block regardless. AllocMem will try all memory 
spaces until one is found with the proper requirements and room for 
the memory request. 


INPUTS 
byteSize - the size of the desired block in bytes. This number is 
rounded up to the next larger memory chunk size for the 
actual allocation. The chunk size is guaranteed to be 


at least 8. 
attributes -— 
requirements 

MEMF CHIP: Only certain parts of memory are reachable 
by the special chip sets' DMA circuitry. 
Anything that will use on-chip DMA *MUST* 
be in memory with this attribute. DMA 
includes screen memory, things that are 
blitted, audio blocks, sprites and 
trackdisk.device buffers. 

MEMF_FAST: This is non-chip memory. It is possible 


for the processor to get. locked out of chip 
memory under certain conditions. If one 
cannot accept these delays, then one should 
use FAST memory (by default the system will 
allocate from FAST memory first anyway). 


This is rarely specified, since it would 
cause incompatibility with non-expanded 
machines. 
MEMF_ PUBLIC: Memory must not be mapped, swapped, 
or otherwise made non-addressable. ALL 
MEMORY THAT IS REFERENCED VIA INTERRUPTS 
AND/OR BY OTHER TASKS MUST BE EITHER PUBLIC 
OR LOCKED INTO MEMORY! This includes both 
code and data. 


options 
MEMF_CLEAR: 


The memory will be initialized to all 
Zeros . 


RESULT 
memoryBlock - a pointer to the newly allocated block. If there are 
no free regions large enough to satisfy the request (or if 
the amount of requested memory is invalid), return zero. 


WARNING 
The result of any memory allocate MUST be checked, and a viable 
error handling path taken. ANY allocation may fail if memory has 








been filled. 


EXAMPLES 
AllocMem(321,MEMF_CHIP) -— private chip memory 
AllocMem(25,MEMF PUBLIC |MEMF_CLEAR) - a cleared “public” system 
structure that does not require chip memory. 


NOTE 
If the free list is corrupt, the system will panic with alert 
AN_MemCorrupt, $81000005. 
This function may not be called from interrupts. 

SEE ALSO 


FreeMem 





||| 


yr - ¥ 








exec. Library/AllocSignal exec. library/AllocSignal 


NAME 
AllocSignal ~~ allocate a signal bit 
SYNOPSIS 
signalNum = AllocSignal(signalNum) 
DO bo 
BYTE AllocSignal (LONG); 
FUNCTION 
Allocate a signal bit from the current tasks' pool. Either a. 
particular bit, or the next free bit may be allocated. The signal 
associated with the bit will be properly initialized (cleared). At 
Jeast 16 user signals are available per task. Signals should be 
deallocated before the task exits. 
If the signal is already in use (or no free signals are available) 
a -l is returned. 
This function can only be used by the currently running task. 
WARNING : 
Signals may not be allocated or freed from exception handling code. 
INPUTS 
signalNum - the desired signal number {of 0..31} or -1 for no 
preference. 
RESULTS . 
signalNum -~ the signal bit number allocated [0..31}. If no signals 
are available, this function returns ~1. 
SEE ALSO 


FreeSignal 





exec. Library/AllocTrap exec. library/AllocTrap 
NAME 
AllocTrap —- allocate a processor trap vector 


SYNOPSIS 
trapNum = AllocTrap(trapNum) 
DO DO 

LONG AllocTrap(LONG) ; 


FUNCTION 
Allocate a trap number from the current task's pool. These trap 
numbers are those associated with the 68000 TRAP type instructions. 
Either a particular number, or the next free number may be 
allocated. 


If the trap is already in use (or no free traps are available) a -1 
is returned. 


This function only affects the currently running task. 


Traps are sent to the trap handler pointed at by te_TrapCode. 
Unless changed by user code, this points to a standard trap 
handler. The stack frame of the exception handler will be: 


O0(SP) = Exception vector number. This will be in the 
range of 32 to 47 (corresponding to the 
Trap #1...Trap #15 instructions). 

4(SP) = 68000/68010/68020/68030, etc. exception frame 


te_TrapData is not used. 


WARNING 
Traps may not be allocated or freed from exception handling code. 
You are not allowed to write to the exception table yourself. In 
fact, on some machines you will have trouble finding it — the VBR 
register may be used to remap its location. 


INPUTS 
trapNum - the desired trap number fof 0..15} or —1 
for no preference. 


RESULTS 
trapNum - the trap number allocated {of 0..15}.. If no traps are 
available, this function returns -1. Instructions of the 
form "Trap #trapNum" will be sent to the task's trap 
handler. 


SEE ALSO 
FreeTrap 














ST -W 


exec. library/At tempt Semaphore exec. library/Attempt Semaphore exec. library/AvailMem 


NAME 

AttemptSemaphore ~~ try to obtain without blocking 
SYNOPSIS 

success = AttemptSemaphore(signalSemaphore) 

DO AO 


LONG AttemptSemaphore(struct. SignalSemaphore *); 


FUNCTION 
This call is similar to ObtainSemaphore(), except that it will not 
block if the semaphore could not be locked. 


INPUT 
signalSemaphore —- an initialized signal semaphore structure 
RESULT 
success ~~ TRUE if the semaphore was locked, false if some 
other task already possessed the semaphore. 
SEE ALSO 


ObtainSemaphore(), ReleaseSemaphore(), exec/semaphores .h 














exec. library/AvailMem 


NAME 

AvailMem ~~ memory available given certain requirements 
SYNOPSIS 

size = AvailMem(attributes) 

DO DL 

ULONG AvailMem(ULONG) ; 
FUNCTION 

This function returns the amount of free memory given certain 


attributes. 


To find out what the largest block of a particular type is, add 
MEMF_LARGEST into the requirements argument. 


WARNING 
Due to the effect of multitasking, the value returned may not 
actually be the amount of free memory available at that instant. 


INPUTS 
requirements - a requirements mask as specified in AllocMem. Any 
of the AllocMem bits are valid, as is MEMF_LARGEST 
which returns the size of the largest block matching 
the requirements. 


RESULT 
size — total free space remaining (or the largest free block). 


EXAMPLE 
AvailMem(MEMF_CHIP |MEMF_LARGEST) ; 
/* return size of largest available chip memory chunk */ 


SEE ALSO 
exec/memory.h 











9T - ¥ 











exec. library/Cause exec. library/Cause 
NAME 
Cause -- cause a software interrupt 


SYNOPSIS 
Cause({interrupt) 
Al 


void Cause(struct Interrupt *); 


FUNCTION 
This function causes a software interrupt to occur. If it is 
called from user mode (and processor level 0), the software 
interrupt will preempt the current task. This call is often used 
by high-level hardware interrupts to defer medium-length processing 
down to a lower interrupt level. Note that a software interrupt is 
still a real interrupt, and must obey the same restrictions on what 
system routines it may call. 


Currently only 5 software interrupt priorities are implemented: 
—32, -16, 0, +16, and +32. Priorities in between are truncated, 
values outside the —32/+32 range are not allowed. 


NOTE 
When setting up the Interrupt. structure, set the node type to 
NT_INTERRUPT. 
IMPLEMENTATION 
1l> Checks if the node type is NT_SOFTINT. If so does nothing since 
the softint is already pending. No nest count is maintained. 
2> Sets the node type to NT_SOFTINT. 
3> Links into one of the 5 priority queues. 
4> Pokes the hardware interrupt bit used for softints. 
The node type returns to NT_INTERRUPT after removal from the list. 
INPUTS 


interrupt ~- pointer to a properly initialized interrupt node 


exec. library/CheckIoO 


exec. library/CheckIo 


CheckIO -- get the status of an JIORequest 


SYNOPSIS 


result = CheckIO(iORequest) 
DO AL 
BOOL CheckIO(struct. IORequest *); 


FUNCTION 


This function determines the current state of an I/O request and 
returns FALSE if the I/O has not yet completed. This function 
effectively hides the internals of the I/O completion mechanism. 


CheckIO will NOT remove the returned IORequest from the reply port. 
This is best performed with WaitIO(). If the request has already 
completed, WaitIO() will return quickly. Use of the Remove() 
function is dangerous, since other tasks may still be adding things 
to your message port; a Disable() would be required. 


This function should NOT be used to busy loop (looping until IO is 
complete). WaitIO() is provided for that purpose. 


INPUTS 


ioRequest - pointer to an I/O request block 


RESULTS 


result ~ null if I/O is still in progress. Otherwise 
DO points to the IORequest block. 


SEE ALSO 


DoIO, SendIO, WaitIO, AbortIO 











exec. library/CloseDevice exec. library/CloseDevice 
NAME 
CloseDevice -- conclude access to a device 
SYNOPSIS 
CloseDevice(iORequest ) 
Al 
void CloseDevice(struct IORequest *); 
FUNCTION 
This function informs the device that access to a device/unit 
previously opened has been concluded. The device may perform 
certain house-cleaning operations. 
The user must ensure that all outstanding IORequests have been 
returned before closing the device. The AbortIO function can kill 
any stragglers. 
After a close, the I/O request structure is free to be reused. 
INPUTS 
iORequest. - pointer to an I/O request structure 
SEE ALSO 


OpenDevice 


LT -W¥ 








exec. library/CloseLibrary 








exec. Library/CloseLibrary 


NAME 
CloseLibrary -- conclude access to a library 


SYNOPSIS 
CloseLibrary (library) 
Al 


void CloseLibrary(struct Library *); 


FUNCTION 
This function informs the system that access to the given library 
has been concluded. The user must not reference the library or any 
routine in the library after this close. 


INPUTS 

library - pointer to a library node 
SEE ALSO 

OpenLibrary 





| 


exec. Library/CopyMem exec. library/CopyMem exec. Library/CopyMemQuick exec. library/CopyMemQuick 


NAME NAME 

CopyMem - general purpose memory copy routine CopyMemQuick - optimized memory copy routine 
SYNOPSIS SYNOPSIS . . 

CopyMem( source, dest, size ) CopyMemQuick( source, dest, size ) 


AO Al DO 
void CopyMem(APTR, APTR,ULONG) ; 


AO AL DO 
void CopyMem(ULONG *,ULONG *,ULONG); 


FUNCTION FUNCTION . . . . oo . 
CopyMem is a general purpose, fast memory copy routine. It can CopyMemQuick is a highly optimized memory copy routine, with 
deal with arbitrary lengths, with its pointers on arbitrary restrictions on the size and alignment of its arguments. Both the 


alignments. It attempts to optimize larger copies with more 
efficient copies, it uses byte copies for small moves, parts of 
larger copies, or the entire copy if the source and destination are 


source and destination pointers must be longword aligned. In 
addition, the size must be an integral number of longwords (e.g. 
the size must be evenly divisible by four). 


misaligned with respect to each other. 


Arbitrary overlapping copies are not supported. 





Arbitrary overlapping copies are not supported. 
The internal implementation of this routine will change from system 
The internal implementation of this routine will change from to system, and may be implemented via hardware DMA. 
system to system, and may be implemented via hardware DMA. 
INPUTS 
INPUTS source — a pointer to the source data region, long aligned 
source - a pointer to the source data region dest - a pointer to the destination data region, long aligned 
dest - a pointer to the destination data region size —- the size (in bytes) of the memory area 
size — the size (in bytes) of the memory area 
SEE ALSO 
SEE ALSO CopyMem 
CopyMemQuick 


8T - ¥ 














6t - ¥ 








exec. Library/Deallocate 


Deallocate -- deallocate a block of memory 


SYNOPSIS 


Deallocate(MemHeader, memoryBlock, byteSize) 
AO Al DO 


void Deallocate(struct MemHeader *,APTR,ULONG); 


FUNCTION 


This function deallocates memory by returning it to the appropriate 
private free memory pool. This function can be used to free an 
entire block allocated with the above function, or it can be used 
to free a sub-block of a previously allocated block. Sub-blocks 
must be an even multiple of the memory chunk size (currently 8 
bytes). 


This function can even be used to add a new free region to an 
existing MemHeader, however the extent pointers in the MemHeader 
will no longer be valid. 


If memoryBlock is not on a block boundary (MEM_BLOCKSIZE) then it 
will be rounded down in a manner compatible with Allocate(). Note 
that this will work correctly with all the memory allocation 
routines, but may cause surprises if one is freeing only part of a 
region. The size of the block will be rounded up, so the freed 
block will fill to an even memory block boundary. 


INPUTS 


freeList - points to the free list 

memoryBlock - memory block to return 

byteSize - the size of the desired block in bytes. If NULL, nothing 
happens. 


SEE ALSO 


Allocate 


exec. library/Deallocate exec. Library/Debug 


exec. library/Debug 


Debug -~ run the system debugger 


SYNOPSIS 


void Debug(0L); 
bo 


FUNCTION 


This function calls the system debugger. By default this debugger 
is "ROM-WACK"., Other debuggers are encouraged to take over this 
entry point (via SetFunction()) so that when an application calls 
Debug(), the alternative debugger will get control. Currently a 
zero is passed to allow future expansion. 


The Debug() call may be made when the system is in a questionable 
state; if you have a SetFunction() patch, make few assumptions, be 
prepared for Supervisor mode, and be aware of differences in the 
Motorola stack frames on the 68000,'10,'20, and '30. 


SEE ALSO 


SetFunction 
your favorite debugger's manual 
the ROM-WACK chapter of the ROM Kernel Manual 





o~ - ¥ 





exec. library/Disable 


exec. library/Disable 


NAME 
Disable -—- disable interrupt processing. 


SYNOPSIS 
Disable(); 


void Disable( void); 


FUNCTION 
Prevents interrupts from being handled by the system, until a 
matching Enable() is executed. Disable() implies Forbid(). 


RESULTS 
All interrupt processing is deferred until the task executing makes 
a call to Enable() or is placed in a wait state. Normal task 
rescheduling does not occur while interrupts are disabled. In order 
to restore normal interrupt processing, the programmer must. execute 
exactly one call to Enable() for every call to Disable(). 


IMPORTANT REMINDER: 


It is important to remember that there is a danger in using 
disabled sections. Disabling interrupts for more than ~250 
microseconds will prevent vital system functions (especially serial 
I/0) from operating in a normal fashion. 


Think twice before using Disable(), then think once more. 
After all that, think again. With enough thought, the need 
for a Disable() can often be eliminated. 

Do not use a macro for Disable(), insist on the real thing. 


This call may be made from interrupts, it will have the effect 
of locking out all higher-level interrupts (lower-level interrupts 
are automatically disabled by the CPU). 


WARNING 
In the event of a task entering a Wait after disabling interrupts, 
the system "breaks" the forbidden state and runs normally until the 
task which called Forbid() is rescheduled. 


If caution is not taken, this can cause subtle bugs, since any 
device or DOS call will (in effect) cause your task to wait. 


SEE ALSO 
Forbid, Permit, Enable 


exec. Library/DoIO 


exec. library/DoIO 


NAME : 

DoIO ~~ perform an I/O command and wait for completion 
SYNOPSIS 

error = DoIO(iORequest) 

DO Al 


BYTE DoIO(struct IORequest *); 


FUNCTION 
This function requests a device driver to perform the I/O command 
specified in the I/O request. This function will always wait until 
the I/O request is fully complete. 


IMPLEMENTATION 
This function first tries to complete the IO via the "Quick 1/0" 
mechanism. The io Flags field is always set to IOF_QUICK (0x01) 
before the internal device call. 


INPUTS 
iORequest ~ pointer to an IORequest initialized by OpenDevice() 


RESULTS 
error - a sign-extended copy of the io_Error field of the 
TORequest. Most device commands require that the error 
return be checked. 


SEE ALSO 
Sendio, CheckIO, WaitIO, AbortIO, amiga.lib/BeginIo 











Te - W 











exec. library/Enable 


NAME 
Enable —- permit system interrupts to resume. 


SYNOPSIS 
Enable(); 


void Enable(void); 


FUNCTION 
Allow system interrupts to again occur normally, after a matching 
Disable() has been executed. 


RESULTS 
Interrupt processing is restored to normal operation. The 
programmer must execute exactly one call to Enable() for every call 
to Disable(). 


SEE ALSO 
Forbid, Permit, Disable 


exec. library/Enable exec. library/Enqueue 











exec. library/Enqueve 


NAME 
Engueue -- insert or append node to a system queue 

SYNOPSIS 
Enqueue(list, node) 

AO Al 

void Enqueue(struct List *, struct Node *); 

FUNCTION 
Insert or append a node into a system queue. The insert is 
performed based on the node priority -- it will keep the list 
properly sorted. New nodes will be inserted in front of the first 
node with a lower priority. Hence a FIFO queue for nodes of equal 
priority : 

WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 

INPUTS 
list - a pointer to the system queue header 
node ~ the node to enqueue 

SEE ALSO 


AddHead, AddTail, Insert, Remove, RemHead, RemTail 





ce - WW 


‘Fj... —>"7.2"...”- rt 
exec. library/FindName 





exec. Library/FindName 


NAME 

FindName -- find a system list node with a given name 
SYNOPSIS 

node = FindName(start, name) 

DO AQ Al 


struct Node *FindName(struct List *,char *); 


FUNCTION 
Traverse a system list until a node with the given name is found. 
To find multiple occurrences of a string, this function may be 
called with a node starting point. 


No arbitration is done for access to the list! If multiple tasks 
aceess the same list, an arbitration mechanism such as 
SignalSemaphores must be used. 


INPUTS 
start - a list header or a list. node to start the search 
(if node, this one is skipped) 
name —- a pointer to a name string terminated with null 


RESULTS 
node —- a pointer to the node with the same name else 
zero to indicate that the string was not found. 


Jexec. library/FindPort exec. library/FindPort 


NAME 

FindPort. -- find a given system message port 
SYNOPSIS 

port = FindPort (name) 

DO Al 


struct MsgPort *FindPort(char *); 


FUNCTION 
This function will search the system message port list for a port 
with the given name. The first port matching this name will be 
returned. No arbitration of the port list is done. This function 
MUST be protected with A Forbid()/Permit() pair! 


EXAMPLE 
#include “exec/types.h" 
struct MsgPort *FPindPort()j; 


ULONG SafePutToPort(message, portname) 
struct Message *message; 
char *portname; 





{ 
struct MsgPort *port; 


Forbid(); 
port = FindPort(portname) ; 
if (port) 
PutMsg (port ,message) ; 
Permit(); 
return((ULONG)port); /* If zero, the port has gone away */ 


INPUT 
name - name of the port to find 


RETURN 
port - a pointer to the message port, or zero if 
not found. 





a 








ct - ¥ 


exec. library/FindResident 








exec. library/FindResident 


NAME : 
FindResident - find a resident module by name 


SYNOPSTS 
resident = FindResident (name) 
Al 
struct Resident *FindResident(char *); 


FUNCTION 
Find the resident tag with the given name. If found return a 
pointer to the resident tag structure, else return zero. 


Resident modules are used by the system to pull all its parts 
together at startup. Resident tags are also found in disk based 
devices and libraries. 


INPUTS 
name - pointer to name string 


RESULT 
resident — pointer to the resident tag structure or 
zero if none found. 


SEE ALSO 
exec/resident .h 


exec. library/FindSemaphore 








exec, library/FindSemaphore 


NAME 
FindSemaphore ~- find a given system signal semaphore 
SYNOPSIS 
signalSemaphore = FindSemaphore(name) 
0 Al 
struct SignalSemaphore *FindSemaphore(char *); 
FUNCTION 
This function will search the system signal semaphore list for a 
semaphore with the given name. The first semaphore matching this 
name will be returned. 
INPUT 
name - name of the semaphore to find 
RESULT 
semaphore - a pointer to the signal semaphore, or zero if not 
found. 
BUGS 


This routine does not arbitrate for access to the semaphore list, 
surround the call with a Forbid()/Permit() pair. 

















vo -. 











exec. library/FindTask 


NAME 

FindTask -- find a task with the given name or find oneself 
SYNOPSIS . 

task = FindTask(name) 

DO Al 


struct Task *FindTask(char *); 


FUNCTION 
This function will check all task queues for a task with the given 
name, and return a pointer to its task control block. If a NULL 
name pointer is given a pointer to the current task will be 
returned. 


Finding oneself with a NULL for the name is very quick. Finding a 
task by name is very system expensive, and will disable interrupts 
for a long time. 


INPUT 
name — pointer to a name string 


RESULT 
task - pointer to the task (or Process) 








exec. library/FindTask exec. library/Forbid 


NAME 


SYNO} 


FUNC 





exec. Library/Forbid 


Forbid -- forbid task rescheduling. 


PSIS 
Forbid() 


void Forbid( void); 


TION 

Prevents other tasks from being scheduled to run by the dispatcher, 
until a matching Permit() is executed, or this task is scheduled to 
Wait. Interrupts are NOT disabled. 


RESULTS 


The current task will not be rescheduled as long as it is ready to 
run. In the event that the current task enters a wait state, other 
tasks may be scheduled. Upon return from the wait state, the original 
task will continue to run without disturbing the Forbid(). 


Calls to Forbid() nest. In order to restore normal task rescheduling, 
the programmer must execute exactly one call to Permit() for every 
eall to Forbid(). 


WARNING 


SEB 


In the event of a task entering a Wait after a Forbid(), the system 
“breaks" the forbidden state and runs normally until the task which 
called Forbid() is rescheduled. 

If caution is not taken, this can cause subtle bugs, since any 
device or DOS call will (in effect) cause your task to wait. 


Forbid() is not useful or safe from within an interrupt routine 
(Since interrupts are always higher priority than tasks, and 
since interrupts are allowed interrupt a Forbid()). 


ALSO 
Permit, Disable 








ce -W¥ 











exec. library/FreeEntry exec. library/FreeEntry 
NAME 
FreeEntry ~- free many regions of memory 
SYNOPSIS 


FreeEntry(memList) 
AO 
void FreeEntry(struct Membist *); 
FUNCTION 


This routine takes a memList structure (as returned by AllocEntry) 
and frees all the entries. 


INPUTS 
memList -- pointer to structure filled in with MemEntry 
structures 
SEE ALSO 
AllocEntry 


exec. library/FreeMem exec. library/FreeMem 


NAME 
FreeMem —~ deallocate with knowledge 


SYNOPSIS 
FreeMem(memoryBlock, byteSize) 
Al bo 


void FreeMem(void *,ULONG); 


FUNCTION 
Free a region of memory, returning it to the system pool from which 
it came. Freeing partial blocks back into the system pool is 
unwise. 


NOTE 
If a block of memory is freed twice, the system will GURU. The 
Alert is AN FreeTwice ($81000009). Future versions may add more 
sanity checks to the memory lists. 


INPUTS 
memoryBlock — memory block to free 
If the memoryBlock previously returned by an allocation 
routine. 
byteSize - the size of the block in bytes 


SEE ALSO 
AllocMem 








exec. library/FreeSignal 


9% - ¥ 





exec. library/FreeSignal 


NAME 
FreeSignal -~ free a signal bit 


SYNOPSIS 
FreeSignal(signalNum) 
: DO 


FreeSignal (ULONG); 


FUNCTION 
This function frees a previously allocated signal bit for reuse. 
This call must be performed while running in the same task in which 
the signal was allocated. 


WARNING 
Signals may not be allocated or freed from exception handling code. 


INPUTS 
signalNum - the signal number to free [{0..31} 





exec. library/FreeTrap 





exec. library/FreeTrap 


NAME 
FreeTrap —- free a processor trap 


SYNOPSIS 
FreeTrap(trapNum) 
DO 


void FreeTrap(ULONG) ; 


FUNCTION 
This function frees a previously allocated trap number for reuse. 
This call must be performed while running in the same task in which 
the trap was allocated. 


WARNING ; 
Traps may not be allocated or freed from exception handling code. 


INPUTS 
trapNum ~ the trap number to free {of 0..15} 


Ut 











exec. library/Getcc 













NAME 
Getcc -— get. condition codes in a 68010 compatible way. 


SYNOPSIS 
conditions = GetCC() 

DO 
UWORD = GetCC( void); 


FUNCTION 
The 68000 processor has a "MOVE SR,<ea>" instruction which gets a 
copy of the processor condition codes. 


on the 68010,20 and 30 CPUs, "MOVE SR,<ea>" is privileged. User 
code will trap if it is attempted. These processors need to use 
the "MOVE CCR,<ea>" instruction instead. 


This function provides a means of obtaining the CPU condition codes 
in a manner that will make upgrades transparent. This function is 
very short and quick. 


RESULTS 
conditions ~ the 680XX condition codes 


4@-¥ 


exec. library/Getcc exec. Llibrary/GetMsg 


exec. library/GetMsg 


GetMsg -- get next message from a message port 


SYNOPSIS 


message = GetMsg(port) 
DO AO 


struct Message *GetMsg(struct MsgPort *); 


FUNCTION 


This function receives a message from a given message port. It 
provides a fast, non~copying message receiving mechanism. The 
received message is removed from the message port. 


This function will not wait. If a message is not present this 
function will return zero. If a program must wait for a message, 
it can Wait() on the signal specified for the port or use the 
WaitPort() function. There can only be one task waiting for any 
given port. 


Getting a message does not imply to the sender that the message is 
free to be reused by the sender. When the receiver is finished 
with the message, it may ReplyMsg() it back to the sender. 


Getting a signal does NOT always imply a message is ready. More 
than one message may arrive per signal, and signals may show up 

without messages. Typically you must loop to GetMsg() until it 

returns zero, then Wait().or WaitPort(). 


INPUT 


port -— a pointer to the receiver message port 


RESULT 


message —- a pointer to the first message available. If 
there are no messages, return zero. 
Callers must be prepared for zero at any time. 


SEE ALSO 


PutMsg, ReplyMsg, WaitPort, Wait, exec/ports.h 














fl 








exec, Library/InitCode exec. library/InitCode 


NAME 
InitCode - initialize resident code modules 


SYNOPSIS 
InitCode(startClass, version) 
DO DL 
void InitCode(ULONG,ULONG) ; 


FUNCTION 
Initialize all resident modules with the given startClass and with 
versions equal or greater than that specified. Modules are 
initialized in a prioritized order. 


Resident modules are used by the system to pull all its parts 
together at startup. Resident tags are also found in disk based 
devices and libraries. 


INPUTS 
startClass - the class of code to be initialized: coldstart, 
coolstart, warmstart, 
version ~ a major version number 


SEE ALSO 
exec/resident .h 


8e - v 








hl 


exec. library/InitResident exec. Library/InitResident 


InitResident ~ initialize resident module 


SYNOPSIS 


InitResident(resident, segList) 
AL D1 
void InitResident(struct Resident *,BPTR); 


FUNCTION 


Initialize a module (these are also called "ROM-tags"). This includes 
interpreting the fields of the ROM-tag, and calling the initialization 
hooks. 


An automatic method of library/device base and vector table 
initialization is also provided through the use of a such a ROM-tag 
(Resident) structure. In this case, the initial code hunk of the 
library or device should contain “MOVEQ #-1,d0; RTS;". Following 
that must be an initialized Resident structure including RTF_AUTOINIT 
in rt_Flags, and an rt_Init pointer which points to four longwords as 
follows: 


- Size of your library/device base structure including initial 
Library or Device structure. 

~ Pointer to a longqword table of standard, then library 
specific function offsets, terminated with —l1L. 

- Pointer to data table in exec/InitStruct format for 
initialization of Library or Device structure. 

- Pointer to library initialization routine, which will receive 
library/device base in d0, segment in a0, and must return 
non-zero to link the library/device into the device/library 
list. 


SEE ALSO 


exec/resident.h 





6a - Vv 











exec. library/InitSemaphore exec. Llibrary/InitSemaphore 
NAME 
InitSemaphore -- initialize a signal semaphore 


SYNOPSIS 
InitSemaphore(signalSemaphore) 
AO 


void InitSemaphore(struct. SignalSemaphore *); 


FUNCTION 
This function initializes a signal semaphore and prepares it for 
use. It does not allocate anything, but does initialize list 
pointers and the semaphore counters. 


Semaphores are often used to protect critical data structures 
or hardware that can only be accessed by one task at a time. 
After initialization, the address of the SignalSemaphore may be 
made available to any number of tasks. Typically a task will 
try to ObtainSemaphore(), passing this address. in. If no other 
task owns the semaphore, then the call will lock and return 
quickly. If more tasks try to ObtainSemaphore(), they will 

be put to sleep. When the owner of the semaphore releases 

it, the next waiter in turn will be woken up. 


Semaphores are often preferable to the old-style Forbid()/Permit() 
type arbitration. With Forbid()/Permit() *all* other tasks are 
prevented from running. With semaphores, only those tasks that 
need access to whatever the semaphore protects are subject 

to waiting. 


INPUT 
signalSemaphore -- a signal semaphore structure (with all fields 
set to zero before the call) 


SEE ALSO 
ObtainSemaphore(), AttemptSemaphore(), ReleaseSemaphore() 
exec/semaphores .h 


























exec. library/InitStruct exec. library/Initstruct 
NAME 
InitStruct - initialize memory from a table 
SYNOPSIS 
InitStruct(initTable, memory, size); 
Al A2 DO 
void InitStruct(struct InitStruct *, APTR, ULONG); 
FUNCTION 
Clear a memory area except those words whose data and offset values 
are provided in the initialization table. Typically only assembly 
programs take advantage of this, and only with the macros defined 
in “exec/initializers.i'". 
The initialization table has byte commands to 
|2 | byte given! |byte once 
load jcount|}|word} into |next rptr| offset, |repetitively 
long 
Not all combinations are supported. The offset, when specified, is 
relative to the memory pointer provided (Memory), and is initially 
zero. The initialization data (InitTable) contains byte commands 
whose 8 bits are interpreted as follows: 
ddssnnann 
dd the destination type (and size): 
00 next destination, nnnn is count 
01 next destination, nnnn is repeat 
10 destination offset is next byte, nnnn is count 
1l destination offset is next rptr, nnnn is count 
ss the size and location of the source: 
00 long, from the next two aligned words 
01 word, from the next aligned word 
10 byte, from the next byte 
11 ERROR ~ will cause an ALERT (see below) 
nnnn the count or repeat: 
count the (numinber+1) of source items to copy 
repeat - the source is copied (number+tl) times. 
initTable commands are always read from the next even byte. Given 
destination offsets are always relative to memory (A2). 
The command 00000000 ends the InitTable stream: use 00010001 if you 
really want to copy one longword. 
24 bit APTR not supported for 68020 compatibility -~ use long. 
INPUTS 
initTable - the beginning of the commands and data to init 
Memory with. Must be on an even boundary unless only 
byte initialization is done. 
memory - the beginning of the memory to initialize. Must be 
on an even boundary if size is specified. 
size - the size of memory, which is used to clear it before 
initializing it via the initTable. If Size is zero, 
memory is not cleared before initializing. 
We recommend an EVEN number for size; odd byte sizes 
may be truncated. 
SEE ALSO 


exec/initializers.i 





Till 


og -v 





exec. library/Insert exec. library/Insert 
NAME 
Insert -~ insert a node into a list 


SYNOPSIS 
Insert(list, node, listNode) 
AO Al A2 
void Insert(struct List *, struct Node *, struct Node *); 


FUNCTION 
Insert a node into a doubly linked list AFTER a given node 
position. Insertion at the head of a list is possible by passing a 
zero value for listNode, though the AddHead function is slightly 
faster for that special case. 


WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 


INPUTS : 
list - a pointer to the target list header 
node ~ the node to insert 
listNode - the node after which to insert 


SEB ALSO 
AddHead, AddTail, Enqueue, RemHead, Remove, RemTail 


exec’. Library/MakeFunctions 





exec. library/MakeFunctions 


NAME 
MakeFunctions -- construct a function jump table 


SYNOPSIS 
tableSize = MakeFunctions(target, functionArray, funcDispBase) 
bo AQ Al A2 
ULONG MakeFunctions(APTR,APTR,APTR); 


FUNCTION 
This function constructs a function jump table of the type used by 
resources, libraries, and devices. It allows the table to be built 
anywhere in memory, and can be used both for initialization and 
replacement. This function also supports function pointer 
compression by expanding relative displacements into absolute 
pointers. 


INPUT 
destination - the target address for the high memory end of the 
function jump table. Typically this will be the library 
base pointer. 


functionArray ~- pointer to an array of function pointers or 
function displacements. If funcDispBase is zero, the array 
is assumed to contain absolute pointers to functions. If 
funcDispBase is not zero, then the array is assumed to 
contain word displacements to functions. In both cases, 
the array is terminated by a -1 (of the same size as the 
actual entry. 





funcDispBase - pointer to the base about which all function 
displacements are relative. If zero, then the function 
array contains absolute pointers. 


RESULT 
tableSize - size of the new table in bytes. 


SEB ALSO 
exec/MakeLibrary 











T€é - ¥ 


exec. library/MakeLibrary 





exec. library/MakeLibrary 


NAME 


MakeLibrary -- construct a library 


SYNOPSIS 


library = MakeLibrary(vectors, structure, init, dSize, segList) 
DO AO Al A2 DO DL 
struct Library *MakeLibrary 

(APTR, struct InitStruct *,APTR,ULONG, BPTR) ; 


FUNCTION 


This function is used for constructing a library vector and data 
area. The same call is used to make devices. Space for the library 
is allocated from the system's free memory pool. The size fields of 
the library are filled. The data portion of the library is 
initialized. init may point to a library specific entry point, 

or NULL if no call is to be made. 


INPUTS 


vectors ~ pointer to an array of function pointers or function 
displacements. If the first word of the array is -1, then 
the array contains relative word displacements (based off 
of vectors); otherwise, the array contains absolute 
function pointers. The vector list is terminated by a —1 
(of the same size as the pointers). 


structure ~ points to an "InitStruct" data region. If NULL, 
then it will not be used. 


init — an entry point that will be called before adding the 
library to the system. If null, it will not be called. When 
it is called, it will be called with the libAddr in DO and 
the segList parameter in AO. The result of the init function 
will be the result returned by MakeLibrary. 
A Forbid()/Permit() pair surrounds this call. 


dSize - the size of the library data area, including the 
standard library node data. 


segList - pointer to an AmigaDOS Seglist (segment list). 
This is passed to a library's init code, and is used later 
for removing the library from memory. 


RESULT 


library ~- the reference address of the library. This is tie 
address used in references to the library, not the 
beginning of the memory area allocated. If the library 
vector table require more system memory than is 
available, this function will return NULL. 


SEE ALSO 


InitStruct, InitResident, exec/initializers.i 


exec. library/ObtainSemaphore 





exec. library/ObtainSemaphore 


NAME 


ObtainSemaphore -- gain exclusive access to a semaphore 


SYNOPSIS 


ObtainSemaphore(signalSemaphore) 
AO 


void ObtainSemaphore(struct SignalSemaphore *); 


FUNCTION 


Signal semaphores are used to gain exclusive access to an object. 
ObtainSemaphore is the call used to gain this access. If another 
user currently has the semaphore locked the call will block until 
the object is available. 


If the current task already has locked the semaphore and attempts to 
lock it again the call will still succeed. A "nesting count" is 
incremented each time the current owning task of the semaphore calls 
ObtainSemaphore(). This counter is decremented each time 
ReleaseSemaphore() is called. When the counter returns to zero the 
semaphore is actually released, and the next waiting task is called. 


A queue of waiting tasks is maintained on the stacks of the waiting 
tasks. Each will be called in turn as soon as the current task 
releases the semaphore. 


Signal Semaphores are different than Procure()/Vacate() semaphores. 
The former requires less CPU time, especially if the semaphore is 
not currently locked. They require very little set up and user 
thought. The latter flavor of semaphore make no assumptions about 
how they are used -- they are completely general. Unfortunately 
they are not as efficient as signal semaphores, and require the 
locker to have done some setup before doing the call. 


INPUT 


signalSemaphore -- an initialized signal semaphore structure 


SEE ALSO 


InitSemaphore(), ReleaseSemaphore() 
AttemptSemaphore(), ObtainSemaphoreList () 


ce - v 








exec. library/ObtainSemaphoreList exec. library/obtainSemaphoreList 


ObtainSemaphoreList -- get a list of semaphores. 


SYNOPSIS 


ObtainSemaphoreList (list) 
AO 


void ObtainSemaphoreList(struct List *); 


FUNCTION 


Signal semaphores may be linked together into a list. This routine 
takes a list of these semaphores and attempts to lock all of them at 
once. This call is preferable to applying ObtainSemaphore() to each 
element in the list because it attempts to lock all the elements 
simultaneously, and won't deadlock if someone is attempting to Lock 
in some other order. 


This routine assumes that only one task at a time will attempt to 
lock. the entire. list of semaphores. In other words, there needs to 
be a higher level lock (perhaps another signal semaphore...) that is 
used before someone attempts to lock the semaphore list via 
ObtainSemaphoreList(). 


Note that deadlocks may result if this call is used AND someone 
attempts to use ObtainSemaphore() to lock more than one semaphore on 
the list. If you wish to lock more than semaphore (but not all of 
them) then you should obtain the higher level lock (see. above) 


INPUT 


list -~ a list of signal semaphores 


SEE ALSO 


ObtainSemaphore(), ReleaseSemaphore(), ReleaseSemaphoreList() 





Mi 


exec. library/OldOpenLibrary exec. library/O1ldOpenLibrary 


NAME 
OldOpenLibrary -- obsolete OpenLibrary 


SYNOPSIS 
library = OldOpenLibrary(libName) 
DO AL 


struct Library *OldOpenLibrary(APTR) ; 


FUNCTION 
The 1.0 release of the Amiga system had an incorrect version of 
OpenLibrary that did not check the version number during the 
library open. This obsolete function is provided so that object 
code compiled using a 1.0 system will still run. 


This exactly the same as "OpenLibrary(libName,0L);" 


INPUTS 

libName - the name of the library to open 
RESULTS 

library - a library pointer for a successful open, else zero 
SEE. ALSO 

CloseLibrary 











ce - © 


exec. library/OpenDevice 














exec. Library/OpenDevice 


NAME 
OpenDevice —~ gain access to a device 


SYNOPSIS 
error = OpenDevice(devName, unitNumber, iORequest, flags) 
DO DO Al D1 
BYTE OpenDevice(char *,ULONG,struct IORequest *,ULONG); 


FUNCTION 
This function opens the named device/unit and initializes the given 
I/O request block. Specific documentation on opening procedures 
may come with certain devices. 


The device may exist in memory, or on disk; this is transparent to 
the OpenDevice caller. 


A full path name for the device name is legitimate. For example 
"test:devs/fred:device". This allows the use of custom devices 
without requiring the user to copy the device into the system's 
DEVS: directory. 


NOTE 
All calls to OpenDevice should have matching calls to CloseDevice! 


INPUTS 
devName — requested device name 


unitNumber ~ the unit number to open on that device. The format of 
the unit number is device specific. If the device does 
not have separate units, send a zero. 


jORequest ~ the I/O request block to be returned with 
appropriate fields initialized. 


flags - additional driver specific information. This is sometimes 
used to request opening a device with exclusive access. 


RESULTS 
error - Returns a sign-extended copy of the io_Error field 
of the IORequest. Zero if successful, else an error code 
is returned. 


BUGS 
AmigaboS file names are not case sensitive, but Exec lists are. If 
the library name is specified in a different case than it exists on 
disk, unexpected results may occur. 


Tasks should not be allowed to make OpenDevice calls that will 
cause the device to be loaded from disk (since tasks are not 
allowed to make dos.library calls). 


SEE ALSO 
CloseDevice, DoIO, SendIO, CheckIO, AbortIO, WaitIo 








exec. library/OpenLibrary exec. Library/OpenLibrary 


NAME 
OpenLibrary -- gain access to a library 
SYNOPSIS 
library = OpenLibrary(libName, version) 
DO Al DO 


struct Library *OpenLibrary(char *,ULONG); 


FUNCTION 
This function returns a pointer to a library that was previously 
installed into the system. If the requested library is exists, and 
if the library version is greater than or equal to the requested 
version, then the open will succeed. 


The device may exist in memory, or on disk; this is transparent to 
the OpenDevice caller. Only Processes are allowed to call 
OpenLibrary (since OpenLibrary may in turn call dos. library). 


A full path name for the library name is legitimate. For example 
“wp: libs/wp.library". This allows the use of custom libraries 
without requiring the user to copy the library into the system's 
LIBS: directory. 


NOTE 
All calls to OpenLibrary should have matching calls to CloseLibrary! 


INPUTS 
libName ~ the name of the library to open 


version ~ the version of the library required. 


RESULTS 
library ~- a library pointer for a successful open, else zero 


BUGS 
AmigaboS file names are not case sensitive, but Exec lists are. If 
the library name is specified in a different case than it exists on 
disk, unexpected results may occur. 


Tasks should not be allowed to make OpenLibrary calls that will 
cause the library to be loaded from disk (since tasks are not 
allowed to make dos.library requests). 


SEE ALSO 
CloseLibrary 














Wy 


gu 


ve 


i 











exec. library/OpenResource exec. library/OpenResource 


NAME 
OpenResource —- gain access to a resource 


SYNOPSIS 
resource = OpenResource( resName) 
bo Al 
APTR OpenResource(char *); 


FUNCTION . 
This function returns a pointer to a resource that was previously 
installed into the system. 


There is no CloseResource() function. 


INPUTS 
resName — the name of the resource requested. 


RESULTS 
resource — if successful, a resource pointer, else NULL 











exec. Library/Permit exec. library/Permit 
NAME 
Permit ~- permit task rescheduling. 
SYNOPSIS 
Permit () 


void Permit (void) ; 


FUNCTION 
Allow other tasks to be scheduled to run by the dispatcher, after a 
matching Forbid() has been executed. 


RESULTS 
Other tasks will be rescheduled as they are ready to run. In order 
to restore normal task rescheduling, the programmer must execute 
exactly one call to Permit({) for every call to Forbid(). 


SEE ALSO 
Forbid, Disable, Enable 








se -W 





exec. library/Procure 





exec. library/Procure 


NAME 
Procure -- bid for a message lock (semaphore) 

SYNOPSIS 
result = Procure(semaphore, bidMessage) 
DO AO Al 
BYTE Procure(struct Semaphore *, struct Message *); 

FUNCTION 
This function is used to obtain a message based semaphore lock. If 
the lock is immediate, Procure() returns a true result, and the 
bidMessage is not used. If the semaphore is already locked, 
Procure() returns false, and the task must wait for the bidMessage 
to arrive at its reply port. 
Straight “Semaphores" use the message system. They are therefore 
queueable, and users may wait on several of them at the same time. 
This makes them more powerful than "Signal Semaphores" 

INPUT 
semaphore - a semaphore message port. This port is used to queue 
all pending lockers. This port should be initialized with the 
PA_IGNORE option, as the MP_SigTask field is used for a pointer to 
the current locker message (not a task). New semaphore ports must 
also have the SM_BIDS word initialized to -l. If the semaphore is 
public, it should be named, its priority set, and the added with 
AddPort. Message port priority is often used for anti-deadlock 
locking conventions. 

RESULT 
result - true when the semaphore is free. In such cases no waiting 
needs to be done. If false, then the task should wait at its 
bidMessage reply port. 

BUGS 
Procure() and Vacate() do not have proven reliability. 

SEE ALSO 
Vacate() 








exec. library/PutMsg 


exec. Llibrary/PutMsg 


NAME 
PutMsg ~~ put a message to a message port 
SYNOPSIS 
PutMsg(port, message) 
AO Al 
void PutMsg(struct MsgPort *, struct Message *); 
FUNCTION : 
This function attaches a message to a given message port. It 
provides a fast, non-copying message sending mechanism. 
Messages can be attached to only one port at a time. The message 
body can be of any size or form. Because messages are not copied, 
cooperating tasks share the same message memory. The sender task 
should not recycle the message until it has been replied by the — 
receiver. Of course this depends on the message handling conventions 
setup by the involved tasks. If the ReplyPort field is non~zero, 
when the message is replied by the receiver, it will be sent back to 
that port. 
Any one of the following actions can be set to occur when a message 
is put: 
1. no special action 
2. signal a given task (specified by MP_SIGTASK) 
3. cause a software interrupt (specified by MP_SIGTASK) 
The action is selected depending on the value found in the MP_FLAGS 
of the destination port. 
IMPLEMENTATION 
1. Sets the LN_TYPE field to "NT_MESSAGE" . 
2. Attaches the message to the destination port. . 
3. Performs the specified arrival action at the destination. 
INPUT 
port - pointer to a message port 
message —- pointer to a message 
SEE ALSO 


GetMsg, ReplyMsg, exec/ports.h 





I 








96 - WV 


iil 











exec. Library/RawDoFint 


exec. Library/RawDoFmt 








NAME. 
RawDoFmt —- format data into a character stream. 
SYNOPSIS 
RawDoFmt(FormatString, DataStream, PutChProc, PutChData); 
AO Al A2 A3 
void(char *,APTR,void (*)(),APTR); 
FUNCTION 
perform "C"-language-like formatting of a data stream, outputting 
the result a character at a time. Where % formatting commands are 
found in the FormatString, they will be replaced with the 
corresponding element in the DataStream. %% must be used in the 
string if a % is desired in the output. 
INPUTS 
FormatString - a "C"-language-like null terminated format string, 
with the following supported % options: 
%[flags] [width. limit] [length] type 
flags ~ only one allowed. ‘'~' specifies left justification. 
width - field width. If the first character is a '0', the 
field will be padded with leading 0's. 
. ~ must follow the field width, if specified 
limit - maximum number of characters to output from a string. 
(only valid for %s). 
length - size of input data defaults to WORD, '1' changes this 
to long. 
type — supported types are: 
d — decimal 
x ~ hexadecimal 
s — string 
c - character 
DataStream - a stream of data that is interpreted according to 
the format string. Often this is a pointer into 
the task's stack. 
PutChProc - the procedure to call with each character to be 
output, called as: 
PutChProc(Char, PutChData); 
DO-0:8 A3 
the procedure is called with a null Char at the end of 
the format string. 

PutChData ~ a value that is passed through to the PutChProc 
procedure. This is untouched by RawDoFmt, and may be 
modified by the PutChProc. 

EXAMPLE 


Simple version of the C "sprintf" function. Assumes C-style 


stack-based function conventions. 
long eyecount; 
eyecount=2 ; 
sprintf(string,"%s have %ld eyes.","Fish",eyecount) ; 


would produce "Fish have 2 eyes." in the string buffer. 


XDEF _sprintf 
_sprintf: ; ( string, format, {values} ) 
movem.1 a2/a3/a6,-(sp) 


move.1 5*4(sp),a3 ;Get the output string pointer 
move.] 6%*4(sp),a0 ;Get the FomnatString pointer 
lea.1 7*4(sp),al ;Get the pointer to the DataStream 
lea.l stuffChar(pc) ,a2 


move.1 
jsr 


_AbsExecBase ,a6 
_ LVORawDoF int. (a6) 


movem.1 (sp)+,a2/a3/a6 
rts 


;Put data to output string: 


i PutchProc function used by RawDoFmt 
stuffChar: move.b d0,(a3)+ 
rts 


WARNING 
This is the only Amiga ROM function that accepts word inputs. If 
your compiler defaults to longs, you will need to add a "1" to your 
% specification. This can get strange for characters, which must 
look like "Sic". 


SEE ALSO 
Documentation on the C language "printf" call in any C language 
reference book. 











fexec. library/ReleaseSemaphore 


LE -W¥ 








exec. Library/ReleaseSemaphore 


NAME 
ReleaseSemaphore -~ make signal semaphore available to others 


SYNOPSIS 
ReleaseSemaphore(signalSemaphore) 
AO 


void ReleaseSemaphore(struct SignalSemaphore *); 


FUNCTION 
ReleaseSemaphore() is the inverse of ObtainSemaphore(). It makes 
the semaphore lockable to other users. If tasks are waiting for 
the semaphore and this this task is done with the semaphore then 
the next waiting task is signalled. 


Each ObtainSemaphore() call must be balanced by exactly one 
ReleaseSemaphore() call. This is because there is a nesting count 
maintained in the semaphore of the number of times that the current 
task has locked the semaphore. The semaphore is not released to 
other tasks until the number of releases matches the number of 
obtains. 


Needless to say, havoc breaks out if the task releases more times 
than it has obtained. 


INPUT 
signalSemaphore —- an initialized signal semaphore structure 


SEE ALSO 
ObtainSemaphore(), AttemptSemaphore( ) 


exec. library/ReleaseSemaphoreLi st 





exec. library/ReleaseSemaphoreList 


NAME . 
ReleaseSemaphoreList -- make a list of semaphores available 


SYNOPSIS . 
ReleaseSemaphoreList (list) 
AO 


void ReleaseSemaphoreList (struct List *); 


FUNCTION . . ; 
ReleaseSemaphoreList() is the inverse of ObtainSemaphoreList(). It 
releases each element in the semaphore list. 


Needless to say, havoc breaks out if the task releases more times 
than it has obtained. 


INPUT . 
list ~- a list of signal semaphores 


SEE ALSO . ; 
ObtainSemaphore(), ReleaseSemaphore(), ObtainSemaphoreList() 


AttemptSemaphore( ) 

















il 


ll 





exec. library/RemDevice exec. library/RemDevice 


NAME 
RemDevice -- remove a device from the system 


SYNOPSIS 
void Rembevice(device) 
Al 


void RemDbevice(struct Device *); 


FUNCTION 
This function calls the device's EXPUNGE vector, which requests 
that a device delete itself. The device may refuse to do this if 


it is busy or currently open. This is not typically called by user 
code. 


There are certain, limited circumstances where it may be 
appropriate to attempt to specifically flush a certain device. 
Example: 


/* Attempts to flush the named device out of memory. */ 
#include "exec/types.h" 
#include "exec/execbase.h" 


void FlushDevice(name) 
char *name; 





struct Device *result; 


Forbid(); 

if(result=(struct Device *)FindName( &SysBase—>DeviceList,name) ) 
RemDevice( result) ; . 

Permit(); 


] 


> INPUTS 
! device ~ pointer to a device node 
Ww 
© SEE ALSO 
AddLibrary 








exec. library/RemHead 


exec. library/RemHead 


NAME . 
RemHead -- remove the head node from a list 
SYNOPSIS 
node = RemHead(list) 
DO AO 


struct Node *RemHead(struct List *); 


FUNCTION 
Get a pointer to the head node and remove it from the list. 
Assembly programmers may prefer to use the REMHEAD macro from 
"exec/lists.i". 


WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 


INPUTS 
list - a pointer to the target list header 


RESULT . 
node ~ the node removed or zero when empty list 


SEE ALSO 
AddHead, AddTail, Enqueue, Insert, Remove, RemTail 














exec. library/RemIntServer exec. library/RemIntServer exec. library/RemLibrary exec. library/RemLibrary 








NAME NAME 
RemIntServer -—- remove an interrupt server RemLibrary -~ remove a library from the system 
SYNOPSIS SYNOPSTS 
RemIntServer(intNum, interrupt) void RemLibrary(library) 
DO Al Al 


void RemIntServer(ULONG,struct Interrupt *); void RemLibrary(struct Library *); 


FUNCTION 
This function removes an interrupt server node from the given 
server chain. 


FUNCTION 
This function calls the library's EXPUNGE vector, which requests 
that a library delete itself. The library may refuse to do this if 
it is busy or currently open. This is not typically called by user 


If this server was the last one on this chain, interrupts for this code. 
chain are disabled. 
There are certain, limited circumstances where it may be 
INPUTS appropriate to attempt to specifically flush a certain Library. 
intNum ~ the Portia interrupt bit (0..14) Example: 
interrupt - pointer to an interrupt server node 
7* Attempts to flush the named library out of memory. */ 
BUGS #include "exec/types.h" 
Under V33/34 Kickstart, the feature that disables the interrupt #include "exec/execbase.h" 
does not function. For most server chains this does not 
cause a problem. void FlushLibrary (name) 
char *name; 
SEE ALSO { 


AddintServer, hardware/intbits.h struct Library *result; 
Forbid(); _. 
if(result=(struct Library *)FindName(&SysBase->LibList ,name) ) 

RemLibrary (result); 
Permit(); 


INPUTS 
library - pointer to a library node structure 


6€e -W 














ov -¥ 











exec. library/Remove exec. Llibrary/Remove 


NAME 
Remove ~~ remove a node from a list 


SYNOPSIS 
Remove (node) 
AL 
void Remove(struct Node *); 


FUNCTION 
Remove a node from whatever list it is in. Nodes that are not part 
of a list must not be Removed! Assembly programmers may prefer to 
use the REMOVE macro from "exec/lists.i". 


WARNING 
This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 


INPUTS 
node ~ the node to. remove 


SEE ALSO 
AddHead, AddTail, Enqueue, Insert, RemHead, RemTail 


exec. library/RemPort 


exec. library/RemPort 


NAME 
RemPort -- remove a message port from the system 
SYNOPSIS 
RemPort (port) 
Al 
void RemPort(struct MsgPort *); 
FUNCTION 
This function removes a message port structure from the system's 
message port list. Subsequent attempts to rendezvous by name with 
this port will fail. 
INPUTS 
port ~ pointer to a message port 
SEE ALSO 


AddPort, 


FindPort. 





i 


Tt - WV 


exec. library/RemResource 











NAME 
RemResource —~- remove a resource from the system 


SYNOPSIS 
RemResource{ resource) 


1 
void RemResource(APTR) ; 
FUNCTION 
This function removes an existing resource from the system resource 
list. 


INPUTS 
resource —- pointer to a resource node 


SEE ALSO 
AddResource 


exec. Llibrary/RemResource exec. library/RemSemaphore 


exec. library/RemSemaphore 


NAME 
RemSemaphore ~~ remove a signal semaphore from the system 
SYNOPSIS 
RemSemaphore (signalSemaphore) 
Al 
void RemSemaphore(struct SignalSemaphore *); 
FUNCTION 
This function removes a signal semaphore structure from the 
system's signal semaphore list. Subsequent attempts to 
rendezvous by name with this semaphore will fail. 
INPUTS 
signalSemaphore -- an initialized signal semaphore structure 
SEE ALSO 


AddSemaphore, FindSemaphore 








ey - 


Ll 








exec. library/RemTail ‘exec. library/RemTail 


NAME 
RemTail —- remove the tail node from a list 

SYNOPSIS 
node = RemTail(list) 

DO AQ 
struct Node *Remfail(struct List *); 

FUNCTION . : 
Remove the last node from a list, and return a pointer to it. If 
the list is empty, return zero. Assembly. programmers may prefer to 
use the REMTAIL macro from “exec/lists.i". 

WARNING ‘ 

This function does not arbitrate for access to the list. The 
calling task must be the owner of the involved list. 

INPUTS 
list ~ a pointer to the target list header 

RESULT . 
node ~ the node removed or zero when empty list 

SEE ALSO 


AddHead, AddTail, Enqueue, Insert, Remove, RemHead, RemTail 


[ree Beenaeress 





exec. library/RemTask 


NAME 
Remfask ——- remove a task from the system 


SYNOPSTS 
Remfask (task) 
Al 
void RemTask(struct Task *); 


FUNCTION 
This function removes a task from the system. Deallocation of 
resources should have been performed prior to calling this 
function. Removing some other task is very dangerous. Generally 
is is best to arrange for tasks to call RemTask(OL) on themselves. 


RemTask will automagically free any memory lists attached to the 
task's TC_MEMENTRY list. 


INPUTS 
task -— pointer to the task node representing the task to be 
removed. A zero value indicates self removal, and will 
cause the next ready task to begin execution. 


SEE ALSO 
AddTask, exec/AllocEntry, amiga.lib/DeleteTask 








cv -W 





exec. library/ReplyMsg 





exec. library/ReplyMsg 


NAME 
ReplyMsg -- put a message to its reply port 


SYNOPSIS 
ReplyMsg(message) 
Al 


void ReplyMsg(struct Message *); 


FUNCTION 
This function sends a message to its reply port. This is usually 
done when the receiver of a message has finished and wants to 
return it to the sender (so that it can be re-used or deallocated, 
whatever). 


This call may be made from interrupts. 


INPUT 
message — a pointer to the message 


IMPLEMENTATION 
i> Places "NT_REPLYMSG" into LN_TYPE. 
2> Puts the message to the port specified by MN_REPLYPORT 
If there is no replyport, sets LN_TYPE to "NT_FREEMSG". 


SEE ALSO 
GetMsg, PutMsg, exec/ports.h 





exec. library/SendIo 








exec. library/SendIo 


NAME 
SendIO -- initiate an 1/0 command 


SYNOPSIS 
SendIO( iORequest ) 
Al 


void SendIO(struct IORequest *); 


FUNCTION 
This function requests the device driver start processing the given 
I/O request. The device will return control without waiting for 
the 1/0 to complete. 


The io_Flags field of the IORequest will be set to zero before the 
request is sent. 


INPUTS 
iORequest ~ pointer to an I/O request, or a device specific 
extended IORequest. 


SEE ALSO 
DoIO, CheckIO, WaitIo, AbortIO 





vy - ¥ 


lexec. Library/SetExcept exec. Library/SetExcept 


NAME 

SetExcept -- define certain signals to cause exceptions 
SYNOPSIS 

oldSignals = SetExcept(newSignals, signalMask) 

DO DO DL 


ULONG SetExcept (ULONG, ULONG) ; 


FUNCTION 
This function defines which of the task's signals will cause a 
private task exception. When any of the signals occurs the task's 
exception handler will be dispatched. If the signal occurred prior 
to calling SetExcept, the exception will happen immediately. 


The user function pointed to by the task's tc_ExceptCode gets 
called as: 


newExcptSet = <exceptCode>(signals, exceptData) ,SysBase 
DO DO Al AG 


signals - The set of signals that caused this exception. These 
Signals have been disabled from the current set of signals 
that can cause an exception. 


exceptData - A copy of the task structure tc_ExceptData field. 


newExcptSet - The set of signals in NewExceptSet. will be re—- 
enabled for exception generation. Usually this will be the 
same as the Signals that caused the exception. 


All registers are preserved by the system before the call. 


INPUTS 
newSignals ~ the new values for the signals specified in 
signalMask. 
signalMask - the set of signals to be effected 


RESULTS : 
oldSignals ~ the prior exception signals 


EXAMPLE 
Get the current state of all exception signals: 
SetExcept (0,0) 
Change a few exception signals: 
SetExcept ($1374 ,$1074) 


SEE ALSO 
Signal, SetSignal 





exec. Library/SetFunction 





ul 


exec. Library/SetFunction 


NAME 
SetFunction -- change a function vector in a library 
SYNOPSIS 
oldFune = SetFunction(library, funcOffset, funcEntry) 
DO A AO.W DO 
APTR SetFunction(struct Library *,LONG,APTR); 
FUNCTION 
SetFunction is a functional way of changing where vectors in a 
library point. They are changed in such a way that the 
checksumming process will never falsely declare a library to be 
invalid. 
NOTE 
SetFunction cannot be used on non-standard libraries like 
dos.library. Here you must manually Forbid(), preserve all 6 
original bytes, set the new. vector, SumLibrary(), then Permit(). 
INPUTS 
library ~ a pointer to the library to be changed 
funcOffset - the offset of the function to be replaced 
funcEntry ~ pointer to new function 
RESULTS 
oldFunc - pointer to the old function that was just replaced 











[exec. library/Set Intvector exec. library/Set IntVector 


NAME 
SetIntVector -~ set a system interrupt vector 


SYNOPSIS 
oldInterrupt = SetIntVector(intNumber, interrupt) 
DO DO-0:4 Al 
struct Interrupt *SetIntVector(ULONG, struct Interrupt *); 


FUNCTION 
This function provides a mechanism for setting the system interrupt 
vectors. These are non-sharable, setting something here 
disconnects the old handler. 


Both the code and data pointers of the vector are set to the new 
values. A pointer to the old interrupt structure is returned. When 
the system calls the specified interrupt code the registers are 
setup as follows: 


DO ~ scratch 
Dl - scratch (on entry: active portia 
interrupts -> equals INTENA & INTREQ) 


AO - scratch (on entry: pointer to base of custom chips 
for fast indexing) 
Al ~ scratch (on entry: interrupt's is Data pointer) 


A5 — jump vector register (scratch on call) 
A6é ~ Exec library base pointer (scratch on call) 


all other registers - must be preserved 


INPUTS 
intNum ~ the Portia interrupt bit number (0..14) 
interrupt - a pointer to an Interrupt: structure containing 
the handler's entry point and data segment pointer. It is a 
good idea to give the node a name so that other users may 
identify who currently has control of the interrupt. 


Gi - Wv 


RESULT 
A pointer to the prior interrupt node which had control 
of this interrupt. 


SEE ALSO 
AddIntServer, exec/interrupts.h, exec/hardware.h 














exec. library/SetSignal exec. library/SetSignal 
NAME . 
SetSignal -- define the state of this task's signals 


SYNOPSIS 
oldSignals = SetSignal(newSignals, signalMask) 
DO DO D1 


ULONG SetSignal (ULONG , ULONG) ; 


FUNCTION 
This function defines the states of the task's signals. 
Setting the state of signals is considered dangerous. 
Reading the state of signals is safe. 


INPUTS 
newSignals - the new values for the signals specified in 
signalSet. 
signalMask - the set of signals to be affected 


RESULTS 
oldSignals ~- the prior values for all signals 


EXAMPLES 
Get the current state of all signals: 
SetSignal (0,0); 
Clear all signals: 
SetSignal (0, OxFFFFFFFFL) ; 
Clear the CTRL-C signal: 
SetSignal(0,SIGBREAKF_CTRL C); 


Check if the CTRL-C signal was pressed: 


#include "libraries/dos.h" 


if(SetSignal(0L,0L) & SIGBREAKF_CTRL_C) 
printf("CTRL-C pressed!\n"); 


SEE ALSO 
Signal, Wait 





Il 





94 - ¥ 


jexec. Library/SetsR exec. Library/SetsSR 


NAME 

SetSR ~~ get and/or set processor status register 
SYNOPSIS 

oldSR = SetSR(newSR, mask) 

DO DO DL 


ULONG SetSR(ULONG, ULONG) ; 


FUNCTION 
This function provides a means of modifying the CPU status register 
in a "safe" way (well, how safe can a function like this be 
anyway?). This function will only affect the status register bits 
specified in the mask parameter. The prior content of the entire 
status register is returned. 


INPUTS 
newSR ~- new values for bits specified in the mask. 
All other bits are not effected. 
mask ~ bits to be changed 


RESULTS 
oldSR - the entire status register before new bits 


EXAMPLES 
To get. the current SR: 
currentSR = SetSR(0,0); 
To change the processor interrupt level to 3: 
oldSR = SetSR($0300,$0700) ; 
Set processor interrupts back to prior level: 
SetSR(oldsR ,$0700) ; 











exec. Library/SetTaskPri exec. library/SetTaskPri 
NAME 
SetTaskPri ~- get and set the priority of a task 


SYNOPSIS 
oldPriority - SetTaskPri(task, priority) 
DO-0:8 AL DO-0:8 
BYTE SetTaskPri(struct Task *,LONG); 


FUNCTION 
This function changes the priority of a task regardless of its 
state. The old priority of the task is returned. A reschedule is 
performed, and a context switch may result. 


To change the priority of the currently running task, pass the 
result of FindTask(0); as the task pointer. 


INPUTS 
task - task to be affected 
priority — the new priority for the task 


RESULT 
oldPriority — the tasks previous priority 


I 











exec. library/Signal exec. library/Signal 


NAME 
Signal -- signal a task 
SYNOPSIS 
Signal(task, signals) 
Al DO 


void Signal(struct Task *,ULONG); 


FUNCTION 
This function signals a task with the given signals. If the task 
is currently waiting for one or more of these signals, it will be 
made ready and a reschedule will occur. If the task is not waiting 
for any of these signals, the signals will be posted to the task 
for possible later use. A signal may be sent to a task regardless 
of whether its running, ready, or waiting. 


This function is considered "low level". Its main purpose is to 
support multiple higher level functions like PutMsg. 


This function is safe to call from interrupts. 


INPUT 
task - the task to be signalled 
signals ~- the signals to be sent 


SEE ALSO 
Wait, SetSignal 


Ly - 





exec. library/SumKickData 











exec. library/SumKickData 


NAME 
SumKickData -- compute the checksum for the Kickstart delta list 


SYNOPSTS 
void SumKickData( void) 


FUNCTION 
The Amiga system has some ROM (or Kickstart) resident code that 
provides the basic functions for the machine. This code is 
unchangeable by the system software. This routine is part of a 
support system to modify parts of the ROM. 


The ROM code is linked together at run time via ROM-tags (also known 
as Resident structures, defined in exec/resident.h). These tags tell 
Exec's low level boot code what subsystems exist in which regions of 
memory. The current list of ROM-tags is contained in the ResModules 
field of ExecBase. By default this list contains any ROM-tags found 
in the address ranges $FCOQ000-SFFFFFF and $F00000-SF7FFFF. 


There is also a facility to selectively add or replace modules to the 
ROM-tag list. These modules can exist in RAM, and the memory they 
occupy will be deleted from the memory free list during the boot 
process. SumKickData() plays an important role in this run-time 
modification of the ROM-tag array. 


Three variables in EBxecBase are used in changing the ROM-tag array: 
KickMemPtr, KickTagPtr, and KickCheckSum. KickMemPtr points to a 
linked list of MemEntry structures. The memory that these MemEntry 
structures reference will be allocated (via AllocAbs) at boot time. 
The MemEntry structure itself must also be in the list. 


KickTagPtr points to a long-word array of the same format as the 
ResModules array. The array has a series of pointers to ROM-tag 
structures. The array is either null terminated, or will have an 
entry with the most significant bit (bit 31) set. The most 
significant bit being set says that this is a link to another 
long-word array of ROM-tag entries. This new array's address can be 
found by clearing bit 31. 


KickCheckSum has the result of SumKickData({). It is the checksum of 
both the KickMemPtr structure and the KickTagPtr arrays. If the 
checksum does not compute correctly then both KickMemPtr and 
KickTagPtr will be ignored. 


If all the memory referenced by KickMemPtr can't be allocated then 
KickTagPtr will be ignored. 


There is one more important caveat about adding ROM-tags. All this 
ROM-tag magic is run very early on in the system —- before expansion 
memory is added to the system. Therefore any memory in this 
additional ROM-tag area must be addressable at this time. This means 
that your ROM-tag code, MemEntry structures, and resident arrays 
cannot be in expansion memory. There are two regions of memory that 
are acceptable: one is chip memory, and the other is "Ranger" memory 
(memory in the range between $C00000-$D80000). 


Remember that changing an existing ROM-tag entry falls into the 
"heavy magic" category -- be very careful when doing it. The odd are 
that you will blow yourself out of the water. 


NOTE 
SumKickData was introduced in the 1.2 release 


SEE ALSO 
InitResident, FindResident 





BY - 


exec. library/SumLibrary 








exec. Library/SumLibrary 


NAME 
SumLibrary -- compute and check the checksum on a library 
SYNOPSIS 
SumLibrary (library) 
: Al 
void SumLibrary(struct Library *); 
FUNCTION 
SumLibrary computes a new checksum on a library. It can also be 
used to check an cold checksum. If an old. checksum does not match, 
and the library has not been. marked as changed, then the system 
will call Alert(). 
This call could also be periodically made by some future 
system-checking task. 
INPUTS . 
library - a pointer to the library to be changed 
NOTE 
An alert will occur if the checksum fails. 
SEE ALSO 


SetPunction 


exec. library/SuperState 





exec. library/SuperState 


NAME. 
SuperState -- enter supervisor state with user stack 
SYNOPSIS 
oldSysStack = SuperState() 
DO 
APTR SuperState( void); 
FUNCTION 
Enter supervisor mode while running on the user's stack. The user 
still has access to user stack variables. Be careful though, the 
user stack must. be large enough to accommodate space for all 
interrupt data ~- this includes all possible nesting of interrupts. 
This function does nothing when called from supervisor state. 
RESULTS 
oldSysStack - system stack pointer; save this. It will come in 
handy when you return to user state. If the system 
is already in supervisor mode, oldSysStack is zero. 
SEE ALSO 


UserState 

















exec. library/TypeofMem exec. library/TypeofMem 


NAME 

TypeOfMem -~ determine attributes of a given memory address 
SYNOPSIS 

attributes = TypeOfMem({ address) 

DO Al 

ULONG TypeOfMem(void *); 
FUNCTION 


Given a RAM memory address, search the system memory lists and 
return its memory attributes. The memory attributes are similar to 
those specified when the memory was first allocated: (eg. MEMF_CHIP 
and MEMF FAST). 


This function is usually used to determine if a particular block of 
memory is within CHIP space. 


If the address is not in known-space, a zero will be returned. 
(Anything that is not RAM, like the ROM or expansion area, will 
return zero. Also the first few bytes of a memory area are used up 
by the MemHeader. ) 


INPUT 
address - a memory address 


RESULT 
attributes - a long word of memory attribute flags. 
If the address is not in known RAM, zero is returned. 


SEE ALSO 
AllocMem( ) 


6b - WwW 





exec. library/UserState exec. Llibrary/UserState 


NAME 
UserState -- return to user state with user stack 
SYNOPSIS 
UserState(sysStack) 
DO 
void ‘UserState(APTR) ; 
FUNCTION 
Return to user state with user stack, from supervisor state with 
user stack. This function is normally used in conjunction with the 
SuperState function above. 
This function must not be called from the user state. 
INPUT 
sysStack ~ supervisor stack pointer 
BUGS 
This function is broken in V33/34 Kickstart. 
SEE ALSO 


SuperState 


os ~~ W¥ 








exec. Library/Vacate exec. library/Vacate 


NAME 
Vacate ~~ release a message lock (semaphore) 
SYNOPSIS 
Vacate( semaphore) 
AO 
void Vacate(struct Semaphore *); 
FUNCTION 
This function releases a previously locked semaphore (see 
the Procure() function). 
If another task is waiting for the semaphore, its bidMessage 
will be sent to its reply port. 
INPUT 
semaphore — the semaport message port representing the 
semaphore to be freed. 
BUGS 
Procure() and Vacate() do not have proven reliability. 
SEE ALSO 


Procure 





exec. Library/wait 








exec. Library/Wwait 


NAME 

Wait -- wait for one or more signals 
SYNOPSIS 

signals = Wait(signalSet) 

DO DO 

ULONG Wait (ULONG) ; 
FUNCTION 


This function will cause the current task to suspend waiting for 
one or more signals. When one or more of the specified signals 
occurs, the task will return to the ready state, and those signals 
will be cleared. 


If a signal occurred prior to calling Wait, the wait condition will 
be immediately satisfied, and the task will continue to run without 
delay. 


CAUTION 
This function cannot be called while in supervisor mode or 
interrupts! This function will break the action of a Forbid() or 
Disable() call. 


INPUT 
signalSet - The set of signals for which to wait. 
Each bit represents a particular signal. 


RESULTS 
signals — the set of signals that were active 





To - W 


exec. library/WaitIO 





exec. library/WaitIo 


NAME 
WaitIO —- wait for completion of an I/O request 

SYNOPSIS 
error = WaitIO(iORequest) 
DO Al 
BYTE WaitIO(struct IORequest *); 

FUNCTION 
This function waits for the specified I/O request to complete, then 
removes it from the replyport. If the I/O has already completed, 
this function will return immediately. 
This function should be used with care, as it does not return until 
the I/O request completes; if the I/O never completes, this 
function will never return, and your task will hang. If this 
situation is a possibility, it is safer to use the Wait() function. 
Wait() will return return when any of a specified set of signal is 
received. This is how I/O timeouts can be properly handled. 

WARNING 
If this I0Request was "Quick" or otherwise finished BEFORE this 
call, this function drops though immediately, with no call to 
Wait(). A side effect is that the signal bit related the port may 
remain set. Expect this. 

INPUTS 
iORequest - pointer to an I/O request block 

RESULTS 
error ~ zero if successful, else an error is returned 

(a sign extended copy of io_Error). 
SEE ALSO 


DoIO, SendIO, CheckIO, AbortIO 


exec. library/WaitPort 


exec. library/waitPort 


NAME 
WaitPort -- wait for a given port to be non-empty 


SYNOPSIS 
message = WaitPort(port) 
bo AO 
struct Message *WaitPort(struct MsgPort *); 


FUNCTION 
This function waits for the given port to become non-empty. If 
necessary, the Wait function will be called to wait for the port 
signal. If a message is already present at the port, this function 
will return immediately. The return value is always a pointer to 
the first message queued (but it is not removed from the queue). 


CAUTION 
More than one message may be at the port when this returns. It is 
proper to call the GetMsg() function in a loop until all messages 
have been handled, then wait for more to arrive. 


To wait for more than one port, combine the signal bits from each 
port into one call to the Wait() function, then use a GetMsg() loop 
to collect any and all messages. It is possible to get a signal 
for a port WITHOUT a message showing up. Plan for this. 


INPUT 
port - a pointer to the message port 


RETURN . . 
message ~ a pointer to the first available message 


SEE ALSO 
GetMsg 





fo - ¥ 


il 











TABLE OF CONTENTS 


expansion. 
expansion. 
expansion. 
expansion. ] 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 
expansion. 


Library/AddDosNode 

Library /MakeDosNode 
Library/AddCon figbev 
ibrary/AllocBoardMem 
Library/AllocConfigbev 
library/AllocExpansionMem 
library/ConfigBoard 
ibrary/ConfigChain 
library/FindConfigDev 
library/FreeBoardMem 
library/FreeConfigDev 
Library/FreeExpansionMem 
library/GetCurrentBinding 
library/ObtainConfigBinding 
library/ReadExpansionByte 
library/ReadExpansionkom 
ibrary/ReleaseConfigqBinding 
library/RemConfigqDev 
library/SetCurrentBinding 
library/WriteExpansionByte 





expansion. library/AddDosNode expansion. library/AddDosNode 


NAME 
AddDosNode ~- mount a disk to the system 
SYNOPSIS 
ok = AddDosNode( bootPri, flags, deviceNode ) 
DO bo D1 AO 
FUNCTION 


This routine makes sure that your disk device (or a device 
that wants to be treated as if it was a disk...) will be 
entered into the system. If the dos is already up and 
running, then it will be entered immediately. If the dos 
has not yet been run then the data will be recorded, and the 
dos will get it later. 


We hope to eventually try and boot off a disk device. We will 
try and boot off of each device in turn, based on priority, 
iff there is no boot floppy in the floppy disk drive. As of 
this writing that facility does not yet exist. 


There is only one additional piece of magic done by AddDosNode. 
If there is no executable code specified in the deviceNode 
structure (e.g. dn SegList, dn_Handler, and dn_Task are all 
null) then the standard dos file handler is used for your 
device. 


Documentation note: a "task" as used here is a dos-task, not 
an exec-task. A dos-task, in the strictest sense, is the 
address of an exec-style message port. In general, it is 

a pointer to a process's pr_MsgPort field (e.g. a constant 
number of bytes after an exec port). 


INPUTS 
bootPri -- a BYTE quantity with the boot priority for this disk. 
This priority is only for which disks should be looked at: 
the actual disk booted from will be the first disk with 
a valid boot block. If no disk is found then the “bootme" 
hand will come up and the bootstrap code will wait for 
a floppy to be inserted. Recommend priority assignments are: 


+5 -- unit zero for the floppy disk. The floppy should 
always be highest priority to allow the user to 
abort out of a hard disk boot. 
0 -- the run of the mill hard disk 
-5 -— a "network" disk (local disks should take priority). 
-128 —— don't even bother to boot from this device. 


flags ~- additional flag bits for the call: 

ADN_STARTPROC (bit 0) —- start a handler process immediately. 
Normally the process is started only when the device node 
is first referenced. This bit is meaningless if you 
have already specified a handler process (non-null dn_Task). 


deviceNode ~- a legal DOS device node, properly initialized. 
Typically this will be the result of a MakeDosNode() 
call, but feel free to manufacture your own if you need 
to. If deviceNode is null then AddDosNode does nothing. 


RESULTS 
ok ~— non-zero everything went ok, zero if we ran out of memory 
or some other weirdness happened. 


EXAMPLES 
/* enter a bootable disk into the system. Start a file handler 


*x process immediately. 
* 





AddDosNode( 0, ADNF_STARTPROC, MakeDosNode( paramPacket_) ); 








eg —-¥ 








BUGS 
The flexible boot strategy is only that -- strategy. 
needs to be reflected in code somewhere. 


SEE ALSO 
MakeDosNode 


BUGS 


It still 





expansion. library/MakeDosNode 


NAME 

MakeDosNode ~~ construct dos data structures that a disk needs 
SYNOPSIS 

deviceNode = MakeDosNode( parameterPkt ) 

Da AO 
FUNCTION 


This routine manufactures the data structures needed to enter 

a dos disk device into the system. This consists of a DeviceNode, 

a FileSysStartupMsg, a disk environment vector, and up to two 

bepl strings. See the libraries/dosextens and libraries/filehandler 
include files for more information. 


MakeDosNode will allocate all the memory it needs, and then 
link the various structure together. It will make sure all 
the structures are long-word aligned (as required by the bos). 
It then returns the information to the user so he can 

change anything else that needs changing. Typically he will 
then call AddDosNode() to enter the new device into the dos 
tables. 


INPUTS 
parameterPkt - a longword array containing all the information 
needed to initialize the data structures. Normally I 
would have provided a structure for this, but the variable 
length of the packet caused problems. The two strings are 
pull terminated strings, like all other exec strings. 


description 

a string with dos handler name 
L string with exec device name 
2 unit number (for OpenDevice) 
3 

4 

5 


longword 


flags (for OpenDevice) 
# of longwords in rest of enviroment 
—n file handler environment (see libraries/filehandler.h) 


RESULTS 
deviceNode ~— pointer to initialize device node structure, or 
null if there was not enough memory. 


EXAMPLES 
/* set up a 3.5" amiga format floppy drive for unit 1 */ 
char execName[] = "“trackdisk.device"; 
char dosName[] = "dfl"; 


ULONG parmPkt[] = { 
(ULONG) dosName, 
(ULONG) execName, 


l, /* unit number */ 

0, /* OpenDevice flags */ 

/* here. is the environment block */ 

il, /* table upper bound */ 

512>>2, /* # lonqwords in a block */ 

0, /* sector origin ~- unused */ 

2, /* number of surfaces */ 

i, /* secs per logical block -~ unused */ 
ii, /* secs per track */ 

2, /* reserved blocks ~~ 2. boot blocks */ 
0, /* 7? ~~ unused */ 

0, /* interleave */ 

0, /* ljower cylinder */ 

79, /* upper cylinder */ 

5, /* number of buffers */ 


a 


struct Device Node *node, *MakeDosNode(); 





expansion. library/MakeDosNode 





lh 


bo - ¥ 











node = MakeDosNode( parmPkt ); 
BUGS 


SEE ALSO 
AddDosNode 








expansion. library/AddConfigDev 


NAME 
AddCconfigDev - add a new ConfigDev structure to the system 


SYNOPSIS 
AddConfigDev( configDev ) 
AQ 


FUNCTION 
This routine adds the specified ConfiqDev structure to the 
list of Configuration Devices in the system. 


INPUTS 
configDev - a valid ConfigbDev structure. 


RESULTS 
EXCEPTIONS 


SEE ALSO 
RemConfigDev 


BUGS 








cso -¥ 





expansion, library/AllocBoardMem 


NAME 

AllocBoardMem —- allocate standard device expansion memory 
SYNOPSIS 

startSlot = AllocBoardMem( slotSpec ) 

DO DO 
FUNCTION 


This function allocates numslots of expansion space (each slot 
is E_SLOTSIZE bytes). It returns the slot number of the 
start of the expansion memory. The EC_MEMADDR macro may be 
used to convert this to a memory address. 


AllocBoardMem() knows about the intracacies of expansion 
board hardware and will allocate the proper expansion 
memory for each board type. 

INPUTS 


slotSpec - the memory size field of the Type byte of 
an expansion board 


Not typically called by user code. 


SEE ALSO . 
AllocExpansionMem, FreeExpansionMem, FreeBoardMem 


BUGS 








RESULTS 
startSlot - the slot number that was allocated, or -l for error. 
EXAMPLES 
struct ExpansionRom *er; 
slot = AllocBoardMem( er—->er_Type & ERT_MEMMASK ) 
EXCEPTIONS 





expansion. Library/AllocconfigDev 


NAME 
AllocConfigqDev - allocate a ConfigDev structure 
SYNOPSIS 
configDev = AllocConfigDev() 
DO 
FUNCTION 
This routine returns the address of a ConfigDev structure. 
It is provided so new fields can be added to the structure 
without breaking old, existing code. The structure is cleared 
when it is returned to the user. 
INPUTS 
RESULTS 
configDev - either a valid ConfigDev structure or NULL. 
EXCEPTIONS 
SEE ALSO 
FreeConfigdev 
BUGS 





I 





9G -~ © 








expansion. library/AllocExpansionMem 


NAME 
AllocExpansionMem - allocate expansion memory 


SYNOPSIS 
startSlot = AllocExpansionMem( numSlots, slotOffset ) 
DO DO DL 

FUNCTION 


This function allocates numslots of expansion space (each slot 
is E_SLOTSIZE bytes). It returns the slot number of the 

start of the expansion memory. The EC_MEMADDR macro may be 
used to convert this to a memory address. 


Boards that fit the expansion architecture have alignment 
rules. Normally a board must be on a binary boundary of its 
size. Four and Eight megabyte boards have special rules. 
User defined boards might have other special rules. 


The routine AllocBoardMem() knows about all the allocation 
rules for standard boards. Most users will want to use 
that routine if they want memory for a standard expansion 
device. 


If AllocExpansionMem() succeeds, the startSlot will satisfy 
the following equation: 


(startSlot - slotoOffset) MOD. slotAlign = 0 
INPUTS 
numSlots — the number of slots required. 


slotoffset - an offset from that boundary for startSlot. 


RESULTS 


startSlot - the slot number that was allocated, or ~1 for error. 


EXAMPLES 
AllocExpansionMem( 2, 0 ) 
Tries to allocate 2 slots on a two slot boundary. 
AllocExpansionMem( 64, 32 ) 


This is the allocation rule for 4 meg boards. It allocates 
4 megabytes (64 slots) on an odd 2 meg boundary. 


EXCEPTIONS 
Not typically called by user code. 


SEE ALSO 
FreeExpansionMem, AllocBoardMem, FreeBoardMem 


BUGS 





expansion. library/ConfigBoard 


NAME 
ConfigBoard ~ configure a board 


SYNOPSIS 
error = ConfigBoard( board, confiqDev ) 
DO AO Al 


FUNCTION 
This routine configures an expansion board. The board 
will generally live at E_EXPANSTIONBASE, but the base is 
passed as a parameter to allow future compatibility. 
The configbev parameter must be a valid configDev that 
has already had ReadExpansionRom() called on it. 


ConfigBoard will allocate expansion memory and place 
the board at its new address. It will update configlev 
accordingly. If there is not enough expansion memory 
for this board then an error will be returned. 


INPUTS 
board ~ the current address that the expansion board is 
responding. 
configbevy - an initialized ConfigDev structure. 


RESULTS 
error - non-zero if there was a problem configuring this board 


EXCEPTIONS 
Not normally called by user code 


SEE ALSO 
FreeConfigDev 


BUGS 





i 








ig - Ww 








expansion. library/ConfigChain 


NAME 

ConfigChain - configure the whole damn system 
SYNOPSIS 

error = ConfigChain( baseAddr ) 

DO 
FUNCTION 


This is the big one! This routine will take a base address 
(generally E_EXPANSIONBASE) and configure all the devices that 
live there. This routine will call all the other routines 
that might need to be called. All boards that are found will 
be linked into the configuration list. 


INPUTS 
baseAddr - the base address to start looking for boards. 


RESULTS 
error ~ non-zero if something went wrong. 


EXCEPTIONS 
Not normally called by user code 


SEE ALSO 
FreeConfigDev 


BUGS 





expansion. library/FindConfigDev 


NAME . 
FindConfigDev - find a matching ConfigDev entry 


SYNOPSIS 
configDev = FindConfigDev( oldConfigDev, manufacturer, product ) 
dO AO DO Dl 


FUNCTION 
This routine searches the list of existing ConfigDev 
structures in the system and looks for one that has 
the specified manufacturer and product codes. 


If the oldConfigDev is NULL the the search is from the 
start of the list of configuration devices. If it is 
not null then it searches from the first configuration 
device entry AFTER oldconfigDev. 


A code of -l is treated as a wildcard -- e.g. it matches 
any manufacturer (or product) 


INPUTS 
oldconfigDev - a valid ConfigDev structure, or NULL to start 
from the start of the list. 
manufacturer ~ the manufacturer code being searched for, or 
-i to ignore manufacturer numbers. 
product - the product code being searched for, or -1 to 
ignore product numbers. 


RESULTS 
configDev - the next ConfigDev entry that matches the 
manufacturer and product codes, or NULL if there 
are no more matches. 
EXCEPTIONS 
EXAMPLES 
/* to find all configdevs of the proper type */ 
struct Configbev *cd = NULL; 
while( cd = FindConfigDev( cd, MANUFACTURER, PRODUCT ) ) [{ 
/* do something with the returned ConfigDev */ 
} 
SEE ALSO 


BUGS 





IH 





eg - ¥ 











expansion. library/FreeBoardMem 


NAME 
FreeBoardMem - allocate standard device expansion memory 
SYNOPSIS 
FreeBoardMem( startSlot, slotSpec ) 
dO DL 
FUNCTION 


This function frees numslots of expansion space (each slot 
is E_SLOTSIZE bytes). It is the inverse function of 
AllocBoardMem( ) . 


INPUTS 
startSlot - a slot number in expansion space. 
slotSpec — the memory size field of the Type byte of 
an expansion board 


RESULTS 

EXAMPLES 
struct ExpansionRom *er; 
int startSlot; 


int slotSpec; 


slotSpec = er->er_ Type & ERT_MEMMASK; 
startSlot = AllocBoardMem( er->er_Type & ERT_MEMMAK ); 


if( startSlot != -l1) f{ 
FreeBoardMem( startSlot, slotSpec ); 
} 


EXCEPTIONS 
If the caller tries to free a slot that is already in the 
free list, FreeBoardMem will Alert() (e.g. crash the 
system). 


Not normally called by user code 


SEE ALSO 
AllocExpansionMem, FreeExpansionMem, AllocBoardMem 


BUGS 


——— 


exp 





ansion.library/FreeConfigDev 


NAME 
FreeConfigDev -— allocate a ConfigDev structure 


SYNOPSIS 
FreeConfigDev( configbev )} 
AO 


FUNCTION 
This routine frees a ConfigDev structure as returned by 
AllocconfigDbev. 


INPUTS 
configDev ~ a valid ConfigDev structure. 


RESULTS 
EXCEPTIONS 


SEE ALSO 
AlloccConfigbev 


BUGS 


i 








6S 








expansion. library/FreeExpansionMem 


NAME 
FreeExpansionMem — allocate standard device expansion memory 
SYNOPSIS 
FreeExpansionMem( startSlot, numSlots ) 
DO DL 
FUNCTION 
This function allocates numslots of expansion space (each slot 
is E_SLOTSIZE bytes). It is the inverse function of 
AllocExpansionMem(). 
INPUTS 
startSlot - the slot number that was allocated, or ~1 for error. 
numSlots ~ the number of slots to be freed. 
RESULTS 
EXAMPLES 
EXCEPTIONS 


If the caller tries to free a slot that is already in the 
free list, FPreeExpansionMem will Alert() (e.g. crash the 
system) . 

Not nomnally called by user code 


SEE ALSO 
AllocExpansionMem, AllocBoardMem, FreeBoardMem 


BUGS 


expansion. library/GetCurrentBinding 


NAME 
GetCurrentBinding ~ sets static board configuration area 


SYNOPSIS 
actual = GetCurrentBinding( currentBinding, size ) 
AQ DO:16 


FUNCTION 
This function writes the contents of the "currentBinding" 
structure out of a private place. It may be set via 
SetCurrentBinding(). This is really a kludge, but it is 
the only way to pass extra arguments to a newly configured 
device. 


A CurrentBinding structure has the name of the currently 
loaded file, the product string that was associated with 
this driver, and a pointer to the head of a singly linked 
list of ConfigDev structures (linked through the cd_NextcD 
field). 


Many devices may not need this information; they have hard 
coded into themselves their manufacture number. It is 
recommended that you at least check that you can deal with 
the product code in the linked ConfigDev structures. 


INPUTS 
currentBinding - a pointer to a CurrentBinding structure 


size - the size of the user's binddriver structure. No 
more than this much data will be copied. If size is 


larger than the libraries idea a CurrentBinding size, 
then the structure will be null padded. 


RESULTS 

actual - the true size of a CurrentBinding structure is returned. 
EXAMPLES 
EXCEPTIONS 


SEE ALSO 
GetCurrentBinding 


BUGS 








il 





Hl 








expansion. library/ObtainConfigBinding 


NAME 
ObtainConfigBinding — try to get permission to bind drivers 
SYNOPSIS 
ObtainConfigBinding() 
FUNCTION . 
ObtainConfigBinding gives permission to bind drivers to 
ConfigDev structures. It exists so two drivers at once 
do not try and own the same ConfigDev structure. This 
call will block until it is safe proceed. 
Individual drivers to not need to call this routine. It 
is intended for BindDriver program, and others like it. 
If your drivers won't be loaded via the standard method, 
you may need to lock out others. 
It is crucially important that people lock out others 
before loading new drivers. Much of the data that is used 
to configure things is statically kept, and others need 
to be kept from using it. 
This call is build directly on Exec SiqnalSemaphore code 
(e.g. ObtainSemaphore) . 
INPUTS 
RESULTS 
EXCEPTIONS 
SEE ALSO 
» ReleaseConfigBinding 
\ 
a BUGS 
° 











expansion. library/ReadExpansionByte 


NAME 

ReadExpansionByte — read a byte nybble by nybble. 
SYNOPSIS 

byte = ReadExpansionByte( board, offset ) 

DO Ad bo 
FUNCTION 


ReadExpansionByte reads a byte from a new-style expansion 
board. These boards have their readable data organized 
as a series of nybbles in memory. This routine reads 

two nybbles and returns the byte value. 


In general, this routine will only be called by ReadExpansionRom. 


The offset is a byte offset into a ExpansionRom structure. 
The actual memory address read will be four times larger. 
The macros EROFFSET and ECOFFSET are provided to help get 
these offsets from C. 


INPUTS 
board ~ a pointer to the base of a new style expansion board. 
offset — a logical offset from the board base 


RESULTS 
byte — a byte of data from the expansion board, or -1 if there 
was an error reading from the board. 


EXAMPLES 

byte = ReadExpansionByte( cd->BoardAddr, EROFFSET( er_Type ) ); 

ints = ReadExpansionByte( cd->BoardAddr, ECOFFSET( ec_Interrupt ) ); 
EXCEPTIONS 


Not typically called by user code. 


SEE ALSO 
WriteExpansionByte, ReadExpansionRom 


BUGS 








T9 -¥ 





expansion. Llibrary/ReadExpansionRom 
NAME 
ReadExpansionRom — read a boards configuration rom space 
SYNOPSIS 
error = ReadExpansionRom( board, configDev ) 
DO AO Al 
FUNCTION 
ReadExpansionRom reads a the rom portion of an expansion 
device in to cd_Rom portion of a ConfigDev structure. 
This routine knows how to detect whether or not there is 
actually a board there, 
In addition, the Rom portion of a new style expansion hoard 
is encoded in ones-complement format (except for the first 
two nybbles -~ the er_Type field). ReadExpansionRom knows 
about this and un-complements the appropriate fields. 
INPUTS 
board ~ a pointer to the base of a new style expansion board. 
configbev — the ConfigDev structure that will be read in. 
offset - a logical offset from the configdev base 
RESULTS 
error - If the board address does not contain a valid new style 
expansion board, then error will be non-zero. 
EXAMPLES 
configDev = AllocConfigbev(); 
if( ! configDev ). panic(); 
error = ReadExpansionBoard( board, configDev ); 
if( ! error ) [{ 
configqDev->cd_BoardAddr = board; 
ConfigBoard( configDev ); 
j 
EXCEPTIONS 
Not typically called by user code. 
SEE ALSO 
ReadExpansionByte, WriteExpansionByte 
BUGS 











expansion. library/ReleaseConfigBinding 


NAME 
ReleaseConfigBinding - allow others to bind to drivers 


SYNOPSIS 
ReleaseConfigBinding() 


FUNCTION : . . 
This call should be used when you are done binding drivers. 
to Configbev entries. It releases the SignalSemaphore; this 
allows others to bind their drivers to ConfigDev structures. 

INPUTS 

RESULTS 

EXAMPLES 

EXCEPTIONS 


SEE ALSO 
ObtainConfigBinding 


BUGS 





"I 





c9 - © 














expansion. library/RemConfigDev 


NAME 
RemConfigDev ~- remove a ConfigDev structure from the system 


SYNOPSIS 
RemConfigDev( configDev )} 
AQ 


FUNCTION 
This routine removes the specified ConfigDev structure from the 
list of Configuration Devices in the system. 


INPUTS 
configDev ~- a valid ConfigDev structure. 


RESULTS 
EXCEPTIONS 


SEE ALSO 
AddcConfigDev 


BUGS 





expansion. library/SetCurrentBinding 


NAME 
SetCurrentBinding ~— sets static board configuration area 


SYNOPSIS 
SetCurrentBinding( currentBinding, size ) 
AO DO:16 


FUNCTION 
This function records the contents of the "currentBinding" 
structure in a private place. It may be read via 
GetCurrentBinding(). This is really a kludge, but it is 
the only way to pass extra arguments to a newly configured 
device. 


A CurrentBinding structure has the name of the currently 
loaded file, the product string that was associated with 
this driver, and a pointer to the head of a singly linked 
list of ConfigDev structures (linked through the cd_NextCD 
field). 

Many devices may not need this information; they have hard 
coded into themselves their manufacture number. It is 
recommended that you at least check that you can deal with 
the product. code in the linked Configbev structures. 


INPUTS 
currentBinding - a pointer to a CurrentBinding structure 


size ~ the size of the user's binddriver structure. No 
more than this much data will be copied. If size is 
larger than the libraries idea a CurrentBinding size, 
then the structure will be null padded. 
RESULTS 
EXAMPLES 
EXCEPTIONS 


SEE ALSO 
GetCurrentBinding 


BUGS 


il 











a OY . : Y 
expansion. Library/WriteExpansionByte 


NAME 

WriteExpansionByte — write a byte nybble by nybble. 
SYNOPSIS 

error = WriteExpansionByte( board, offset, byte ) 

DO AO DO DL 
FUNCTION 


WriteExpansionByte. write a byte to a new-style expansion 
board. These boards have their writeable data organized 
as a series of nybbles in memory. This routine writes 
two nybbles in a very carefull manner to work with all 
types of néw expansion boards. 


To make certain types of board less expensive, an expansion 
board's write registers may be organized as either a 
byte-wide or nybble-wide register. If it is nybble-wide 
then it must latch the less significant nybble until the 
more significant nybble is written. This allows the 
following algorithm to work with either type of board: 


write the low order nybble to bits D15-D12 of 
byte (offset*4)+2 


write the entire byte to bits D15-D8 of 
byte (offset*4) 


The offset is a byte offset into a ExpansionRom structure. 
The actual memory address read will be four times larger. 
The macros EROFFSET and ECOFFSET are provided to help get 
these offsets from C. 


INPUTS 
board — a pointer to the base of a new style expansion board. 
offset - a logical offset from the configdev base 
byte — the byte of data to be written to the expansion board. 


€9.- v 


RESULTS 
error ~ the routine will return a zero on success, non-zero if 
there was a problem. 


Not typically called by user code. 


SEE ALSO 
ReadExpansionByte, ReadExpansionRom 


BUGS 








EXAMPLES 
err = WriteExpansionByte( cd->BoardAddr, ECOFFSET( ec_Shutup ), 0 
err = WriteExpansionByte( cd->BoardAddr, ECOFFSET( ec_Interrupt ), 
EXCEPTIONS 


) 
L 


i 


i 





|| 


v9 -~ © 








TABLE OF 


graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics.] 
graphics. ] 
graphics. ] 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics.] 
graphics .] 
graphics.] 
graphics. 1] 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics .] 
gxaphics.] 
graphics. 
graphics. 
graphics, 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 


CONTENTS 


library/AddAnimOb 
library/AddBob 
library/AddFont 
library/AddVSprite 
library/AllocRaster 
library/AndRectRegion 
library/AndRegionRegion 
ibrary/Animate 
ibrary/AreaCircle 
ibrary/AreaDraw 
library/AreaEllipse 
library/AreaEnd 
library/AreaMove 
library/AskFont 
library/AskSoftStyle 
library/AttemptLockLayerRom 
library/BltBitMap 
library/BItBitMapRastPort 
library/BltClear 
library/BltMaskBitMapRastPort 
library/BltPattern 
library/BitTemplate 
library/CBump 
library/CEND 
library/ChangeSprite 
ibrary/CINIT 
ibrary/ClearEOL 
ibrary/ClearRectRegion 
ibrary/ClearRegion 
library/ClearScreen 
library/ClipBlit 
library/CloseFont 
Library/CMOVE 
library/CopySBitMap 
ibrary/CWAIT 
ibrary/DisownBlitter 
library/DisposeRegion 
library/DoCollision 
library/Draw 
library/DrawEllipse 
ibrary/DrawGList 
library/Flood 
library/FreeColorMap 
library/FreeCopList 
library/FreeCprList 
library/FreeGBuf fers 
library/FreeRaster 
library/FreeSprite 
library/FreeVPortCopLists 
library/GetColorMap 
library/GetGBuf fers 
library/GetRGB4 
library/GetSprite 
library/InitArea 
library/InitBitMap 
library/InitGels 
library/InitGMasks 
library/InitMasks 
library/InitRastPort 
library/InitTmpRas 
library/InitView 
library/InitvPort 
library/LoadRGB4 
library/LoadView 
library/LockLayerRom 
library/MakeVvPort 
library/Move 
library/MoveSprite 
library/MrgCop 
library/NewRegion 











|graphics. 
graphics. 
graphics. 
graphics. 
. library/PolyDraw 


graphics 


graphics 








graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
graphics. 
. library/WaitBOVP 
graphics. 
graphics. 
graphics. 
graphics. 


library/OpenFont 
library/OrRectRegion 
library/OrRegionRegion 
library/OwnBlitter 


library/QBlit 
library/OQBSBlit 
library/ReadPixel 
library/RectFill 
library/RemBob 
library/RemFont 
library/RemI Bob 
library/RemVSprite 
library/ScrollRaster 
library/ScrollvPort 
library/SetAPen 
library/SetBPen 
library/SetCollision 
library/SetDrmd 
library/SetFont 
library/SetoPen 
library/SetRast 
library/SetRGB4 
library/SetRGB4CM 
library/SetSoftStyle 
library/SortGhist 
library/SyncSBitMap 
library/Text 
library/TextLength 
library/UnlockLayerRom 
library/VBeamPos 
library/WaitBlit 


library/WaitTOF 
library/WritePixel 
library/XorRectRegion 
library/XorRegionRegion 


! 








s9 -W¥ 








graphics. library/AddAanimob 


NAME 

AddAnimOb -- Add an AnimOb to the linked list of AnimObs. 
SYNOPSIS 

AddAnimOb(anOb, anKey, rp) 


ad al a2 


struct AnimOb *anOb, **ankey; 
struct RastPort *rp; 


FUNCTION 
Links this AnimOb into the current list pointed to by animkey. 
Initializes all the Timers of the AnimOb's components. 
Calls AddBob with each component's Bob. 
rp->GelsInfo must point to an initialized GelsiInfo structure. 


INPUTS 
anOb = pointer to the AnimOb structure to be added to the list 
ankey = address of a pointer to the first Animob in the list 
(anKey = NULL if there are no AnimObs in the list so far) 
rp = pointer to a valid RastPort 


BUGS 


SEE ALSO 
Animate graphics/rastport.h graphics/gels.h 


graphics. library/AddAnimOb graphics. library/AddBob 





graphics. library/AddBob 


NAME 

AddBob -- Adds a Bob to current gel list. 
SYNOPSIS 

AddBob(Bob, rp) 


ad al 


struct Bob *Bob; 
struct RastPort *xp; 


FUNCTION 
Sets up the system Bob flags, then links this gel into the list 
via AddvSprite. 


INPUTS 
Bob = pointer to the Bob structure to be added to the gel list 
rp = pointer to a RastPort structure 

BUGS 


SEE ALSO 
InitGels AddVSprite graphics/gels.h graphics/rastport.h 





I 





99 - © 





graphics. library/AddFont graphics. library/AddFont 


NAME 
AddFont. ~- add a font to the system list 


SYNOPSIS 
AddFont(textFont) 
al 


struct TextFont *textFont; 


PUNCTION 
This function adds the text font to the system, making it 
available for use by any application. The font added must be 
in public memory, and remain until successfully removed. 


INPUTS 
textFont - a TextFont structure in public ram. 


BUGS 


SEE ALSO 
SetFont RemFont graphics/text.h 





graphics. library/AddvSprite 








NAME 
AddVSprite —— Add a VSprite to the current gel list. 


SYNOPSTS 
AddVSprite(vs, rp) 
aQ al 


struct VSprite *vs; 
struct RastPort *rp; 


FUNCTION 
Sets up the system VSprite flags 
Links this VSprite into the current gel list using its Y,X 


INPUTS 

vs = pointer to the VSprite structure to be added to the gel list 
rp = pointer to a RastPort structure 

BUGS 


SEE ALSO 
InitGels graphics/rastport.h graphics/gels.h 








graphics. library/AddVSprite 





19 -W 





graphics. library/AllocRaster 








graphics. library/AllocRaster 


NAME 
AllocRaster -~ Allocate space for a bitplane. 


SYNOPSIS 
planeptr = AllocRaster( width, height ) 
do g0:16 dl:16 


PLANEPTR planeptr; 
USHORT width,height,; 


FUNCTION 
This function calls the memory allocation routines 
to allocate memory space for a bitplane width bits 
wide and height bits high. 


INPUTS 
width - number of bits wide for bitplane 
height ~ number of rows in bitplane 


RESULT 
planeptr - pointer to first word in bitplane 
If unable to allocate space then planeptr will be NULL. 


BUGS 


SEE ALSO 
FreeRaster graphics/gfix.h 


Igraphics. library/AndRectRegion 





graphics. library/AndRectRegion 


NAME 
AndRectRegion -~— Perform 2d AND operation of rectangle 
with region, leaving result in region. 
SYNOPSIS 
AndRectRegion({ region, rectangle) 


ad al 


struct Region *region; 
struct Rectangle *rectangle; 


FUNCTION ; ; 
Clip away any portion of the region that exists outside 
of the rectangle. Leave the result in region. 


INPUTS 
region — pointer to Region structure 
rectangle ~- pointer to Rectangle structure 
BUGS 


SEB ALSO . . 
AndRegionRegion OrRectRegion graphics/regions.h 





|| 





89 - WV 





graphics. library/AndRegionRegion 





graphics. library/AndRegionRegion 


NAME 

AndRegionRegion —~- Perform 2d AND operation of one region 

with second region, leaving result in second region. 

SYNOPSIS 

status = AndRegionRegion( region], region2) 

dao ad al 

BOOL status; 

struct Region *regionl, *region2; 
FUNCTION 


Remove any portion of region2 that is not in regionl. 


INPUTS 
regionl - pointer to Region structure 
region2 ~ pointer to Region structure to use and for result 


RESULTS 
status — return TRUE if successful operation 
return FALSE if ran out of memory 


BUGS 


SEE. ALSO 
OrRegionRegion AndRectRegion graphics/regions.h 








graphics. library/Animate 


NAME 

Animate -—- Processes every AnimOb in the current animation list. 
SYNOPSIS 

Animate(ankey, rp) 


ad al 


struct AnimOb **ankey; 
struct RastPort *rp; 


FUNCTION 
For every AnimOb in the list 

- update its location and velocities 

— call the AnimOb's special routine if one is supplied 

- for each component of the AnimOb 
~ if this sequence times out, switch to the new one 
- call this component's special routine if one is supplied 
~ set the sequence's VSprite's y,x coordinates based 

on whatever these routines cause 


INPUTS 
key = address of the variable that points to the head AnimOb 
rp = pointer to the RastPort structure 

BUGS 

SEE ALSO 


AddAnimOb graphics/gels.h graphics/rastport.h 





graphics. library/Animate 





69 - ¥ 








graphics. library/AreaCircle graphics. library/AreaCircle 
NAME 
AreaCircle —- add a circle to areainfo list for areafill. 
SYNOPSIS 
error = (int) AreaCircle( rp, cx, cy, radius) 
DO Al bo Dl b2 


LONG error; 

struct RastPort *rp; 
SHORT cx, Cy; 

SHORT radius; 


FUNCTION 
Add circle to the vector buffer. 


INPUTS 
rp ~ pointer to a RastPort structure 


(ex, cy) ~ are coordinates of a "centerpoint" in the raster 
radius is the radius of the circle to draw around the centerpoint 


This function is a macro which calls 
AreaEllipse(rp,cx,cy,radius,radius). 


RESULTS 
0 if no error 
-l if no space left in vector list 


SEE ALSO 
AreaMove, AreaDraw, AreaCircle, InitArea, AreaEnd, graphics/rastport.h 
graphics/gfxmacros.h 





gxvaphics.library/AreaDraw graphics. library/AreaDraw 


NAME 


AreaDraw -- Add a point to a list of end points for areafill. 
SYNOPSIS 
error = AreaDraw( rp, X, y) 
do Al DO:16 D1:16 
LONG error; 
struct RastPort *rp; 
SHORT XVI 
FUNCTION 


Add point to the vector buffer. 


INPUTS 

rp ~ points to a RastPort structure 

x,y - are coordinates of a point in the raster 
RETURNS 


0 if no error 
-l if no space left in vector list 


BUGS 


SEE ALSO . 
AreaMove InitArea AreaEnd graphics/rastport.h 





(| 





WY 


OL 








graphics. library/AreaEllipse graphics. library/AreaEllipse 
NAME 
AreaEllipse -- add a ellipse to areainfo list for areafill. 
SYNOPSIS 
error = AreaEllipse( rp, cx, cy, a, b ) 
do al d0:16 @i:16 d2:16 d3:16 
LONG error; 


struct RastPort *rp; 
SHORT cx, cy; 
SHORT a, b; 


FUNCTION 
Add ellipse to the vector buffer. 


INPUTS 
rp ~ pointer to a RastPort structure 
cx — x coordinate of the centerpoint relative to the rastport. 
cy — y coordinate of the centerpoint relative to the rastport. 
a ~ the horizontal radius of the ellipse (note: a must be > 0) 
b - the vertical radius of the ellipse (note: b must be > 0) 


RESULTS 
0 if no error 
-1 if no space left in vector list 


SEE ALSO 
AreaMove, AreaDraw, AreaCircle, InitArea, AreaEnd, graphics/rastport.h 











graphics. library/AreaEnd graphics. library/AreaEnd 


NAME 


SYNOPSIS 


do 


Areaknd -- Process table of vectors and produce areafill. 


error = AreaEnd(rp) 
AL 


LONG error; 
struct RastPort *rp; 


FUNCTION 


RESULT 


INPUTS 


BUGS 


SEE ALSO 


Trigger the filling operation. 

Process the vector buffer and generate required 
fill into the raster planes. After the fill is 
complete reinitialize for the next AreaMove. Use 
the raster set up by InitTmpRas when generating an 
areafill mask. 


Fill the area enclosed by the definitions in the vector table. 
Returns -1 if an error occured anywhere. 
Returns 0 if no error. 


rp points to a RastPort structure 


InitArea AreaMove AreaDraw AreaEllipse graphics/rastport.h 








TL -~ W 





graphics. library/AreaMove 





graphics. library/AreaMove 


NAME 
AreaMove —- Define a new starting point for a new 
shape in the vector list. 
SYNOPSIS 
error = AreaMove( rp, X, y) 
do al 0:16 di:16 
LONG error; 
struct RastPort *rp; 
SHORT X/Yi 
FUNCTION 
Close the last polygon and start another polygon 
at (x,y). Enter necessary points in vector 


buffer. Cosing a polygon may result in the generation 

of another AreaDraw{) to close previous polygon. 

Remember to have an initialized AreaInfo structure attached 
to the RastPort. 


INPUTS 
rp ~ points to a RastPort structure 
X,Y ~ positions in the raster 


RETURNS 
0 if no error 
-l if no space left in vector list 


BUGS 


SEE ALSO 
InitArea AreaDraw AreaFkllipse AreaEnd graphics/rastport.h 


graphics. library/AskFont 





graphics. library/AskFont 


NAME 

AskFont -- get the text attributes of the current font 
SYNOPSIS 

AskFont(rp, textAttr) 


al ad 


struct RastPort *rp; 
struct TextAttr *textAttr; 


FUNCTION . 
This function fills the text attributes structure with the 
attributes of the current font in the RastPort. 


INPUTS . 
rp — the RastPort from which the text attributes are extracted 
textAttr - the TextAttr structure to be filled 

BUGS 


SEE ALSO 
graphics/text.h 





|| 





cL - W 











graphics. library/AskSoftStyle graphics. library/AskSoftStyle 


NAME 
AskSoftStyle —- Get the soft style bits of the current font. 
SYNOPSIS 
enable = AskSoftStyle(rp) 
ao al 
ULONG enable; 
struct RastPort *rp; 
FUNCTION 
This function returns those style bits of the current font 
that are not intrinsic in the font itself, but 
algorithmically generated. These are the bits that are 
valid to set in the enable mask for SetSoftStyle 
INPUTS 
rp — the RastPort from which the font and style are extracted. 
RESULTS 
enable - those bits in the style algorithmically generated 
Style bits that are not defined are also set. 
BUGS 
SEE ALSO 


SetsoftStyle graphics/text .h 











graphics. library/AttemptLockLayerRom 
* 


NAME 

AttemptLockLayerRom —- Attempt to Lock Layer structure 
by rom(gfx lib) code 

SYNOPSIS 
gotit = AttemptLockLayerRom( layer ) 
do a5 
BOOLEAN gotit; 
struct Layer *layer; 

FUNCTION 
Query the current state of the lock on this Layer. If it is 
already locked then return FALSE, could not lock. If the 
Layer was not locked then lock it and return TRUE. 
This call does not destroy any registers. 
This call nests so that callers in this chain will not lock 
themselves out. 

INPUTS 
layer - pointer to Layer structure 

RESULT 
returns TRUE or FALSE depending on whether the Layer is now 
locked by the caller. 

SEE ALSO 


LockLayerRom UnlockLayerRom 


i 











DstX,; DstY, Sizex, SizeY, Minterm, Mask [, TempA]) 
D2:16 D316 D4:16 D5:16 D6:8 D7:8 [A2] 


ULONG planecnt; 

struct BitMap *SrcBitMap,*DstBitMap; 
SHORT Srex,SrcY; 

SHORT DstX,DstY; 

SHORT SizeX,SizeY; 

UBYTE MinTerm,Mask; 

CPTR TempA; /*optional */ 


FUNCTION 
Perform non-destructive blits to move a rectangle from one 
area in a BitMap to another area, which can be on a different 
BitMap 
This blit is assumed to be friendly: no error conditions (e.g. 
a rectangle outside the BitMap bounds) are tested or reported. 


INPUTS 
SrcBitMap, DstBitMap — the BitMap(s) containing the 
rectangles 

~ the planes copied from the source to the destination are 
only those whose plane numbers are identical and less 
than the minimum Depth of either BitMap and whose Mask 
bit for that plane is non-zero. 

— SrcBitMap and DstBitMap can be identical 

SrcexX, SreY — the x and y coordinates of the upper left corner 
of the source rectangle. Valid range is positive 
signed integer such that the raster word's offset 

. (32767-Size) 
pstx. “Dst Y — the x and y coordinates of the upper left 
corer of the destination for the rectangle. Valid 
range is as for Src. 

sizeX, Sizey - the size of the rectangle to be moved. Valid 
range is (X: 1..976; Y: 1..1023 such that final raster 
word's. offset is 0..32767) 

Minterm - the logic function to apply to the rectangle when 
A is non-zero (i.e. within the rectangle). B is the 
source rectangle and C, Dis the destination for the 
rectangle. 

- $0C0O is a vanilla copy 

~ $030 inverts the source before the copy 

- $050 ignores the source and inverts the destination 

- see the hardware reference manual for other combinations 

Mask ~ the write mask to apply to this operation. Bits set 
indicate the corresponding planes (if not greater than 
the minimum plane count) are to participate in the 
operation. Typically this is set to Oxff. 

TempA — If the copy overlaps exactly to the left or right 
(i.e. the scan line addresses overlap), and TempA is 
non-zero, it points to enough chip accessable memory 
(MAXBYTESPERROW) to hold a line of A source for the blit. 
BitBitMap will allocate the needed TempA if none is 
provided and one is needed. If the blit does not overlap; 
SrcBitMap != DstBitMap then TempA need not be supplied. 


eL- 





RESULTS 
planecnt ~ the number of planes actually involved in the blit. 


BUGS 
This routine uses over 300 bytes of stack when it really does 
not need to. It calculates all blits ahead of time and then 

sits in a loop doing the blits when it should overlap blits 
with calculations. 





graphics. library/BltBitMap graphics. library/B1ltBitMap SEE ALSO 
ClipBlit graphics/gfx.h hardware/blit.h 
NAME 
B1tBitMap —- Move a rectangular region of bits in a BitMap. 
SYNOPSIS 
planecnt = B1tBitMap(SrcBitMap, SrcX, SrcY, DstBitMap, 
DO AO DO:16 D1:16 Al 








i) 


il 








graphics. library/B1tBitMapRastPort graphics. library/B1tBitMapRastPort graphics. library/BltClear graphics. library/BltClear 
NAME. NAME 
B1tBitMapRastPort -— Blit from source bitmap to destination rastport. 
BltClear - Clear a block of memory words to zero. 
SYNOPSTS 
BLtBitMapRastPort. SYNOPSIS 
(srcbm,srex, srcy ,destrp,destx,desty,sizex,sizeY,minterm) BltClear( memBlock, bytecount, flags ) 
ad dO dl al d2 d3 d4 d5 a6 al do al 


struct BitMap *srebm; 
SHORT srex,srcy; 

struct RastPort *destrp; 
SHORT destX,destyY; 
SHORT sizeX,sizeY; 
UBYTE minterm; 


FUNCTION oo, 
Blits from source bitmap to position specified in destination rastport 


using minterm. 


INPUTS 
srcbm ~ a pointer to the source bitmap 
srex ~ x offset into source bitmap 
srey — y offset into source bitmap 


destrp - a pointer to the destination rastport 
destX - x offset into dest rastport 

destY - y offset into dest rastport 

sizeX — width of blit in pixels 

sizeY ~ height of blit in rows 

minterm ~ minterm to use for this blit 


RETURNS 
TRUE 


BUGS 


SEE ALSO 
BltMaskBitMapRastPort graphics/gfx.h graphics/rastport.h 





APTR memBlock; 
ULONG bytecount,; 
ULONG flags; 


FUNCTION 
For memory that is local and blitter accessable 
the most efficient way to clear a range of memory locations is 
to use the system's most efficient data mover, the blitter. 
This command accepts the starting location and count and clears 
that block to zeros. 


INPUTS 
memBloc — pointer to local memory to be cleared 
memBlock is assumed to be even. 
flags set bit 0 to force function to wait until blit 


is done. 
set bitl to use row/bytesperrow 
bytecount if (flags & 2) == 0 then 
even number of bytes to clear. 
else 


low 16 bits is taken as number of bytes 
per row and upper 16 bits taken as 
number of rows. 


This function is somewhat hardware dependant. In the 
rows/bytesperrow mode, rows must be <=1024. 
In bytecount mode multiple runs of the blitter 
may be used to clear all the memory. 
may be used to clear all the memory. 
RESULT 
The block of memory is set to zeros. 


BUGS 


SEE ALSO 











GL~W 














graphics. library/BltMaskBitMapRastPort 


NAME, 
BltMaskBitMapRastPort —- blit from source bitmap to destination rastport 
with masking of source image. 
SYNOPSIS 
BltMaskBitMapRastPort 
(srebm,srex,srcy,destrp,destXx,destY,sizex,sizeY ,minterm,bltmask) 
ad dO dl al d2 a3 d4 d5 a6 a2 
struct BitMap *srcbm; 
SHORT srex,srcy; 
struct RastPort *destrp; 
SHORT destX,destyY; 
SHORT sizeX,sizeyY; 
UBYTE minterm; 
APTR bltmask; * chip memory * 
FUNCTION 
Blits from source bitmap to position specified in destination rastport 
using bltmask to determine where source overlays destination, and 
minterm to determine whether to copy the source image "as is" or 
to "invert" the sense of the source image when copying. In either 
case, blit only occurs where the mask is non-zero. 
INPUTS 
srcbm ~ a pointer to the source bitmap 
srex ~ x offset into source bitmap 
srey -— y offset into source bitmap 
destrp —- a pointer to the destination rastport 
destX — x offset into dest rastport 
destY - y offset into dest rastport 
sizexX - width of blit in pixels 
sizeY - height of blit in rows 
minterm — either (ABC|ABNC|ANBC) if copy source and blit thru mask 
or (ANEC ) if invert source and blit thru mask 
bltmask —' pointer to the single bit-plane mask, which must be the 
same size and dimensions as the planes of the 
source bitmap. 
RETURNS 
BUGS 
SEE ALSO 
BltBitMapRastPort graphics/gfx.h graphics/rastport .h 


graphics. library/BltPattern 





graphics. library/BltPattern 


NAME 
BltPattern ~- Using standard drawing rules for areafill, 
blit through a mask. 
SYNOPSIS 
BltPattern(rp, mask, xl, yl, maxx, maxy, bytecnt) 


al, a0 do dl = d2 d3 a4 
struct RastPort *rp; 

APTR mask; 

SHORT x1,yl,maxx ,maxy; 

SHORT bytecnt; 


FUNCTION 
Blit using drawmode,areafill pattern, and mask 
at position rectangle (xl,yl) (maxx,maxy). 


INPUTS 
rp - points to RastPort 
mask — points to 2 dimensional mask if needed 
if mask == NULL then use a rectangle. 
xl,yl - upper left of rectangular region in RastPort 
maxx,maxy — points to lower right of rectangular region in RastPort 
byteent — BytesPerRow for mask 


RETURNS 


SEE ALSO 
AreaEnd 


|| 





v 


OL 





graphics. library/BltTemplate graphics. library/BltTemplate 


NAME 
BltTemplate ~~ Cookie cut a shape in a rectangle to the RastPort. 
SYNOPSIS 
BltTemplate(SreTemplate, SreX, SreMod, rp, 
ad d0:16 dl:16 al 
DstX, DstY, Sizex, SizeY) 
d2:16 3:16 d4:16 d5:16 

CPTR SreTemplate; 

SHORT Srex; 

SHORT SreMod ; 

struct RastPort *rp; 

SHORT DstX ,DSty; 

SHORT Sizex,Sizey; 

FUNCTION 

This function draws the image in the template into the 

RastPort in the current color and drawing mode at the 

specified position. The template is assumed not to overlap 

the destination. 

Tf the template falls outside the RastPort boundary, it is 

truncated to that boundary. 

Note: the SrcTemplate pointer should point to the "nearest" word 
(rounded down) of the template mask. Fine alignment of the mask 
is acheived by setting the Srex bit offseet within the range 
of 0 to 15 decimal. 

INPUTS 

SrcTemplate — pointer to the first (nearest) word of the template mask. 

Srex ~ x bit offset into the template mask (range 0..15). 

SrceMod — number of bytes per row in template mask. 

rp ~ pointer to destination RastPort. 

DstX, DstY - x and y coordinates of the upper left 

corner of the destination for the blit. 
Sizex, Sizey - size of the rectangle to be used as the 
template. 
BUGS 
The destination rastport (rp) must have an associated 
Layer structure or srcX will be ignored. 
SEE ALSO 


BltPattern graphics/rastport .h 








graphics. library/CBump 








i 


graphics. library/CBump 
NAME 


CBump — increment user copper list. pointer (bump to next position in list). 
SYNOPSIS 

CBump( c ) 

al 

struct UCopList *c; 
FUNCTION : 

Increment pointer to space for next instruction in user copper list. 
INPUTS 

c - pointer to UCopList structure 
RESULTS 

User copper list pointer is incremented to next position. 

Pointer is repositioned to next user copperlist instruction block 

if the current block is full. 

Note: CBump is usually invoked for the programmer as part of the 
macro definitions CWAIT or CMOVE. 

BUGS 
SEE ALSO 


CINIT CWAIT CMOVE CEND graphics/copper.h 











YW 


LL 














graphics. library/CEND graphics. library/CEND 
NAME 
CEND —— Terminate user copper list. 
SYNOPSIS 
CEND( c ) 


struct UCophist *c; 


FUNCTION 
Add instruction to terminate user copper list. 


INPUTS 
c — pointer to UCopList structure 


RESULTS 
This is actually a macro that calls the macro CWAIT(c,10000,255). 
10000 is a magical number that the graphics library uses. 
I hope display technology doesn't catch up too fast! 


BUGS 


SEE ALSO 
CINIT CWAIT CMOVE graphics/copper.h 





graphics. library/ChangeSprite graphics. library/ChangeSprite 


NAME 

ChangeSprite —- Change the sprite image pointer. 
SYNOPSIS 

ChangeSprite( vp, s, newdata) 


aO al a2 


struct ViewPort *vp; 
struct SimpleSprite *s; 
APTR newdata; /* chip memory */ 


FUNCTION 
The sprite image is changed to use the data starting at newdata 


INPUTS 
vp — pointer to ViewPort structure that this sprite is 
relative to. 
or 0 if relative only top of View 
s ~ pointer to SimpleSprite structure 
newdata — pointer to data structure of the following form. 
struct spriteimage 


UWORD posctl[2]; /* used by simple sprite machine*/ 


UWORD data[height] [2]; /* actual sprite image */ 
UWORD reserved [2]; /* initialized to */ 
f* Ox0,0x0 */ 
te 
Programmer must initialize reserved[2].  Spriteimage must he 


in CHIP memory. The height subfield of the SimpleSprite structure 
must be set to reflect the height of the new spriteimage BEFORE 
calling ChangeSprite. The programmer may allocate two sprites to 
handle a single attached sprite. After GetSprite, ChangeSprite, 
the programmer can set the SPRITE_ATTACHED bit in posctl[1] of the 
odd numbered sprite. 


If you need more than 8 sprites look up VSprites in the 
graphics documentation. 

RESULTS 

BUGS 


SEE ALSO 
FreeSprite ChangeSprite MoveSprite AddVSprite graphics/sprite.h 














TT 


Ji 





BL - WV 





graphics. library/CINIT graphics. library/CINIT ‘\graphics. library/ClearEOL graphics. library/ClearEoL 
NAME NAME ; 
CINIT -- Initialize user copperlist to accept intermediate ClearKOL - Clear from current position to end of line. 
user copper instructions. 
SYNOPSIS 
SYNOPSIS ClearEOL( rp ) 
ucl = CINIT( c,n ) al 
UCopperListInit( c ,n) struct RastPort *rp; 
aQ do 
FUNCTION 
struct UCopList *ucl; Clear a rectangular swath from the current position to the 
struct UCopList *c; right edge of the rastPort. The height of the swath is taken 
short n; from that of the current text font, and the vertical 
positioning of the swath is adjusted by the text baseline, 
FUNCTION such that text output at this position would lie wholly on 
Allocates and/or initialize copperlist structures/buffers. this newly cleared area. 
This is a macro that calls UCopListLinit. CINIT will Clearing consists of setting the color of the swath to zero, 
allocate a new UCopList if c==0. If (c¢ != 0) it will or, if the DrawMode is 2, to the BgPen. 
initialize the data structures to begin new copperlist 
without allocating more memory and it ignores n. INPUTS 
rp — pointer to RastPort structure 
INPUTS 
c ~ pointer to UCopList structure BUGS 
n — number of instructions buffer must hold 
SEE ALSO 
RESULTS Text ClearScreen SetRast graphics/text.h graphics/rastport.h 
An initialize list to accept intermediate copper instructions. 
BUGS 
CINIT will not actually allocate a new copperlist if c==0. 
Instead you must allocate a 12 byte MEMF PUBLIC |MEMF_CLEAR block, 
and pass it to this function. The system's FreeVPortCopLists 
function will take care of deallocating it. 
SEE ALSO 





%, 








64 -¥ 





graphics. library/ClearRectRegion 


graphics. library/ClearRectRegion 


NAME 
ClearRectRegion —- Perform 2d CLEAR operation of rectangle 
with region, leaving result in region. 
SYNOPSIS 
status = ClearRectRegion(region, rectangle) 
do ad al 
BOOL error; 


struct Region *region; 
struct Rectangle *rectangle; 


FUNCTION 
Clip away any portion of the region that exists inside 
of the rectangle. Leave the result in region. 


INPUTS 
region —- pointer to Region structure 
rectangle - pointer to Rectangle structure 


RESULTS 
status — return TRUE if successful operation 
return FALSE if ran out of memory 
BUGS 


SEE ALSO 
AndRectRegion graphics/regions.h 











graphics. library/ClearRegion 


NAME 

ClearRegion ~~ Remove all rectangles from region. 
SYNOPSIS 

ClearRegion( region) 

ad 
struct Region *region; 

FUNCTION . : . 

Clip away all rectangles in the region leaving nothing. 
INPUTS 

region — pointer to Region structure 
BUGS 
SEE ALSO 


NewRegion graphics/regions.h 


graphics. library/ClearRegion 








| 





08 - Ww 








graphics. library/ClearScreen graphics. library/ClearScreen 


NAME 
ClearSereen ~ Clear from current position to end of RastPort. 
SYNOPSIS 
ClearScreen( rp ) 
al 
struct RastPort *rp; 
FUNCTION 
Clear a rectangular swath from the current position to the 
right edge of the rastPort with ClearEOL, then clear the rest 
of the’ screen from just beneath the swath to the bottom of 
the rastPort. 
Clearing consists of setting the color of the swath to zero, 
or, if the DrawMode is 2, to the BgPen. 
INPUTS 
rp - pointer to RastPort structure 
BUGS 
SEE ALSO 


ClearEOL Text: SetRast graphics/text.h graphics/rastport .h 





graphics. library/ClipBlit graphics. library/ClipBlit 


NAME 
ClipBlit -- Calls BltBitMap() after accounting for windows 
SYNOPSIS 


ClipBlit(Sre, SreX, SreY, Dest, DestX, DestY, XSize, YSize, Mintem ); 
ad do dl al a2 d3 a4 da5 dé 


FUNCTION . . 
Performs the same function as Bl1tBitMap(), except that it 
takes into account the Layers and ClipRects of the layer library, 
all of which are (and should be) transparent to you. So, whereas 
BltBitMap() requires pointers to BitMaps, ClipBlit requires pointers to 
the RastPorts that contain the Bitmaps, Layers, et cetera. 


If you are going to blit blocks of data around via the RastPort of your 
Intuition Window, you must call this routine (rather than B1tBitMap()). 


Fither the Src RastPort, the Dest RastPort, both, or neither, can have 
Layers. This routine takes care of all cases. 


See B1tBitMap() for a thorough explanation. 
INPUTS 
Sre = pointer to the RastPort of the source for your blit 
Srex, SreY = the topleft offset into Sre for your data 
Dest = pointer to the RastPort to receive the blitted data 
DestXx, DestY = the topleft offset into the destination RastPort 
XSize = the width of the blit 
YSize = the height of the blit 
Minterm = the boolean blitter function, where SRCB is associated with the 
Sre RastPort and SRCC goes to the Dest RastPort 
RESULT 
None 
BUGS 
None 


SEE ALSO 


BltBitMap(); 











|graphics. Library/CloseFont graphics. library/CloseFont 


NAME 
CloseFont —- Release a pointer to a system font. 
SYNOPSIS 
CloseFont (font) 
al 
struct TextFont *font; 
FUNCTION 
This function indicates that the font specified is no longer 
in use. It is used to close a font opened by OpenFont, so 
that fonts that are no longer in use do not consume system 
resources. 
INPUTS 
font - a font pointer as returned by OpenFont or OpenDiskFont 
BUGS. 
SEE ALSO 


OpenFont diskfont.library/OpenDiskFont graphics/text.h 





18 -W 





graphics. Llibrary/CMOVE graphics. library/CMOVE 
NAME 
CMOVE -- append copper move instruction to user copper list. 
SYNOPSIS 
CMOVE( Cc ,a,vV ) 
CMove( c , a, Vv ) 
al do dl 
CBump( Cc ) 
al 
struct UCopList *c; 
APTR a; 
SHORT Vv; 
FUNCTION 


Add instruction to move value v to hardware register a. 


INPUTS 
c — pointer to. UCopList structure 
a ~ hardware register 
v ~ 16 bit value to be written 


RESULTS 
This is actually a macro that calls CMove(c,&a,v) 
and then calls CBump(c) to bump the local pointer 
to the next instruction. Watch out for macro side affects. 


BUGS 


SEE ALSO 
CINIT CMOVE CWAIT graphics/copper-.h 


|| 





c8 - WY 








graphics. library/CopySBitMap graphics. library/CopySBitMap 


NAME 

CopySBitMap ~-  Syncronize Layer window with contents of 

Super BitMap 

SYNOPSIS 

CopySBitMap( layer ) 

ad 

struct Layer *layer; 

FUNCTION 


This is the inverse of SyncSBitMap. 

Copy all bits from SuperBitMap to Layer bounds. 

This is used for those functions that do not 

want to deal with the ClipRect structures but do want 
to be able to work with a SuperBitMap Layer. 


INPUTS 


layer - pointer to a SuperBitMap Layer 
The Layer must already be locked by the caller. 


BUGS 


SEE ALSO 
LockLayerRom SyncSBitMap 


graphics. library/CWAIT 








graphics. library/CWAIT 


NAME 

CWAIT -- Append copper wait instruction to user copper list. 
SYNOPSIS 

CWAIT( c,v,h) 

CWait{ ¢,v,h) 

al do dl 
CcBump( c ) 
al 

struct UCopList *c; 

short v,h; 
FUNCTION 

Add instruction to wait for vertical beam position v and 

horizontal position h to this intermediate copper list. 
INPUTS 

c — pointer to UCopList structure 

v - vertical beam position (relative to top of viewport) 

h - horizontal beam position 
RESULTS 

this is actually a macro that calls CWait(c,v,h) 

and then calls CBump(c) to bump the local pointer 

to the next instruction. 
BUGS 

User waiting for horizontal values of greater than 222 decimal is illegal. 
SEE ALSO 


CINIT CMOVE CEND graphics/copper.h 








u 


€8 











graphics. library/DisownBlitter graphics. library/DisownBlitter 


NAME 

DisownBlitter -— return blitter to free state. 
SYNOPSIS 

DisownBlitter() 
FUNCTION 

Free blitter up for use by other blitter users. 

INPUTS 
RETURNS 
SEE ALSO 


ownBlitter 





graphics. library/DisposeRegion 


NAME 

DisposeRegion —- Return all space for this region to free 

memory pool. 

SYNOPSIS 

DisposeRegion (region) 

ad 
struct Region *region; 

FUNCTION 


Free all RegionRectangles for this Region then 
free the Region itself. 


INPUTS 
region — pointer to Region structure 


BUGS 


SEE ALSO 
NewRegion graphics/regions.h 








graphics, library/DisposeRegion 


|| 





graphics. library/Docollision 





8 - WV 











graphics. library/DoCollision 


NAME 
DoCollision -~ Test every gel in gel list for collisions. 


SYNOPSIS 
DoCollision(rp) 
al 


struct RastPort *rp; 


FUNCTION 
Tests each gel. in gel list for boundary and gel-to-gel collisions. 
On detecting one of these collisions, the appropriate collision- 
handling routine is called. See the documentation for a thorough 
description of which collision routine is called. This routine 
expects to find the gel list correctly sorted in Y,X order. 
The system routine SortGList performs this function for the user 


INPUTS 
rp = pointer to a RastPort 


BUGS 


SEE ALSO 
InitGels SortGList graphics/gels.h graphics/gels.h 


graphics. library/Draw 





graphics. library/Draw 


NAME 
Draw -~ Draw a line between the current pen position 
and the new x,y position. 
SYNOPSIS 
Draw( rp, _ X, y) 
al d0:16 dl1:16 
struct RastPort *rp; 
SHORT X,Y; 
FUNCTION 


Draw a line from the current pen position to (x,y)- 
INPUTS 


rp - pointer to a RastPort 
-x,y - point in the RastPort to end the line. 


BUGS 


SEE ALSO 
Move graphics/rastport .h 














graphics. library/DrawEllipse graphics. library/DrawEllipse 


NAME 
DrawEllipse -- Draw an ellipse centered at cx,cy with vertical 
and horizontal radii of a,b respectively. 
SYNOPSTS 


DrawEllipse( rp, cx, cy, a, b ) 
al dO dl d2 a3 


struct RastPort *rp; 
SHORT cx, cy; 
SHORT a, b; 


FUNCTION 
Create an elliptical outine within the rectangular region 
specified by the parameters, using the current foreground pen color. 


INPUTS 
rp ~ pointer to the RastPort into which the ellipse will be drawn. 
cx — x coordinate of the centerpoint relative to the rastport. 
cy - y coordinate of the centerpoint relative to the rastport. 
a — the horizontal radius of the ellipse (note: a must be > 0) 
b — the vertical radius of the ellipse (note: b must be > 0) 


Note: this routine does not clip the ellipse to a non-layered rastport. 


BUGS 


SEE ALSO 
DrawCircle, graphics/rastport.h 


cs - WwW 





graphics. library/DrawGList 








graphics. library/DrawGList 


NAME 
DrawGList -~ Process the gel list, queueing VSprites, drawing Bobs. 


SYNOPSIS 
DrawGList(rp, vp) 
al a0 


struct RastPort *rp; 
struct ViewPort *vp; 


FUNCTION 
Performs one pass of the current gel list. 
~- If nextLine and lastColor are defined, these are 
initialized for each gel. 
~- If it's a VSprite build it into the copper list. 
- If it's a Bob, draw it into the current raster. 
~ Copy the save values into the "old" variables, 
double-buffering if required. 





INPUTS 
rp = pointer to the RastPort where Bobs will be drawn 
vp = pointer to the ViewPort for which VSprites will be created 


BUGS 
MUSTDRAW isn't implemented yet. 


SEE ALSO 
InitGels graphics/gels.h graphics/rastport.h graphics/view.h 


| 


98 -—W 














graphics. library/Flood graphics. library/Flood 


NAME 

Flood -- Flood rastport like areafill. 
SYNOPSIS 

error = Flood( rp, mode, x, y) 

ao al d2 do dl 


BOOLEAN error; 
struct RastPort rp; 
ULONG mode; 

SHORT X,Y; 


FUNCTION 
Search the BitMap starting at (x,y). Fill all adjacent pixels 
if they are: 
a: arenot the same as AOLPen Mode 0 
b: same as the one at (x,y) Mode L 
When actually doing the fill use the modes that apply to 
standard areafill routine such as drawmodes and patterns. 


INPUTS 
rp — pointer to RastPort 
(x,y) — coordinate in BitMap 


mode —- 0 fill all adjacent pixels searching for border 
1 f111 all adjacent pixels that have same pen number 
as (x,y) 


Note: in order to use Flood, the destination RastPort must 
have a valid TmpRas raster whose size is as large as 
that of the RastPort. 


SEE ALSO 
AreaEnd graphics/rastport.h 


graphics. library/FreeColorMap 





graphics. library/FreeColorMap 


NAME 
FreeColorMap -- Free the ColorMap structure and return memory 
to free memory pool. 
SYNOPSIS 
FreeColorMap( colormap ) 
a0 
struct ColorMap *colormap; 
FUNCTION 
Return the memory to the free memory pool that was allocated 
with GetColorMap. 
INPUTS : 
colormap — pointer to ColorMap allocated with GetColorMap 
RESULT 
The space is made available for others to use. 
BUGS 
SEE ALSO 


SetRGB4 GetColorMap graphics/view.h 








18 - ¥ 











graphics. library/FreeCopList 


NAME 

FreeCopList —- deallocate intermediate copper list 
SYNOPSIS 

FreeCopList(coplist) 

aQ 

struct CopList *coplist; 
FUNCTION 

Deallocate all memory associated with this copper list. 
INPUTS 

coplist ~ pointer to structure CopList 
RESULTS 

memory returned to memory manager 
BUGS 
SEE ALSO 


graphics/copper.h 


graphics. library/FreeCopList graphics. library/FreeCprList 





NAME 
FreeCprList -- deallocate hardware copper list 


SYNOPSIS 
FreeCprList(cprlist) 
ad 
struct cprlist *cprlist; 


FUNCTION 
return cprlist to free memory pool 


INPUTS 
cprlist — pointer to cprlist structure 


RESULTS 
memory returned and made available to other tasks 


BUGS 


SEE ALSO 
graphics/copper.h 





graphics. library/FreeCprList 





||| 





88 - ¥ 














graphics. library/FreeGBuffers graphics. library/FreeGBuffers 


NAME 

FreeGBuffers —- Deallocate memory obtained by GetGBufers. 
SYNOPSIS 

FreeGBuffers(anOb, rp, db) 


ad al do 


struct. AnimOb *anOb; 
struct RastPort *rp; 
BOOL db; 


FUNCTION 
For each sequence of each component of the Animob, 
deallocate memory for: 
SaveBuffer 
BorderLine 
CollMask and ImageShadow (point to same buffer) 
if db is set (user had used double-buffering) deallocate: 
DBufPacket 
BufBuffer 


INPUTS 
anOb = pointer to the AnimOb structure 
rp = pointer to the current RastPort 


db = double-buffer indicator (set TRUE for double-buffering) 
BUGS 
SEE ALSO 

GetGBuffers graphics/gels.h graphics/rastport.h 


graphics. library/FreeRaster 


graphics. library/FreeRaster 


NAME 


FreeRaster —— Release an allocated area to the system free memory pool. 
SYNOPSIS 
FreeRaster( p, width, height) 
ad d0:16 d1:16 
PLANEPTR p; 
USHORT width,height; 
FUNCTION 
Return the memory associated with this PLANEPTR of size 
width and height to the MEMF_CHIP memory pool. 
INPUTS 
Pp = a pointer to a memory space returned as a 
result of a call to AllocRaster. 
width - the width in bits of the bitplane. 
height ~ number of rows in bitplane. 
the same values of width and height with which you 
called AllocRaster in the first place, when the 
pointer p returned. This defines the size of the 
memory space which is to be returned to the free 
memory pool. 
BUGS 
SEE ALSO 


AllocRaster graphics/gfix.h 














68 - W 





graphics. library/FreeSprite 





graphics. library/FreeSprite 


NAME 
FPreeSprite -~ Return sprite for use by others and virtual 
sprite machine. 


SYNOPSIS 
FreeSprite( pick ) 
do 


SHORT pick; 


FUNCTION 
Mark sprite as available for others to use. 

These sprite routines are provided to ease sharing of sprite 
hardware and to handle simple cases of sprite usage and 
movement. It is assumed the programs that use these routines 
do want to be good citizens in their hearts. ie: they will 
not FreeSprite unless they actually own the sprite. 

Virtual Sprite machine may ignore simple sprite machine. 


INPUTS 
pick ~ number in range of 0-7 


RESULTS 
sprite made available for subsequent callers of GetSprite 
as well as use by Virtual Sprite Machine 

BUGS 


SEE ALSO 
GetSprite ChangeSprite MoveSprite graphics/sprite.h 





graphics. library/FreevPortCopLists 


NAME 
FreevPortCopLists —- deallocate all intermediate copper lists and 
their headers from a viewport 


SYNOPSIS 
FreevPortCopLists (vp) 
a0 


struct ViewPort *vp; 


FUNCTION 
Search display, color, sprite, and user copper 
lists and call FreeMem() to deallocate them from memory 


INPUTS 
vp — pointer to ViewPort structure 


RESULTS 
vp->DspIns = NULL; vp—>SpriIns = NULL; vp->ClriIns = NULL; 
vp->UCopIns = NULL; 


BUGS 
none known 


SEE ALSO 
graphics/view.h 


graphics. library/FreevPortCopLists 








iy 


i 








graphics. library/GetColorMap graphics. library/GetColorMap graphics. library/GetGBuffers graphics. library/GetGBuffers 
NAME NAME 
GetColorMap -- allocate and initialize Colormap GetGBuffers -- Attempt to allocate ALL buffers of an entire AnimOb. 
SYNOPSIS 
SYNOPSIS status = GetGBuffers(anOb, rp, db) 
cm = GetColorMap( entries ) do ad al dd 
dao do 


struct ColorMap *cm; 
LONG entries; 


FUNCTION 

Allocates, initializes and returns a pointer to a ColorMap 

data structure, later enabling calls to SetRGB4 

and LoadRGB4 to load colors for a view port. The ColorTable 
pointer in the ColorMap structure points to a hardware 
specific colormap data structure. You should not count on 
it being anything you can understand. Use GetRGB4() to 
query it or SetRGB4CM to set it directly. 


INPUTS 
entries — number of entries for this colormap 


RESULT 
The pointer value returned by this routine, if nonzero, 
may be stored into the ViewPort.ColorMap pointer. 
If a value of 0 is returned, the system was unable 
to allocate enough memory space for the required 
data structures. 


BUGS 


SEE ALSO 
SetRGB4 FreeColorMap 


06 -W 








BOOL status; 

struct AnimOb *anOb; 
struct RastPort *rp; 
BOOL db; 


FUNCTION 
For each sequence of each component of the AnimOb, allocate memory for: 


SaveBuf fer 

BorderLine 

CollMask and ImageShadow (point to same buffer) 

if db is set TRUE (user wants double-buffering) allocate: 
DBufPacket 
BufBuffer 


INPUTS 
anOb = pointer to the AnimOb structure 
rp = polnter to the current RastPort 
db double-buffer indicator (set TRUE for double~buffering) 


nou 


RESULT 
status = TRUE if the memory allocations were all successful, else FALSE 


BUGS 
If any of the memory allocations fail it does not free the partial 
allocations that did succeed. 


SEE ALSO 
FreeGBuffers graphics/gels.h 








Té6é -W 





graphics. library/GetRGB4 





graphics. library/GetRGB4 


NAME 

GetRGB4 —- Inquire value of entry in ColorMap. 
SYNOPSIS 

value = GetRGB4( colormap, entry ) 

dao ad ao 

ULONG value; 

struct ColorMap *colormap; 

LONG entry; 
FUNCTION 

Read and format a value from the ColorMap. 
INPUTS 

colormap — pointer to ColorMap structure 

entry — index into colormap 
RESULT 

returns ~1 if no valid entry 

return UWORD RGB value 4 bits per gun right justified 
BUGS 
SEE ALSO 


SetRGB4 LoadRGB4 GetColorMap FreeColorMap graphics/view.h 


graphics. library/GetSprite 








graphics. library/GetSprite 


NAME 

GetSprite —— Attempt to get a sprite for the simple sprite 
manager. 

SYNOPSIS 

Sprite Number = GetSprite( sprite, pick ) 
dao ad do 

SHORT Sprite_Number; 
struct SimpleSprite *sprite; 
SHORT pick; 

FUNCTION 
Attempt to allocate one of the eight sprites for private use 
with the simple sprite manager. This must be done before using 
further calls to simple sprite machine. If the programmer 
wants to use 15 color sprites you must allocate both sprites 
and set the 'SPRITE_ATTACHED' bit in the odd sprite’s posctldata 
array. 

INPUTS 
sprite — ptr to programmers SimpleSprite structure. 
pick — number in the range of 0-7 or 

-] if programmer just wants the next one. 

RESULTS 
If pick is 0-7 attempt to allocate the sprite. If the sprite 
is already allocated then return —1. 
If pick -1 allocate the next sprite starting search at 0. 
If no sprites are available return -1 and fill -1 in num entry 
of SimpleSprite structure. 
If the sprite is available for allocation, mark it allocated 
and fill in the 'num' entry of the SimpleSprite structure. 
If successful return the sprite number. 

BUGS 

SEE ALSO 


FreeSprite ChangeSprite MoveSprite GetSprite graphics/sprite.h 





|| 





c6 - W 








graphics.library/InitArea graphics. library/InitArea 





NAME 
InitArea ~~ Initialize vector collection matrix 

SYNOPSIS 
InitArea( areainfo, buffer, maxvectors ) 

ad al do 

struct AreaInfo *areainfo; 
APTR buffer; 
SHORT maxvectors; 

FUNCTION 
This function provides initialization for the vector collection matrix 
such that it has a size of (max vectors ). The size of the region 
pointed to by buffer (short pointer) should be five (5) times as large 
as maxvectors. This size is in bytes. Areafills done by using AreaMove, 
AreaDraw, and AreaEnd must have enough space allocated in this table to 
store all the points of the largest fill. AreaEllipse takes up two 
vectors for every call. If AreaMove/Draw/Ellipse detect too many 
vectors going into the buffer they will return —l. 

INPUTS 
areainfo - pointer to AreaInfo structure 
buffer ~ pointer to chunk of memory to collect vertices 
maxvectors ~ max number of vectors this buffer can hold 

RESULT 
Pointers are set up to begin storage of vectors done by 
AreaMove, Areabraw, and AreaEllipse. 

BUGS 

SEE ALSO 


AreaEnd AreaMove AreaDraw AreaEkllipse graphics/rastport.h 





[graphics librazy/InitBitMap 





graphics. library/InitBitMap 


NAME 
InitBitMap —- Initialize bit map structure with input values. 
SYNOPSIS 
InitBitMap( bm, depth, width, height ) 
ad dd dl d2 
struct BitMap *bm; 
BYTE depth; 
SHORT width, height; 
FUNCTION 
Initialize various elements in the BitMap structure to 
correctly reflect depth, width, and height. 
Must be used before use of BitMap in other graphics calls. 
The Planes[8] are not initialized and need to be set up 
by the caller. The Planes table was put at the end of the 
structure so that it may be truncated to conserve space, 
as well as extended. All routines that use BitMap should 
only depend on existence of depth number of bitplanes. 
INPUTS 
bm - pointer to a BitMap structure (gfx.h) 
depth - number of bitplanes that this bitmap will have 
width ~ number of bits (columns) wide for this BitMap 
height- number of bits (rows) tall for this BitMap 
BUGS 
SEE ALSO 


graphics/gfx.h 














graphics. library/InitGels graphics. library/InitGels 
NAME 
InitGels -- initialize a gel list; must be called before using geis. 


SYNOPSIS 
InitGels(head, tail, GInfo) 
ad al a2 


struct VSprite *head, *tail; 
struct GelsInfo *Ginfo; 


FUNCTION 
Assigns the VSprites as the head and tail of the gel list in GfxBase. 
Links these two gels together as the keystones of the list. 
If the collHandler vector points to some memory array, sets 
the BORDERHIT vector to NULL. 


INPUTS 
head = pointer to the VSprite structure to be used as the gel list head 


R 


tail = pointer to the VSprite structure to be used as the gel list tail 
GInfo = pointer to the GelsInfo structure to be initialized 
BUGS 


SEE ALSO 


graphics/gels.h  graphics/rastport.h 


€6-W 


graphics. library/InitGMasks graphics. library/InitGMasks 


NAME 
InitGMasks -- Initialize all of the masks of an Animob. 
SYNOPSIS 
InitGMasks(anOb) 
ad 


struct AnimOb *anOb; 


FUNCTION 
For every sequence of every component call InitMasks. 
INPUTS 
anOb = pointer to the AnimOb 
BUGS 
SEE ALSO 


InitMasks graphics/gels.h 








Ah 








b6 - ¥ 











graphics. library/InitMasks graphics. library/InitMasks 


NAME 
InitMasks -- Initialize the BorderLine and CollMask masks of a VSprite. 


SYNOPSIS 
InitMasks(vs) 
ad 


struct VSprite *vs; 


FUNCTION 
Creates the appropriate BorderLine and CollMask masks of the VSprite. 
Correctly detects if the VSprite is actually a Bob definition, handles 
the image data accordingly. 


INPUTS 
vs = pointer to the VSprite structure 


BUGS 


SEE ALSO 
InitGels graphics/gels.h 








graphics. library/InitRastPort graphics. library/InitRastPort 
NAME 
InitRastPort -—- Initialize raster port structure 
SYNOPSIS 
InitRastPort( rp ) 
al 


struct RastPort *rp; 


FUNCTION 

Initialize a RastPort structure to standard values. 
The struct Rastport describes a control structure 
for a write-able raster. The RastPort structure 
describes how a complete single playfield display 
will be written into. A RastPort structure is 
referenced whenever any drawing or filling 
operations are to be performed on a_ section of 
memory . 


The section of memory which is being used in this 
way may or may not be presently a part of the 
current actual onscreen display memory. The name 
of the actual memory section which is linked to 
the RastPort is referred to here as a "raster" or 
as a bitmap. 


NOTE: Calling the routine InitRastPort only 
establishes various defaults. It does NOT 
establish where, in memory, the rasters are 


located. To do- graphics with this RastPort the user 
must set up the BitMap pointer in the RastPort. 


INPUTS 
rp = pointer to a RastPort structure. 


RESULT 
all entries in RastPort get zeroed out. 
exceptions: 
The following get ~-1: 
Mask, FgPen,AOLPen, LinePtrn 
DrawMode = JAM2 
The font is set to the standard system font 


BUGS 


SEE ALSO 
graphics/rastport.h 














G6 -¥ 


fgraphics. library/InitTmpRas 








graphics. library/InitTmpRas 


NAME 
InitTmpRas -- Initialize area of local memory for usage by 
areafill, floodfill, text. 
SYNOPSIS 
InitTmpRas(tmpras, buffer, size) 
ad a 
struct TmpRas *timpras; 
APTR buffer; 
LONG size; 
FUNCTION 


The area of memory pointed to by buffer is set up to be used 
by RastPort routines that may need to get some memory for 


intermediate operations in preparation to putting the graphics 
into the final BitMap. 


Tmpras is used to control the usage of buffer. 


INPUTS 


tmpras - pointer to a TmpRas structure to be linked into 
a RastPort 


buffer - pointer to a contguous piece of chip memory. 
size — size in bytes of buffer 


RESULT 
makes buffer available for users of RastPort 


BUGS 
Would be nice if RastPorts could share one TmpRas. 


SEE ALSO 
AreaEnd Flood Text graphics/rastport.h 


graphics. library/InitView 





graphics. library/InitView 


NAME 
InitView -— Initialize View structure. 
SYNOPSIS 

InitView( view ) 


al 
struct View *view; 


FUNCTION 
Initialize View structure to default values. 


INPUTS 
view ~ pointer to a View structure 


RESULT 
View structure set to all O's. (1.0,1.1.1.2) ; 
Then values are put in DxOffset,DyOffset to properly position 
default display about .5 inches from top and left on monitor. 
InitView pays no attention to previous contents of view. 


BUGS 


SEE ALSO 
MakevPort graphics/view.h 








HA 





96 -¥ 





graphics. library/InitvPort 





graphics 


NAME 
InitVPort — Initialize ViewPort structure. 


SYNOPSIS 
InitvPort( vp ) 
ad 


struct ViewPort *vp; 


FUNCTION 
Initialize ViewPort structure to default values. 


INPUTS 
vp ~ pointer to a ViewPort structure 


RESULT 
BUGS 


SEE ALSO 
MakeVPort graphics/view.h 


-Llibrary/InitvPort 








graphics. library/LoadRGB4 


NAME 


SYNOPSIS 


FUNCTION 


INPUTS 


RESULTS 


BUGS 


graphics. library/LoadRGB4 


LoadRGB4 -—- Load RGB color values from table. 


LoadRGB4( vp, colors , count ) 
ad al d0:16 


struct ViewPort *vp; 
UWORD colors[{]; 
SHORT count; 


load the count words of the colormapper from table starting at 
entry 0. 


vp - pointer to ViewPort, whos colors you want to change 
colors - pointer to table of RGB values set up as an array 





of USHORTS 
background-- OxORGB 
colorl —- Ox0ORGB 
color2 -~ OxORGB 
etc. UWORD per value. 


The colors are interpreted as 15 = maximum intensity. 
0 = minimum intensity. 
count = number of UWORDs in the table to load into the 
colormap starting at color O{background) and proceeding 
to the next higher color number 


The ViewPort should have a pointer to a valid ColorMap to store 
the colors in. 

Update the hardware copperlist to reflect the new colors. 
Update the intermediate copperlist with the new colors. 


SEE ALSO 


SetRGB4 GetRGB4 GetColorMap graphics/view.h 











graphics. library/LoadView graphics. library/LoadView 


NAME 
LoadView —- Use a (possibly freshly created) coprocessor instruction 
List to create the current display. 


SYNOPSIS 
LoadView( View ) 
Al 


struct View *View; 


FUNCTION 
Install a new view to be displayed during the next display 
refresh pass. 
Coprocessor instruction list has been created by 
InitvPort, MakeView, and MrgCop. 


INPUTS 
View — a pointer to the View structure which contains the 
pointer to the constructed coprocessor instructions list. 


RESULT 
The new View is displayed, according to your instructions. 
The vertical blank routine will pick this pointer up and 
direct the copper to start displaying this View. 


BUGS 


SEE ALSO 
InitvPort MakevVPort MrgCop intuition/RethinkDisplay graphics/view.h 


- wv 


£6 








graphics. library/LockLayerrRom graphics. Llibrary/LockLayerkom 
* 


NAME 


LockLayerRom -—- Lock Layer structure by rom(gfx lib) code. 
SYNOPSIS 
LockLayerRom( layer ) 
a5 
struct Layer *layer; 
FUNCTION 
Return when the layer is locked and no other task may 
alter. the ClipRect structure in the Layer structure. 
This call does not destroy any registers. 
This call nests so that callers in this chain will not lock 
themselves out. 
Do not have the Layer locked during a call to intuition. 
There is a potential deadlock problem here, if intuition 
needs to get other locks as well. 
Having the layer locked prevents other tasks from using the 
layer library functions, most notably intuition itself. So 
be brief. 
layer.library's LockLayer is identical to LockLayerRom. 
INPUTS 
layer — pointer to Layer structure 
RESULTS 
The layer is locked and the task can render assuming the 
ClipRects will not change out from underneath it until 
an UnlockLayerRom is calied. 
SEE ALSO 


UnlockLayerRom graphics/clip.h 








hh 


86 -W 





[graphics.library/MakevPort graphics. library/MakevPort 


NAME 

MakevPort —- generate display copper list. 
SYNOPSIS 

MakeVPort( view, viewport ) 


ad al 


struct View *view; 
struct ViewPort *viewport; 


FUNCTION 
Use information in the View, ViewPort, ViewPort-—>RasInfo; 
construct. intermediate copper list for this ViewPort. 


INPUTS 
view ~ pointer to View structure 
viewport — pointer to ViewPort structure 
The viewport must have valid pointer to a Rasinfo. 


RESULTS 
constructs intermediate copper list and puts pointers in 
viewport .DspIns 
If the ColorMap ptr in ViewPort is NULL then it uses colors 
from the default color table. 
If DUALPF in Modes then there must be a second RasInfo pointed 
to by the first RasInfo 


BUGS 
SEE ALSO 


InitvPort MrgCop graphics/view.h 
Intuition's MakeScreen RemakeDisplay and RethinkDisplay 











graphics. library/Move graphics. library/Move 


NAME 
Move -- Move graphics pen position. 
SYNOPSIS 
Move( rp, X, y) 
al d0:16 d1:16 
struct RastPort *rp; 
SHORT X,Y; 
FUNCTION 
Move graphics pen position to (x,y) relative to upper left (0,0) 
of RastPort. 
Note: Text uses the same position. 
INPUTS 
rp ~ pointer to a RastPort structure 
x,y ~— point in the RastPort 
RESULTS 
BUGS 
SEE ALSO 


Draw graphics/rastport.h 


i 

















graphics. library/MoveSprite graphics. library/MoveSprite 


NAME 
MoveSprite —- Move sprite to a point relative to top of viewport. 
SYNOPSIS 
MoveSprite( vp, sprite, x, y ) 
ao al do dl 
struct ViewPort *vp; 
struct SimpleSprite *sprite; 
SHORT - X,Y; 
FUNCTION 
Move sprite image to new place on display. 
INPUTS 
vp — pointer to ViewPort structure 
if vp = 0, sprite is positioned relative to View. 
sprite — pointer to SimpleSprite structure 
(x,y) — new position relative to top of viewport or view. 
RESULTS 
Calculate the hardware information for the sprite and 
place it in the posctldata array. During next video display 
the sprite will appear in new position. 
BUGS 


Sprites really appear one pixel to the left of the position you specify. 
This bug affects the apparent display position of the sprite on the screen, 
but does not affect the numeric position relative to the viewport or view. 


SEE ALSO 
FreeSprite ChangeSprite GetSprite graphics/sprite.h 








graphics. library/MrgCop graphics. library/MrgCop 
NAME, 
MrgCop -- Merge together coprocessor instructions. 


SYNOPSIS 
MrgCop( View ) 
Al 


struct View *View; 


FUNCTION 
Merge together the display, color, sprite and user coprocessor 
instructions into a single coprocessor instruction stream. This 
essentially creates a per-display-frame program for the coprocessor. 
This function MrgCop is used, for example, by the graphics animation 
routines which effectively add information into an essentially 
static background display. This changes some of the user 
or sprite instructions, but not those which have formed the 
basic display in the first place. When all forms of coprocessor 
instructions are merged together, you will have a complete per— 
frame instruction list for the coprocessor. 


Each of the coprocessor instruction lists MUST be 
The merge routines 


Restrictions: 
internally sorted in min to max Y-X order. 
depend on this! 
Each list must be terminated using CEND(copperlist) 
INPUTS 
View - a pointer to the view structure whose coprocessor 
instructions are to be merged. 


RESULT 
The view structure will now contain a complete, sorted/merged 
list of instructions for the coprocessor, ready to be used by 
the display processor. The display processor is told to use 
this new instruction stream through the instruction LoadView(). 

BUGS 

SEE ALSO 


InitVPort MakevPort LoadView graphics/view.h 
Intuition's RethinkDisplay 


(fl 





0O0oT -¥& 





graphics. library/NewRegion graphics. library/NewRegion 


NAME 
NewRegion -- Get a clear region. 


SYNOPSIS 
region = NewRegion() 
ao 


struct Region *region; 


FUNCTION 
Create a Region structure, initialize it to empty and return 
a pointer it. 


RESULTS 
region — pointer to initialized region. If it could not allocate 
required memory region = NULL. 


INPUTS 
none 


BUGS 


SEE ALSO 
graphics/regions.h 


graphics. library/OpenFont 











' 


graphics. library/OpenFont 


NAME 
OpenFont —- Get a pointer to a system font. 

SYNOPSIS 
font = OpenFont(textattr) 
dao ad 
struct TextFont *font; 
struct TextAttr *textAttr; 

FUNCTION 
This function searches the system font space for the graphics 
text font that best matches the attributes specified. The 
pointer to the font returned can be used in subsequent 
SetFont and CloseFont calls. It is important to match this 
call with a corresponding CloseFont call for effective 
management of ram fonts. 

INPUTS 
textAttr — a TextAttr structure that describes the text font 

attributes desired 

RESULTS 
font is zero if the desired font cannot be found. If the named 
font is found, but the size and style specified are not 
available, a font with the nearest attributes is returned. 

BUGS 

SBE ALSO 


CloseFont SetFont diskfont.library/OpenDiskFont graphics/text.h 











Tot - ¥ 








graphics. library/OrRectRegion graphics. library/OrRectRegion 


NAME 

OrRectRegion -- Perform 2d OR operation of rectangle 

with region, leaving result in region. 

SYNOPSIS 

status = OrRectRegion( region, rectangle) 

do ad al 

BOOL status 

struct Region *region; 

struct Rectangle *rectangle; 
FUNCTION 


If any portion of rectangle is not in the region then add 
that portion to the region. 


INPUTS 
region ~ pointer to Region structure 
rectangle — pointer to Rectangle structure 


RESULTS 
status — return TRUE if successful operation 
return FALSE if ran out of memory 


BUGS 


SEE ALSO 
AndRectRegion OrRegionRegion graphics/regions.h 





graphics. library/OrRegionRegion graphics. library/OrRegionRegion 


NAME 
OrRegionRegion ~~ Perform 2d OR operation of one region 
with second region, leaving result in second region 
SYNOPSIS 
status = OrRegionRegion(regionl,region2) 
do a0 al 
BOOL status; 
struct Region *regionl, *region2; 
FUNCTION 


If any portion of regionl is not in the region then add 


that portion to the region2 


INPUTS 
regionl ~ pointer to Region structure 
region2 - pointer to Region structure 


RESULTS 
status — return TRUE if successful operation 
return FALSE if ran out. of memory 
BUGS 


SEE ALSO 
OrRectRegion graphics/regions .h 





ih 





col - ¥ 





graphics. Library/OwnBlitter graphics. library/OwnBlitter 





NAME 
OwnBlitter -- get the blitter for private usage 


SYNOPSIS 
OwnBlitter() 


FUNCTION 
If blitter is available return immediately with the blitter 
locked for your exclusive use. If the blitter is not available 
put task to sleep. It will be awakened as soon as the blitter 
is available. When the task first owns the blitter the blitter 
may still be finishing up a blit for the previous owner. You 
must do a WaitBlit before actually using the blitter registers. 


Calls to OwnBlitter() not nest. If a task that owns the 
blitter calls OwnBlitter() again, a lockup will result. 
(Same situation if the task calls a system function 
that tries to own the blitter). 


INPUTS 
NONE 


RETURNS 


SEE ALSO 
DisownBlitter 


itl 





graphics. library/PolyDraw : graphics. library/PolyDraw 
* 
NAME 
PolyDraw —- Draw lines from table of (x,y) values. 
SYNOPSIS 
PolyDraw( rp, count , array ) 
al do ad 
struct RastPort *rp; 
SHORT count; 
SHORT array[]; 
FUNCTION 
starting with the first pair draw connected lines to 
it and every succeeding pair. 
INPUTS 
rp ~ pointer to RastPort structure 
count ~ number of points in array (x,y) pairs 
array ~ pointer to first (x,y) pair 
BUGS 
SEE ALSO 


Draw Move graphics/rastport .h 

















cot -¥ 














graphics. library/OBlit graphics. library/QBlit 


NAME 
QBlit -- Queue up a request for blitter usage 


SYNOPSIS 
QBlit( bp ) 
al 


struct bltnode *bp; 


FUNCTION 
Link a request for the use of the blitter to the end of the 
current blitter queue. The pointer bp points to a blit structure 
containing, among other things, the link information, and the 
address of your routine which is to be called when the blitter 
queue finally gets around to this specific request. When your 
routine is called, you are in control of the blitter ... it is 
not busy with anyone else's requests. This means that you can 
directly specify the register contents and start the blitter. 
See the description of the blit structure and the uses of QBlit 
in the section titled Graphics Support in the OS Kernel Manual. 
Your code must be written to run either in supervisor or user 
mode on the 68000. 


INPUTS 
bp - pointer to a blit structure 


RESULT 
Your routine is called when the blitter is ready for you. 
In general requests for blitter usage through this channel are 
put in front of those who use the blitter via OwnBlitter and 
DisownBlitter. However for small blits there is more overhead 
using the queuer than Own/Disown Blitter. 


BUGS 


SBE ALSO 
OBSBlit hardware/blit.h 


graphics. library/QBSBlit graphics. library/QBSBlit 


NAME 
QBSBlit —- Synchronize the blitter request with the video beam. 
SYNOPSIS 
QBSBlit( bsp ) 
al 
struct bltnode *bsp; 
FUNCTION 


Call a user routine for use of the blitter, enqueued separately from 
the QBlit queue. Calls the user routine contained in the blit 
structure when the video beam is located at a specified position 
onscreen. Useful when you are trying to blit into a visible part 
of the screen and wish to perform the data move while the beam is 
not trying to display that same area. (prevents showning part of 
an old display and part of a new display simultaneously). Blitter 
requests on the QBSBlit queue take precedence over those on the 
regular blitter queue. The beamposition is specified the blitnode. 


INPUTS 
bsp -— pointer to a blit structure. See description in the 
Graphics Support section of the manual for more info. 


RESULT 
User routine is called when the QBSBlit queue reaches this 
request AND the video beam is in the specified position. 
If there are lots of blits going on and the video beam 
has wrapped around back to the top it will call all the 
remaining bltnodes as fast as it can to try and catch np. 


BUGS 
Not very smart when getting blits from different tasks. 
They all get. put in same queue so there are unfortunately 
some interdependencies with the beam syncing. 

SEE ALSO 


QBlit hardware/blit.h 








||| 








POT —-¥ 








graphics. library/ReadPixel graphics. library/ReadPixel 


NAME 

ReadPixel -- read the pen number value of the pixel at a 

specified x,y location within a certain RastPort. 

SYNOPSIS 

penno = ReadPixel( rp, Xx, y) 

do al 40:16 d1:16 

LONG penno; 

struct RastPort *rp; 

SHORT XV; 
FUNCTION 


Combine the bits from each of the bit-planes used to describe 

a particular RastPort into. the pen number selector which that 
bit combination normally forms for the system hardware selection 
of pixel color. 


INPUTS 
rp - pointer to a RastPort structure 
(x,y) a point in the RastPort 


RESULT 
Pen — (0..255) number at that position is returned. 
-l is returned if cannot read that pixel 
BUGS 
SEE ALSO 
WritePixel graphics/rastport.h 


graphics. library/RectFill 





Ui 


graphics. library/RectFill 


NAME 
RectFill -~- Fill a defined rectangular area with 
the current drawing pen color, outline color, 
secondary color, and pattern. 
SYNOPSIS 
RectFill( rp, xmin, ymin, xmax, ymax) 
al d0:16 d1:16 d2:16 d3:16 
struct RastPort *rp; 
SHORT xmin, ymin; 
SHORT xmax , ymax; 
FUNCTION 
Fill the rectangular region specified by the 
parameters with the chosen pen colors, areafill 
pattern, and drawing mode. If no areafill pattern is 
specified, fill the rectangular region with the FgPen 
color, taking into account the drawing mode. 
INPUTS 


rp ~ pointer to a RastPort structure 

(xmin, ymin) (xmax,ymax) are the coordinates of the upper 

left corner and the lower right corner, respectively, of the 
rectangle. 

The following relation MUST be true: 

(xmax >= xmin) and (ymax >= ymin) 


BUGS 
Complement mode with FgPen complements all bitplanes. 


SEE ALSO 
AreaEnd graphics/rastport .h 











SOT - ¥ 














graphics. library/RemBob graphics. library/RemBob 


NAME 

RemBob -~ Remove a Bob from the gel list. 
SYNOPSIS 

RemBob (bob) 


struct Bob *bob; 


FUNCTION 
Marks a Bob as no-longer~required. The gels internal code then 
removes the Bob from the list of active gels the next time 
DrawGList is executed. This is implemented as a macro. 
If the user is double-buffering the Bob, it could take two 
calls to DrawGList before the Bob actually disappears from 
the RastPort. 


INPUTS 
Bob = pointer to the Bob to be removed 


BUGS 


SEE ALSO 
RemIBob DrawGList graphics/gels.h graphics/gfxmacros.h 





graphics. library/RemFont 





graphics. library/RemFont 


NAME 
RemFont. -— Remove a font from the system list. 
SYNOPSIS 
RemFont (textFont) 
al 
struct TextFont *textFont; 
FUNCTION : 
This function removes a font from the system, ensuring that 
access to it is restricted to those applications that 
currently have an active pointer to it: i.e. no new SetFont 
requests to this font are satisfied. 
INPUTS 
textFont — the TextFont structure to remove. 
BUGS 
SEE ALSO 


SetFont AddFont graphics/text.h 








| 


90T - ¥ 





graphics. Library/Rem1 Bob graphics. library/RemI Bob 


NAME 
RemIBob —- Immediately remove a Bob from the gel list and the RastPort. 


SYNOPSIS 
RemiBob(bob, rp,. vp) 
a0 al a2 


struct Bob *bob; 
struct RastPort *rp; 
struct ViewPort *vp; 


FUNCTION 
Removes a Bob immediately by uncoupling it from the gel list and 
erases it from the RastPort. 


INPUTS 
bob = pointer to the Bob to be removed 
rp = pointer to the RastPort if the Bob is to be erased 
vp = pointer to the ViewPort for beam-synchronizing 


wou 


BUGS 


SEE ALSO 
InitGels RemVSprite graphics/gels.h 











il 


graphics. library/RemVSprite graphics. library/RemVSprite 


NAME 
RemVSprite -- Remove a VSprite from the current gel list. 


SYNOPSIS 
RemVSprite(vs) 
ad 


struct VSprite *vs; 


FUNCTION : 
Unlinks the vVSprite from the current gel list. 
INPUTS . 
vs = pointer to the vSprite structure to be removed from the gel list 
BUGS 
SEE ALSO 
InitGels RemIBob graphics/gels.h 








40T - ¥ 





graphics. library/ScrollRaster 





graphics. library/ScrollRaster 


NAME 
ScrollRaster ~~ Push bits in rectangle in raster around by 
dx,dy towards 0,0 inside rectangle. 
SYNOPSIS 
ScrollRaster( rp, dx, dy, xmin, ymin, xmax, ymax) 
al dao dl d2 a3 a4 a5 
struct RastPort *rp; 
SHORT dx,dy; 
SHORT xmin, ymin; 
SHORT xmax , ymax; 
FUNCTION 
Move the bits in the raster by (dx,dy) towards (0,0) 
The space vacated is RectFilled with BGPen. 
Limit the scroll operation to the rectangle defined 
by (xmin,ymin) (xmax,ymax). Bits outside will not be 
affected. If xmax,ymax is outside the rastport then use 
the lower right corner of the rastport. 
If you are dealing with a SimpleRefresh layered RastPort you 
should check rp->Layer—>Flags & LAYER_REFRESH to see if 
there is any damage in the damage list. If there is you should 
call the appropriate BeginRefresh(Intuition) or BeginUpdate(graphics) 
routine sequence. 
INPUTS 


rp — pointer to a RastPort structure 

dx,dy are integers that may be postive, zero, or negative 
xmin,ymin ~ upper left of bounding rectangle 

xmax, ymax - lower right of bounding rectangle 


EXAMPLE 
ScroliRaster(rp,0,1) /7* shift raster up by one row */ 
ScrollRaster(rp,-l,-l) /* shift raster down and to the right by 1 pixel 


BUGS 
In 1.2/V1.3 if you ScrollRaster a SUPERBITMAP exactly left or right, 
and there is no TmpRas attached-to the RastPort, the system will 
allocate one for you, but will never free it or record its location. 
The only workaround is to attach a valid TmpRas of size at least 
MAXBYTESPERROW to the RastPort before the call. 
ScrollRaster does not add the shifted areas into the damage list. 
This can cause difficulties for SIMPLE REFRESH windows. 

SEE ALSO 


graphics/rastport .h 





graphics. library/ScrollivPort 








graphics. library/ScrollvPort. 


~ NAME 
ScrollvPort ~~ Reinterpret RasInfo information in ViewPort. 
SYNOPSIS 
ScrollvPort( vp ) 
ad 
struct ViewPort *vp; 
FUNCTION 
After the programmer has adjusted the Offset values in 
the RasInfo structures of ViewPort, change the 
the copper lists to reflect the the Scroll positions. 
Changing the BitMap ptr in RasInfo and not changing the 
the Offsets will effect a double buffering affect. 
INPUTS 


vp ~ pointer to a ViewPort structure 
that is currently be displayed. 
RESULTS 
modifies hardware and intermediate copperlists to reflect 
new RasInfo 


BUGS 
pokes not fast enough to avoid some visible hashing of display 


SEE ALSO 
MakeVPort MrgCop LoadView graphics/view.h 





s0T —-¥ 


i 














graphics. library/SetAPen 


Prnehise: Nbrany/sotare 
NAME 


SetAPen —- Set primary pen 


SYNOPSIS 
SetAPen( rp, pen ) 
al do 


struct RastPort *rp; 
UBYTE pen; 


FUNCTION 
Set the primary drawing pen for lines, fills, and text. 


INPUTS 
rp — pointer to RastPort structure. 
pen — (0-255) 


RESULT 
Changes the minterms in the RastPort to reflect new primary pen. 
Set line drawer to restart pattern. 





BUGS 


SEE ALSO 
SetBPen graphics/rastport.h 











graphics. library/SetBPen graphics. library/SetBPen 


NAME 
SetBPen —- Set secondary pen 
SYNOPSIS 
SetBPen( rp, pen ) 
al dO 
struct RastPort *rp; 
UBYTE pen; 
FUNCTION 
Set the secondary drawing pen for lines, fills, and text. 
INPUTS 
rp ~ pointer to RastPort structure. 
pen ~ (0-255) 
RESULT 
Changes the minterms in the RastPort to reflect new secondary pen. 
Set line drawer to restart pattern. 
BUGS 
SEE ALSO 


SetAPen graphics/rastport.h 











60T -— ¥ 


graphics. library/SetCollision 





graphics. library/SetCollision 


NAME 
SetCollision -- Set a pointer to a user collision routine. 
SYNOPSIS 
SetCollision(num, routine, GInfo) 
do ad al 
ULONG num; 


VOID (*routine)(); 
struct GelsInfo *GInfo; 


FUNCTION 
Sets a specified entry (num) in the user's collision vectors table 
equal to the address of the specified collision routine. 


INPUTS 
num = collision vector number 
routine = pointer to the user's collision routine 
GInfo = pointer to a GelsInfo structure 


BUGS 


SEE ALSO 
InitGels graphics/gels.h graphics/rastport.h 





graphics. library/SetDrmd 








graphics. library/SetDrmMd 


NAME 
SetDrMd -- Set drawing mode 
SYNOPSTS 
SetDrMd( rp, mode ) 
al d0:8 
struct RastPort *rp; 
UBYTE mode; 
FUNCTION 
Set the drawing mode for lines, fills and text. 
Get the bit definitions from rastport.h 
INPUTS 


rp — pointer to RastPort structure. 
mode ~ 0-255, some combinations may not make much sense. 


RESULT 
The mode set is dependant on the bits selected. 
Change minterms to reflect new drawing mode. 
Set line drawer to restart pattern. 


BUGS 


SEE ALSO 
SetAPen graphics/rastport.h 





oit -v 








graphics. library/SetFont graphics. library/SetFont 


NAME, 

SetFont -- Set the text font and attributes in a RastPort. 
SYNOPSIS 

SetFont(rp, font) 


al ad 


struct. RastPort *rp; 
struct TextFont *font; 


FUNCTION 
This function sets the font in the RastPort to that described 
by font, and updates the text attributes to reflect that 
change. If font is zero, this call leaves the RastPort 
with no font. This function clears the effect of any previous 
soft styles. 


INPUTS 
rp - the RastPort in which the text attributes are to be changed 
font — pointer to a’ TextFont structure returned from OpenFont 
or OpenDiskFont 


BUGS 


SEE ALSO 
OpenFont diskfont.library/OpenDiskFont graphics/text.h 





graphics. library/SetoPen graphics. library/SetoPen 


NAME 
SetOPen -- Change the Area OutLine pen and turn on Outline 
mode for areafills. 
SYNOPSIS 
SetoOPen(rp, pen) 
struct RastPort *rp; 
UBYTE pen; 
FUNCTION 
This is implemented as a c-macro. 
Pen is the pen number that will be used to draw a border 
around an areafill during AreaEnd(). 
INPUTS 
rp = pointer to RastPort structure 
pen = number between 0-255 
BUGS 
SEE ALSO 


AreaEnd() graphics/gfxmacros.h graphics/rastport.h 


lL 











Ttt - ¥ 








graphics. library/SetRast 


NAME 
SetRast ~ Set an entire drawing area to a specified color. 


SYNOPSIS 
SetRast( rp, pen ) 
al ao 


struct RastPort *rp; 
UBYTE pen; 


FUNCTION 
Set the entire contents of the specified RastPort to the 
specified pen. 
INPUTS 
rp — pointer to RastPort structure 
pen — the pen number (0-255) to jam into bitmap 


RESULT 
The drawing area becomes the selected pen number. 


BUGS 


SEE ALSO 
RectFill graphics/rastport.h 


graphics. library/SetRast graphics. library/SetRGB4 





graphics. library/SetRGB4 


NAMB 
SetRGB4 —— Set one color register for this viewport. 


SYNOPSIS 
SetRGB4( vp, n, Yr, g, b) 
aQ dO d@1:4 d2:4 d3:4 


struct ViewPort *vp; 
SHORT n; - 
UBYTE r,g,b; 


FUNCTION 
Change the color look up table so that this viewport displays 
the color (r,g,b) for pen number n. 


INPUTS 
vp - pointer to viewport structure 


n the color number (range from 0 to 31) 
xr ~ red level 
g - green level 
b - blue level 
RESULT 


If there is a ColorMap for this viewport store the value in 
in the structure ColorMap. 

The selected color register is changed to match your specs. 
If the color value is unused then nothing will happen. 


BUGS 


SEE ALSO 
LoadRGB4 GetRGB4 graphics/view.h 








hh 





ctl - © 











graphics. library/SetRGB4CM graphics. library/SetRGB4CM 


NAME 
SetRGB4CM —- Set one color register for this ColorMap. 


SYNOPSIS 
SetRGB4CM( om, n, Xx; g; b) 
aO dO dil:4 d2:4 d3:4 


struct ColorMap *cm; 


SHORT n; 
UBYTE r,g,b; 
INPUTS 
cm = colormap 
n = the color number (range from 0 to 31) 
r= red level 
g = green level 
b = blue level 
RESULT 


Store the (r,g,b) triplet at index n of the ColorMap structure. 
This function can be used to set up a ColorMap before before 
linking it into a viewport. 


BUGS 


SEE ALSO 
GetColorMap GetRGB4 SetRGB4 graphics/view.h 


graphics. library/SetSoftStyle 








graphics. library/SetsoftStyle 


NAME 
SetSoftStyle -- Set the soft style of the current font. 


SYNOPSIS 
newStyle = SetSoftStyle(rp, style, enable) 
ao al do dl 


ULONG newStyle; 
struct RastPort *rp; 
ULONG style; 

ULONG enable; 


FUNCTION 
This function alters the soft style of the current font. Only 
those bits that are also set. in enable are affected. The 
resulting style is returned, since some style request changes 
will not be honored when the implicit style of the font 
precludes changing them. 


INPUTS 
rp - the RastPort from which the font and style are extracted. 
style —- the new font style to set, subject to enable. 
enable - those bits in style to be changed. Any set bits here 
that would not be set as a result of AskSoftStyle will 
be ignored, and the newStyle result. will not be as 
expected. 


RESULTS 
newStyle - the resulting style, both as a result of previous 
soft style selection, the effect of this function, and 
the style inherent in the set font. 


BUGS 


SEE ALSO 
AskSoftStyle graphics/text.h 








€It - ¥ 








graphics. library/SortGList graphics. library/SortGList 


NAME 
SortGList -- Sort the current gel list, ordering its y,x coordinates. 


SYNOPSIS 
SortGLlist(rp) 
al 


FUNCTION 
Sorts the current gel list according to the gels' y,x coordinates. 
This sorting is essential before calls to DrawGList or DoCollision. 


INPUTS 
rp = pointer to the RastPort structure containing the GelsInfo 


BUGS 


SEE ALSO 
InitGels DoCollision DrawGList graphics/rastport.h 





graphics. library/SyncSBitMap graphics. library/SyncSBitMap 
NAME 
SyncSBitMap -- Syncronize Super BitMap with whatever is 


in the standard Layer bounds. 


SYNOPSIS 
SyncSBitMap( layer } 
ad 


struct Layer *layer; 


FUNCTION 
Copy all bits from ClipRects in Layer into Super BitMap 
BitMap. This is used for those functions that do not 
want to deal with the ClipRect structures but do want 
to be able to work with a SuperBitMap Layer. 


INPUTS 
layer — pointer to a Layer that has a SuperBitMap 
The Layer should already be locked by the caller. 


RESULT 
A bitmap that the programmer can now diddle with the bits. 
After diddling the programmer should call CopySBitMap to 
copy the bits back into the onscreen layer. 


BUGS 


SEE ALSO 
CopySBitMap graphics/clip.h 








VIT - W 





graphics. library/Text 





graphics. library/Text 


NAME 
Text -~ Write text characters (no formatting). 
SYNOPSIS 
Text(rp, string, count) 
al ad d0-0:16 


struct RastPort *rp; 
STRPTR string; 
SHORT count; 


FUNCTION 

This graphics function writes printable text characters to the 
specified RastPort at the current position. No control meaning 
is applied to any of the characters, and only text on the 
current line is output. 

If the characters displayed run past the RastPort boundary, 

the current position is truncated to the boundary, and 

thus does not represent the true position. 


INPUTS 

rp - a pointer to the RastPort which describes where the 
text is to be output 

count — the string length. 
to be output. 

string ~ the address of string to output 


If zero, there are no characters 


BUGS 


The maximum string length (in pixels) is limited to (1024 — 16 = 1008) 
pixels wide. 


Text is clipped to the width of the rastport even if the Text() write 
was made starting to the left of the rastport. 


SEE ALSO 
Move TextLength graphics/text.h graphics/rastport.h 





graphics. library/TextLength 








graphics. library/TextLength 


NAME 
TextLength ~— Determine raster length of text data. 


SYNOPSIS 
length = TextLength(rp, string, count) 
a0:16 al a do:16 


SHORT length; 

struct RastPort *rp; 
STRPTR string; 

SHORT count; 


FUNCTION 
This graphics function determines the length that text data 
would occupy if output to the specified RastPort with the 
current attributes. The length is specified as the number of 
raster dots: to determine what the current position would be 
after a Write using this string, add the length to cp_x 
(cp_y is unchanged by Write). 


INPUTS 
rp - a pointer to the RastPort which describes where the 
text attributes reside. 
string - the address of string to determine the length of 
count — the string length. If zero, there are no characters 
in the string. 


RESULTS 
length — the number of pixels in x this text would occupy, not 
including any negative kerning that may take place at 
the beginning of the text string, nor taking into 
account the effects of any clipping that may take 
place. 


BUGS 
A length that would overflow single word arithmatic is not 
calculated correctly. 


SEE ALSO 
Text graphics/text.h graphics/rastport.h 





Sit —- ¥ 


graphics. library/UnlockLayerRom 
* 





graphics. library/UnlockLayerRom 


NAME 
UnlockLayerRom —— Unlock Layer structure by rom(gfx lib) code. 


SYNOPSTS 
UnlockLayerRom( layer ) 
a5 


FUNCTION 
Release the lock on this layer. If the same task has called 
LockLayerRom more than once than the same number of calls to 
UnlockLayerRom must happen before the layer is actually freed 
so that other tasks may use it. 
This call does destroy scratch registers. 
This call is identical to UnlockLayer (layers.library). 


INPUTS 
layer - pointer to Layer structure 


BUGS 


SEE ALSO 
LockLayerRom graphics/clip.h 
* 


graphics. library/VBeamPos 





graphics. library/VBeamPos 


NAME 
VBeamPos ~~ Get vertical beam position at. this instant. 


SYNOPSIS 
pos = VBeamPos() 
ao 


LONG pos; 


FUNCTION 
Get the vertical beam position from the hardware. 


INPUTS 
none 


RESULT 
interrogates hardware for beam position and returns value. 
valid results in the range of 0-511 
Because of multitasking, the actual value returned may have 
no use. If you are the highest priority task then the value 
returned should be close,. within 1 line. 


BUGS 


SEE ALSO 


9TT - © 














graphics. library/WaitBlit graphics. library/WaitBlit 
NAME 
WaitBlit -- Wait for the blitter to be finished before proceeding 
with anything else. 


SYNOPSIS 
WaitBlit() 


FUNCTION 
WaitBlit returns when the blitter is idle. This function should 
normally only be used when dealing with the blitter in a 
synchronous manner, such as when using OwnBlitter and DisownBlitter. 
WaitBlit does not wait for all blits queved up using QBlit or 
QBSBlit. You should call WaitBlit if you are just about to free 
some memory that you have used with the blitter. 


Note that many graphics calls fire up the blitter, and let it run. 


The CPU does not need to wait for the blitter to finish before returning. 


When examining bits with the CPU right after a blit, or when freeeing 
temorary memory used by the blitter, a WaitBlit() may be required. 


INPUTS 
none 


RESULT 
Your program waits until the blitter is finished. Unlike most Amiga rom 
routines, the CPU registers DO/D1/A0 and Al are preserved by this call. 


BUGS 
There is a bug in the older revisions of the Agnus chip that can 
cause the BUSY bit to indicate the blit has finished when the blitter 
has, in fact, not started the blit yet (even though BltSize has been 
written). This most often occurs in a heavily loaded systen with 
extended memory, HIRES, and 4 bitplanes. WaitBlit currently tries to 
avoid the Agnus problem by testing the BUSY bit multiple times to make 
sure the blitter has started, there is no need for further action on the 
part of the WaitBlit user. Also this pig busy waits. (sigh) 


The hardware bug was fixed as of the first "Fat Agnus" chip, as used 
in all A500 and A2000 computers. 


SEE ALSO 
OwnBlitter DisownBlitter hardware/blit.h 


graphics. library/WaitBOvP graphics. library/WaitBOVP 
* 
NAME 
WaitBOVP -- Wait till vertical beam reached bottom of 
this viewport. 


SYNOPSIS 
WaitBOVP( vp ) 
ad 


FUNCTION 
Returns when vertical beam reaches bottom of this viewport 


INPUTS 
vp — pointer to ViewPort structure 


RESULT 
This function will return sometime after the beam gets beyond 
the bottom of the viewport. Depending on the multitasking load 
of the system, the actual beam position may be different than 
what would be expected in a lightly loaded system. 


BUGS 
Horrors! This function currently busy waits waiting for the 
beam to get to the right place. It should use the copper 
interrupt to trigger and send signals like WaitTOF does. 


SEE ALSO 
WaitTOF VBeamPos 














LTT - ¥ 


graphics. library/Wait TOF 





graphics. library/WaitTOF 


NAME 
WaitTOP — Wait for the top of the next video frame. 


SYNOPSIS 
Wait TOF() 


FUNCTION 
Wait for vertical blank to occur and all vertical blank 
interrupt routines to complete before returning to caller. 


INPUTS 
none 


RESULT 
Place this task on the TOF wait queue. When vertical blank 
interupt comes around the interrupt service routine fires off 
signals to all the tasks doing WaitTOF. The highest priority task 
ready gets to run then. 


BUGS 


SEE ALSO 
exec/Wait exec/Signal 


~ (graphics. library/writePixel 








graphics. library/WritePixel 


NAME 
“ WritePixel -- Change the pen num of one specific pixel ina 
specified RasterPort. 
SYNOPSIS 
error = WritePixel( rp, xX, yY) 
do al DO DiI 
LONG error; 
struct RastPort *rp; 
SHORT X,Y; 
FUNCTION 


Changes the pen number of the selected pixel in the specified 
RastPort to that currently specified by PenA, the primary 
drawing pen. Obey minterms in RastPort. 


INPUTS 
rp ~ a pointer to the RastPort structure 
(x,y) 7 point within the RastPort at which the selected 
pixel is located. 


RESULT 
error = 0 if pixel succesfully changed 
=-l if (x,y) is outside the RastPort 
BUGS 


SEE ALSO 
ReadPixel graphics/rastport.h 








8TT - 














graphics. library/XorRectRegion graphics. library/XorRectRegion 


NAME 
XorRectRegion ~- Perform 2d XOR operation of rectangle 
with region, leaving result in region 
SYNOPSIS 
status = XorRectRegion(region, rectangle) 
ao ad al 
BOOL status; 
struct Region *region; 
struct Rectangle *rectangle; 
FUNCTION 
Add portions of rectangle to region if they are not in 
the region. 
Remove portions of rectangle from region if they are 
in the region. 
INPUTS 


region — pointer to Region structure 
rectangle — pointer to Rectangle structure 


RESULTS 
status - return TRUE if successful operation 
return FALSE if ran out of memory 


BUGS 


SEE ALSO 
OrRegionRegion AndRegionRegion graphics/regions.h 


graphics. library/XorRegionRegion 








graphics. library/XorRegionRegion 


NAME. 
XorRegionRegion —- Perform 2d XOR operation of one region . 
with second region, leaving result in second region 


SYNOPSIS 
status = XorRegionRegion(regionl, region2) 
do ad al 


BOOL status; 
struct Region *regionl, *region2; 


FUNCTION . 
Join the regions together. If any part of regionl overlaps 
region2 then remove that from the new region. 


INPUTS 
regionl 
region2 


pointer to Region structure 
pointer to Region structure 


iow 


RESULTS 
status - return TRUE if successful operation 
return FALSE if ran out of memory 


BUGS 








6TI - ¥ 











— 
TABLE OF CONTENTS icon. library/AddFreeList icon. library/AddFreeList 
icon. library/AddFreeList NAME 

icon. library/BumpRevision AddFreeList - add memory to the free list 

icon. library/FindToolType | 

icon. library/FreeDiskoObject SYNOPSIS 

icon. library/FreeFreeList status = AddFreehist( free, mem, len ) 

icon. library/GetDiskObject. bo AO Al A2 

icon. library/MatchToolvalue 

icon. library/PutDiskobject FUNCTION 


This routine adds the specified memory to the free list. 
The free list will be extended (if required). If there 
is not enough memory to complete the call, a null is returned. 


Note that AddFreeList does NOT allocate the requested memory. 
It only records the memory in the free list. 


INPUTS 
free -- a pointer to a FreeList structure 
mem —- the base of the memory to be recorded 


len -- the length of the memory to be recorded 


RESULTS 
status -- nonzero if the call succeeded. 





EXCEPTIONS 


SEE ALSO 
AllocEntry, FreeEntry, FreeFreeList 


BUGS 














iil 


oe—T - ¥ 


icon. library/BumpRevision 





NAME 

BumpRevision - reformat a name for a second copy 
SYNOPSIS 

result = BumpRevision( newbuf, oldname  ) 

DO AO Al 
FUNCTION 


BumpRevision takes a name an turns it into a “copy of name". 
It knows how to deal with copies of copies. The routine 
will truncate the new name to the maximum dos name size 
(currently 30 characters). 


INPUTS 
newbuf ~ the new buffer that will receive the name (it must 
be at least 31 characters long). 
oldname - the original name 


RESULTS 
result -— a pointer to newbuf 

EXCEPTIONS 

EXAMPLE 
oldname newbuf 
"foo" “copy of foo" 
"copy of foo" "copy 2 of foo" 
“copy 2 of foo" "copy 3 of foo" 
"copy 199 of foo" “copy 200 of foo" 
“copy foo" "copy of copy foo" 
“copy 0 of foo" “copy lL of foo" 
"012345678901234567890123456789" “copy of 0123456789012345678901" 

SEE ALSO 

BUGS 


icon. Llibrary/BumpRevision icon. library/FindToolType 








icon. library/FindToolType 


NAME 

FindToolType — find the value of a ToolType. variable 
SYNOPSTS 

value = FindToolType(: toolTypeArray, typeName  ) 

DO AO Al 
FUNCTION 


This function searches a tool type array for a given entry, 
and returns a pointer to that entry. This is useful for 
finding standard tool type variables. The returned 
value is not a new copy of the string but is only 
a pointer to the part of the string after typeName. 


INPUTS 
toolTypeArray — an array of strings 
typeName — the name of the tooltype entry 


RESULTS 
value — a pointer to a string that is the value bound to 
typeName, or NULL if typeName is not in 
the toolTypeArray. 


EXCEPTIONS 


EXAMPLE 
Assume the tool type array has two strings in it: 
“FILETYPE=text" 
“TEMPDIR=:t" 





FindToolType( toolTypeArray, "FILETYPE" ) returns "text" 
FindToolType( toolTypeArray, "TEMPDIR" ) returns ":t" 
FindToolType( toolTypeArray, "MAXSIZE" ) returns NULL 


SEE ALSO 
MatchTool Value 





BUGS 











T2T - ¥ 





icon. library/FreeDiskobject 





icon. library/FreeDiskObject 


NAME 
FreeDiskObject — free all memory in a Workbench disk object 


SYNOPSIS 
FreeDiskObject( diskobj ) 
AO 


FUNCTION 
This routine frees all memory in a Workbench disk object, and the 
object itself. It is implemented via FreeFreeList() 
GetDiskObject() takes care of all the initialization required 
to set up the objects free list. This procedure may ONLY 
be called on DiskObject allocated via GetDiskobject(). 


INPUTS 
diskobj —- a pointer to a Diskobject structure 


RESULTS 
EXCEPTIONS 


SEE ALSO 
GetDiskObject, FreeFreeList 


BUGS 











icon. library/FreeFreeList 


NAME 
FreeFreeList — free all memory in a free list 


SYNOPSIS 
FreeFreeList( free ) 
AO 


FUNCTION 
This routine frees all memory in a free list, and the 
free list itself. It is useful for easily getting 
rid of all memory in a series of structures. There is 
a free list in a Workbench object, and this contains 
all the memory associated with that object. 


A FreeList is a list of MemList structures. See the 
MemList and MemEntry documentation for more information. 


If the FreeList itself is in the free list, it must be 
in the first MemList in the FreeList. 


INPUTS 
free -- a pointer to a FreeList structure 


RESULTS 
EXCEPTIONS 


SEE ALSO 
AllocEntry, FreeEntry, AddFreeList 


BUGS 


icon. library/FreeFreeList 





cet — © 





| 











icon. library/GetDiskObject icon. Library/GetDiskoObject. 


NAME 

GetDiskObject - read in a Workbench disk object 
SYNOPSIS 

diskobj = GetDiskObject( name ) 

DO AO 
FUNCTION 


This routine reads in a Workbench disk object in from disk. The 
name parameter will have a ".info" postpended to it, and the 
info file of that name will be read. If the call fails, 
it will return zero. The reason for the failure may be obtained 
via IoErr(). 


Using this routine protects you from any future changes to 
the way icons are stored within the system. 


A FreeList structure is allocated just after the Diskobject 
structure; FreeDiskObject makes use of this to get rid of the 
Memory that was allocated. 


INPUTS 
name ~- name of the object 


RESULTS 
diskobj -- the Workbench disk object in question 


EXCEPTIONS 


SEE ALSO 
FreeDiskObject. 


BUGS 


icon. library/MatchToolValue 





icon. library/MatchToolValue 


NAME 

MatchToolValue - check a tool type variable for a particular value 
SYNOPSIS 

result = MatchToolValue( typeString, value ) 

DO AO Al 
FUNCTION 


MatchToolValue is useful for parsing a tool type value for 
a known value. It knows how to parse the syntax for a tool 
type value (in particular, it knows that ifn separates 
alternate values). 


INPUTS 
typeString -— a ToolType value (as returned by FindToolType) 
value - you are interested if value appears in typeString 


RESULTS 
result - a one if the value was in typeString 
EXCEPTIONS 
EXAMPLE 
Assume there are two type strings: 
typel = "text" 
type2 = "alb|c" 


MatchToolValue( typel, "text" ) returns 1 
MatchToolValue( typel, "data" ) returns 0 
MatchToolValue( type2, "al! ) returns 1 
MatchToolValue( type2, "“b" ) returns 1 
MatchToolValue( type2, "d" ) returns 0 
MatchToolValue( type2, "alb" ) returns 0 


SEE ALSO 
FindToolType 


BUGS 














cet -W 








icon. library/PutDiskObject icon. library/PutDiskObject 


NAME 
PutDiskObject - write out a DiskObject to disk 


SYNOPSIS 
status = PutDiskObject( name, diskobj ) 
DO AO Al 


FUNCTION 
This routine writes out a DiskObject structure, and its 
associated information. The file name of the info 
file will be the name parameter with a 
".info" postpended to it. If the call fails, a zero will 
be returned. The reason for the failure may be obtained 
via IoErr(). 


Using this routine protects you from any future changes to 
the way icons are stored within the system. 


INPUTS 
name —— name of the object 
diskobj -- a pointer to a DiskObject 


RESULTS 
status -- non-zero if the call succeeded 


EXCEPTIONS 


SEE ALSO 
GetDiskobject, FreeDiskobject 


BUGS 





tT 


vel - © 


TABLE OF CONTENTS 


intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition, 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 
intuition. 


library/ActivateGadget 
library/ActivateWindow 
library/AddGadget 
library/AddGList 
library/AllocRemember 
library/AutoRequest 
library/BeginRefresh 
library/BuildsysRequest 
library/ClearDMRequest 
library/ClearMenuStrip 
library/ClearPointer 
library/CloseScreen 
library/CloseWindow 
library/CloseWorkBench 
library/CurrentTime 
library/DisplayAlert 
library/DisplayBeep 
library/DoubleClick 
library/DrawBorder 
library/DrawImage 
library/EndRefresh 
library/EndRequest 
library/FreeRemember 
library/FreeSysRequest 
library/GetDefPrefs 
library/GetPrefs 
library/GetScreenData 
library/InitRequester 
library/IntuiTextLength 
library/ItemAddress 
library/LockI Base 
library/MakeScreen 
library /Modi fyIDCMP 
library/ModifyProp 
library /MoveScreen 
library/MovewWindow 
library/NewModifyProp 
library/Of {Gadget 
library/OffMenu 
library/OnGadget 
library/OnMenu 
library/OpenScreen 
library/OpenWindow 
library/OpenWorkBench 
library/PrintIText 
library/RefreshGadgets 
library/RefreshGList 
library/RefreshWindowFrame 
library/RemakeDisplay 
library/RemoveGadget. 
library/RemoveGList 
library/ReportMouse 
library/Request 
library/RethinkDisplay 
library/ScreenToBack 
library/ScreenToFront. 
library/SetDMRequest 
library/SetMenuStrip 
library/SetPointer 
library/SetPrefs 
library/SetWindowTitles 
library/ShowTitle 
library/SizeWindow 
library/UnlockIBase 
library/ViewAddress 
library/ViewPortAddress 
library/WBenchToBack 
library/WBenchToFront 
library/WindowLimits 
library /WindowToBack 


intuition. library/WindowToFront 


itl 











Sel - ¥ 








intuition. library/ActivateGadget intuition. library/ActivateGadget 


NAME 
ActivateGadget —- Activate a (String) Gadget. 
SYNOPSIS 
Success = ActivateGadget (Gadget, Window, Request) 
DO AO Al A2 


BOOL Success; 

struct Gadget *Gadget; 
struct Window *Window; 
struct Requester *Request; 


FUNCTION 
Activates a String Gadget. If successful, this means that the user 
does not need to click in the gadget before typing. 


The Window parameter must point to the window which contains the Gadget. 


If the gadget is actually in a Requester, the Window must contain 
the Requester, and a pointer to the Requester must also be 

passed. The Requester parameter must only be valid if the Gadget 
has the REQGADGET flag.set, a requirement for all Requester Gadgets. 


The success of this function depends on a rather complex set 
of conditions. The intent is that the user is never interrupted from 
what interactions he may have underway. 


The current set of conditions includes: 

-— The Window must be active. (Use the ACTIVEWINDOW IDCMP). 

- No other gadgets may be in use. This includes system gadgets, 
such as those for window sizing, dragging, etc. 

- If the gadget is in'a Requester, that Requester must 
be active. (Use the REQSET and REQCLEAR IDCMP). 

- The right mouse button cannot be held down (e.g. menus 


INPUTS 
Gadget = pointer to the Gadget that you want activated. 
Window = pointer to a Window structure containing the Gadget. 
Requester = pointer to a Requester (may by NULL if this isn't 
a Requester Gadget (i.e. REQGADGET is not set)). 


RESULT 
If the conditions above are met, and the Gadget is in fact a String 
Gadget, then this function will return TRUE, else FALSE. 

BUGS 


SEE ALSO 


intuition. library/ActivateWindow 





intuition. library/ActivatewWindow 


NAME 

ActivateWindow -- Activate an Intuition Window. 
SYNOPSIS 

ActivateWindow(Window) 


AO 
struct Window *Window; 


FUNCTION 
Activates an Intuition Window. 


Note that this call may have its action deferred: you cannot assume 

that when this call is made the selected window has become active. 

This action will be postponed while the user plays with gadgets and menus, 
or sizes and drags windows. You may detect when the window actually 

has become active by the ACTIVEWINDOW IDCMP Message. 


This call is intended to provide flexibility but not to confuse the 
user. Please call this function synchronously with some action 
by the user. 


INPUTS 
Window = a pointer to a Window structure 


RESULT 
None 


BUGS 
Calling this function in a tight loop can blow out Intuition's deferred 


action queue. 


SEE ALSO 
OpenWindow(), and the ACTIVATE Window Flag 














9cT — © 


intuition. library/AddGadget 








intuition. library/AddGadget 


NAME 

AddGadget -- Add a Gadget to the Gadget list of the Window or Screen. 
SYNOPSIS 

RealPosition = AddGadget(Window, Gadget, Position) 

bo AO Al DO 


USHORT RealPosition; 
struct Window *Window; 
struct Gadget *Gadget; 
USHORT Position; 


FUNCTION 
Adds the specified Gadget to the Gadget list of the given Window, 
linked in at the position in the list specified by the Position 
argument (that is, if Pos == 0, the Gadget will be inserted at the 
head of the list, and if Position == 1 then the Gadget will be inserted 
after the first Gadget and before the second). If the Position 
you specify is greater than the number of Gadgets in the list, 
your Gadget will be added to the end of the list. 


Calling AddGadget() does not cause your gadget do be redisplayed. 
The benefit of this is that you may add several gadgets without having 
the gadget list be redrawn every time. 


This procedure returns the position at which your Gadget was added. 


NOTE: A relatively safe way to add the Gadget to the end of the 

list is to specify a Position of -1 (i.e., (USHORT) ~0). That way, 
only the 65536th (and multiples of it) will be inserted at the wrong 
position. The return value of the procedure will tell you where it was 
actually inserted. 


NOTE: The System Window Gadgets are initially added to the 

front of the Gadget List. The reason for this is: If you position your 
own Gadgets in some way that interferes with the graphical representation 
of the system Gadgets, the system's ones will be "hit" 

first by User. If you then start adding Gadgets to the front of the list, 
you will disturb this plan, so beware. On the other hand, if you don't 
violate the design rule of never overlapping your Gadgets, there's no 
problem. 


NOTE: You may not add your own gadgets to a Screen. Gadgets may 
be added to backdrop windows, however, which can be visually similar, 
but also provide an IDCMP channel for gadget input messages. 


INPUTS 
Window = pointer to the Window to get your Gadget 
Gadget = pointer to the new Gadget 
Position = integer position in the list for the new Gadget (starting from 
zero as the first position in the list) 


RESULT 
Returns the position of where the Gadget was actually added. 


BUGS 


SEE ALSO 
AddGList(), RemoveGadget () 


intuition. library/AddGList 


FUNCTION 


intuition. library/AddGList 


AddGList -- adda linked list of gadgets to a Window or Requester 


SYNOPSIS 


RealPosition = AddGList(Window, Gadget, Position, Numgad, Requester); 
DO AO Al DO DL A2 


USHORT RealPosition; 

struct Window *Window; 
struct Gadget *Gadget; 
USHORT Position; 

USHORT Numgad; 

struct Requester *Requester; 


Adds the list of Gadgets to the Gadget list of the given Window 
or Requester linked in at the position in the list specified by 
the Position argument. 


See AddGadget() for more information about gadget list position. 


The Requester parameter will be ignored unless the REQGADGET bit 
is set in the GadgetType field of the first Gadget in the list. 

In that case, the gadget list is added to the Requester gadgets. 
NOTE: be sure that REQGADGET is either set of cleared consistently 
for all gadgets in the list. NOTE ALSO: The Window parameter 
should point to the Window that the Requester (will) appear in. 


Will add 'Numgad' gadgets from gadget list linked by the field 
NextGadget, or until some NextGadget field is found to be NULL. Does 
not assume that the Numgad'th gadget has NextGadget equal to NULL. 





NOTE WELL: In order to link your gadget list in, the NextGadget 

field of the Numgad'th (or last) gadget will be modified. Thus, if 
you are adding the first 3 gadgets from a linked list of five gadgets, 
this call will sever the connection between your third and fourth 
gadgets. 


INPUTS 


Window = pointer to the Window to get your Gadget 
Gadget = pointer to the first Gadget to be added 
Position = integer position in the list for the new Gadget 
(starting from zero as the first position in the list) 
Numgad = the number of gadgets from the linked list to be added 
if Numgad equals -l1, the entire null-terminated list of 
gadgets will be added. 
Requester = the requester the gadgets will be added to if the 
REQGADGET GadgetType flag is set for the first gadget in the list 


RESULT 


Returns the position of where the first Gadget in the list was actually 
added. 


BUGS 


SEE ALSO 


AddGadget(), RemoveGadget() 








4@T - ¥ 








intuition. library/AllocRemember 


intuition. library/AllocRemember 


NAME 

AllocRemember -- AllocMem and create a link node to make FreeMem easy. 
SYNOPSIS 

MemBlock = AllocRemember(RememberKey, Size, Flags) 

po AO bo DL 


CPTR MemBlock; 

struct Remember **RememberKey; 
ULONG Size; 

ULONG Flags; 


FUNCTION 
This routine calls the EXEC AllocMem() function for you, but also links 
the parameters of the allocation into a master list, so that 
you can simply call the Intuition routine FreeRemember() at a later 
time to deallocate all allocated memory without being required to 
remember the details of the memory you've allocated. 


This routine will have two primary uses: 

- Let's say that you're doing a long series of allocations in a 
procedure (such as the Intuition OpenWindow() procedure). 
If any one of the allocations fails for lack of memory, you 
need to abort the procedure. Abandoning ship correctly involves 
freeing up what memory you've already allocated. This procedure 
allows you to free up that memory easily, without being required 
to keep track of how many allocations you've already done, what the 
sizes of the allocations were, or where the memory was allocated. 


~ Also, in the more general case, you may do all of the allocations 
in your entire program using this routine. Then, when your 
program is exiting, you can free it all up at once witha 
simple call to FreeRemember() . 


You create the "anchor" for the allocation master list by creating 
a variable that's a pointer to struct Remember, and initializing 
that pointer to NULL. This is called the RememberKey. Whenever 
you call AllocRemember(), the routine actually does two memory 
allocations, one for the memory you want and the other for a copy 
of a Remember structure. The Remember structure is filled in 

with data describing your memory allocation, and it's linked 

into the master list pointed to by your RememberKey. Then, to 
free up any memory that's been allocated, all you have to do is 
call FreeRemember() with your RememberKey. 


Please read the FreeRemember() function description, too. As you will 
see, you can select either to free just the link nodes and keep all the 
allocated memory for yourself, or to free both the nodes and your memory 
buffers. 


INPUTS 
RememberKey = the address of a pointer to struct Remember. Before the 
very first call to AllocRemember, initialize this pointer to NULL. 
Size = the size in bytes of the memory allocation. Please refer to the 
exec. library/AllocMem function for details. 
Flags = the specifications for the memory allocation. 
the exec. library/AllocMem function for details. 


Please refer to 


EXAMPLE 
struct Remember *RememberKey ; 
RememberKey = NULL; 


AllocRemember (&RememberKey, BUFSIZE, MEMP_ CHIP); 
FreeRemember (&RememberKey, TRUE); 


RESULT 
If the memory allocation is successful, this routine returns the byte 
address of your requested memory block. Also, the node to your block 
will be linked into the list pointed to by your RememberKey variable. 


—- 





If the allocation fails, this routine returns NULL and the List pointed 
to by RememberKey, if any, will be undisturbed. 


BUGS 


SEE ALSO 
FreeRemember(), exec. library/AllocMem( ) 


8¢eT - ¥ 





intuition. library/AutoRequest intuition. library/AutoRequest 


NAME 
AutoRequest -—— Automatically build and get response from a Requester. 
SYNOPSIS 
Response = AutoRequest (Window, BodyText, PositiveText, NegativeText, 
DO AO Al A2 A3 
PositiveFlags, NegativeFlags, Width, Height) 
DO DL D2 D3 


BOOL Response; 

struct Window *Window; 

struct IntuiText *BodyText, *PositiveText, *NegativeText; 
ULONG PositiveFlags, NegativeFlags; 

SHORT Width, Height; 


PUNCTION 
This procedure automatically builds a Requester for you and then 
waits for a response from the user, or for the system to satisfy your 
request. If the response is positive, this procedure returns TRUE. 
If the response is negative, this procedure returns FALSE. 





An IDCMPFlag specification is creates by bitwise "or'ing" your 
PositiveFlags,. NegativeFlags, and the IDCMP classes GADGETUP and 
RAWKEY. You may specify zero flags for either the PositiveFlags 
or NegativeFlags arguments. 


The IntuiText arguments, and the Width and Height values, are 
passed directly to the BuildSysRequest() procedure along with 
your Window pointer and the IDCMP flags. Please refer to 
BuildSysRequest() for a description of the IntuiText that you are 
expected to supply when calling this routine. It's an important 
but long-winded description that need not be duplicated here. 


If the BuildSysRequest() procedure does not return a pointer 
to a Window, it will return TRUE or FALSE (not valid structure 
pointers) instead, and these BOOL values will. be returned to 
you immediately. 


On the other hand, if a valid Window pointer is returned, that 
Window will have had its IDCMP Ports and flags initialized according 
to your specifications. AutoRequest() then waits for IDCMP messages 
on the UserPort, which satisfies one of four requirements: 
~ either the message is of a class that matches 
one of your PositiveFlags arguments (if you've supplied 
any), in which case this routine returns TRUE. Or 
- the message class matches one of your NegativeFlags 
arguments (if you've supplied any), in which case 
this routine returns FALSE. Or 
- the IDCMP message is of class GADGETUP, which means that one of 
the two Gadgets, as provided with the PositiveText and NegativeText 
arguments, was selected by the user. If the TRUE Gadget 
was selected, TRUE is returned. If the FALSE Gadget was 
selected, FALSE is returned. 
- Lastly, two RAWKEY messages may satisfy the request: those 
for the V and B keys with the left Amiga key depressed. 
These keys, satisfy the gadgets on the left or right side of 
the Requester--TRUE or FALSE--, respectively. 


When the dust has settled, this routine calls FreeSysRequest() if 
necessary to clean up the Requester and any other allocated memory. 


INPUTS 
Window = pointer to a Window structure 
BodyText. = pointer to an IntuiText structure 
PositiveText = pointer to an IntuiText structure, may be NULL. 
NegativeText = pointer to an IntuiText structure, MUST be valid! 
PositiveFlags = flags for the IDCMP 
NegativeFlags = flags for the IDCMP 
Width, Height = the sizes to be used for the rendering of the Requester 





RESULT 
The return value is either TRUE or FALSE. See the text above for a 
complete description of the chain of events that might lead to either 
of these values being returned. 


BUGS 


SEE ALSO 
BuildSysRequest () 








ect -— ¥ 





[inet ion aera /Begionereess 





intuition. library/BeginRefresh 


NAME 


BeginRefresh -- Sets up a Window for optimized refreshing. 
SYNOPSIS 
BeginRefresh (Window) 
AO 


struct Window *Window; 


FUNCTION 
This routine sets up your Window for optimized refreshing. 


It's role is to provide Intuition integrated access to the Layers 
library function BeginUpdate(). Its additional contribution is 
to be sure that locking protocols for layers are followed, by 
locking both layers of a GIMMEZEROZERO window only after the 
parent Layer_Info has been locked. Also, the WINDOWREFRESH 

flag is set in your window, for your information. 


The purpose of BeginUpdate(), and hence BeginRefresh(), is to 
restrict rendering in a Window (Layer) to the region in 

that needs refreshing after an operation such as window sizing or 
uncovering. This restriction to the "Damage Region" persists until 
you call EndRefresh(). 


For instance, if you have a SIMPLE_REFRESH Window which is partially 
concealed and the user brings it to the front, you may receive a 
message asking you to refresh your display. If you call BeginRefresh() 
before doing any of the rendering, then the layer that underlies your 
Window will be arranged such that the only rendering that will actually 
take place will be that which goes to the newly-revealed areas. This 
is very performance-efficient, and visually attractive. 


After you have performed your refresh of the display, you should call 
EndRefresh() to reset the state of the layer and the Window. Then you 
may proceed with rendering to the Window as usual. 


You learn that your Window needs refreshing by receiving either a 
message of class REFRESHWINDOW through the IDCMP, or an input event 

of class IECLASS REFRESHWINDOW through the Console Device. Whenever 
you are told that your Window needs refreshing, you should call 
BeginRefresh() and EndRefresh() to clear the refresh-needed state, 

even if you don't plan on doing any rendering. You may relieve yourself 
of even this burden by setting the NOCAREREFRESH Flag when opening 

your window. 


INPUTS 
Window = pointer to the Window structure which needs refreshing 


RESULT 
None 


BUGS 
SEE ALSO 


EndRefresh(), layers. library/BeginUpdate(), OpenWindow( ) 
The "Windows" chapter of the Intuition Reference Manual 





La GadgetID field set to FALSE. 


intuition. library/BuildSysRequest intuition. library/BuildSysRequest 


NAME 
BuildSysRequest ~~ Build and display a system Requester. 

SYNOPSIS 
ReqWindow = BuildSysRequest (Window, BodyText, PositiveText, NegativeText, 
DO AO Al A2 A3 


IDCMPFlags, Width, Height) 
DO D2 D3 


struct Window *ReqWindow; 
struct Window *Window; 

struct IntuiText *BodyText; 
struct IntuiText *PositiveText; 
struct IntuiText *NegativeText; 
ULONG IDCMPFlags; 

SHORT Width, Height; 


FUNCTION 
This procedure builds a Requester based on the supplied information. 
If all goes well and the Requester is constructed, this procedure 
returns a pointer to the Window in which the Requester appears. 
That Window will have the IDCMP UserPort and WindowPort initialized 
to reflect the flags found in the IDCMPFlags argument. You may then 
Wait() on those ports to detect the user's response to your Requester, 
which response may include either selecting one of the Gadgets or 
causing some other event to be noticed by Intuition (like DISKINSERTED, 
for instance). After the Requester is satisfied, you should call the 
FreeSysRequest() procedure to remove the Requester and free up any 
allocated memory. 


The requester used by this function has the NOISYREQ flag bit set, 
which means that the set of IDCMPFlags that may be used here 
include RAWKEY, MOUSEBUTTONS, and others. 


If it isn't possible to construct the Requester for any reason, this 
procedure will instead use the text arguments to construct a text 
string for a cal] to the DisplayAlert() procedure, and then will return 
either a TRUE or FALSE depending on whether DisplayAlert() returned 

a FALSE or TRUE respectively. 


If the Window argument you supply is equal to NULL, a new Window will 
be created for you in the Workbench Screen. If you want the Requester 
created by this routine to be bound toa particular Window, you should 
not supply a Window argument of NULL. 

The text arguments are used to construct the display. Each is a 
pointer to an instance of the structure IntuiText. 


The BodyText argument should be used to describe the nature of 

the Requester. As usual with IntuiText data, you may link several 
lines of text together, and the text may be placed in various 
locations in the Requester. This IntuiText pointer will be stored 
in the Reqlext variable of the new Requester. : 


The PositiveText argument describes the text that you want associated 
with the user choice of "Yes, TRUE, Retry, Good." If the Requester 
is successfully opened, this text will be rendered in a Gadget in 

the lower-left of the Requester, which Gadget will have the 

GadgetID. field set to TRUE. If the Requester cannot be opened and 

the DisplayAlert() mechanism is used, this text will be rendered in 
the lower-left corner of the Alert display with additional text 
specifying that the left mouse button will select this choice. This 
pointer can be set to NULL, which specifies that there is no TRUE 
choice that can be made. 


The NegativeText. argument describes the text that you want associated 
with the user choice of "No, FALSE, Cancel, Bad." If the Requester 
is successfully opened, this text will be rendered in a Gadget in 

the lower-right of the Requester, which Gadget will have the 

If the Requester cannot be opened and 


Il 





O€T —- ¥ 


i 














the DisplayAlert() mechanism is used, this text will be rendered in 
the lower-right corner of the Alert display with additional text 
specifying that the right mouse button will select this choice. This 
pointer cannot be set to NULL. There must. always be a way for the 
user to cancel this Requester. 


The Positive and Negative Gadgets created by this routine have 
the following features: 

~ BOOLGADGET 

— RELVERIFY 

— REQGADGET 

~ TOGGLESELECT 


When defining the text for your Gadgets, you may find it convenient 

to use the special constants used by Intuition for the construction 

of the Gadgets. These include defines like AUTODRAWMODE, AUTOLEFTEDGE, 
AUTOTOPEDGE and AUTOFRONTPEN. You can find these in your local 
intuition.h (or intuition.i) file. 


The Width and Height values describe the size of the Requester. All 
of your BodyText must fit within the Width and Height of your 
Requester. The Gadgets will be created to conform to your sizes. 


VERY IMPORTANT NOTE: for this release of this procedure, a new Window 
is opened in the same Screen as the one containing your Window. ; 
Future alternatives will be provided as a function distinct from this 
one. 


INPUTS 

Window = pointer to a Window structure 

BodyText = pointer to an IntuiText structure 

PositiveText = pointer to an IntuiText structure 

NegativeText = pointer to an IntuiText structure 

IDCMPFlags = the IDCMP flags you want used for the initialization of the 
IDCMP of the Window containing this Requester 

Width, Height = the size required to render your Requester 


RESULT 
If the Requester was successfully rendered in a Window, the value 
returned by this procedure is a pointer to the Window in which the 
Requester was rendered. If, however, the Requester cannot. be rendered 
in the Window, this routine will have called DisplayAlert() before 
returning and will pass back TRUE if the user pressed the left mouse 
button and FALSE if the user pressed the right mouse button. 


BUGS 
This procedure currently opens a Window as wide as the Screen in 
which it was rendered, and then opens the Requester within that 
Window. Also, if DisplayAlert() is called, the PositiveText and 
NegativeText are not rendered in the lower corners of the Alert. 


SEE ALSO : 
FreeSysRequest(), DisplayAlert(), ModifyIDCMP(), exec. library/Wait(), 
Request()', AutoRequest() 





intuition. library/ClearDMRequest. intuition. library/ClearDMRequest 
NAME 
ClearDMRequest. ~~ clears (detaches) the DMRequest of the Window. 
SYNOPSIS 
Response = ClearDMRequest (Window) 
DO AO 


BOOL Response; 
struct Window *Window; 


FUNCTION 
Attempts to clear the DMRequester from the specified window, 
that is detaches the special Requester that you attach to 
the double-click of the menu button which the user can then 
bring up on demand. This routine WILL NOT clear the DMRequester 
if it's active (in use by the user). The IDCMP message class REQCLEAR 
can be used to detect that the requester is not in use, 
but that message is sent only when the last of perhaps several 
requesters in use in a window is terminated. 


INPUTS 
Window = pointer to the window from which the DMRequest is to be cleared. 


RESULT 
If the DMRequest was not currently in use, zeroes out the DMRequest 
pointer in the Window and returns TRUE. 
pointer in the Window and returns TRUE. 
If the DMRequest was currently in use, doesn't change the pointer 
and returns FALSE. 





BUGS 


SEE ALSO 
SetDMRequest(), Request() 














TET -¥ 





{intuition. Library/ClearMenuStrip intuition. library/ClearMenustrip 


NAME 


ClearMenuStrip -- Clears (detaches) the Menu strip from the Window 


SYNOPSIS 
ClearMenuStrip(Window) 
AO 


struct Window *Window; 


FUNCTION 
Detaches the current menu strip from the Window; menu strips 
are attached to windows using the SetMenuStrip() function. 


If the menu is in use (for that matter if any menu is in use) 
this function will block (Wait()) until the user has finished. 


Call this function before you make any changes to the data 
in a Menu or MenuItem structure which is part of a menu 
strip linked into a window. 


INPUTS 
Window = pointer to a Window structure 


RESULT 
None 


BUGS 


SEE ALSO 
SetMenuStrip() 








intuition. library/ClearPointer intuition. library/ClearPointer 


NAME 

ClearPointer -- clears the Mouse Pointer definition from a Window. 
SYNOPSIS 

ClearPointer (Window) 


AO 
struct Window *Window; 


FUNCTION 
Clears the Window of its own definition of the Intuition mouse pointer. 
After calling ClearPointer(), every time this Window is the active 
one the default Intuition pointer will be the pointer displayed 
to the user. If your Window is the active one when this routine 
is called, the change will take place immediately. 


Custom definitions of the mouse pointer which this function clears 
are installed by a call to SetPointer(). 


INPUTS 
Window = pointer to the Window to be cleared of its Pointer definition 


RESULT 
None 


BUGS 


SEE ALSO 
SetPointer() 


1 








ceT -~ ¥ 





intuition. library/CloseScreen intuition. library/CloseScreen 


NAME 

CloseScreen -~- Closes an Intuition Screen. 
SYNOPSIS 

CloseScreen (Screen) 


AO 
struct Screen *Screen; 


FUNCTION 
Unlinks the Screen, unlinks the ViewPort, deallocates everything that 
Intuition allocated when the screen was opened (using OpenScreen()). 
Doesn't care whether or not there are still any Windows attached to the 
Screen. Doesn't try to close any attached Windows; in fact, ignores them 
altogether. If this is the last Screen to go, attempts to reopen 
Workbench. 


INPUTS 
Screen = pointer to the Screen to be closed. 


RESULT 
None 


BUGS 


SEE ALSO 
OpenScreen( ) 








intuition. library/CloseWindow intuition. library/CloseWindow 


NAME 

CloseWindow ~~ Closes an Intuition Window. 
SYNOPSIS 

CloseWindow (Window) 


AO 
struct Window *Window; 


FUNCTION 
Closes an Intuition Window. Unlinks it from the system, unallocates 
its memory, and if its Screen is a system one that would be empty 
without the Window, closes the system Screen too. 


When this function is called, all IDCMP messages which have been sent 

to your window are deallocated. If the window had shared a Message Port 
with other windows, you must be sure that there are no unreplied messages 
for. this window in the message queue. Otherwise, your program will 

try to make use of a linked list (the queue) which contains free 

memory (the old messages). This will give you big problems. 

memory (the old messages). This will give you big problems. 

NOTE: If you have added a Menu strip to this Window (via 

a call to SetMenuStrip()) you must be sure to remove that Menu strip 

(via a call to ClearMenuStrip()) before closing your Window. 


NOTE: This function may block until it is safe to delink and free 
your window. Your program may thus be suspended while the user 
plays with gadgets, menus, or window sizes and position. 





INPUTS 


Window = a pointer to a Window structure 


RESULT 
None 


BUGS 


SEE ALSO 
OpenWindow(), CloseScreen() 

















eet - wv 





intuition. library/CloseWorkBench intuition. library/CloseWorkBench 


NAME 

CloseWorkBench -—- Closes the Workbench Screen. 
SYNOPSIS 

Success = CloseWorkBench() 

DO 


BOOL Success; 


FUNCTION 

This routine attempts to close the Workbench. The actions taken are: 

- fest whether or not any applications have opened Windows on the 
Workbench, and return FALSE if so. Otherwise 

- Clean up all special buffers 

~ Close the Workbench Screen 

- Make the Workbench program mostly inactive (it will still 
monitor disk activity) 

- Return TRUE 


INPUTS 
None 


RESULT 
TRUE if the Workbench Screen closed successfully 
FALSE if the Workbench was not open, or if it has windows 
open which are not Workbench drawers. 


BUGS 


SEE ALSO 
OpenWindow() 








intuition. library/CurrentTime 








intuition. library/CurrentTime 


NAME 

CurrentTime -~ Get the current time values. 
SYNOPSIS 

CurrentTime(Seconds, Micros) 


AO Al 
ULONG *Seconds, *Micros; 


FUNCTION 
Puts copies of the current time into the supplied argument pointers. 


This time value is not extremely accurate, nor is it of a very fine 
resolution. This time will be updated no more than sixty times a 
a second, and will typically be updated far fewer times a second. 


INPUTS 
Seconds = pointer to a LONG variable to receive the current seconds value 


Micros = pointer to a LONG variable for the current microseconds value 
RESULT 
Puts the time values into the memory locations specified by the arguments 
Return value is not defined. 
BUGS 


SEE ALSO 
timer .device/TR_GETSYSTIME 





peT -— ¥ 








intuition. library/DisplayAlert intuition. library/DisplayAlert 


NAME 

DisplayAlert -- Create the display of an Alert message. 
SYNOPSIS 

Response = DisplayAlert(AlertNumber, String, Height) 

bo DO AO DL 


BOOL Response; 
ULONG AlertNumber ; 
UBYTE *String; 
SHORT Height; 


FUNCTION 
Creates an Alert display with the specified message. 


If the system can recover from this Alert, its a RECOVERY_ALERT and 
this routine waits until the user presses one of the mouse buttons, 
after which the display is restored to its original state and a 
BOOL value is returned by this routine to specify whether or not 
the User pressed the LEFT mouse button. 


If the system cannot recover from this Alert, it's a DEADEND_ALERT 
and this routine returns immediately upon creating the Alert display. 
The return value is FALSE. 


NOTE THIS: Starting with Version 1.2, if Intuition can't get enough 
memory to display a RECOVERY_ALERT, the value FALSE will be returned. 


The AlertNumber is a LONG value, historically related to the value 
sent to the Alert() routine. But the only bits that are pertinent to 
this routine are the ALERT_TYPE bit(s). These bits must be set to 
either RECOVERY ALERT for Alerts from which the system may safely 
recover, or DEADEND_ALERT for those fatal Alerts. These states are 
described in the paragraph above. 


The String argument points to an AlertMessage string. The AlertMessage 
string is comprised of one or more substrings, each of which is 
comprised of the following components: 

- first, a 16-bit x-coordinate and an 8-bit y-coordinate, 
describing where on the Alert display you want this string 
to appear. The y-coordinate describes the offset to the 
baseline of the text. 

- then, the bytes of the string itself, which must be 
null-terminated (end with a byte of zero) 

- lastly, the continuation byte, which specifies whether or 
not there's another substring following this one. If the 
continuation byte is non-zero, there IS another substring 
to be processed in this Alert Message. If the continuation 
byte is zero, this is the last substring in the message. 


The last argument, Height, describes how many video lines tall you 
want the Alert display to be. 


INPUTS 
AlertNumber = the number of this Alert Message. The only pertinent bits 
of this number are the ALERT_TYPE bit(s). The rest of the 
number is ignored by this routine 
String = pointer to the Alert message string, as described above 
Height = minimum display lines required for your message 


RESULT 
A BOOL value of TRUE or FALSE. If this is a DEADEND_ALERT, FALSE 
is always the return value. If this is a RECOVERY_ALERT. The return 
value will be TRUE if the User presses the left mouse button in 
response to your message, and FALSE if the User presses the right hand 
button is response to your text, or if the alert could not 
be posted. 


BUGS 
If the system is worse off than you think, the level of your Alert 











may become DEADEND_ALERT without you ever Knowing about it. 


SEE ALSO 











S€T -¥ 











intuition. library/DisplayBeep intuition. library/DisplayBeep 


NAME 
DisplayBeep -- flashes the video display. 
SYNOPSIS 
DisplayBeep( Screen) 
AO 


struct Screen *Screen; 


FUNCTION 
“Beeps" the video display by flashing the background color of the 
specified Screen. If the Screen argument is NULL, every Screen 
in the display will be beeped. Flashing everyone's Screen is not 
a polite thing to do, so this should be reserved for dire 
circumstances. 


The reason such a routine is supported is because the Amiga has 

no internal bell or speaker. When the user needs to know of 

an event that is not serious enough to require the use of a Requester, 
the DisplayBeep() function may be called. 


INPUTS 
Screen = pointer to a Screen. If NULL, every Screen in the display 
will be flashed 


RESULT 
None 


BUGS 


SEE ALSO 


intuition. library/DoubleClick 





intuition. library/DoubleClick 


NAME 
DoubleClick -- Test two time values for double-click timing. 

SYNOPSIS 
IsDouble = DoubleClick(StartSecs, StartMicros, CurrentSecs, CurrentMicros) 
AO pO DL Da D3 


BOOL IsDouble; 
LONG StartSecs, StartMicros; 
LONG CurrentSecs, CurrentMicros; 


FUNCTION 
Compares the difference in the time values with the double~click 
timeout range that the user has set (using the "Preferences" tool) or 
some other program has configured into the system. If the 
difference between the specified time values is within the current 
double-click time range, this function returns TRUE, else it 
returns FALSE. 


These time values can be found in InputEvents and IDCMP Messages. 
The time values are not perfect; however, they are precise enough for 
nearly all applications. 


INPUTS 
StartSeconds, StartMicros = the timestamp value describing the start of 


the double-click time period you are considering 
CurrentSeconds, CurrentMicros = the timestamp value describing 
the end of the double-click time period you are considering 


RESULT 
If the difference between the supplied timestamp values is within the 


double-click time range in the current set of Preferences, this 
function returns TRUE, else it returns FALSE 


BUGS 


SEE ALSO 
currentTime( ) 





. fl 


9ET - WV 








[retition. brary /Drawborder intuition. library/DrawBorder 


NAME 
DrawBorder -- draws the specified Border into the RastPort. 
SYNOPSIS 
DrawBorder(RastPort, Border, Leftoffset, TopOffset) 
AO Al DO DL 


struct RastPort *RastPort; 
struct Border *Border ; 
SHORT LeftOffset, Topoffset; 


FUNCTION 
First, sets up the DrawMode and Pens in the RastPort according to the 
arguments of the Border structure. Then, draws the vectors of 


As with all graphics rendering routines, the border will be clipped to 
to the boundaries of the RastPort's layer, if it exists. This Is 
the case with Window RastPorts. 


If the NextBorder field of the Border argument is non-zero, 
the next Border is rendered as well, and so on until some NextBorder 
field is found to be NULL. 





INPUTS 
RastPort = pointer to the RastPort to receive the border rendering 
Border = pointer to a Border structure 
Leftoffset = the offset which will be added to each vector's x coordinate 
TopoOffset = the offset which will be added to each vector's y coordinate 


RESULT 
None 


BUGS 


SEE ALSO 





intuition. library/DrawImage 


the Border argument into the RastPort, offset by the Left and Top Offsets. 


intuition. library/DrawImage 


NAME 

DrawImage -—- draws the specified Image into the RastPort. 
SYNOPSIS 

DrawImage(RastPort, Image, Leftoffset, TopOffset) 


AQ Al DO DL 


struct RastPort *RastPort; 
struct Image *Image; 
SHORT LeftOffset, TopOffset,; 


FUNCTION 
First, sets up the DrawMode and Pens in the RastPort according to the 
arguments of the Image structure. Then, moves the image data of 
the Image argument into the RastPort, offset by the Left and Top Offsets. 
This routine does window layer clipping as appropriate -- if you 
draw an image outside of your Window, your imagery will be 
clipped at the Window's edge. 





If the NextImage field of the Image argument is non-zero, 
the next Image is rendered as well, and so on until some 
NextImage field is found to be NULL. 


INPUTS 
RastPort = pointer to the RastPort to receive image rendering 
Image = pointer to an Image structure 
Leftoffset = the offset which will be added to the Image's x coordinate 
TopOffset = the offset which will be added to the Image's y coordinate 


RESULT 
None 


BUGS 


SEE ALSO 





LET - © 








intuition. Llibrary/EndRefresh 











intuition. library/EndRefresh 


NAME 

EndRefresh -—- Ends the optimized refresh state of the Window. 
SYNOPSIS 

EndRefresh(Window, Complete) 


AO DO 


struct Window *Window; 
BOOL Complete; 


FUNCTION 
This function gets you out of the special refresh state of your 
Window. It is called following a call to BeginRefresh(), which 
routine puts you into the special refresh state. While your Window 
is in the refresh state, the only rendering that will be wrought in 
your Window will be to those areas which were recently revealed and 
need to be refreshed. 


After you've done all the refreshing you want to do for this Window, 
you should call this routine to restore the Window to its 
non-refreshing state. Then all rendering will go to the entire 
Window, as usual. 


The Complete argument is a boolean TRUE or FALSE value used to 
describe whether or not the refreshing you've done was all the 
refreshing that needs to be done at this time. Most .often, this 
argument will be TRUE. But if, for instance, you have multiple 
tasks or multiple procedure calls which must run to completely 
refresh the Window, then each can call its own Begin/EndRefresh() 
pair with a Complete argument of FALSE, and only the last calls 
with a Complete argument of TRUE. 


For your information, this routine calls the Layers library function 
EndUpdate(), unlocks your layers (calls UnlockLayerRom()), clears 

the LAYERREFRESH bit in your Layer Flags, and clears the WINDOWREFRESH 
bit in your window flags. 


INPUTS 
Window = pointer to the Window currently in optimized-refresh mode 
Complete = Boolean TRUE or FALSE describing whether or not this 
Window is completely refreshed 


RESULT 
None 


BUGS 


SEE ALSO 
BeginRefresh(), layers.library/EndUpdate(), layers. library/UnlockLayerRom( ) 





intuition. library/EndRequest intuition. library/EndRequest 
NAME 


EndRequest -- Ends the Request and resets the Window. 


SYNOPSIS 
EndRequest (Requester, Window) ; 
AO Al 


FUNCTION 
Ends the Request by erasing the Requester and resetting the Window. 
Note that this doesn't necessarily clear all Requesters from the Window, 
only the specified one. If the Window labors under other Requesters, 
they will remain in the Window. 


INPUTS 
Requester = pointer to the Requester to be removed 
Window = pointer to the Window structure with which this Requester 
is associated 


RESULT 
None 


BUGS 


SEE ALSO 
Request () 








| 








intuition. Library/FreéRemember intuition. library/FreeRemember 





NAME 
FreeRemember -- Free memory allocated by calls to AllocRemember(). 


SYNOPSIS 
FreeRemember(RememberKey, ReallyForget) 
AO DO 


struct Remember **RememberKey ; 
BOOL ReallyForget ; 


FUNCTION 


It will either free up just the Remember structures, which supply the 
link nodes that tie your allocations together, or it will deallocate 
both the link nodes AND your memory buffers too. 


If you want to deallocate ‘just the Remember structure link nodes, 
you should set the ReallyForget argument to FALSE. However, if you 
want FreeRemember to really deallocate all the memory, including 
both the Remember structure link nodes and the buffers you requested 
via earlier calls to AllocRemember(), then you should set the 
ReallyForget argument to TRUE. 


INPUTS 

RememberKey = the address of a pointer to struct Remember. This 
pointer should either be NULL or set to some value (possibly 
NULL) by a call to AllocRemember(). 

ReallyForget = a BOOL FALSE or TRUE describing, respectively, 
whether you want to free up only the Remember nodes or 
if you want this procedure to really forget about all of 
the memory, including both the nodes and the memory buffers 
referenced by the nodes. 


> EXAMPLE 
| struct Remember *RememberKey ; 
RememberKey = NULL; 
6 AllocRemember(&RememberKey, BUFSIZE, MEMF CHIP); 
FreeRemember( &RememberKey, TRUE) ; 
RESULT 
None 
BUGS 
SEE ALSO 


AllocRemember(), exec. library/FreeMem( ) 


This function frees up memory allocated by the AllocRemember() function. 


intuition. library/FreeSysRequest intuition. library/FreeSysRequest 
NAME 
FreeSysRequest —- Frees resources used by a call to BuildSysRequest(). 


SYNOPSIS 
FreeSysRequest (Window) 
AO 


struct Window *Window; 


FUNCTION 
This routine frees up all memory allocated by a successful call to 
the BuildSysRequest() procedure. If BuildSysRequest() returned a 
pointer to a Window, then you are able to Wait() on the message port 
of that Window to detect an event which satisfies the Requester. 
When you want to remove the Requester, you call this procedure. It 
ends the Requester and deallocates any memory used in the creation 
of the Requester. It also closes the special window that was opened 
for your System Requester. 


NOTE: if BuildSysRequest() did not return a pointer to a Window, 
you should not call FreeSysRequest()! 


INPUTS 
Window = value of the Window pointer returned by a successful call to 
the BuildSysRequest() procedure 


RESULT 
None 


BUGS 


SEE ALSO 
BuildSysRequest(), AutoRequest(), CloseWindow(), exec. library/Wait() 











6e€T - ¥ 





intuition. library/GetDefPrefs intuition. library/GetDefPrefs 


NAME 

GetDefPrefs -~ Get a copy of the the Intuition default Preferences. 
SYNOPSIS 

Prefs = GetDefPrefs(PrefBuffer, Size) 

DO AO DO 


struct Preferences *Prefs; 
struct Preferences *PrefBuffer; 
SHORT Size; 


FUNCTION 
Gets a copy of the Intuition default preferences data. Writes the 
data into the buffer you specify. The number of bytes you want 
copied is specified by the Size argument. 


The default Preferences are those that Intuition uses when it 
is first opened. If no preferences file is found, these are 
the preferences that are used. These would also be the startup 
Preferences in an AmigaDOS-less environment. 


It is legal to take a partial copy of the Preferences structure. 
The more pertinent Preferences variables have been grouped near 
the top of the structure to facilitate the memory conservation 
that can be had by taking a copy of only some of the Preferences 
structure. 


INPUTS 
PrefBuffer = pointer to the memory buffer to receive your copy of the 
Intuition Preferences 
Size = the number of bytes in your PrefBuffer, the number of bytes 
you want copied from the system's internal Preference settings 


RESULT 
Returns your parameter PrefBuffer. 


BUGS 


SEE ALSO 
GetPrefs() 








intuition. library/GetPrefs 





intuition. library/GetPrefs 


NAME 

GetPrefs -—-- Get the current setting of the Intuition Preferences. 
SYNOPSIS 

Prefs = GetPrefs(PrefBuffer, Size) 

DO AO DO 


struct Preferences *Prefs; 
struct Preferences *PrefBuffer; 


FUNCTION 
Gets a copy of the current Intuition Preferences data. Writes the 
data into the buffer you specify. The number of bytes you want 
copied is specified by the Size argument. 


It is legal to take a partial copy of the Preferences structure. 
The more pertinent Preferences variables have been grouped near 
the top of the structure to facilitate the memory conservation 
that can be had by taking a copy of only some of the Preferences 
structure. 


INPUTS 
PrefBuffer = pointer to the memory buffer to receive your copy of the 
Intuition Preferences 
Size = the number of bytes in your PrefBuffer, the number of bytes 
you want copied from the system's internal Preference settings 


RESULT 
Returns your parameter PrefBuffer. 


BUGS 


SEE ALSO 
GetDefPrefs(), SetPrefs() 





OvT - © 











intuition. library/GetScreenData intuition. library/GetScreenData 
NAME 
GetScreenData ~—- Get copy of a screen data structure. 
SYNOPSIS 
Success = GetScreenData(Buffer, Size, Type, Screen ) 
DO AO DO DL Al 
BOOL Success; 
CPTR Buffer; 


USHORT Size; 
USHORT Type; 
struct Screen *Screen; 


FUNCTION 
This function copies into the caller's buffer data from a Screen structure 
Typically, this call will be used to find the size, title bar height, and 
other values for a standard screen, such as the Workbench screen. 


To get the data for the Workbench screen, one would call: 
GetScreenData(buff, sizeof(struct Screen), WBENCHSCREEN, NULL) 


NOTE: if the requested standard screen is not open, this function 
will have the effect of opening it. 


INPUTS 
Buffer = pointer to a buffer into which data can be copied 
Size = the size of the buffer provided, in bytes 
pe = the screen type, as specified in OpenWindow (WBENCHSCREEN, 
CUSTOMSCREEN, ...) 
Screen = ignored, unless type is CUSTOMSCREEN, which results only in 
copying ‘size' bytes from 'screen' to ‘puffer’ 
RESULT 


TRUE if successful 
FALSE if standard screen of Type 'type' could not be opened. 


BUGS 


SEE ALSO 
OpenWindow( ) 


—r 





intuition. library/InitRequester intuition. library/InitRequester 
NAME 
InitRequester 


initializes a Requester structure. 


SYNOPSIS 
InitRequester (Requester) 
AO 


struct Requester *Requester; 


FUNCTION 
Initializes a requester for general use. After calling InitRequester, 
you need fill in only those Requester values that fit your needs. 
The other values are set to NULL-~or zero——states. 


INPUTS 
Requester 


a pointer to a Requester structure 


RESULT 
None 


BUGS 


SEE ALSO 


i 











TPT - ¥ 

















intuition. library/IntuiTextLength intuition. Llibrary/IntuiTextLength 
NAME : 
IntuiTextLength -- Returns the length (pixel-width) of an IntuiText. 


SYNOPSIS 
IntuiTextLength(IText) 
DO 


struct IntuiText *IText; 


PUNCTION 
This routine accepts a pointer to an instance of an IntuiText structure, 
and returns the length (the pixel-width) of the string which that 
instance of the structure represents. 


NOTE: if the Font pointer of your IntuiText structure is set to NULL, 
you'll get the pixel-width of your text in terms of the current system 
default font. You may wish to be sure that the field IText->ITextFont 
for 'default font! text is equal to the Font field of the screen it is 
being measured for. 


INPUTS 
IText = pointer to an instance of an IntuiText structure 


RESULT 
Returns the pixel-width of the text specified by the IntuiText data 


BUGS 
Would do better to take a RastPort as argument, so that a NULL in 
the Font pointer would lead automatically to the font for the 
intended target RastPort. 


SEE ALSO 
OpenScreen() 





intuition. library/ItemAddress intuition. library/ItemAddress 


NAME 

ItemAddress -- Returns the address of the specified MenulItem. 
SYNOPSIS 

Item = ItemAddress(MenuStrip, MenuNumber) 

DO AO DO 


struct MenuItem *ItemAddress; 
struct Menu aMenuStrip; 
USHORT MenuNumber ; 


FUNCTION 
This routine feels through the specified MenuStrip and returns the 
address of the Item specified by the MenuNumber. Typically, 
you will use this routine to get the address of a MenuItem from 
a MenuNumber sent to you by Intuition after User has played with 
a Window's Menus. 


This routine requires that the arguments are wel]-defined. 
MenuNumber may be equal to MENUNULL, in which case this routine returns 
NULL. If MenuNumber doesn't equal MENUNULL, it's presumed to be a 
valid Item number selector for your MenuStrip, which includes: 

— a valid Menu number 

- a valid Item Number 

- if the Item specified by the above two components has a 

SubItem, the MenuNumber may have a SubItem component too 


Note that there must be BOTH a Menu number and an Item number. 
Because a SubItem specifier is optional, the address returned by 
this routine may point to either an Item or a SubItem. 


INPUTS 
MenuStrip = a pointer to the first Menu in your MenuStrip 
MenuNumber = the value which contains the packed data that selects 
the Menu and Item (and SubItem). See the Intuition Reference 
Manual for information on Menu Numbers. 


RESULT 
If MenuNumber == MENUNULL, this routine returns NULL, 
else this routine returns the address of the Menultem specified 
by MenuNumber. 


BUGS 
SEE ALSO 


The "Menus" chapter of the Intuition Reference Manual, 
for more information about "Menu Numbers." 








| 





cyt -— © 


fintuition. library/LockIBase 








intuition. Library/LockiBase 


NAME 

LockIBase —- Intuition user's access to Intuition Locking 
SYNOPSIS 

Lock = LockIBase(LockNumber ) 

bo DO 

ULONG Lock; 


ULONG LockNumber ; 
FUNCTION 


Grabs Intuition internal semaphore so that caller may examine 
IntuitionBase safely. 


The idea here is that you can get the locks Intuition needs before 
such IntuitionBase fields as ActiveWindow and FirstScreen are 
changed, or linked lists of windows and screens, are changed. 


Do Not Get Tricky with this entry point, and do not hold these locks 
for long, as all Intuition input processing will wait for you to 
surrender the lock by a call to UnlockIBase(). 


NOTE WELL: A call to this function MUST be paired with a subsequent 
call to UnlockIBase(), and soon, please. 


INPUTS 


A long unsigned integer, LockNumber, specifies which of Intuition's internal 
locks you want to get. This parameter should be zero for all forseeable 
uses of this function, which will let you examine Active fields and linked 
lists of screens and windows with safety. 


RESULT 


Returns another ULONG which should be passed to UnlockIBase() to surrender 
the lock gotten by this call. 


BUGS 
This function should not be called while holding any other system locks 
such as Layer or LayerInfo locks. 


SEE ALSO 
UnlockIBase(), layers.library/LockLayerInfo, exec. Library/ObtainSemaphore 











intuition. Library/MakeScreen intuition. library/MakeScreen 
NAME 
MakeScreen -- Do an Intuition-integrated MakeVPort() of a custom screen 
SYNOPSTS 
MakeScreen (Screen) 
AO 


struct Screen *Screen; 


FUNCTION 
This procedure allows you to do a MakeVPort() for the ViewPort of your 
Custom Screen in an Intuition-integrated way. This allows you to 
do your own Screen manipulations without worrying about interference 
with Intuition's usage of the same ViewPort. 


The operation of this function is as follows: 
— Block until the Intuition View is not in use. 
~ Set the View Modes correctly to reflect if there is a (visible) 
interlaced screen. 
— call MakevPort, passing the Intuition View and your Screen's 
ViewPort. 
- Unlocks the Intuition View. 


After calling this routine, you can call RethinkDisplay() to 
incorporate the new ViewPort of your custom screen into the 
Intuition display. 


INPUTS 
Screen = address of the Custom Screen structure 


RESULT 
None 


BUGS 


SEE ALSO 
RethinkDisplay(), RemakeDisplay(), graphics. library/MakeVPort() 


i 








€yt - 











intuition. library/ModifyIDCMP intuition. Library/Modi fyIDCMP 


NAME 

ModifyIDCMP --. Modify the state of the Window's IDCMPFlags. 
SYNOPSTS 

ModifyIDCMP(Window, IDCMPFlags) 

AO DO 

struct Window *Window; 

ULONG IDCMPFlags; 
FUNCTION 


This routine modifies the state of your Window's IDCMP (Intuition Direct 
Communication Message Port). The state is modified to reflect your 
desires as described by the flag bits in the value IDCMPFlags. 


The four actions that might be taken are: 


-— if there is currently no IDCMP in the given Window, and IDCMPFlags 
is NULL, nothing happens 

~ if there is currently no IDCMP in the given Window, and any of the 
IDCMPFlags is selected (set), then the IDCMP of the Window is 
created, including allocating and initializing the message ports 
and allocating a Signal bit for your Port. See the "Input and 
Output Methods" chapter of the Intuition Reference Manual for full 
details 

- if the IDcMP for the given Window exists, and the 
IDCMPFlags argument is NULL, this. says that you want 
Intuition to close the Ports, free the buffers and free 
your Signal bit. You MUST be the same Task that was active 
when this Signal bit was allocated 

- if the IDCMP for the given Window is opened, and the IDCMPFlags 
argument is not NULL, this means that you want to change the 
state of which events will be broadcast to you through the IDCMP 


NOTE: You can set up the Window->UserPort to any Port of your own 
before you call ModifyIDCMP(). If IDCMPFlags is non-null but 
your UserPort is already initialized, Intuition will assume that 
it's a valid Port with Task and Signal data preset and Intuition 
won't disturb your set-up at all, Intuition will just allocate 

the Intuition Message Port half of it. The converse is true 

as well: if UserPort is NULL when you call here with 

IDCMPFlags == NULL, Intuition will deallocate only the Intuition 
side of the Port. 


This allows you to use a Port that you already have allocated: 

— OpenWindow() with IDCMPFlags equal to NULL (open no ports) 

-— set the UserPort variable of your Window to any valid Port of your 
own choosing 

- call ModifyIDCMP with IDCMPFlags set to what you want 

~ then, to clean up later, set UserPort equal to NULL before calling 
CloseWindow() (leave. IDCMPFlags alone) BUT FIRST: you must make 
sure that no messages sent your window are queued at the port, 
since they will be returned to the memory free pool. 


INPUTS 
Window = pointer to the Window structure containing the IDCMP Ports 
IDCMPFlags = the flag bits describing the new desired state of the IDCMP 


RESULT 
None 


BUGS 
Method for closing a window with a shared port needs to be better 
documented somewhere, or provided as an Intuition call, or both. 
At the present, the technique is available through developer support 
newsletters as a function called CloseWindowSafely(). See, for 
example, Amiga Mail, vol.2. 

SEE ALSO 

OpenWindow(), CloseWindow( ) 











intuition. library/ModifyProp 


NAME 
ModifyProp -- Modify the current parameters of a Proportional Gadget. 
SYNOPSIS 
ModifyProp(Gadget, Window, Requester, 
AQ Al A2 
Flags, HorizPot, VertPot, HorizBody, VertBody) 
DO DI D2 D3 D4 
struct Gadget *Gadget; 


struct Window *Window; 
struct Requester *Requester; 
USHORT Flags; 

USHORT HorizPot, VertPot; 
USHORT HorizBody, VertBody; 


FUNCTION 
Modifies the parameters of the specified Proportional Gadget. 
Gadget's internal state is then recalculated and the imagery 
is redisplayed in the Window or Requester that contains the gadget. 


The 


The Requester variable can point to a Requester structure. If the 
Gadget has the REQGADGET flag set, the Gadget is in a Requester 

and the Window pointer must point to the window of the Requester. 

If this is not the Gadget of a Requester, the Requester argument may 
be NULL. 


NOTE: this function causes all gadgets from the proportional 
gadget to the end of the gadget list to be refreshed, for 
reasons of compatibility. 

For more refinded display updataing, use NewModifyProp 


INPUTS 
PropGadget = pointer to a Proportional Gadget 
Window = pointer to the window containing the gadget or the Window 
containing the Requester containing the Gadget. 
Requester = pointer to a Requester (may be NULL if this isn't 
a Requester Gadget) 
Flags = value to be stored in the Flags variable of the PropInfo 
HorizPot = value to be stored in the HorizPot variable of the PropInfo 
VertPot = value to be stored in the VertPot variable of the PropInfo 
HorizBody = value to be stored in the HorizBody variable of the PropInfo 
VertBody = value to be stored in the VertBody variable of the PropInfo 


RESULT 
None 


BUGS 


SEE ALSO 
NewModifyProp() 
The Intuition Reference Manual contains more information on 
Proportional Gadgets. 








intuition. library/ModifyProp 








| 


intuition. library/MoveScreen 


NAME 

MoveScreen -- attempts to move the Screen by increments provided. 
SYNOPSIS 

MoveScreen(Screen, DeltaX, DeltaY); 


AQ DO DL 


struct Screen *Screen; 
SHORT DeltaX, DeltaY; 


FUNCTION 
Moves the screen the specified increment. 


Currently, only the DeltaY coordinate is significant; you should 
pass zero for DeltaX. 


Sereens are constrained now only by the top and bottom of the 
Intuition View, which is not guaranteed to be the same in all 
versions of the software. 





If the DeltaX and DeltaY variables you specify would move the Screen 
in a way that violates any restrictions, the Screen will be moved 
as far as possible. You may examine the LeftEdge and TopEdge fields 
of the Screen Structure to see where the screen really ended up. 


In operation, this function determines what the actual increments 
that are actually to be used, sets these values up, and calls 


RethinkDisplay(). 
INPUTS 
Screen pointer to a Screen structure 


DeltaXx amount to move the screen on the x-axis 








intuition. Library/MoveScreen intuition. library/MoveWindow 


NAME 


SYNOPSIS 


FUNCTION 


INPUTS 








intuition. library/MoveWindow 
MoveWindow -—- Ask Intuition to move a Window. 


MoveWindow(Window, DeltaX, DeltaY) 
AO DO DL 


struct Window *Window; 
SHORT DeltaX, DeltaY; 


This routine sends a request to Intuition asking to move the Window 
the specified distance. The delta arguments describe how far to 
move the Window along the respective axes. 


Note that the Window will not be moved immediately, but rather 
will be moved the next time Intuition receives an input event, 
which happens currently at a minimum rate of ten times per second, 
and a maximum of sixty times a second. 


This routine does no error-checking. If your delta values specify 
some far corner of the Universe, Intuition will attempt to move 
your Window to the far corners of the Universe. Because of the 
distortions in the space-time continuum that can result from this, 
as predicted by special relativity, the result is generally not 

a pretty sight. 


You are thus advised to consider the dimensions of your Window's screen 
and the current position of your window before calling this function. 


Window = pointer to the structure of the Window to be moved 


IT - ¥ 


Note that DeltaX should be set to zero. DeltaX = signed value describing how far to move the Window on the x-axis 
DeltaY = amount to move the screen on the y-axis DeltaY = signed value describing how far to move the Window on the y-axis 
RESULT RESULT 
None None 
BUGS BUGS 
SEE ALSO SEE ALSO 





RethinkDisplay() SizeWindow(), WindowToFront(), WindowToBack() 


























StT —- © 








intuition. library/NewModifyProp intuition. library/NewModifyProp 


NAME 
NewModifyProp -—- ModifyProp, but with Selective Update 
SYNOPSIS 
NewModifyProp(Gadget, Window, Requester, Flags 
AO Al A2 DO 
HorizPot, VertPot, HorizBody, VertBody, NumGad) 
DL D2 D3 D4 DS 


struct Gadget *Gadget; 
struct Window *Window; 
struct Requester *Requester; 
USHORT Flags; 

USHORT HorizPot, VertPot; 
USHORT HorizBody, VertBody; 
int NumGad ; 


FUNCTION 
Performs the function of ModifyProp(), but can update a 
subset of the entire gadget list. The starting position 
and gadget count are specified as parameters. If NumGad = -1, 





updates are made until the end of the list is reached. 


NOTE 
Under V33/34, NewModifyProp() has the side effect of redrawing 
the entire gadget. In the future this function may only update 
that parts that changed. To cause a full draw operation, use 
RefreshGList(). 


INPUTS 
PropGadget = pointer to a Proportional Gadget 
Window = pointer to the window containing the gadget or the Window 
containing the Requester containing the Gadget. 
Requester = pointer to a Requester (may be NULL if this isn't 
a Requester Gadget ) 
Flags = value to be stored in the Flags variable of the PropInfo 
HorizPot = value to be stored in the HorizPot variable of the PropInfo 
VertPot = value to be stored in the VertPot variable of the Propinfo 
HorizBody = value to be stored in the HorizBody variable of the PropInfo 
VertBody = value to be stored in the VertBody variable of the PropInfo 
NumGad = number of gadgets to be refreshed after propgadget. internals 
have been adjusted. -1 means "to end of list." 


RESULT 
None 


BUGS 


SEE ALSO 
ModifyProp() 
The Intuition Reference Manual contains more information on Proportional 
Gadgets. 








intuition. library/offGadget intuition. library/offiGadget 


NAME 
OffGadget -—- disables the specified Gadget. 
SYNOPSIS 
OffGadget (Gadget, Window, Requester) 
AO Al A2 


struct Gadget *Gadget; 
struct Window *Window; 
struct Requester *Requester; 


FUNCTION 
This command disables the specified Gadget. 
disabled, these things happen: 
- its imagery is displayed ghosted 
~ the GADGDISABLED flag is set 
~ the Gadget cannot be selected by User 


When a Gadget is 


The Window parameter must point to the window which contains the Gadget, 
or which contains the Requester that contains the Gadget 

The Requester parameter must only be valid if the Gadget has the 
REQGADGET flag set, a requirement for all Requester Gadgets. 
NOTE: it's never safe to tinker with the Gadget list yourself. Don't 
supply some Gadget that Intuition hasn't already processed in 

the usual way. 


NOTE: for compatibility reasons, this function will refresh all 
gadgets in a requester, and all gadgets from Gadget to the 
end of the gadget list if Gadget is in a window. 


INPUTS 
Gadget = pointer to the Gadget that you want disabled 
Window = pointer to a Window structure containing the Gadget or 
containing the Requester which contains the Gadget 
Requester = pointer to a Requester (may by NULL if this isn't 
a Requester Gadget (i.e. REQGADGET is not set)). 


RESULT 
None 


BUGS 


SEE ALSO 
AddGadget(), RefreshGadgets() 


99IT - V 


l 








intuition. library/offMenu intuition. library/ofifMenu 


NAME 

offMenu -- disables the given menu or menu item. 
SYNOPSIS 

offMenu(Window, MenuNumber) 


AO DO 


struct Window *Window; 
USHORT MenuNumber ; 


FUNCTION 
This command disables a sub-item, an item, or a whole menu. 
This depends on the contents of the data packed into MenuNumber, 
which is described in the Intuition Reference Manual. 


INPUTS 
Window = pointer to the window 
MenuNumber = the menu piece to be disabled 


RESULT 
None 


BUGS 


SEE ALSO 


intuition. library/OnGadget 








intuition. library/OnGadget 


NAME 
OnGadget -~ enables the specified Gadget. 
SYNOPSIS 
OnGadget (Gadget, Window, Requester) 
AO AL A2 


struct Gadget *Gadget; 
struct Window *Window; 
struct Requester *Requester; 


FUNCTION 
This command enables the specified Gadget. When a Gadget is 
enabled, these things happen: 
- its imagery is displayed normally (not ghosted) 
— the GADGDISABLED flag is cleared 
~ the Gadget can thereafter be selected by the user 


The Window parameter must point to the window which contains the Gadget, 
or which contains the Requester that contains the Gadget 

The Requester parameter must only be valid if the Gadget has the 
REQGADGET flag set, a requirement for all Requester Gadgets. 


NOTE: it's never safe to tinker with the Gadget list yourself. Don't 
supply some Gadget that Intuition hasn't already processed in 
the usual way. 


NOTE: for compatibility reasons, this function will refresh all 
gadgets in a requester, and all gadgets from Gadget to the 
end of the gadget list if Gadget is in a window. 


INPUTS 
Gadget = pointer to the Gadget that you want disabled 
Window = pointer to a Window structure containing the Gadget or 
containing the Requester which contains the Gadget 
Requester = pointer to a Requester (may by NULL if this isn't 
a Requester Gadget (i.e. REQGADGET is not set)). 


RESULT 
None 


BUGS 


SEE ALSO 











4oT -W¥ 











intuition. library/OnMenu intuition. library/OnMenu 


NAME 
OnMenu -- enable the given menu or menu item. 
SYNOPSIS 
OnMenu(Window, MenuNumber ) 
AO DO 


struct Window *Window; 
USHORT MenuNumber ; 


FUNCTION 
This command enables a sub-item, an item, or a whole menu. 
This depends on the contents of the data packed into MenuNumber , 
which is described in the Intuition Reference Manual. 


INPUTS 
Window = pointer to the window 
MenuNumber = the menu piece to be enables 


RESULT 
None 


BUGS 


SEE ALSO 





intuition. library/OpenScreen intuition. library/OpenScreen 


NAME 

OpenScreen -- Open an Intuition Screen. 
SYNOPSIS 

Screen = OpenScreen(NewScreen) 

DO AO 


struct Screen *Screen; 
struct NewScreen *NewScreen; 


FUNCTION 
Opens an Intuition Screen according to the specified parameters 
found in the NewScreen structure. 


Does all the allocations, sets up the Screen structure and all 
substructures completely, and links this Screen's ViewPort into 
Intuition's View structure. 


Before you call OpenScreen(), you must initialize an instance of 
a NewScreen structure. NewScreen is a structure that contains 
all of the arguments needed to open a Screen. The NewScreen 
structure may be discarded immediately after OpenScreen() returns. 


The SHOWTITLE flag is set to TRUE by default when a Screen is opened. 
To change this, you must call the routine ShowTitle(). 


INPUTS 

NewScreen = pointer to an instance of a NewScreen structure. 

That structure is initialized with the following information: 

Left = initial x-position of your Screen (should be zero currently) 

Top = initial y~position of the opening Screen 

Width = the width for this Screen's RastPort. 

Height = the height for his Screen's RastPort, or the constant 
STDSCREENHEIGHT to get current local maximum (at this time 
guaranteed to be at least 200). The actual height the screen 
opended to can be found in the returned Screen structure. 

The "normal" width and height for a particular system is stored by 

the graphics. library in GfxBase->NormalDisplayRows and 

GfxBase—>NormalDisplayColumms. These values will be different 

depending on factors such as PAL video and overscan. 


Depth = number of BitPlanes 

DetailPen = pen number for details (like gadgets or text in title bar) 
BlockPen = pen number for block fills (like title bar) 

Type = Screen type 

Set these flag bits as desired from the set: 

CUSTOMSCREEN -- this is your own Screen, not a System screen. 

CUSTOMBITMAP ~~ this custom screen has bit maps supplied 
in the BitMap field of the NewScreen structure. Intuition is 
not to allocate any Raster BitMaps. 

SCREENBEHIND —- your screen will be created behind all other open 
screens. This allows a program to prepare imagery in the 
screen, change it's colors, and so on, bringing it to the front 
when it is presentable. 

SCREENQUIET —- Intuition will not render system screen gadgets or 
screen title. In concert with the RMBTRAP flag on all your 
screen's windows, this flag will prevent Intuition from rendering 
into your screen's bitplanes. Without RMBTRAP (or using MENUVERIFY 
IDCMP facility to cancel menu operations), this flag will 
prevent Intuition from clearing your menu bar, which is probably 
unacceptable. The title bar layer may still overwrite your 
bitmap on open. 

ViewModes = the appropriate argument for the data type ViewPort.Modes. 
these might include: 
HIRES for this screen to be HIRES width. 
INTERLACE for the display to switch to interlace. 
SPRITES for this Screen to use sprites (pointer comes anyway). 
DUALPF for dual-playfield mode (not supported yet) 





Font = pointer to the default TextAttr structure for text in this Screen 


{_ 





8YT - ¥ 











and all Windows that open in this Screen. Text that uses this TextAttr 


includes title bars of both Screen and Windows, String Gadgets, and 


Menu titles. Of course, IntuiText that specifies a NULL TextAttr field 


will use the Screen/Window default Fonts. 

DefaultTitle = pointer to a line of text that will be displayed along the 
Screen's Title Bar. Null terminated, or. just a NULL pointer 
to get no text 

Gadgets = This field should be set to NULL, since no user Gadgets may 

be attached to a Screen. 

CustomBitMap = if you're not supplying a custom BitMap, this value is 
ignored. However, if you have your own display memory that you 
want used for this Screen, the CustomBitMap argument should 
point to the BitMap that describes your display memory. See the 
“Soreens" chapter and the "Amiga ROM Kernel Manual" for more 
information about BitMaps. 


RESULT 
If ali is well, returns the pointer to your new Screen 
If anything goes wrong, returns NULL 


NOTE 
By default AmigaDOS requesters related to your Process are put on 
the workbench screen (these are messages like "Disk Full"). If 
you wish them to show up on custom screens, DOS must be told. 
This fragment shows the procedure. More information is availble 
in the AmigaDOS books. Sample code fragment: 


ne eut here ---—-7-7>~ 
#include "libraries/dosextens.h" 


struct Process *process; 
struct Window *window; 
APTR temp; 


process=(struct Process *)FindTask(0L); 
temp=process—>pr_WindowPtr; /* save old value */ 
process—>pr_WindowPtr=(APTR)window; 

/* set a pointer to any open window on your screen */ 


your code goes here 
process~)pr_WindowPtr=temp; 
/7* restore value _before_ CloseWindow */ 
CloseWindow(window) ; 
a cut here ——~~~~ 
BUGS 


SEE ALSO 
OpenWindow(), PrintIText(), CloseScreen(), The Intuition Reference Manual 





intuition. library/OpenWindow intuition. library/OpenWindow 


NAME 
OpenWindow —-- Opens an Intuition Window 


SYNOPSIS 
OpenWindow(NewWindow) ; 
where the NewWindow structure is initialized with: 
Left, Top, Width, Height, DetailPen, BlockPen, Flags, 
IDCMPFlags, Gadgets, CheckMark, Text, Type, Screen, BitMap, 
MinWidth, MinHeight, MaxWidth, MaxHeight 


FUNCTION 
Opens an Intuition window of the given height, width and depth, including 
the specified system Gadgets as well as any of your own. Allocates 
everything you need to get going. 


Before you call OpenWindow(), you must initialize an instance of 
a NewWindow structure. NewWindow is a structure that contains 
all of the arguments needed to open a Window. The NewWindow 
structure may be discarded immediately after it is used to open 
the Window. 


If Type == CUSTOMSCREEN, you must have opened your own Screen 
already via a call to OpenScreen(). Then Intuition uses your screen 
argument for the pertinent information needed to get your Window 
going. On the other hand, if type == one of the Intuition's standard 
Sereens, your screen argument is ignored. Instead, 

Intuition will check to see whether or not that Screen 

already exists: if it doesn't, it will be opened first before 
Intuition opens your window in the Standard Screen. 

If the flag SUPER_BITMAP is set, the bitmap variable must point to 
your own BitMap. 

The DetailPen and the BlockPen are used for system rendering; for 
instance, the Title bar is first filled using the BlockPen, and then 
the Gadgets and text are rendered using DetailPen. You can either 
choose to supply special pens for your Window, or, by setting either 
of these arguments to -l, the Screen's Pens will be used instead. 


INPUTS 
NewWindow = pointer to an instance of a NewWindow structure. That 
structure is initialized with the following data: 
Left = the initial x-position for your window 
Top = the initial y-position for your window 
Width = the initial width of this window 
Height = the initial height of this window 
DetailPen = pen number (or -1) for the rendering of Window details 
(like gadgets or text in title bar) 
BlockPen = pen number (or ~1) for Window block fills (like Title Bar) 
Flags = specifiers for your requirements of this window, including: 
- which system Gadgets you want attached to your window: 
— WINDOWDRAG allows this Window to be dragged 
— WINDOWDEPTH lets the user depth-arrange this Window 
~ WINDOWCLOSE attaches the standard Close Gadget 
— WINDOWSIZING allows this Window to be sized. If you ask 
the WINDOWSIZING Gadget, you must specify one or both 
of the flags SIZEBRIGHT and SIZEBBOTIOM below; if you 
don't, the default is SIZEBRIGHT. See the 
following items SIZEBRIGHT and SIZEBBOTTOM for extra 
information. 
~ SIZEBRIGHT is a special system Gadget flag that 
you set to specify whether or not you want the 
RIGHT Border adjusted to account for the physical size 
of the Sizing Gadget. The Sizing Gadget must, after 
all, take up room in either the right or bottom border 
(or both, if you like) of the Window. Setting either 
this or the SIZEBBOTTOM flag selects which edge 
will take up the slack. This will be particularly 
useful to applications that want to use the extra space 
for other Gadgets (like a Proportional Gadget and two 
Booleans done up to look like scroll bars) or, for 











6yT - ¥ 











DCMPFlags = 
Message 


for instance, applications that want every possible 
horizontal bit and are willing to lose lines vertically. 
NOTE: iff you select WINDOWSIZING, you must select 
either SIZEBRIGHT or SIZEBBOTTOM or both. If you select 
neither, the default is SIZEBRIGHT. 
~ SIZEBBOTTOM is a special system Gadget flag that 
you set to specify whether or not you want the 
BOTTOM Border adjusted to account for the physical size 
of the Sizing Gadget. For details, refer to 
SIZEBRIGHT above. 
NOTE: if you select WINDOWSIZING, you must select 
either SIZEBRIGHT or SIZEBBOTTOM or both. If you select 
neither, the default is SIZEBRIGHT. 
GIMMEZEROZERO for easy but expensive output 
what type of window raster you want, either: 
— SIMPLE_REFRESH 
~ SMART REFRESH 
— SUPER_BITMAP 
If the type is SMART_REFRESH, and you do not handle 
REFRESHWINDOW type messages, also set the NOCAREREFRESH 
flag. 
BACKDROP for whether or not you want this window to be one 
of Intuition's special backdrop windows. See BORDERLESS 
as well. 
REPORTMOUSE for whether or not you want to "listen" to 
mouse movement events whenever your Window is the active 
one. After you've opened your Window, if you want to change 
you can later change the status of this via a call to 
ReportMouse({). Whether or not your Window is listening to 
Mouse is affected by Gadgets too, since they can cause 
you to start getting reports too if you like. 
The mouse move reports (either InputEvents or messages on 
the IDCMP) that you get will have the x/y coordinates of the 
current mouse position, relative to the upper-left corner 
of your Window (GIMMEZEROZERO notwithstanding) . 
This flag can work in conjunction with the IDCMP Flag 
called MOUSEMOVE, which allows you to listen via the 
IDCMP . : 
BORDERLESS should be set if you want a Window with no 
Border padding. Your Window may have the Border variables 
set anyway, depending on what Gadgetry you've requested for 
the Window, but you won't get the standard border lines and 
spacing that comes with typical Windows. 
This is a good. way to take over the entire Screen, since you 
can have a Window cover the entire width of the Screen using 
this flag. This will work particularly well in 
conjunction with the BACKDROP flag (see above), since it 
allows you to open a Window that fills the ENTIRE Screen. 
NOTE: this is not a flag that you want to set casually, 
since it may cause visual confusion on the Screen. The 
Window borders are the only dependable visual division 
between various Windows and the background Screen. Taking 
away that. Border takes away that visual cue, so make sure 
that your design doesn't need it at all before you 
proceed. 
ACTIVATE is the flag you set if you want this 
Window to automatically become the active Window. 
The active Window is the one that receives input from 
the keyboard and mouse. It's usually a good idea to 
to have the Window you open when your application 
first starts up be an ACTIVATED one, but all others 
opened later not be ACTIVATED (if the user is off 
doing something with another Screen, for instance, your 
new Window will change where the input is going, which 
would have the effect of yanking the input rug from 
under the user). Please use this flag thoughtfully and 
carefully. 
RMBTRAP, when set, causes the right mouse button events 
to be trapped and broadeast as events. You can receive 
these events through either the IDCMP or the Console. 
IpcMP is the acronym for Intuition Direct Communications 
Port. It's Intuition's sole acronym, given in honor of 








all hack-heads who love to mangle our brains with maniacal names, 
and fashioned especially cryptic and unpronounceable to make them 
squirm with sardonic delight. Here's to you, my chums. Meanwhile, 
I still opt (and argue) for simplicity and elegance. 

If any of the IDCMP Flags is selected, Intuition will create 
a pair of messageports and use them for direct communications with 
the Task opening this Window (as compared with broadcasting 
information via the Console Device). See the “Input and Output 
Methods" chapter of the intuition manual for complete details. 

You request an IDCMP by setting any of these flags. Except 
for the special VERIFY flags, every other flag you set 
tells me that if a given event occurs which your 
program wants to know about, I'm to broadcast the details 
of that event through the IDCMP rather than via the Console device. 
device. This allows a program to interface with Intuition 
directly, rather than going through the Console device. 

Remember, if you are going to open both an IDCMP and 
a Console, it will be far better to get most of the event 
messages via the Console. Reserve your usage of the IDCMP 
for special performance cases; that is, when you aren't going 
to open a Console for your Window and you do want to learn 
about a certain set of events (for instance, CLOSEWINDOW); another 
example would be SIZEVERIFY, which is a function that you get 
ONLY through the use of the IDCMP (because the Console doesn't 
give you any way to talk to Intuition directly). 

On the other hand, if the IDCMPFlags argument is equal to 
zero, no IDCMP is created and the only way you can learn about any 
Window event for this Window is via a Console opened for 
this Window. And you have no way to SIZEVERIFY. 

If you want to change the state of the IDCMP some time after 
you've opened the Window (including opening or closing the IDCMP) 
you call the routine ModifyIDCMP(). 

The flags you can set are: 

— REQVERIFY is the flag which, like SIZEVERIFY and(see 
MENUVERIFY (see immediately below), specifies that you 
want to make sure that your graphical state is quiescent 
before something extraordinary happens. In this 
case, the extraordinary event is that a rectangle of 
graphical data is about to be blasted into your Window. 
If you're drawing into that Window, you probably will 
wish to make sure that you've ceased drawing before 
the user is allowed to bring up the DMRequest you've set 
up, and the same for when system has a request for the 
user. Set this flag to ask for that verification step. 

~ REQCLEAR is the flag you set to hear about it when the 
last Requester is cleared from your Window and 
it's safe for you to start output again (presuming you're 
using REOVERIFY) 

— REQOSET is a flag that you set to receive a broadcast 
when the first Requester is opened in. your Window. 
Compare this with REQCLEAR above. This function is 
distinct from REQVERIFY. This functions merely tells you 
that a Requester has opened, whereas REQVERIFY requires 
you to respond before the Requester is opened. 

— MENUVERIFY is the flag you set to have Intuition stop 
and wait for you to finish all graphical output to your 
Window before rendering the menus. Menus are currently 
rendered in the most. memory-efficient way, which 
involves interrupting output to all Windows in the 
Screen before the Menus are drawn. If you need to 
finish your graphical output before this happens, 
you can set this flag to make sure that you do. 

— SIZEVERIFY means that you will be doing output to your 
Window which depends on a knowledge of the current size 
of the Window. If the user wants to resize the 
Window, you may want to make sure that any queued 
output completes before the sizing takes place 
(critical Text, for. instance). If this is the case, 
set this flag. Then, when the user wants to size, 
Intuition will send you the SIZEVERIFY message and 
Wait() until you reply that it's OK to proceed with 
the sizing. NOTE: when I say that Intuition will 





| 











Wh 


Oost -¥ 


Wait() until you reply, what I'm really saying is 

that User will WAIT until you reply, which suffers the 
great negative potential of User-Unfriendliness. So 
remember: use this flag sparingly, and, as always 
with any IDCMP Message you receive, Reply to it 
promptly! Then, after User has sized the Window, you 
can find out about it using NEWSIZE: 


With all of the "VERIFY" functions, it is not safe 
to .leve them enabled at any time when you task may 
not be able to respond for a long period. 


It is NEVER safe to call Amigabos, directly or 
indirectly, when a “VERIFY" function is active. 

If AmigaDOS needs to put up a disk requester for you, 
your task might end up waiting for the requester 

to be satisfied, at the same time as Intuition is 
waiting for your response. The result is a complete 
machine lockup. USE ModifyIDCMP TO TURN OFF ANY VERIFY 
MESSAGES BEFORE CALLING AmigaDOS!!! 


NEWSIZE is the flag that tells Intuition to send an IDCMP 
Message to you after the user has resized your Window. 

At this point, you could examine the size variables 

in your Window structure to discover the new size 

of the Window 

REFRESHWINDOW when set will cause a Message to be sent 
whenever your Window needs refreshing. This flag makes 
sense only with SIMPLE REFRESH and SMART_REFRESH Windows. 
MOUSEBUTTONS will get reports about Mouse-button 

Up/Down events broadcast to you (Note: only the 

ones that don't mean something to Intuition. If 

the user clicks the Select button over a Gadget, 
Intuition deals with it and you don't find out 

about it through here). 

MOUSEMOVE will work only if you've set the flag 
REPORTMOUSE above, or if one of your Gadgets has the 

flag FOLLOWMOUSE set. Then all mouse movements will be 
reported here. 

GADGETDOWN means that when the User "selects" a Gadget 
you've created with the GADGIMMEDIATE flag set, the fact 
will be broadcast through the IDCMP. 

GADGETUP means that when the User "releases" a Gadget that 
you've created with the RELVERIFY flag set, the fact 

will be broadcast through the IDCMP. 

MENUPICK selects that MenuNumber data will come this way 
CLOSEWINDOW means broadcast the CLOSEWINDOW event through 
the IDCMP rather than the Console 

RAWKEY selects that all RAWKEY events are transmitted via 
the IDCMP. Note that these are absolutely RAW keycodes, 
which you will have to massage before using. Setting this 
and the MOUSE flags effectively eliminates the need to 
open a Console Device to get input from the keyboard and 
mouse. Of course, in exchange you lose all of the Console 
features, most notably the "cooking" of input data and 
the systematic output of text to your Window. 


VANILLAKEY is for developers who don't want the hassle 

of RAWKEYS. This flag will return all the keycodes 

after translation via the current country~dependant keymap. 
When you set this flag, you will get IntuiMessages where the 
Code field has a decoded ASCII character representing the key 
struck on the keyboard. Only codes that map to one character 
are returned, you can't read such keys as HELP or the Function 
keys with VANILLAKEY. 


INTUITICKS gives you simple timer events from Intuition when 
your window is the active one; it may help you avoid opening 
and managing the timer device. With this flag set, you will 
get only one queued-up INTUITICKS message at a time. If 





Intuition notices that you've been sent an INTUITICKS message 
and haven't replied to it, another message will not be sent. 
Intuition receives timer events ten times a second 
(approximately) . 


— DELTAMOVE gives raw (unscaled) input event delta X/Y values. 
This is so you can detect mouse motion regardless of 
screen/window/display boundaries. Note that MOUSEBUTTONS 
messages will also be affected. 


— NEWPREFS indicates you wish to be notified when the system— 
wide preferences changes. 


— Set ACTIVEWINDOW and INACTIVEWINDOW to get messages when those 
events happen to your window. Take care not to confuse this 
“ACTIVEWINDOW" with the remarkably familiar sounding, but 
totally different "WINDOWACTIVE" flag. 


Gadgets = the pointer to the first of a linked list of the your own 
Gadgets which you want attached to this Window. Can be NULL 
if you have no Gadgets of your own 

CheckMark = a pointer to an instance of the struct Image where can 
be found the imagery you want used when any of your 
MenuItems is to be checkmarked. If you don't want to 
supply your own imagery and you want to just use 
Intuition's own checkmark, set this argument to NULL 

Text = a null-terminated line of text to appear on the title bar of 
your window (may be null if you want no text) 

Type = the Screen type for this window. If this equal CUSTOMSCREEN, 
you must have already opened a CUSTOMSCREEN (see text above). 
Types available include: 

— WBENCHSCREEN 
— CUSTOMSCREEN 

Screen = if your type is one of Intuition's Standard Screens, then 
this argument is ignored. However, if Type == CUSTOMSCREEN, 
this must point to the structure of your own Screen 

BitMap = if you have specified SUPER_BITMAP as the type of refreshing you 

want for this Window, then this value points to a instance of 
the struct BitMap. However, if the refresh type is NOT 
SUPER_BITMAP, this pointer is ignored 

MinWidth, MinHeight, MaxWidth, MaxHeight = the size limits for this 
that the minimums cannot be greater than the current size, 
nor can the maximums be smaller than the current size. 


The maximums may be LARGER than the current size, or even larger 
than the current screen. The maximums should be set to 

the highest value your application can handle. This allows 
users with larger display devices to take full advantage 

of your software. If there is no good reason to limit the size, 
then don't. -l or ~0 indicates the maximum available. 


Any one of these can be initialized to zero, which means that 
limit will be set to the current dimension of that axis. 

The limits can be changed after the Window is opened by calling 
the WindowLimits() routine. 


RESULT 


If all is well, returns the pointer to your new Window 
If anything goes wrong, returns NULL 


BUGS 


SEE ALSO 


OpenScreen() 
Modify IDCMP () 
WindowTitles () 





TSTt - ¥ 











intuition. library/OpenWorkBench intuition. library/OpenWorkBench 


NAME 

OpenWorkBench -- Opens the WorkBench Screen 
SYNOPSIS 

WBScreen = OpenWorkBench( ) 

DO 


struct Screen *WBScreen; 


FUNCTION 
This routine attempts to reopen the WorkBench. The actions taken are: 
— general good stuff and nice things, and then return a non-null 
pointer to the Workbench Screen. 
— find that something has gone wrong, and return NULL 


The return value, if not NULL, is indeed the address of the Workbench 
Screen, although you should not use it as such. This is because the 
Workbench may be closed by other programs, which can invalidate 

the address at any time. We suggest that you regard the return 

value as a BOOL indication that the routine has succeeded, if 

you pay any attention to it at all. 


INPUTS 
None 


RESULT 
non-FALSE if WorkBench Screen opened successfully, or was already opened 
FALSE if anything went wrong and the WorkBench Screen isn't out there 
BUGS 


SEE ALSO 








intuition. library/PrintIText intuition. library/PrintIText 
NAME 
PrintIText -- prints the text according to the IntuiText argument 
SYNOPSIS 
PrintIiText(RastPort, IText, LeftOffset, TopOffset) 
AO Al DO D1 


struct RastPort *RastPort; 
struct IntuiText *IText; 
SHORT LeftOffset, Topoffset; 


FUNCTION 
Prints the IntuiText into the specified RastPort. Sets up the RastPort 
as specified by the IntuiText values, then prints the text into the 
RastPort at the IntuiText x/y coordinates offset by the left/top 
arguments. Note, though, that the IntuitText structure itself 
may contain further text position coordinates: those coordinates 
and the Left/Topoffsets are added to obtain the true position of 
the text to be rendered. 


This routine does window layer clipping as appropriate —- if you 
print text outside of your Window, your characters will be 
clipped at the Window's edge. 


If the NextText field of the IntuiText argument is non-NULL, 
the next IntuiText is rendered as well, and so on until some 
NextText field is NULL. 


IntuiText with the ITextAttr field NULL are displayed in the 
font of the RastPort. If the RastPort font is also NULL, the 
system default font, as set via the Preferences tool, will be used. 


INPUTS 
RastPort = the RastPort destination of the text 
IText = pointer to an instance of the structure IntuiText 
Leftoffset = left offset of the IntuiText into the RastPort 
TopOffset = top offset of the IntuiText into the RastPort 


RESULT 
None 


BUGS 


SEE ALSO 





est -~ ¥ 








fintuition. library/RefreshGadgets intuition. library/RefreshGadgets 
NAME 
RefreshGadgets -- Refresh (redraw) the Gadget display 
SYNOPSIS 
RefreshGadgets (Gadgets, Window, Requester) 
AQ AL B2 
FUNCTION 


Refreshes (redraws) all of the Gadgets in the Gadget List starting 
from the specified Gadget. 


The Window parameter must point to the window which contains the Gadget, 
or which contains the Requester that contains the Gadget 

The Requester parameter must only be valid if the Gadget has the 
REQGADGET flag set, a requirement for all Requester Gadgets. 


The Pointer argument points a Window structure. 


The two main reasons why you might want to use this routine are: 
first, that you've modified the imagery of the Gadgets in your 
display and you want the new imagery to be displayed; secondly, 
if you think that some graphic operation you just performed 
trashed the Gadgetry of your display, this routine will refresh 
the imagery for you. 


Note that to modify the imagery of a gadget, you must first remove 
that gadget from the Window's Gadget list, using RemoveGadget() (or 
RemoveGList()). After changing the Image, Border, Text: (including 
Text for a String Gadget), the gadget is replaced in the Gadget List 
(using AddGadget() or AddGList()). Adding gadgets does not cause 
them to be displayed (refreshed), so this function, or RefreshGList() 
is typically called. 


A common technique is to set or reset the SELECTED flag of a 
Boolean Gadget and then call RefreshGadgets() to see them displayed 
highlighted if and only if SELECTED is set. If you wish to do this 
and be completely proper, you must RemoveGadget(), change SELECTED 
flag, AddGadget(), and RefreshGadgets(), or the equivalent. 


The Gadgets argument can be a copy of the FirstGadget variable in 
either the Screen or Window structure that you want refreshed: 

the effect of this will be that all Gadgets will be redrawn. 
However, you can selectively refresh just some of the Gadgets 

by starting the refresh part-way into the list: for instance, 
redrawing your Window non-GIMMEZEROZERO Gadgets only, which you've 
conveniently grouped at the end of your Gadget list. 


Even more control is available using the RefreshGList routine which 
enables you to refresh a single gadget, or number of your choice. 


NOTE: It's never safe to tinker with the Gadget list yourself. Don't 
supply some Gadget list that Intuition hasn't already processed in 
the usual way. 


INPUTS 
Gadgets = pointer to the first in the list of Gadgets wanting refreshment 
Window = pointer to the Window containing the Gadget or its Requester 
Requester = pointer to a Requester (ignored if Gadget is not attached to 
a Requester). 


RESULT 
None 


BUGS 


SEE ALSO 
RefreshGList(), RemoveGadget(), RemoveGList(), AddGadget(), AddGList() 


Uh 





intuition. library/RefreshGList intuition. library/RefreshGList 
NAME 
RefreshGList. -- Refresh (redraw) a chosen number of gadgets. 
SYNOPSIS 
RefreshGList (Gadgets, Window, Requester, NumGad) 
AO Al A2 DO 


struct Gadget *Gadget; 
struct Window *Window; 
struct Requester *Requester; 
SHORT NumGad; 


FUNCTION 
Refreshes (redraws) Gadgets in the Gadget List starting 
from the specified Gadget. At most NumGad gadgets are redrawn. 
If NumGad is -1, all gadgets until a terminating NULL value 
in the NextGadget field is found will be refreshed, making this 
routine a superset of RefreshGadgets(). 


The Requester variable can point to a Requester structure. If 
the first Gadget in the list has the REQGADGET flag set, the 
Gadget list refers to Gadgets in a Requester and the Pointer 
must. necessarily point to a Window. If these are not the Gadgets 
of a Requester, the Requester argument may be NULL. 


Be sure to see the RefreshGadgets() function description, as this 
function is simple an extension of that. 


INPUTS 
Gadgets = pointer to the first in the list of Gadgets wanting refreshment 
Window = pointer to the Window containing the Gadget or its Requester 
Requester = pointer to a Requester (ignored if Gadget is not attached to 
a Requester). 
NumGad = maximum number of gadgets to be refreshed. A value of -1 
will cause all gadgets to be refreshed from Gadget to the 
end of the list. A value of -2 will also do this, but if Gadget 
is a Requester Gadget (REQGADGET) ALL gadgets in the requester 
will be refreshed (this is a mode compatible with vl.1 
RefreshGadgets(). 


RESULT 
None 


BUGS 


SEE ALSO 
RefreshGadgets() 

















est - ¥ 











intuition. library/RefreshWindowFrame 


NAME 

RefreshWindowFrame ~~ Ask Intuition to redraw your window border/gadgets 
SYNOPSIS 

RefreshWindowFrame (Window) 


AO 
struct Window *Window; 
FUNCTION 
Refreshes the border of a window, including title region and all 
of the window's gadgets. 


You may use this call if you wish to update the display of your borders. 
The expected use of this is to correct unavoidable corruption. 


INPUTS 
Window = a pointer to a Window structure 


RESULT 
None 


BUGS 


SEE ALSO 


intuition. library/RemakeDisplay 





intuition. library/RemakeDisplay 


NAME 
RemakeDisplay -- Remake the entire Intuition display 


SYNOPSIS 
RemakeDisplay({ ) 


FUNCTION 
This is the big one. 


This procedure remakes the entire Intuition display. It does 
the equivalent of MakeScreen() for every Screen in the system, 
and then it calls RethinkDisplay()- 


WARNING: This routine can take several milliseconds to run, so 

do not use it lightly. RethinkDisplay() (called by this routine) 
does a Forbid() on entry and a Permit() on exit, which can seriously 
degrade the performance of the multi-tasking Eexecutive. 


INPUTS 
None 


RESULT 
None 


BUGS 


SEE ALSO . . 
MakeScreen(), RethinkDisplay(), graphics. library/MakevPort 








i 





vST - ¥ 





[intuition. library/RemoveGadget intuition. library/RemoveGadget intuition. library/RemoveGList intuition. library/RemoveGList 


NAME NAME: 
RemoveGadget -- removes a Gadget from a Window RemoveGList -- removes a sublist of Gadgets from a Window. 
SYNOPSIS SYNOPSTS 
Position = RemoveGadget (Window, Gadget) Position = RemoveGList(Window, Gadget, Numgad) 
DO Al AL DO AO Al DO 
USHORT Position; struct Window *Window; 
struct Window *Window; struct Gadget *Gadget; 
struct Gadget *Gadget; SHORT Numgad; 
FUNCTION FUNCTION 
Removes the given Gadget from the Gadget list of the specified Removes 'Numgad' Gadgets from the Gadget list of the specified 
Window. Returns the ordinal position of the removed Gadget. Window. Will remove Gadgets from a Requester if the first 


Gadget's GadgetType flag REQGADGET is set. 
If the Gadget is in a Requester attached the the window, this 


routine will look for it and remove it if it is found. Otherwise identical to RemoveGadget() 
If the Gadget pointer points to a Gadget that isn't in the NOTE 
appropriate list, ~1 is returned. If there aren't any Gadgets in the The last gadget in the list does NOT have it's link zeroed. 
list, -l is returned. If you remove the 65535th Gadget from the list 
-l is returned. INPUTS 
Window = pointer to the Window containing the Gadget or the Requester 
INPUTS containing the Gadget to be removed. 
Window = pointer to the Window containing the Gadget. or the Requester Gadget = pointer to the Gadget to be removed. The Gadget itself 
containing the Gadget to be removed. describes whether this is a Gadget that should be removed 
Gadget = pointer to the Gadget to be removed. The Gadget itself describes from the Window or some Requester. 
whether this is a Gadget that should be removed from the Window Numgad = number of gadgets to be removed. If -1, remove all gadgets 
or some Requester. to end of Window Gadget List 
RESULT RESULT 
Returns the ordinal position of the removed Gadget.- If the Gadget Returns the ordinal position of the removed Gadget. If the Gadget 
wasn't found in the appropriate list, or if there are no Gadgets in wasn't found in the appropriate list, or if there are no Gadgets in 
the list, returns -1. the list, returns -1. 
BUGS BUGS 
SEE ALSO SEE ALSO 


AddGadget(), RemoveGList() RemoveGadget(), AddGadget() 














SsT -¥ 


intuition. library/ReportMouse 





L 





intuition. library/ReportMouse 


NAME 
ReportMouse -- tells Intuition whether to report mouse movement. 
SYNOPSIS 
ReportMouse (Boolean, Window) 
DO AQ <-note 


BOOL Boolean; 
struct Window *Window; 


SPECIAL NOTE 
Some compilers and link files switch the arguments to this function about 
in unpredictable ways. The call will take one of two forms: 


ReportMouse(Window, (ULONG)Boolean) ; 
-or— 
ReportMouse(Boolean, Window) ; 


The Manx Aztec compiler prefers the second form. From assembler the 
interface is always the same: Boolean in D0, Window in AO 


Also, it is still endorsed to simply set the REPORTMOUSE flag bit 
in Window->Flags, or reset it, on your own. Make the operation 
an atomic assembly instruction (e.g.: OR.W #REPORTMOUSE , wd_Flags+2(A0) 
where AO contains your window pointer). Most compilers will produce 
an atomic operation when faced with: 

Window->Flags |= REPORTMOUSE; 

Window->Flags &=~REPORTMOUSE ; 
or else bracket the operation between Forbid/Permit(). 


FUNCTION 
Tells Intuition whether or not to broadcast mouse-movement events to 
your Window when it's the active one. The Boolean value specifies 
whether to start or stop broadcasting position information of 
mouse-movement. -If the Window is the active one, mouse-movement reports 
start coming immediately afterwards. This same routine will change 
the current state of the FOLLOWMOUSE function of a 
currently-selected Gadget too. 


Note that calling ReportMouse() when a Gadget is selected will only 
temporarily change whether or not mouse movements are reported while 
that Gadget remains selected; the next time the Gadget is selected, its 
FOLLOWMOUSE flag is examined anew. 


Note also that calling ReportMouse() when no Gadget. is currently 
selected will change the state of the Window's REPORTMOUSE flag, but 
will have no effect on any Gadget that may be subsequently selected. 


The ReportMouse(): function is first performed when OpenWindow( ) 
is first called; if the flag REPORTMOUSE is included among 

the options, then all mouse-movement events are reported 

to the opening task and will continue to be reported 

until ReportMouse() is called with a Boolean value of FALSE. 

If REPORTMOUSE is not set, then no mouse-movement reports will 

be broadcast until ReportMouse() is called with a Boolean of TRUE. 


Note that the REPORTMOUSE flag, as managed by this routine, determines 
IF mouse messages are to be broadcast. Determining HOW they are to 
be broadcast is determined by the MOUSEMOVE IDCMPFlag. 


INPUTS 
Window = pointer to a Window structure associated with this request 
Boolean =~ TRUE or FALSE value specifying whether to turn this 
function on or off 


RESULT 
None 


BUGS 
See above 








SEE ALSO 
The Input and Output section of the Intuition Reference Manual 





9ST - WV 


intuition. library/Request intuition. library/Request intuition. library/RethinkDisplay intuition. library/RethinkDisplay 





NAME NAME 
Request -~- Activates a Requester. RethinkDisplay -- the grand manipulator of the entire Intuition display 
SYNOPSIS SYNOPSIS 
Success = Request (Requester, Window) ; RethinkDisplay() 
DO AO Al 
FUNCTION 
BOOL Success; This function performs the Intuition global display reconstruction. This 
struct Requester *Requester; includes rethinking about all of the ViewPorts and their relationship to 
struct Window *Window; another and reconstructing the entire display based on the results of this 
rethinking. 
FUNCTION 
Links in and displays a Requester into the specified Window. Specifically, and omitting some internal details, the operation consists 


of this: 
This routine ignores the Window's REQVERIFY flag. 
Determine which ViewPorts are invisible and set their VP_HIDE 


INPUTS ViewPort Mode flag. 
Requester = pointer to the Requester to be displayed 
Window = pointer to the Window into which this Requester goes If a change to a viewport height or changing interlace needs 
require, MakeVPort() is called for specific ViewPorts. After 
RESULT this phase, the Copper lists for each Screen's ViewPort are 
If the Requester is successfully opened, TRUE is returned. Otherwise, correctly set up. 


if the Requester could not be opened, FALSE is returned. 
MrgCop() and LoadView() are then called to get these copper lists 
BUGS in action, thus establishing the new state of the Intuition 
POINTREL requesters not currently supported, by THIS call, but display. 
are now supported for Double-Menu Requesters. 
You may perform a MakeScreen() on your Custom Screen before calling this 
SEE ALSO routine. The results will be incorporated in the new display, but 
The Requesters section of the Intuition Reference Manual changing the INTERLACE ViewPort mode for one screens must be reflected 
in the Intuition View, which is best left to Intuition. 





WARNING: This routine can take several milliseconds to run, so 

do not use it lightly. RethinkDisplay() does a Forbid() on entry 
and a Permit() on exit, which can seriously degrade the performance 
of the multi-tasking Eexecutive. 


INPUTS 
None 


RESULT 
None 


BUGS 
SEE ALSO 


RemakeDisplay(), graphics. library/MakeVPort(), graphics. library/MrgCop(), 
graphics. library/LoadView(), MakeScreen() 











4ST - W 











intuition. library/ScreenToBack intuition. library/ScreenToBack intuition. library/ScreenToFront intuition. library/ScreenToFront 


NAME NAME 
ScreenToBack -—- send the specified Screen to the back of the display. ScreenToFront -- brings the specified Screen to the front of the display 
SYNOPSIS SYNOPSIS 
ScreenToBack (Screen) ScreenToFront (Screen) 
AO 
struct Screen *Screen; FUNCTION 
Brings the specified Screen to the front of the display. 
FUNCTION 
Sends the specified Screen to the back of the display. INPUTS 
Screen = a pointer to a Screen structure 
INPUTS 
Screen = pointer to a Screen structure RESULT 
None 
RESULT 
None BUGS 
BUGS SEE ALSO 
SEE ALSO 





8cT -¥ 





intuition. library/SetDMRequest 


NAME . 
SetDMRequest -- sets the DMRequest of the Window. 


SYNOPSIS 
SetDMRequest (Window, DMRequester) 
AO Al 


struct Window *Window; 
struct Requester *DMRequester; 


FUNCTION 
Attempts to set the DMRequester into the specified window. 
The DMRequester is the special Requester that you attach to 
the double-click of the menu button which the user can then 
bring up on demand. This routine WILL NOT set the DMRequester 
if it's already set and is currently active (in use by the user). 
After having called SetDMRequest(), if you want to change the 
DMRequester, the correct way to start is by calling ClearDMRequest() 
until it returns a value of TRUE; then you can call SetDMRequest() 
with the new DMRequester. 


If the POINTREL flag is set, the DMR will open as close to the 
pointer as possible. The RelLeft/Top fields are for fine-tuning 
the position. 


INPUTS 
Window = pointer to the window from which the DMRequest is to be set 
DMRequester = a pointer to a Requester 


RESULT 
If the current DMRequest was not in use, sets the DMRequest 
pointer into the Window and returns TRUE. 
If the DMRequest was currently in use, doesn't change the pointer 
and returns FALSE 


BUGS 


SEE ALSO 
ClearDMRequest(), Request () 


intuition. library/SetMenuStrip 


intuition. library/SetDMRequest 








intuition. library/SetMenuStrip 


SetMenuStrip ~-- Attaches the Menu strip to the Window. 


SYNOPSIS 


Success = SetMenuStrip(Window, Menu) 
DO AO AL 


BOOL Success; 
struct Window *Window; 
struct Menu *Menu; 


FUNCTION 


Attaches the Menu strip to the Window.’ After calling this routine, 
if the user presses the menu button, this specified menu strip 
will be displayed and accessible by the user. 


Menus with zero Menultems are not allowed. 


NOTE: You should always design your Menu strip changes to be a 
two-way operation, where for every Menu strip you add to your 
Window you should always plan to clear that strip sometime. Even 
in the simplest case, where you will have just one Menu strip for 
the lifetime of your Window, you should always clear the Menu strip 
before closing the Window. If you already have a Menu strip attached 
to this Window, the correct procedure for changing to a new Menu 
strip involves calling ClearMenuStrip() to clear the old first. 
The sequence of events should be: 

— OpenWindow( ) 

— zero or more iterations of: 

— SetMenuStrip() 

~ ClearMenuStrip() 

— CloseWindow( ) 


INPUTS 


Window = pointer to a Window structure 
Menu =. pointer to the first Menu in the Menu strip 


RESULT 


TRUE if there were no problems. TRUE always, since this routine 
will Wait until it is OK to proceed. 


BUGS 


SEE ALSO 


ClearMenuStrip() 








est - ¥ 


intuition. library/SetPointer 








intuition. library/SetPointer 


NAME 
SetPointer -—- sets a Window with its own Pointer 
SYNOPSIS 
SetPointer(Window, Pointer, Height, Width, XOffset, YOffset) 


AO Al DO Dl D2 D3 


struct Window *Window; 
USHORT *Pointer; 

SHORT Height, Width; 
SHORT XOffset, YOffset,; 


FUNCTION 
Sets up the Window with the sprite definition for the Pointer. 
Then whenever the Window is the active one, the Pointer 
image will change to its version of the Pointer. If the 
Window is the active one when this routine is called, the 
change takes place immediately. 


The xOffset and YOffset are used to offset the top-left corner 
of the hardware sprite imagery from what Intuition regards as 
the current position of the Pointer. Another way of describing 
it is as the offset from the "hot spot" of the Pointer to the 
top-left corner of the sprite. For instance, if you specify 
offsets of zero, zero, then the top-left corner of your sprite 
image will be placed at the Pointer position. On the other hand, 
if you specify an XOffset of —7 (remember, sprites are 16 pixels 
wide) then your sprite will be centered over the Pointer position. 
If you specify an xOffset of -15, the right-edge of the sprite 
will be over the Pointer position. 


INPUTS 
Window = pointer to the Window to receive this Pointer definition 
Pointer = pointer to the data definition of a Sprite 
Height = the height of the Pointer 


Width = the Width of the sprite (must be less than or equal to sixteen) 
XOffset = the offset for your sprite from the Pointer position 
YOffset = the offset for your sprite from the Pointer position 
RESULT 
None 
BUGS 
SEE ALSO 


ClearPointer () 


intuition. library/SetPrefs 








intuition. library/SetPrefs 


NAME 
SetPrefs -——- Set Intuition Preferences. 
SYNOPSIS . 
Prefs = SetPrefs(PrefBuffer, Size, Inform) 
DO AO DO DL 


struct Preferences *Prefs; 
struct Preferences *PrefBuffer; 
int Size; 

BOOL Inform; 


FUNCTION 
Sets new Preferences values. Copies the first 'Size' bytes 
from your Preferences buffer to the system Preferences table, 
and puts them into effect. 


The ‘Inform' parameter, if TRUE, indicates that a NEWPREFS 
message is to be sent to all Windows that have the NEWPREFS 
IDCMPFlag set. 


It is legal to set a partial copy of the Preferences structure. 
The most frequently changed values are grouped at the beginning 
of the Preferences structure. 


INPUTS 
PrefBuffer = pointer to the memory buffer which contains your 
desired settings for Intuition Preferences 
Size = the number of bytes in your PrefBuffer, the number of bytes 
you want copied to the system's internal Preference settings 
Inform = whether you want the information of. a new Preferences 
setting propogated to all windows. 


RESULT 
Returns your parameter PrefBuffer. 


BUGS 


SEE ALSO 
GetDefPrefs(), GetPrefs() 








o9T —~ ¥ 











intuition. library/SetWindowTitles intuition, library/SetWindowritles 


NAME 

SetWindowTfitles -—- Sets the Window's titles for both Window and Screen 
SYNOPSIS 

SetWindowTitles (Window, WindowTitle, ScreenTitle) 


AO Al A2 


struct Window *Window; 
UBYTE *WindowTitle, *ScreenTitle; 


FUNCTION 
Allows you to set the text which appears in the Window and/or Screen 
title bars. 


The Window Title appears at all times along the Window Title Bar. 
The Window's Screen Title appears at the Screen Title Bar whenever 
this Window is the active one. 


When this routine is called, your Window Title will be changed 
immediately. If your Window is the active one when this routine is 
called, the Screen Title will be changed immediately. 


You can specify a value of ~] (i.e. (struct Window *) ~0) for either of 
the title pointers. This designates that you want to Intuition to leave 
the current setting of that particular title alone, and modify 

only the other one. Of course, you could set both to -l. 


Furthermore, you can set a value of 0 (zero) for either of the 
title pointers. Doing-so specifies that you want no title to 
appear (the title bar will be blank). 


Both of the titles are rendered in the default font of the Window's 
Screen, as set using OpenScreen(). 


In setting the Window's title, Intuition may do some other rendering 

in the top border of your window. If your own rendering sometimes appears 
in your window border areas, you may want to restore the entire 

window border frame. The function SetWindowTitles() does not do this 

in the newer versions. The function RefreshWindowFrame() is provided 

to do this kind of thing for you. 


INPUTS 
Window = pointer to your Window. structure 
WindowTitle = pointer to a null-terminated text string, or set to 
either the value of -l (negative one) or 0 (zero) 
ScreenTitle = pointer to a null-terminated text string, or set to 
either the value of ~1 (negative one) or 0 (zero) 


RESULT 
None 


BUGS 


SEE ALSO 
OpenWindow(), RefreshWindowFrame(), OpenScreen() 











intuition. Library/ShowTitle 





intuition. library/ShowTitle 


NAME 

ShowTitle -—- Set the Screen title bar display mode 
SYNOPSTS 

ShowTitle(Sereen, ShowIt) 

AO po 

struct Screen *Screen; 

BOOL Showlt; 
FUNCTION 


This routine sets the SHOWTITLE flag of the specified Screen, and 
then coordinates the redisplay of the Screen and its Windows. 


The Screen title bar can appear either in front of or behind BACKDROP 
Windows. This is contrasted with the fact that non-BACKDROP Windows 
always appear in front of the Screen Title Bar. You specify whether 
you want the Screen Title Bar to be in front of or behind the 
Screen's BACKDROP Windows by calling this routine. 


The ShowIt argument should be set to either TRUE or FALSE. If TRUE, 
the Screen's Title Bar will be shown in front of BACKDROP Windows. 
If FALSE, the Title Bar will be rendered behind all Windows. 


When a Screen is first opened, the default setting of the SHOWTITLE 
flag is TRUE. 


INPUTS 
Sereen = pointer to a Screen structure 
ShowIt = Boolean TRUE or FALSE describing whether to show or hide the 
Screen Title Bar 


RESULT 
None 


BUGS 


SEE ALSO 














T9T - ¥ 











intuition. Library/sizewindow intuition. library/Sizewindow Jintuition. library/UnlockIBase intuition. library/UnlockI Base 


NAME. 

SizeWindow -~- Ask Intuition to size a Window. 
SYNOPSIS 

SizeWindow(Window, DeltaXx, DeltaY) 


AQ DO DL 


struct Window *Window; 
SHORT DeltaX, DeltaY; 


FUNCTION 
This: routine sends a request to Intuition asking to size the Window 
the specified amounts. The delta arguments describe how much to 
size the Window along the respective axes. 


Note that the Window will not be sized immediately, but rather 

will be sized the next time Intuition receives an input event, 

which happens currently at a minimum rate of ten times per second, 

and a maximum of sixty times a second. You can discover when 

you Window has finally been sized by setting the NEWSIZE flag 

of the IDCMP of your Window. See the "Input and Output Methods" 
chapter of The Intuition Reference Manual for description of the IDCMP. 


This routine does no error-checking. If your delta values specify 
some far corner of the Universe, Intuition will attempt to size 
your Window to the far corners of the Universe. Because of the 
distortions in the space-time continuum that can result from this, 
as predicted by special relativity, the result is generally not 

a pretty sight. 


INPUTS 
Window 
Deltax 
DeltaY 


pointer to the structure of the Window to be sized 
signed value describing how much to size the Window on the x-axis 


signed value describing how much to size the Window on the y-axis 


lobow 


RESULT 
None 


BUGS 


SEE ALSO 
MoveWindow(), WindowToFront(), WindowToBack () 





NAME 
UnlockIBase —— surrender an Intuition lock gotten by LockIBase( ) 


SYNOPSIS 
UnlockIBase (Lock) 
AO 
ULONG Lock; 
FUNCTION 
Surrenders lock gotten by LockIBase(). 


Calling this function when you do not own the specified lock will 
immediately crash the system. 


INPUTS 
The value returned by LockIBase() should be passed to this function, 
to specify which internal lock is to be freed. 


Note that the parameter is passed in AO, not DO, for historical reasons. 


RESULT 
None 


BUGS 


SEE ALSO 
LockIBase( ) 


ill 





e9T - © 





intuition. library/ViewAddress intuition. library/ViewAddress intuition. library/ViewPortAddress intuition. Library/ViewPortAddress 





NAME NAME 
ViewAddress -~- Returns the address of the Intuition View structure. ViewPortAddress -~ Returns the address of a Window's ViewPort structure. 
SYNOPSIS SYNOPSIS 
ViewAddress() ViewPortAddress (Window) 
AO 
FUNCTION 
Returns the address of the Intuition View structure. If you struct Window *Window; 
want to use any of the graphics, text, or animation primitives 
in your Window and that primitive requires a pointer to a View, FUNCTION 
this routine will return the address of the View for you. Returns the address of the ViewPort associated with the specified 
Window. The ViewPort is actually the ViewPort of the Screen within which 
INPUTS the Window is displayed. If you want to use any of the graphics, text, 
None or animation primitives in your Window and that primitive requires a 
pointer to a ViewPort, you can use this call. 
RESULT 
Returns the address of the Intuition View structure INPUTS 
Window = pointer to the Window for which you want the ViewPort address 
BUGS 
RESULT 
SEE ALSO Returns the address of the Intuition View structure 
graphics. library 
BUGS 
SEE ALSO 


graphics. library 

















cot - © 





intuition. library/wBenchToBack 





intuition. library/wBenchToBack 


NAME 

WBenchToBack -—- Sends the WorkBench Screen in back of all Screens. 
SYNOPSIS 

Success = WBenchToBack() 

DO. 


BOOL Success; 


FUNCTION 
Causes the WorkBench Screen, if it's currently opened, to go to 
the background. This does not 'move' the Screen up or down, instead 
only affects the depth-arrangement of the Screen. 


If the WorkBench Screen was opened, this function returns (RUE, otherwise 
it returns FALSE. 


INPUTS 
None 


RESULT 
Tf the WorkBench Screen was opened, this function returns TRUE, otherwise 
it returns FALSE. 

BUGS 


SEE ALSO 
WBenchToFront(), ScreenToFront() 





intuition. library/WBenchToFront 





intuition. library/WBenchToFront 


NAME 

WBenchToFront -- Brings the WorkBench Screen in front of all Screens. 
SYNOPSIS 

Success = WBenchToFront() 

DO 


BOOL Success; 


FUNCTION 
Causes the WorkBench Screen, if it's currently opened, to come to 
the foreground. This does not 'move' the Screen up or down, instead 
only affects the depth-arrangement of the Screen. 


If the WorkBench Screen was opened, this function returns TRUE, otherwise 
it returns FALSE. 


INPUTS 
None 


RESULT 
If the WorkBench Screen was opened, this function returns TRUE, otherwise 
it returns FALSE. 

BUGS 


SEE ALSO 
WBenchToBack(), ScreenToBack( ) 





voOT —- ¥ 





[intuition. library/WindowLimits intuition. library/WindowLimits 


NAME 
WindowLimits -~ Set the minimum and maximum limits of the Window. 
SYNOPSIS 
Success = WindowLimits(Window, MinWidth, MinHeight, MaxWidth, MaxHeight) 
DO AO DO DL D2 D3 
BOooL Success; 


struct Window *Window; 
SHORT MinWidth, MinHeight ; 
USHORT MaxWidth, MaxHeight; 


FUNCTION 
Sets the minimum and maximum limits of the Window's size. Until this 
routine is called, the Window's size limits are equal to the Window's 
initial size, which means that the user won't be able to size it at all. 
After the call to this routine, the Window will be able to be sized 
to any dimensions within the specified limits. 


If you don't want to change any one of the dimensions, set the limit 
argument for that dimension to zero. If any of the limit arguments 
is equal to zero, that argument is ignored and the initial setting 
of that parameter remains undisturbed. 


If any of the arguments is out of range (minimums greater than the 
current size, maximums less than the current size), that limit 
will be ignored, though the others will still take effect if they 
are in range. If any are out of range, the return value from this 
procedure will be FALSE. If all arguments are valid, the return 
value will be TRUE. 


If you want your window to be able to become "as large as possible" 
you may put -1 (i.e. ~0) in either or both Max arguments. But 

please note: screen sizes may vary for several reasons, and you 

must be able to handle any possible size of window you might end 

up with if you use this method. Note that you can use the function 
GetScreenData() to find out how big the screen your window appears in 
is. That function is particularly useful if your window is in 

the Workbench Screen. 


if the user is currently sizing this Window, the new limits will 
not take effect until after the sizing is completed. 


INPUTS 
Window = pointer to a Window structure 
MinWidth, MinHeight, MaxWidth, MaxHeight = the new limits for the size 
of this Window. If any of these is set to zero, it will 
be ignored and that setting will be unchanged. 


RESULT 
Returns TRUE if everything was in order. If any of the parameters was 
out of range (minimums greater than current size, maximums less than 
current size), FALSE is returned and the errant limit request is 
not fulfilled (though the valid ones will be). 


BUGS 


SEE ALSO 
GetScreenData( ) 











intuition. library/WindowToBack intuition. library/WindowfoBack 


NAME 
WindowToBack -- Ask Intuition to send this Window to the back 
SYNOPSIS 
WindowToBack (Window) 
AO 
FUNCTION 


This routine sends a request to Intuition asking to send the Window 
in back of all other Windows in the Screen. 


Note that the Window will not be depth-arranged immediately, but rather 
will be arranged the next time Intuition receives an input event, 

which happens currently at a minimum rate of ten times per second, 

and a maximum of sixty times a second. 

Remember that BACKDROP Windows cannot be depth-arranged. 


INPUTS 
Window = pointer to the structure of the Window to be sent to the back 


RESULT 
None 


BUGS 


SEE ALSO 
MoveWindow(), SizeWindow(), WindowToFront( ) 














S9T -¥ 














intuition. library/WindowToFront intuition. library/WindowToFront 


NAME 
WindowToFront -- Ask Intuition to bring this Window to the front. 


SYNOPSIS 
WindowToFront (Window) 


FUNCTION 
This routine sends a request to Intuition asking to bring the Window 
in front of all other Windows in the Screen. 


Note that the Window will not be depth-arranged immediately, but rather 
will be arranged the next time Intuition receives an input event, 

which happens currently at a minimum rate of ten times per second, 

and a maximum of sixty times a second. 

Remember that BACKDROP Windows cannot be depth-arranged. 


INPUTS 
Window = pointer to the structure of the Window to be brought to front 


RESULT 
None 


BUGS 


SEE ALSO 
MoveWindow(), SizeWindow(), WindowT'oBack() 








| 


99T - W@W 








TABLE OF CONTENTS 


layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
layers. 
. Library/ThinLayerInfo 
layers. 
layers. 
layers. 
layers. 
layers. 


layers 





library/BeginUpdate 
library/BehindLayer 
library/CreateBehindLayer 
library/CreateUpfrontLayer 
library/DeleteLayer 
library/DisposeLayerInfo 
library/EndUpdate 
library/FattenLayerInfo 
library/InitLayers 
library/InstallClipRegion 
library/LockLayer 
library/LockLayerInfo 
library/LockLayers 
library/MoveLayer 

library /MoveLayerInFrontof 
library/NewLayerInfo 
library/ScrollLayer 
library/SizeLayer 
library/SwapBitsRastPortClipRect 


library/UnlockLayer 
library/UnlockLayerInfo 
library/UnlockLayers 
library/UpfrontLayer 
library/WhichLayer 





layers. library/BeginUpdate 








NAME 

BeginUpdate -- Prepare to repair damaged layer. 
SYNOPSIS 

result = BeginUpdate( 1 ) 

dao ad 


BOOLEAN result; 
struct Layer *1; 


FUNCTION 

Convert damage list to ClipRect list and swap in for 
programmer to redraw through. This routine simulates 

the ROM library environment. The idea is to only render in the 
"damaged" areas, saving time over redrawing all of the layer. 
The layer is locked against changes made by the layer library. 


INPUTS 
1 - pointer to a layer 





RESULTS 
result — TRUE if damage list converted to ClipRect list sucessfully. 
FALSE if list conversion aborted. (probably out of memory) 


BUGS 
If BeginUpdate returns FALSE, programmer must abort the attempt to 
refresh this layer and instead call EndUpdate( 1, FALSE ) to restore 
original ClipRect and damage list. 


SEE ALSO 
EndUpdate, graphics/layers.h, graphics/clip.h 


layers. library/BeginUpdate 


| 











49T - ¥ 








layers. library/BehindLayer layers. library/BehindLayer 


NAME 

BehindLayer —- Put layer behind other layers. 
SYNOPSIS 

result = BehindLayer( dummy, 1 ) 

dao aQ al 


BOOLEAN result; 
LONG dummy ; 
struct Layer *1; 


FUNCTION 
Move this layer to the most behind position swapping bits 
in and out of the display with other layers. 
If other layers are REFRESH then collect their damage lists and 
set the LAYERREFRESH bit in the Flags fields of those layers that 
may be revealed. If this layer is a backdrop layer then 
put this layer behind all other backdrop layers. 
If this layer is NOT a backdrop layer then put in front of the 
top backdrop layer and behind all other layers. , 


Note: this operation may generate refresh events in other layers 
associated with this layer's Layer_Info structure. 


INPUTS 
dummy — unused 
1 —- pointer to a layer 


RESULTS 
result -— TRUE if operation successful 
FALSE if operation unsuccessful (probably out of memory) 
BUGS 
SEE ALSO 


graphics/layers.h, graphics/clip-h 


llayers. Library/CreateBehindLayer layers. library/CreateBehindLayer 


NAME 

CreateBehindLayer -~ Create a new layer behind all existing layers. 
SYNOPSIS 

result = CreateBehindLayer(li,bm,x0,y0,xl,yl,flags [,bm2]) 

do aQ al dO dl d2 d3 a4 [ a2 ] 


struct Layer *result; 
struct Layer_Info *1li; 
struct BitMap *bm; 
LONG x0,y0,xl,yl; 

LONG flags; 

struct BitMap *bm2; 


FUNCTION 
Create a new Layer of position and size (x0,y0)~>(xl,yl) 
Make this layer of type found in flags. 
If SuperBitMap, use bm2 as pointer to real SuperBitMap, 
and copy contents of Superbitmap into display layer. 
If this layer is a backdrop layer then place it behind all 
other layers including other backdrop layers. If this is 
not a backdrop layer then place it behind all nonbackdrop 
layers. 


Note: when using SUPERBITMAP, you should also set LAYERSMART flag. 


INPUTS 

li - pointer to LayerInfo structure 

bm — pointer to common BitMap used by all Layers 

x0,y0 — upper left hand corner of layer 

x1,yl - lower right hand corner of layer 

flags - various types of layers supported as bit sets. 
(for bit definitions, see graphics/layers.h ) 

bm2 - pointer to optional Super BitMap 


RESULTS 
result - pointer to Layer structure if successful 
NULL if not successful 
BUGS 


SEE ALSO 
DeleteLayer, graphics/layers.h, graphics/clip.h, graphics/gfx.h 








| 











89T - ¥ 











layers. library/CreateUpfrontLayer layers. library/CreateUpfrontLayer 


NAME 

CreateUpfrontLayer -- Create a new layer on top of existing layers. 
SYNOPSIS 

result = CreateUpfrontLayer(1li,bm,x0,y0,xl,yl,flags [,bm2]) 

do aO al dO di d2 a3 d4 [ a2 ] 


struct Layer *result; 
struct Layer_Info *1i; 
struct BitMap *bm; 
LONG x0,y0,x1l,yl; 
LONG flags; 

struct BitMap *bm2; 


FUNCTION 
Create a new Layer of position and size (x0,y0)->(xl,yl) 
and place it on top of all other layers. 
Make this layer of type found in flags 
if SuperBitMap, use bm2 as pointer to real SuperBitMap. 
and copy contents of Superbitmap into display layer. 


Note: when using SUPERBITMAP, you should also set LAYERSMART flag. 


INPUTS 
li.- pointer to LayerInfo structure 
bm —- pointer to common BitMap used by all Layers 
x0,y0 -- upper left hand corner of layer 
xL,yl - lower right hand corner of layer 
flags ~ various types of layers supported as bit sets. 
bm2 — pointer to optional Super BitMap 


RESULTS 
result - pointer to Layer structure if successful 
NULL if not successful 
BUGS 


SEE ALSO 
DeleteLayer, graphics/layers.h, graphics/clip.h, graphics/gfx-.h 





layers. library/DeleteLayer 














layers. library/DeleteLayer 


NAME 

DeleteLayer -- delete layer from layer list. 
SYNOPSIS 

result = DeleteLayer( dummy, 1 ) 

dao ad, al 


BOOLEAN result; 
LONG dummy; 
struct Layer *1; 


FUNCTION 
Remove this layer from the list of layers. Release memory 
associated with it. Restore other layers that may have been 
obscured by it. Trigger refresh in those that may need it. 
If this is a superbitmap layer make sure SuperBitMap is current. 
The SuperBitMap is not removed from the system but is available 
for program use even though the rest of the layer information has 
been deallocated. 


INPUTS 
dummy ~ unused 
1 - pointer to a layer 


RESULTS 
result - TRUE if this layer successfully deleted from the system 
FALSE if layer not deleted. (probably out of memory ) 


BUGS 


SEE ALSO 
gvaphics/layers.h, graphics/clip.h 








69T - W 








layers. library/DisposeLayerInfo layers. library/DisposeLayeriInfo 


NAME 
DisposeLayerInfo —- Return all memory for LayerInfo to memory pool 


SYNOPSIS 
DisposeLayerInfo(1li) 
ad 
struct Layer_Info *li; 


FUNCTION 


return LayerInfo and any other memory attached to this LayerInfo 
to memory allocator. 


Note: if you wish to delete the layers associated with this Layer_Info 
structure, remember to call DeleteLayer() for each of the layers 
before calling DisposeLayerInfo(). 


INPUTS 
li - pointer to LayerInfo structure 


EXAMPLE 
~- delete the layers associated this Layer_Info structure -—~ 


DeleteLayer(li,simple_layer) ; 
DeleteLayer(li,smart_layer) ; 


-- see documentation on DeleteLayer about deleting SuperBitMap layers —— 
my_super_bitmap ptr = super_layer->SuperBitMap; 
DeleteLayer(li,super_layer) ; 

-- now dispose of the Layer_Info structure itself —- 
DisposeLayerInfo(1i); 


BUGS 


SEE ALSO 
DeleteLayer, graphics/layers.h 





Jlayers. library/EndUpdate 





layers. library/EndUpdate 


NAME 
EndUpdate -- remove damage list and restore state of layer to normal. 
SYNOPSIS 
EndUpdate( 1, flag ) 
ad do 


struct Layer *1; 
USHORT flag; 


FUNCTION 
After the programmer has redrawn his picture he calls this 
routine to restore the ClipRects to point to his standard 
layer tiling. The layer is then unlocked for access by the 
layer library. 


Note: use flag = FALSE if you are only making a partial update. 
You may use the other region functions (graphics functions such as 
OrRectRegion, AndRectRegion, and XorRectRegion ) to clip adjust 
the DamageList to reflect a partial update. 


INPUTS 
1 - pointer to a layer 
flag ~ use TRUE if update was completed. The damage list is cleared. 
use FALSE if update not complete. The damage list is retained. 
EXAMPLE 


-- begin update for first part of two-part refresh —— 
BeginUpdate(my_layer) ; 


-~- do some refresh, but not all ~~ 
my _partial_refresh_routine(my_layer); 


-- end update, false (not completely done refreshing yet) -~ 
EndUpdate(my_layer, FALSE); 


-- begin update for last part of refresh —— 
BeginUpdate(my_layer); 


—— do rest of refresh —— 
my_complete_refresh_routine(my_layer) ; 


-- end update, true (completely done refreshing now) —- 
EndUpdate(my_layer, TRUE); 


BUGS 


SEE ALSO 
BeginUpdate, graphics/layers.h, graphics/clip.h 








| 


olT - ¥ 





layers. library/PattenLayerinfo layers. library/FattenLayeriInfo 
NAME 

FattenLayerInfo -- convert 1.0 LayerInfo to 1.1 LayerInfo 

OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 


SYNOPSIS 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 
FattenLayeriInfo(1li) 
ad 


struct Layer_Info *1li; 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 


FUNCTION 
V1.1 software and any later releases need to have more info in the 
Layer Info structure. To do this in a 1.0 supportable manner requires 
allocation and deallocation of the memory whenever most 
layer library functions are called. To prevent unnecessary 
allocation/deallocation FattenLayerInfo will preallocate the 
necessary data structures and fake out the layer library into 
thinking it has a LayerInfo gotten from NewhayeriInfo. 
NewLayerinfo is the approved method for getting this structure. 
When a program needs to give up the LayerInfo structure it 
must call ThinLayerInfo before freeing the memory. ThinLayerInfo 
is not necessary if New/DisposeLayerInfo are used however. 


INPUTS 
li - pointer to LayerInfo structure 


BUGS 
SEE ALSO 


NewLayerInfo, ThinLayerInfo, DisposeLayerInfo, graphics/layers.h 














layers. library/InitLayers layers. library/InitLayers 
NAME: 

InitLayers -- Initialize Layer_Info structure 

OBSOLETE .OBSOLETE OBSOLETE OBSOLETE OBSOLETE 


SYNOPSIS 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 
InitLayers(1i) 
ad 


struct Layer_Info *li; 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 


FUNCTION 
Initialize Layer Info structure in preparation to use 
other layer operations on this list of layers. 
Make the Layers unlocked (open), available to layer operations. 


INPUTS 
li - pointer to LayerInfo structure 


BUGS 


SEE ALSO 
NewLayerinfo, DisposeLayerInfo, graphics/layers.h 





wit 








TiT -W¥ 





layers. library/InstallClipRegion 





layers. library/InstallClipRegion 


NAME 
InstallClipRegion ~- Install clip region in layer 
SYNOPSIS 
oldclipregion = InstallClipRegion( 1, region ) 
do aQ al 


struct Region *oldclipregion; 
struct Layer *1; 
struct Region *region; 


FUNCTION 
Installs a transparent Clip region in the layer. All 
subsequent graphics calls will be clipped to this region. 
You MUST remember to call InstallClipRegion(1,NULL) before 
calling DeleteLayer(1) or the Intuition function CloseWindow( ) 
if you have installed a non-NULL ClipRegion in 1. 


INPUTS 
1 - pointer to a layer 
region — pointer to a region 


RESULTS 
oldclipregion - The pointer to the previous ClipRegion that 
was installed. Returns NULL if no previous ClipRegion installed. 


Note: If the system runs out of memory while computing the 
resulting ClipRects the LAYERS_CLIPRECTS_LOST bit will 
be set in 1->Flags. 


BUGS 
If the system runs out of memory during normal layer operations, 
the ClipRect list may get swept away and not restored. 
As soon as there is enough memory and the layer library 
gets called again the ClipRect list will be rebuilt. 


SEB ALSO 
BeginUpdate EndUpdate, 
graphies/layers.h, graphics/clip.h, graphics/regions.h 


layers. library/LockLayer 





layers. library/LockLayer 


NAME 
LockLayer —- Lock layer to make changes to ClipRects. 


SYNOPSIS 
LockLayer( dummy, 1 ) 
ad al 


LONG dummy ; 
struct Layer *1; 


FUNCTION 
Make this layer unavailable for other tasks to use. 
If another task is already using this layer then wait for 
it to complete and then reserve the layer for your own use. 
(this function does the same thing as graphics. library/LockLayerRom) 


Note: if you wish to lock MORE THAN ONE layer at a time, you 
must. call LockLayerInfo() before locking those layers and 
then call UnlockLayerInfo() when you have finished. This 
is to prevent system "deadlocks". 


Further Note: while you hold the lock on a layer, Intuition will block 
on operations such as windowsizing, dragging, menus, and depth 
arranging windows in this layer's screen. It is recommended that 
YOU do not make Intuition function calls while the layer is locked. 


INPUTS 
dummy —- unused 
1 - pointer to a layer 


BUGS 
SEE ALSO 


UnlockLayer, LockLayerInfo, UnlockLayerInfo, 
graphics. library/LockLayerkom, graphics/layers.h, graphics/clip.h 








Il 





ezT - ¥ 











layers. library/LockLayerInfo layers. library/LockLayerinfo 


NAME 
LockLayerInfo —- Lock the LayerInfo structure. 


SYNOPSIS 
LockLayerInfo( li ) 
ad 


struct Layer Info *li; 


FUNCTION 
Before doing an operation that requires the LayerInfo 
structure, make sure that no other task is also using the 
LayerInfo structure. tLockLayerInfo() returns when the 
LayerInfo belongs to this task. There should be 
an UnlockLayerInfo for every LockLayerinfo. 


Note: All layer routines presently LockLayerInfo() when they 
start up and UnlockLayerinfo() as they exit. Programmers 
will need to use these Lock/Unlock routines if they wish 

to do something with the LayerStructure that is not 
supported by the layer library. 


INPUTS 
li — pointer to Layer_Info structure 


BUGS 


SEE ALSO 
UniockLayeriInfo, graphics/layers.h 


layers. library/LockLayers 





layers. library/LockLayers 


NAME 
LockLayers ~~ lock all layers from graphics output. 


SYNOPSIS 
LockLayers( li ) 
ad 
struct Layer_Info *li; 
FUNCTION 
First calls LockLayerInfo({)} 
Make all layers in this layer list locked. 


INPUTS 
li ~ pointer to Layer_Info structure 


BUGS 


SEE ALSO . 
LockLayer, LockLayerInfo, graphics/layers.h 











elt -Wv 








layers. library/MoveLayer layers. library/MoveLayer 


NAME 

MoveLayer —~ Move layer to new position in BitMap. 
SYNOPSIS 

result = MoveLayer( dummy, 1, dx, dy ) 

do ad al dO dl 

BOOLEAN result; 

LONG dunmmy ; 

struct Layer *1; 

LONG dx,dy; 
FUNCTION 


Move this layer to new position in shared BitMap. 
If any refresh layers become revealed, collect. damage and 
set REFRESH bit in layer Flags. 


INPUTS 
dummy - unused 
1 + pointer to a nonbackdrop layer 
dx - delta to add to current x position 
dy - delta to add to current y position 


RETURNS 
result — TRUE if operation successful 
FALSE if failed (out of memory) 


BUGS 
May not handle (dx,dy) which attempts to move the layer ouside the 
layer's RastPort->BitMap bounds . 


SEE ALSO 
graphics/layers.h, graphics/clip.h 











layers. library/MoveLayerInFrontof 





layers. library/MoveLayerInFrontof 


NAMB 
MoveLayerInFrontOf-- Put layer in front.of another layer. 
SYNOPSIS 
result = MoveLayerInFrontof( layertomove, targetlayer ) 
ad al 


BOOLEAN result; 
struct. Layer *layertomove; 
struct Layer *targetlayer; 


FUNCTION 
Move this layer in front of target layer, swapping bits 
in and out of the display with other layers. 
Tf this is a refresh layer then collect damage list and 
set the LAYERREFRESH bit in layer—>Flags if redraw required. 


Note: this operation may generate refresh events in other layers 
associated with this layer's Layer_Info structure. 


INPUTS 
layertomove ~ pointer to layer which should be moved 
targetlayer — pointer to target layer in front of which to move layer 


RESULTS 
result = TRUE if operation successful 
FALSE if operation unsuccessful (probably out of memory) 
BUGS 


SEE ALSO 
graphics/layers.h 








i 


PLT -— ¥ 





layers. library/NewLayerInfo 







layers. library/NewLayerInfo 









NAME 
NewLayerinfo —- Allocate and Initialize full Layer_Info structure. 






SYNOPSIS 
result = NewLayerInfo() 
do 


struct Layer_Info *result; 


FUNCTION 
Allocate memory required for full Layer_Info. structure. 
Initialize Layer _Info structure in preparation to use 
other layer operations on this list of layers. 
Make the Layer_Info unlocked (open). 


INPUTS 
None 


RESULT 
result— pointer to Layer_Info structure if successful 
NULL if not enough memory 
BUGS 


SEE ALSO 
graphics/layers.h 





layers. library/ScrollLayer 








layers. library/ScrollLayer 





NAME 
ScrollLayer —- Scroll around in a superbitmap, translate coordinates 
in non-superbitmap layer. 
SYNOPSIS 
ScrollLayer( dummy, 1, dx, dy ) 
ad al dO dl 
LONG dummy; 
struct Layer *1; 
LONG dx,dy; 
FUNCTION 


For a SuperBitMap Layer: 

Update the SuperBitMap from the layer display, then copy bits 
between Layer and SuperBitMap to reposition layer over different 
portion of SuperBitMap. 

For nonSuperBitMap layers, all (x,y) pairs are adjusted by 

the scroll(x,y) value in the layer. To cause (0,0) to actually 
be drawn at (3,10) use ScrollLayer(—3,-10). This can be useful 
along with InstallCclipRegion to simulate Intuition GZZWindows 
without the overhead of an extra layer. 


INPUTS 
dummy — unused 
1 - pointer to a layer 
dx -— delta to add to current x scroll value 
dy - delta to add to current y seroll value 


BUGS 
May not handle (dx,dy) which attempts to move the layer ouside the 
layer's SuperBitMap bounds. 


SBE ALSO 
graphics/layers.h 











Git -¥ 








layers. library/SizeLayer layers. library/SizeLayer 


NAME 

SizeLayer -- Change the size of this nonbackdrop layer. 
SYNOPSIS 

‘result = SizeLayer( dummy, 1, dx, dy ) 

ao ad al dO dl 

BOOLEAN result; 

LONG dummy ; 

struct Layer *1; 

LONG dx, dy; 
FUNCTION 


Change the size of this layer by (dx,dy). The lower right hand 
corner is extended to make room for the larger layer. 

If there is SuperBitMap for this layer then copy pixels into 

or out of the layer depending on whether the layer increases or 
decreases in size. Collect damage list for those layers that may 
need to be refreshed if damage occurred. 


INPUTS 
dummy - unused 
1 — pointer to a nonbackdrop layer 
dx - delta to add to current x size 
dy - delta to add to current y size 


RESULTS 
result — TRUE if operation successful 
FALSE if failed (out of memory) 
BUGS 


SEE ALSO 
graphics/layers.h, graphics/clip-h 








layers. Library/SwapBitsRastPortClipRect 


NAME 
SwapBitsRastPortClipRect —- Swap bits between common bitmap 
and obscured ClipRect 
SYNOPSIS 
SwapBitsRastPortClipRect( rp, cr ) 
aO al 


struct RastPort *rp; 
struct ClipRect *cr; 


FUNCTION 
Support routine useful for those that need to do some 
operations not done by the layer library. Allows programmer 
to swap the contents of a small BitMap with a subsection of 
the display. This is accomplished without using extra memory. 
The bits in the display RastPort are exchanged with the 
bits in the ClipRect's BitMap. 


Note: the ClipRect structures which the layer library allocates are 
actually a little bigger than those described in the graphics/clip.h 
include file. So be warned that it is not a good idea to have 
instances of cliprects in your code. 


INPUTS 

rp — pointer to rastport 

er - pointer to cliprect to swap bits with 
BUGS 


SEE ALSO 
graphics/clip.h, graphics/rastport.h, graphics/clip.h 


91T - ¥ 








layers. library/ThinLayerinfo layers. library/ThinLayerInfo 


NAME 
ThinLayerInfo —- convert 1.1 LayerInfo to 1.0 LayerInfo. 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 


SYNOPSIS 
OBSOLETE OBSOLETE OBSOLETE OBSOLETE OBSOLETE 
ThinLayerinfo(11) 
ad 


struct Layer_Info *li; 
OBSOLETE OBSOLETE OBSOLBTE OBSOLETE OBSOLETE 


FUNCTION 
return the extra memory needed that was allocated with 
FattenLayerInfo. This is must be done prior to freeing 
the Layer Info structure itself. V1.1 software should be 
using DisposeLayeriInfo. 


INPUTS 
li - pointer to LayerInfo structure 


BUGS 


SEE ALSO 
DisposeLayerInfo, FattenLayerInfo, graphics/layers.h 


layers. library/UnlockLayer 











layers. library/UnlockLayer 


NAME 
UnlockLayer -- Unlock layer and allow graphics routines to use it. 


SYNOPSIS 
UnlockLayer( 1 ) 
ad 
struct Layer *1; 


FUNCTION 
When finished changing the ClipRects or whatever you. were 
doing with this layer you must call UnlockLayer() to allow 
other tasks to proceed with graphic output to the layer. 


INPUTS 
1 - pointer to a layer 


BUGS 


SEE ALSO 
graphics/layers.h, graphics/clip.h 











4iT - ¥ 





layers. library/UnlockLayerInfo layers. library/UnlockLayerInfo 


NAME 

UniockLayerInfo -- Unlock the LayerInfo structure. 
SYNOPSIS 

UnlockLayerInfo( li ) 


ad 
struct Layer_Info *1li; 


FUNCTION 
After the operation is complete that required a LockLayerInfo, 
unlock the LayerInfo structure so that other tasks may 
affect the layers. 


INPUTS 
li - pointer to the Layer_Info structure 


BUGS 


SEE ALSO 
LockLayerInfo, graphics/layers.h 





layers. library/UnlockLayers layers. library/UnlockLayers 


NAME 
UnlockLayers -~ Unlock all layers from graphics output. 
Restart graphics output to layers that have been waiting 


SYNOPSIS 
UnlockLayers( li ) 
ad 


struct Layer Info *li; 

FUNCTION 
Make all layers in this layer list unlocked. 
Then call UnlockLayerInfo 


INPUTS 
1i ~- pointer to the Layer_Info structure 


BUGS 


SEE ALSO 
LockLayers, UnlockLayer, graphics/layers.h 














8iT -¥ 








layers. library/UpfrontLayer 


NAME 

UpfrontLayer -- Put layer in front of all other layers. 
SYNOPSIS 

result = UpfrontLayer( dummy, 1 ) 

do aQ al 


BOOLEAN result; 
LONG dummy ; 
struct Layer *1; 


FUNCTION 
Move this layer to the most upfront position swapping bits 
in and out of the display with other layers. 
If this is a refresh layer then collect damage list and 
set the LAYERREFRESH bit in layer->Flags if redraw required. 
By clearing the BACKDROP bit in the layers Flags you may 
bring a Backdrop layer up to the front of all other layers. 


Note: this operation may generate refresh events in other layers 
associated with this layer's Layer_Info structure. 


INPUTS 
dummy — unused 
1 — pointer to a nonbackdrop layer 


RESULTS 
result - TRUE if operation successful 
FALSE if operation unsuccessful (probably out of memory) 


BUGS 


SEE ALSO 
graphics/layers.h 








layers. Library/UpfrontLayer ayers. library/whichLayer 





layers. library/WhichLayer 


NAME 

WhichLayer ——- Which Layer is this point in? 
SYNOPSIS 

layer = WhichLayer(.li, x, y ) 

do aQ dO dl 
FUNCTION 


Starting at the topmost layer check to see if this point (x,y) 
occurs in this layer. If it does return the pointer to this 
layer. Return NULL if there is no layer at this point. 


INPUTS 
li = pointer to LayerInfo structure 
(%,y) = coordinate in the BitMap 
RESULTS 


layer — pointer to the topmost layer that this point is in 
NULL if this point is not in a layer 


SEE ALSO 
graphics/layers.h 








61T - ¥ 


TABLE OF CONTENTS 


. library/SPAbs 
:library/SPAdd 
.library/SPCeil 
.library/SPcmp 
.library/SPDiv 
.library/SPPix 
. library/SPFloor 
.library/SPF1t 
.library/SPMul 
. library/SPNeg 
. library/SPSub 
mathffp. 


library/SPTst 











mathffp.library/SPAbs mathffp.library/SPAbs 


NAME 
SPAbs ~ obtain the absolute value of the fast floating point number 
C USAGE 
fnum2 = SPAbs(fnuml); 
do 
FUNCTION 
Accepts a floating point number and returns the absolute value of 
said number. 
INPUTS 
fnuml — floating point number 
RESULT 
fnum2 -— floating point absolute value of fnuml 
BUGS 
None 
SEE ALSO 


_LVOSPAbs, abs 








Mathffp. library/SPAdd 


NAME 
SPAdd ~ add two floating point numbers 
C USAGE 
fnum3 = SPAdd(fnuml, fnum2); 
al dao 
FUNCTION 
Accepts two floating point numbers and returns the arithmetic 
sum of said numbers. 
INPUTS 
fnuml — floating point number 
fnum2 - floating point number 
RESULT 
fnum3 ~ floating point number 
BUGS 
None 
SEE ALSO 


_Lvospadd, faddi 


O8T - Vv 











mathffp. library/SPAdd mathffp.library/sPceil 








mathffp. library/SPceil 


NAME 

spceil -- compute Ceil function of a number 
SYNOPSIS 

x = SPCeil( y ); 

ao do 

float X+Vi 
FUNCTION 

Calculate the least integer greater than or equal to x and return it. 

This identity is true. Ceil(x) = —Floor(-x). 
INPUTS 

y -— Motorola Fast Floating Point Format Number 
RESULT 

X —-- Motorola Fast Floating Point Format Number 
BUGS 
SEE ALSO 


SPFloor 








T8t - ¥ 











mathffp. library/SPCmp 


mathffp. library/SPCmp 


NAME 
spcmp — compares two floating point numbers and sets 
appropriate condition codes 
C USAGE 
if (SPCmp(fnuml, fnum2)) [{...] 
dl dao 
FUNCTION 
Accepts ‘two floating point numbers and returns the condition 
codes set to indicate the result of said-comparison. Additionally, 
the integer functional result is returned to indicate the result 
of said comparison. 
INPUTS 
fnuml — floating point number 
fnum2 ~ floating point number 
RESULT 
Condition codes set to reflect the following branches: 
GT — fnum2 > fnuml 
GE -— fnum2 >= fnuml 
BQ - fnum2 = fnuml 
NE — fnum2 != fnuml 
LT - fnum2 <  fnuml 
LE — fnum2 <= fnuml 
Integer functional result as: 
+1 => fnuml > fnum2 
-1 => fnuml < fnum2 
0 => fnuml = fnum2 
BUGS 
None 
SEE ALSO 


_Lvosecmp, fempi 








mathffp.library/SPDiv 


NAME 
SPDiv — divide two floating point numbers 
C USAGE 
fnum3 = SPDiv(fnuml, fnum2); 
dl do 
FUNCTION 
Accepts two floating point numbers and returns the arithmetic 
division of said numbers. 
INPUTS 
fnuml ~— floating point number 
fnum2 -— floating point number 
RESULT 
fnum3 — floating point number 
BUGS 
None 
SEE ALSO 


_LvospDiv, fdivi 


mathffp.library/SPDiv 





i 


c8t - ¥ 


mathffp.library/SPFix mathffp. library/SPFix mathffp. Llibrary/SPFloor mathffp. library/SPFloor 








NAME NAME 
SPFloor —- compute Floor function of a number 
SPFix -— convert fast floating point number to integer 
SYNOPSIS 
C USAGE Xx = SPFloor( y ); 
do do 
inum = SPFix(fnum) ; 
do float X,Y? 

FUNCTION FUNCTION 


Calculate the largest integer less than or equal to x and return it. 
Accepts a floating point number and returns the truncated 
integer portion of said number. INPUTS 

y —- Motorola Fast Floating Point number 


INPUTS 
RESULT 

fnum — floating point number x — Motorola Fast Floating Point number 
RESULT BUGS 

inum - signed integer number SEE ALSO 

spCeil 

BUGS 

None 
SEE ALSO 


_LVOSPFix, ffixi 








est - ¥ 





mathffp.library/SPF1t 





mathffp.library/SPF1t 
NAME 


SPFl1t — convert integer number to fast floating point 


C USAGE 


fnum = SPF1t(inum); 
dao 


FUNCTION 


Accepts an integer and returns the converted 
floating point result of said number. 


INPUTS 

inum — signed integer number 
RESULT 

fnum - floating: point number 
BUGS 

None 
SEE ALSO 


_LVOSPFit, ff1ti 











mathffp.library/SPMul mathffp. library/SPMul 


NAME 
SPMul — multiply two floating point numbers 
C USAGE 
fnum3 = SPMul(fnuml, fnum2); 
dl do 
FUNCTION 
Accepts two floating point numbers and returns the arithmetic 
multiplication of said numbers. 
INPUTS 
fnuml — floating point number 
fnum2 - floating point number 
RESULT 
fnum3 — floating point number 
BUGS 
None 
SEE ALSO 


_LvospMul, fmuli 





v8T —- ¥ 














mathffp. library/SPNeg mathffp.library/SPNeg 
NAME 


SPNeg —- negate the supplied floating point number 
C USAGE 


fnum2 = SPNeg(fnuml) ; 
do 


FUNCTION 


Accepts a floating point number and returns the value 
of said number after having been subtracted from 0.0 


INPUTS 
fnuml ~ floating point number 
RESULT 
fnum2 ~- floating point negation of fnuml 
BUGS 
None 
SEE ALSO 


_LVOSPNeg, fnegi 





mathffp.library/SPSub mathffp. library/SPSub 
NAME 


SPSub - subtract two floating point numbers 


C USAGE 

fnum3 = SPSub(fnuml, fnum2); 

al do 

FUNCTION 

Accepts two floating point numbers and returns the arithmetic 

subtraction of said numbers. 
INPUTS 

fnuml -— floating point number 

fnum2 - floating point number 
RESULT 

fnum3 - floating point number 
BUGS 

None 
SEE ALSO 


_LVosPSub, fsubi 








Sst -W¥ 





mathffp. library/SPTst mathffp. library/SPTst 


NAME 
SPTst ~ compares a fast floating point number against the 
value zero (0.0) and sets the appropriate 
condition codes 
C USAGE 
if (!(¢SPTst(fnum))) [...] 
dl 
FUNCTION 
Accepts a floating point number and returns the condition 
codes set to indicate the result of a comparison against 
the value of zero (0.0). Additionally, the integer functional 
result is returned. 
INPUTS 
fnum ~ floating point number 
RESULT 
Condition codes set to reflect the following branches: 
EQ - fnum = 0,0 
NE — fnum != 0.0 
PL — fnum >= 0.0 
MI ~ fmum ¢ 0.0 
Integer functional result as: 
+1 => fnum > 0.0 
-~l => fnum ¢ 0.0 
0 => fnum = 0.0 
BUGS 
None 
SEE ALSO 





_LvospTst, ftsti 





Ht 


98T -— ¥ 





TABLE OF CONTENTS 


mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas . 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 
mathieeedoubbas. 


library/IEEEDPAbs 
library/IEEEDPAdd 
library/IEEEDPCeil 
library/IEEEDPCmp 
library/IEEEDPDiv 
library/IEEEDPFix 
library/IEEEDPFloor 
library/IEEEDPF1t 
library/IEEEDPMul 
library/IEEEDPNeq 
library/IEEEDPSub 
library/IEEEDPTst. 


mathieeedoubbas. library/IEEEDPAbs 


mathieeedoubbas. library/IEEEDPAbs 


NAME 

IEEEDPAbs ~— compute absolute value of IEEE double precision argument 
SYNOPSIS 

X = IEEEDPAbs( y ); 

da0/dl d0/dl 

double x,y; 
FUNCTION 

Take the absolute value of argument y and return it to caller. 
INPUTS 

y ~~ IEBE double precision floating point value 
RESULT 

Xx ~~ IEEE double precision floating point value 
BUGS 
SEE ALSO 





L8T - ¥ 


mathieeedoubbas. library/IEEEDPAdd 








mathieeedoubbas. library/IEEEDPAdd 


NAME 

IEEEDPAdd —- add one Gouble precision IEEE number to another 
SYNOPSIS 

x = IEEEDPAdd( y , 2 ) 

da0/dl. d0/dl d2/da3 

double xX,y,2; 
FUNCTION 

Compute x = y + z in IEEE double precision. 
INPUTS 

y —— IEEE double precision floating point value 

zZ —- IEEE double precision floating point value 
RESULT 

Xx 77 IEEE double precision floating point value 
BUGS 
SEE ALSO 

IEEEDPSub 


mathieeedoubbas. library/IEEEDPCeil 


mathieeedoubbas. library/IEEEDPCeil 


NAME 
IEEEDPCeil -- compute Ceil function of IEEE double precision number 
SYNOPSIS 
x = IEEEDPCeil( y); 
d0/dl dad/dl 
double x,y; 
FUNCTION 
Calculate the least integer greater than or equal to x and return it. 
This value may have more than 32 bits of significance. 
This identity is true. Ceil(x) = ~Floor(-x). 
INPUTS 
y -- IEEE double precision floating point value 
RESULT 
x -- IEEE double precision floating point value 
BUGS 
SEE ALSO 


TEEEDPFloor 





88T -W 


mathieeedoubbas. library/IEEEDPCmp 








mathieeedoubbas. library/IEEEDPCmp 


NAME 
IEEEDPCmp -- compare two double precision floating point numbers 
SYNOPSIS 
c = TEEEDPCmp( yo, 2 ); 
do do/dl d2/d3 
double y,2; 
long Cc; 
FUNCTION 


Compare y with z. Set the condition codes for less, greater, or 
equal. Set return value c to -1 if y<z, or +1 if yz, or 0 if 


y == 2. 
INPUTS 

y —- IEEE double precision floating point value 

Z —— IEEE double precision floating point value 
RESULT 

c=1 ce = gt for (y > 2) 

c= 0 ce = eq for (y == 2) 

e=-l ce lt for (y < %) 
BUGS 
SEE ALSO 


mathieeedoubbas. library/IEEEDPDiv 








mathieeedoubbas. library/IEEEDPDiv 


NAME 

IEEEDPDiv —- divide one double precision IEEE by another 
SYNOPSIS 

Xx = IBEEDPDiv( y , Zz ); 

d0/dl d0/dl d2/d3 

double xX,Y,2; 
FUNCTION 

Compute x = y / 2 in IEEE double precision. 
INPUTS 

y ~~ IEEE double precision floating point value 

Zz —- IEEE double precision floating point value 
RESULT 

Xx —- IEEE. double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPMul 








68T - W¥ 








mathieeedoubbas. library/IEEEDPFix mathieeedoubbas. library/IEEEDPFix 


NAME 
JEEEDPFix —- convert IEEE double float to integer 
SYNOPSIS 
x = IEREDPFix( y); 
do a0/d 
long XF 
double y; 
FUNCTION / 
Convert IEEE double precision argument to a 32 bit signed integer 
and return result. 
INPUTS 
y -- IEEE double precision floating point value 
RESULT 
if no overflow occured then return 
x -- 32 bit signed integer 
if overflow return largest +- integer 
For round to zero 
BUGS 
SEE ALSO 


TEBEDPF1t 











mathieeedoubbas. library/IEEEDPFloor 


NAME 
IEEEDPFloor —- compute Floor function of IEEE double precision number 
SYNOPSIS 
x = IEEEDPFloor( y_ ); 
dao/dl 
double X,Y; 
FUNCTION 
Calculate the largest integer less than or equal to x and return it. 
This value may have more than 32 bits of significance. 
INPUTS 
y -~ IEEE double precision floating point value 
RESULT 
x -- IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPCeil 








Wh 


O6T —- ¥ 











mathieeedoubbas. library/IEEEDPF1t mathieeedoubbas. library/IEEEDPF1t 


NAME 
IEEEDPFlt -- convert integer to IEEE double precision number 
SYNOPSIS 
x = IBEEDPFIt( y ); 
dao/dl ao 
double x; 
long yi 
FUNCTION 
Convert a signed 32 bit value to a double precision IEEE value 
and return it in d0/dl. No exceptions can occur with this 
function. 
INPUTS 
y ~~ 32 bit integer in d0o 
RESULT 
x is a 64 bit double precision IEEE value 
BUGS 
SEE ALSO 


IEEEDPFix 


mathieeedoubbas. library/IBEEDPMul mathieeedoubbas. Library/IEEEDPMul 


NAME 

IEEEDPMul —- multiply one double precision IEEE number by another 
SYNOPSIS 

x = IEEEDPMuUl( y , Zz ) 

a0/dl do/dl d2/d3 

double %,Y,2; 
FUNCTION 

Compute x = y * 2 in IEEE double precision. 
INPUTS 

y -~ IEEE double precision floating point value 

Z% —-- IEEE double precision floating point value 
RESULT 

x —- IEEE double precision floating point value 
BUGS 
SEE ALSO 

TEEEDPDiv 








Tét - WV 








mathieeedoubbas. library/IEEEDPNeg mathieeedoubbas. library/IEEEDPNeg 


NAME 

IEEEDPNeg —- compute negative value of IEEE double precision number 
SYNOPSIS 

x = TEEEDPNeg( y ); 

a0/dl a0/dal 

double x,y; 
FUNCTION 

Invert the sign of argument y and return it to caller. 
INPUTS 

y - IEEE double precision floating point value 
RESULT 

X — IEEE double precision floating point value 
BUGS 
SEE ALSO 


mathieeedoubbas. library/IEEEDPSub 





mathieeedoubbas. library/1IEEEDPSub “4 


NAME 
IEEEDPSub —— subtract one double precision IEEE number from another 
SYNOPSIS 
x = IEEEDPSub( yo, 2 )i 
ao0/dl da0/dl d2/d3 


double x,¥,2; 


FUNCTION 

Compute x = y ~ 2 in IEEE double precision. 
INPUTS 

y —- IEEE double precision floating point value 

y —- IEEE double precision floating point value 
RESULT 

x -- IEEE double precision floating point value 
BUGS 
SEE ALSO 

IEEEDPAdd 








Imi 


c6T - 








mathieeedoubbas. library/IEEBEDPTst mathieeedoubbas. library/IEEEDPTst 


NAME 
IEEEDPTst —- compare IEEE double precision value to 0.0 
SYNOPSIS 
c = IEEEDPTst( y_); 
do d0/d1 
double y; 
long Cc; 
FUNCTION 
Compare y to 0.0, set the condition codes for less than, greater 
than, or equal to 0.0. Set the return value c to -1] if less.than, 
to +1 if greater than, or 0 if equal to 0.0. 
INPUTS 
y —- IEEE double precision floating point value 
RESULT 
e=1 ec = gt for (y > 0.0) 
c=0 cc = eq for (y == 0.0) 
e=-l ce = lt for (y ¢ 0.0) 
BUGS 
SEE ALSO 














Ml 


€6t - ¥ 





TABLE OF CONTENTS 


mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 
mathieeedoubtrans 





. library/IEEEDPAcos 
.library/IEEEDPAsin 
. Library/IEEEDPAtan 
. Library/IEEEDPCos 

. library/IEEEDPCosh 
. library/IEEEDPExp 
_library/IEEEDPFieee 
. library/IEEEDPLog 

. library/IBEEDPLog1l0 
. Library/IEEEDPPow 
.library/IEEEDPSin 

. library/IEEEDPSincos 
.library/IEEEDPSinh 
.library/IEEEDPSqrt 
.library/IBEEDPTan 
.library/IEEEDPTanh 
. library/IEEEDPTieee 


mathieeedoubtrans.library/TEEEDPAcos 


NAME 

IEEEDPAcos —— compute the arc cosine of a number 
SYNOPSIS 

x = IEEEDPAcos( y ); 

dao/dal do0/dl 

double x,y; 
FUNCTION 

Compute arc cosine of y in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

x - IEEE double precision floating point value 
BUGS 
SEE ALSO 


JEEEDPCos(), IEEEDPAtan(), IBEEDPASin ( ) 














b6T — © 








mathieeedoubtrans. library/IEEEBDPAsin 


NAME 
IEEEDPAsin -—- compute the arcsine of a number 


SYNOPSIS 
xX = JEEEDPAsin( y ); 

do/dl : da0/dl 

double x,y; 
FUNCTION 

Compute the are sine of y in IEEE double precision 
INPUTS 

y ~ IEEE double precision floating point value 
RESULT 

x ~ IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPSin(), IEEEDPAtan(), IEEEDPAcos() 








eS 


mM 





athieeedoubtrans. library/IBEEDPAtan 


NAME 

IEEEDPAtan ~- compute the arctangent of a floating point number 
SYNOPSIS 

x = IEEEDPAtan( yy); 

do/dl d0/dl 

double x,y; 
FUNCTION 

Compute arctangent of y in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

x — IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPTan({), IEEEDPAsin(), IEEEDPACos() 








S6éT -W¥ 








mathieeedoubt rans. library/IEEEDPCos 


NAME 

IEEEDPCos -- compute the cosine of a floating point number 
SYNOPSIS 

x = IEEEDPCos( y ); 

ad/dl d0/dl 

double x,y; 
FUNCTION 

Compute cosine of y in IEEE double precision 
INPUTS 

y - IEEE double precision floating point value 
RESULT 

X - IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPAcos(), IEEEDPSin(), IBEEDPTan() 








mathieeedoubtrans. library/IEEEDPCosh 


NAME 

JEEEDPCosh —- compute the hyperbolic cosine of a floating point number 
SYNOPSIS 

x = IEEEDPCosh( y ); 

ad/dl d0/al 

double x,y; 
FUNCTION 

Compute hyperbolic cosine of y in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

xX - IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPSinh(), IEEEDPTanh( ) 





96T - ¥ 








mathieeedoubtrans. library/IEEEDPExp 


NAME 

IEEEDPEXp -- compute the exponential of e 
SYNOPSIS 

X = IBEEDPExp( y ); 

d0/dl dgo/dl 

double x,y; 
FUNCTION . 

Compute ey in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

X — IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPLog ( ) 








mathieeedoubtrans. library/IEEEDPFieee 


NAME 
IBEEDPFieee —— convert IEEE single to IEEE double 


SYNOPSTS 
x = JEEEDPFieee( y ); 
a0/dl ao 


float vi 
double x; 


FUNCTION ; 
Convert IEEE single precision number to IEEE double precision. 


INPUTS 
y — IEEE single precision floating point value 


RESULT 
x — IBEE double precision floating point value 


BUGS 


SEE ALSO 
IEEEDPTieee ( ) 





L6T - ¥ 











mathieeedoubtrans. library/IEEEDPLog mathieeedoubtrans. library/IEEEDPLogl0 


NAME NAME 
IEEEDPLog -- compute the natural logarithm of a floating point number IEEEDPLogl0 -- compute logarithm base 10 of a number 
SYNOPSIS SYNOPSIS 
x = IBEEDPLog( y ); xX = IEEEDPLogl0( y ); 
a0/dal do/dl a0/dl da0/dal 
double x,y; double x,yY; 
FUNCTION FUNCTION ; _ 
Compute 1n(y) in IEEE double precision Compute the logarithm base 10 of y in IEEE double precision 
INPUTS INPUTS oa . . 
y ~ IEEE double precision floating point value y - IBEE double precision floating point value 
RESULT RESULT . . . 
x ~ IEEE double precision floating point value x - IEEE double precision floating point value 
BUGS BUGS 
SEE ALSO SEE ALSO 
IEEEDPExp( ) TEEEDPLOg( ) 








hh 





86T - ¥ 


mathieeedoubtrans. library/IEEEDPPow 





NAME 
IEEEDPPow —- raise a number to another number power 


SYNOPSIS 
% = IEEEDPPow( x , y ); 
d0/al. a2/d3 d0/d1 


double x,y,2; 


FUNCTION . 
Compute y x in IEEE double precision 


INPUTS 
x — IEEE double precision floating point value 
y ~ IEEE double precision floating point value 


RESULT 
Z ~ IEEE double precision floating point value 


BUGS 


SEE ALSO 


mathieeedoubtrans. library/IEEEDPSin 


NAME 
SYNOPSIS 
xX = IEEEDPSin( y ); 
do0/dl d0/d1 
double x,y; 
FUNCTION 


Compute sine of y in IEEE 


INPUTS 
y ~ IEEE double precision 


RESULT 
xX ~ IEEE double precision 


BUGS 


SEE ALSO 





IEEEDPSin ~~ compute the sine of a floating point number 


double precision 


floating point value 


floating point value 


IEEEDPAsin(), IEEEDPTan(), IEEEDPCos() 





66T - ¥ 











mathieeedoubtrans. library/IEEEDPSincos 


NAME 
IEEEDPSincos ~- compute the are tangent of a floating point number 
SYNOPSIS 
x = IEEEDPSincos( z, Y_); 
d0/dl aQ d0/dl 
double x,¥,*2; 
FUNCTION 
Compute sin and cosine of y in IEEE double precision. 
Store the cosine in *z. Return the sine of y. 
INPUTS 
y — IEEE double precision floating point value 
Zz —- pointer to IEEE double precision floating point number 
RESULT 
xX ~ IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPSin(), IEEEDPCos() 








mathieeedoubtrans. library/IEEEDPSinh 


NAME 

IEEEDPSinh —- compute the hyperbolic sine of a floating point number 
SYNOPSIS 

x = IEBEDPSinh( y ); 

a0/dal d0/dl 

double x,y; 
FUNCTION 

Compute hyperbolic sine of y in IEEE double precision 
INPUTS 

y - IEEE double precision floating point value 
RESULT 

x - IEEE double precision floating point value 
BUGS 
SEE ALSO 


IEEEDPCosh, IEEEDPTanh 








o0c - 





mathieeedoubtrans. library/IBEEDPSqrt 


NAME 

TEEEDPSgrt —- compute the square root of a number 
SYNOPSIS 

Xx = TBEBDPSqrt( y ); 

d0/dal do/dl 

double x,y; 
FUNCTION 

Compute square root of y in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

x — IEBE double precision floating point value 
BUGS 
SEE ALSO 








mathieeedoubtrans. library/1EEEDPTan 


NAME 

IEEEDPTan —- compute the tangent of a floating point number 
SYNOPSIS 

xX = IEEEDPTan( y_); 

dao/di do/d 

double x,y; 
FUNCTION 

Compute tangent of y in IEEE double precision 
INPUTS 

y — IEEE double precision floating point value 
RESULT 

x - IEEE double precision floating point value 
BUGS 
SEE ALSO 


TEEEDPAtan(), IEEEDPSin(), IEEEDPCos() 


ll 











Tot - ¥ 








mathieeedoubtrans. library/IBEEDPTanh 


NAME 

IEEEDPTanh —-- compute the hyperbolic tangent of a floating. point number 
SYNOPSIS 

x = IEEEDPTanh( y_ ); 

d0/dl d0/dl 

double x,y; 
FUNCTION 

Compute hyperbolic tangent of y in IEEE double precision 
INPUTS 

y - IEEE double precision floating point value 
RESULT 

x - IEEE double precision floating. point value 
BUGS 
SEE ALSO 


IEEEDPSinh(), IEEEDPCosh( ) 











mathieeedoubtrans. library/IEEEDPTieee 


NAME 
IEEEDPTieee -- convert IEEE double to IEEE single 
SYNOPSIS 
x = IEEEDPTieee( y. ); 
dao ao/dal 
double y; 
float X; 
FUNCTION 
Convert IEEE double precision number to IEEE single precision. 
INPUTS 
y - IBEE double precision floating point value 
RESULT 
x - IEEE single precision floating point value 
BUGS 
SEE ALSO 


IEEEDPFieee() 


coe - 


[TABLE OF CONTENTS 





mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 
mathtrans. 


library/SPAcos 
library/SPAsin 
library/SPAtan 
library/SPCos 
library/SPCosh 
library/SPExp 
library/SPFieee 
library/SPLog 
library/SPLog1l0 
library/SPPow 
library/SPSin 
library/SPSincos 
library/SPSinh 
library/SPSqrt 
library/sPTan 
library/SPTanh 
library/SPTieee 





Jmathtrans. library/SPAcos mathtrans.library/SPAcos 





NAME 
SPAcos — obtain the arccosine of the floating point number 
SYNOPSIS 
fnum2 = SPAcos(fnuml); 
do.1 
float fnum2; 
float fnunl; 
FUNCTION 
Accepts a floating point number representing the cosine 
of an angle and returns the value of said angle in 
radians 
INPUTS 
fnuml — Motorola fast floating point number 
RESULT 
fnum2.- Motorola fast floating point number 
BUGS 
None 
SEE ALSO 
SPSin 





coe - ¥ 











mathtrans.library/SPAsin mathtrans. library/SPAsin 
NAME 
SPAsin — obtain the arcsine of the floating point number 
SYNOPSIS 
fnum2 = SPAsin(fnum]); 
do.l 


float fnum2; 
float fnuml; 


FUNCTION 
Accepts a floating point number representing the sine 
of an angle and returns the value of said angle in 
radians 
INPUTS 
fnuml - Motorola fast floating point number - 
RESULT 
fnum2 ~ Motorola fast floating point number 
BUGS 
None 
SEE ALSO 


SPCos 








mathtrans. library/SPAtan mathtrans. library/SPAtan 


NAME 
SPAtan -— obtain the arctangent of the floating point number 
SYNOPSIS 
fnum2 = SPAtan(fnuml); 
do0.1 
float fnum2; 
float fnuml; 
FUNCTION 
Accepts a floating point number representing the tangent 
of an angle and returns the value of said angle in 
radians 
INPUTS 
fnuml - Motorola fast floating point number 
RESULT 
fnum2 - Motorola fast floating point number 
BUGS 
None 
SEE ALSO 
SPTan 








poe - Wv 








mathtrans. library/SPCos mathtrans. library/SPCos 


NAME 
SPCos - obtain the cosine of the floating point number 
SYNOPSIS 
fnum2 = SPCos(fnum]); 
do. 
float fnum2; 
float fnuml; 
FUNCTION 
Accepts a floating point number representing an angle 
in radians and returns the cosine of said angle. 
INPUTS 
fnuml - Motorola fast floating point number 
RESULT 
fnum2 - Motorola fast floating point number 
BUGS 
None 
SEE ALSO 
SPAcos 











mathtrans. library/SPCosh mathtrans. library/SPCosh 


NAME 

SPCosh - obtain the hyperbolic cosine of the floating point number 
SYNOPSIS 

fnum2 = SPCosh(fnuml) ; 

do.1 

float fnum2; 

float fnuml; 
FUNCTION 

Accepts a floating point number representing an angle 

in radians and returns the hyperbolic cosine of said angle. 
INPUTS 

fnuml - Motorola fast floating point number 
RESULT 

fnum2 - Motorola fast floating point number 
BUGS 

None 
SEE ALSO 

SPSinh 





Gog - ¥v 











mathtrans.1library/SPExp mathtrans. library/SPExp mathtrans. library/SPFieee mathtrans. library/SPFieee 





NAME NAME 
SPExp — obtain the exponential (e**X) of the floating point number SPFieee - convert single precision ieee to FFP number 
SYNOPSIS SYNOPSTS 
fnum2 = SPExp(fnuml); fnum = SPFieee(ieeenum) ; 
do.1 do.1 
float fnum2; float fnum; 
float fnuml; float ieeenum; 
FUNCTION FUNCTION 
Accepts a floating point number and returns the value Accepts a standard single precision format 
of e raised to the fnuml power returns the same number, converted to Motorola 
fast floating point number 
INPUTS 
INPUTS 
fnuml ~ Motorola fast floating point number 
ieeenum - IEEE Single Precision Floating Point 
RESULT 
RESULT 
fnum2 — Motorola fast floating point number 
fnum — Motorola fast floating point number 
BUGS 
BUGS 
None 
None 
SEE ALSO 
SEE ALSO 
SPLOg 
spTieee 





90 - © 








mathtrans.library/SPLog mathtrans.library/SPhog 


NAME 
SPLog — obtain the natural logarithm of the floating point number 
SYNOPSIS 
fnum2 = SPLog(fnuml); 
dao.1 
float fnum2; 
float fnuml; 
FUNCTION 
Accepts a floating point number and returns the natural 
logarithem (base e) of said number 
INPUTS 
fnuml — Motorola fast floating point number 
RESULT 
fnum2 — Motorola fast floating point number 
BUGS 
None 
SEE ALSO 
SPExp 














mathtrans. library/SPLogl0 mathtrans. library/SPLogl0 


NAME 
SPLogl0 - obtain the naperian logarithm(base 10) of the 
floating point number 
SYNOPSIS 
fnum2 = SPLogl0(fnuml) ; 
do. 
float fnum2; 
float fnunl; 
FUNCTION 
Accepts a floating point number and returns the naperian 
logarithm (base 10) of said number 
INPUTS 
fnuml - Motorola fast floating point number 
RESULT 
fnum2 - Motorola fast floating point number 
BUGS 
None 
SEE ALSO 


SPExp, SpLog 











40@ -W 








mathtrans. library/SPPow 






mathtrans. library/SPPow 





NAME 


SPPow - raise a number to a power 










SYNOPSIS 


result = SPPow(fnuml, fnum2); 
di.l do.1 

float fnuml, fnum2; 

float result; 









FUNCTION 





Accepts two floating point numbers and returns the 
result of fnum2 raised to the fnuml power 


fnuml - Motorola fast floating point number 
fnum2 - Motorola fast floating point number 


RESULT 

result - Motorola fast floating point number 
BUGS 

None 
SEE ALSO 


SPExp, SPLOog 





mathtrans. library/SPSin 






NAME 


SYNOPSIS 


FUNCTION 


INPUTS 









spsin — obtain the sine of the floating point number 






fnum2 = SPSin(fnuml); 
do.1 


float fnum2; 
float fnuml; 


Accepts a floating point number representing an angle 
in radians and returns the sine of said angle. 


fnuml — Motorola fast floating point number 
fnum2 ~ Motorola fast floating point number 
None 


SPAsin 








mathtrans. library/SPSin 








| 


soc - ¥v 





mathtrans. library/SPSincos mathtrans. library/SPSincos 


NAME 
SPSincos — obtain the sine and cosine of a number 
SYNOPSIS 
fnum3 = SPSincos(pfnum2, fnuml); 
il, do.l 
float *pfnum2; 
float fnumi; 
float fnum3; 
FUNCTION 
Accepts a floating point number (fnuml) representing 
an angle in radians and a pointer to another floating 
point number (pfnum2). It computes the cosine and nlaces it in 
*pfnum2. It computes the sine and returns it as a result. 
INPUTS 
fnuml - Motorola fast floating point number 
pfnum2 - pointer to Motorola fast floating point number 
RESULT 
*pfnum2 ~- Motorola fast floating. point number (cosine) 
fnum3 — Motorola fast floating point number (sine) 
BUGS 
None 
SEE ALSO 
SPSin, SPCos 








mathtrans. library/SPSinh mathtrans.library/SPSinh 


NAME 

sPSinh - obtain the hyperbolic sine of the floating point. number 
SYNOPSIS 

fnum2 = SPSinh(fnuml); 

do.1 

float fnum2; 

float fnuml; 
FUNCTION 

Accepts a floating point number representing an angle 

in radians and returns the hyperbolic sine of said angle. 
INPUTS 

fnuml — Motorola fast floating point number 
RESULT 

fnum2 - Motorola fast floating point number 
BUGS 

None 
SEE ALSO 

SPCosh 





602 - Wv 











mathtrans. library/SPSqrt 


NAME 
sPSqrt - obtain the square root of the floating point number 
SYNOPSIS 
fnum2 = SPSqrt(fnuml); 
do.1 
float fnum2; 
float fnuml; 
FUNCTION 
Accepts a floating point number and returns the square toot 
of said number 
INPUTS 
fnuml ~ Motorola fast floating point number 
RESULT 
fnum2 - Motorola fast floating point number 
BUGS 
None 
SEE ALSO 


SPPow, SPMul 


mathtrans. library/SPSqrt mathtrans. library/SPTan 








NAMB 
SPTan — obtain the tangent of the floating point number 
SYNOPSIS 
fnum2 = SPTan(fnuml) ; 
do.t 
float fnum2; 
float fnuml; 
FUNCTION 
Accepts a floating point number representing an angle 
in radians and returns the tangent of said angle. 
INPUTS 
fnuml - Motorola fast floating point number 
RESULT 
fnum2 - Motorola fast floating point number 
BUGS 
None 
SEE ALSO 
SPAtan 


mathtrans. library/SPTan | 











ill 








oT? - ¥ 





mathtrans. library/SPTanh mathtrans. library/SPTanh 







NAME 
SPTanh — obtain the hyperbolic tangent of the floating point number 
SYNOPSIS 
fnum2 = SPTanh({fnum)); 
do.1 
float fnum2; 
float fnuml; 


FUNCTION 


Accepts a floating point number representing an angle 
in radians and returns the hyperbolic tangent of said angle. 


INPUTS 


fnuml — Motorola fast floating point number 


fnum2 - Motorola fast floating point number 


SPSinh, SPCosh 











mathtrans.library/sPTieee mathtrans. library/SPTieee 


NAME 
SPTieee -— convert FFP number to single precision ieee 
SYNOPSIS 
ieeenum = SPTieee(fnum) ; 
do.1 
float ieeenum; 
float fnum; 
FUNCTION 
Accepts a Motorola fast floating point number and 
returns the same number, converted into IEEE 
standard single precision format 
INPUTS 
fnum - Motorola fast floating point number 
RESULT , 
ieeenum —- IEEE Single Precision Floating Point 
BUGS 
None 
SEE. ALSO 
spFieee 

















Tl? -¥ 








TABLE OF CONTENTS translator. library/Translate translator. library/Translate 


translator. library/Translate NAME 
Translate - Converts an English string into phonemes 
SYNOPSIS 
rtnCode = Translate(instring, inlen, outbuf, outlen) 
DO AO DO AL D1 


LONG Translate(APTR,LONG,APTR, LONG); 


FUNCTION 
The translate function converts an English string into 
a string of phonetic codes suitable as input to the 
narrator device. 


INPUTS 
instring - pointer to English string 
inlen — length of English string 
outbuf - a char array which will hold the phonetic codes 
outlen ~ the length of the output array 
RESULTS 
rtnCode — 


Translate will return a zero if no error has occured. 
The only error that can occur is overflowing the output 
buffer. If Translate determines that an overflow will 
occur, it will stop the translation at a word boundary 
before the overflow happens. If this occurs, Translate 
will return a negative number whose absolute value 
indicates where in the INPUT string Translate stopped. 
The user can then use the offset -rtnCode from the 
beginning of the buffer in a subsequent Translate call 
to continue the translation where s/he left off. 


BUGS 


SEE ALSO 











Section B 


Device Summaries 


This section contains summaries for the device calls that are built into the Amiga 
operating system software. These documents have been automatically extracted from the 
original source code and are often called autodocs. 


Devices are based on the library concept mentioned in Section A. Libraries generally 
provide a set of usable functions. Devices usually are hardware independent mechanisms 
for talking to some sort of physical media (such as a disk drive or serial port). Devices 
often have their own independent tasks, and can perform asynchronous operations even 
when the task that called them is busy. 


Devices are described fully in the Amiga ROM Kernel Manual: Libraries and Devices. 
Only a brief introduction will be given here. 


The following is a partial list of the devices that are currently part of the Amiga 
software: 


Device Names 


audio.device narrator.device 
clipboard.device __ parallel.device 
console.device printer.device- 
gameport.device — serial.device 
input.device timer.device 


keyboard.device —_ trackdisk.device 





Devices are more complex to use than libraries. Opening a device requires: 


o A message port (MsgPort). This structure is used for inter-task communication. 
Ports may be created with the amiga.lib/CreatePort() function (see Section F). 


o An I/O Request (IORequest). This special structure, plus any extensions, is your 
sole source of communication with the device. Commands and data (or data 
pointers) are placed in this structure and sent off to the device. The exact format of 
this structure is defined in the ‘‘exec/io.h” include file in Section D. An JORequest 
is typically created with the amiga lib/CreateExtIO() function (see Section F). 


o The name of the device for the exec OpenDevice() call. The actual device may 
exist in ROM or on disk. This is transparent to the application programmer. 


Opening the device prepares the IORequest for use. The request will be tied to the one 
and only device that initialized it. Commands may be placed in the io Command 
field, then the request may be sent to the device. There are two primary options for 
starting I/O: 


o DolIO() - An exec call that does the I/O, and returns after it has finished (this is 
“synchronous I/O”), and is the easiest option to use. 


o SendIO() - An exec call that starts the I/O, but returns immediately (‘‘asynchro- 
nous I/O”). The device will complete its job while the calling task continues to run. 
Before reusing the I/O Request, you must wait for the I/O to finish (multiple pend- 
ing requests are possible with multiple I[ORequest structures). 


When you have finished using a device, a call to CloseDevice() completes the transac- 
tion. For those programs using asynchronous I/O, any outstanding requests must have 
already been completed. This can be done by a WaitIO(), or by forcing termination 
with an AbortIO()/WaitIO() pair. . 


* 


* A complete example of using the trackdisk.device. 
* This moves the heads from track 0 to 79 and back. 
* 


* 


#include "exec/types.h" 
#include "devices/trackdisk.h" 
#include "libraries/dos.h" 

/* #include "proto/exec.h" */ 
/* #include "functions.h" */ 


struct MsgPort *CreatePort(); 
struct [TORequest *CreateExtI0O(); 
void DeletePort(); 

void DeleteExtIoO(); 


/* Declare return types */ 


struct MsgPort *trackport; /* Storage for pointers */ 
struct IOExtTD *trackI0O; 
short openerror; /* flag */ 


void cleanexit(returncode) 
int returncode; 


printf("openerror =%d\n"  ,openerror); 

printf("trackIoO $%1lx\n",trackIO); 

printf ("trackport =$%lx\n",trackport) ; 

printf("io Error =%d\n" ,tracki0- >lotd_Req.io Error) ; 


if(!openerror) CloseDevice(trackI0) ; 
if (trackI0O) DeleteExtIO(trackI0O, (long)sizeof(struct IOEXtTD)); 
if(trackport) DeletePort(trackport) ; 


exit(returncode) ; 


void main() 


trackport=CreatePort(0L,0L); 
if(!trackport) 
cleanexit(RETURN_FAIL); 
trackI0O=(struct IOExtTD *) 
CreateExtIO(trackport, (long)sizeof(struct IOExtTD)); 
if(!trackIoO) 
cleanexit(RETURN_FAIL+1); 
if(openerror= OpenDevice("trackdisk. device" ,0L,trackIO,0L)) 
cleanexit( RETURN _FAIL+2); 


trackIO—>iotd_Req.io_Command=TD_SEEK; /* command */ 
trackIO->iotd_Req.io_Offset =0OL; /k out */ 
printf("1l\n"); 

DolO(trackI0O); 


trackIO—>iotd_Req.io_Offset =79*11*2*512L; /* in */ 
printf("2\n"); 
DolO(trackIO); 
trackIO—->iotd_Req.io_Offset =OL; /* out */ 
printf("3\n"); 
DolIO(trackIO); 
trackIO->iotd Req.io Offset =79*11*2*512L; /* in */ 
printf("4\n"); 
DoIO(trackIO); 


cleanexit(RETURN_ OK); 








TABLE OF CONTENTS 


audio.doc 
clipboard .doec 
console.doc 
gameport .doc 
input .doc 
keyboard. doc 
|narrator.doc 
parallel .doc 
printer .doc 
serial.doc 
timer .doc 
trackdisk.doc 


B-1 

B-ll 
B-15 
B-22 
B-26 
B-32 
B-36 
B-41 
B-47 
B-58 
B-66 
B-70 





TABLE 


audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 
audio. 


OF CONTENTS 


device/CloseDevice 
device/ADCMD_ALLOCATE 
device/ADCMD_FINISH 
device/ADCMD_FREE 
device/ADCMD_LOCK 
device/ADCMD_PERVOL 
device/ADCMD_SETPREC 
device/ADCMD_WAITCYCLE 
device/CMD_CLEAR 
device/CMD_FLUSH 
device/CMD_READ 
device/CMD_RESET 
device/CMD_START 
device/CMD_STOP 
device/CMD_UPDATE 
device/CMD_WRITE 
device/OpenDevice 





audio. device/CloseDevice 


NAME 


CloseDevice - terminate access to the audio device 


SYNOPSIS 


CloseDevice(iORequest ) ; 
Al 


FUNCTION 


The CloseDevice routine notifies the audio device that it. will no 
longer be used. It takes an I/O audio request block (IOAudio) and 
clears the device pointer (io Device). If there are any channels 
allocated with the same allocation key (ioa_Allockey), CloseDevice 
frees (ADCMD FREE) them. CloseDevice decrements the open count, if the 


count falls to zero, and the system needs memory, the device is expunged. 


INPUTS 


OUTPUTS 


iORequest — pointer to audio request block (struct. IOAudio) 
io_Device - pointer to device node, must be set by (or 
copied from I/O block set by) open (OpenDevice) 
io Unit - bit map of channels to free (ADCMD FREE) (bits 0 
thru 3 correspond to channels 0 thru 3) 
ioa_AllocKey- allocation key, used to free channels 
iORequest — pointer to audio request block (struct IOAudio) 
io Device - set to -l 
io_Unit - set to zero 





audio. device/ADCMD_ALLOCATE 


ADCMD ALLOCATE — allocate a set of audio channels 


FUNCTION 


ADCMD_ALLOCATE is a command that allocates multiple audio channels. 
ADCMD ALLOCATE takes an array of possible channel combinations 
(ioa_Data) and an allocation precedence (In_Pri) and tries to allocate 
one of the combinations of channels. 





If the channel combination array is zero length (ioa_Length), the 
allocation succeeds; otherwise, ADCMD_ALLOCATE checks each 
combination, one at a time, in the specified order, to find one 
combination that does not require ADCMD_ALLOCATE to steal allocated 
channels. 


If it must steal allocated channels, it uses the channel combination 
that steals the lowest precedence channels. 


ADCMD ALLOCATE cannot steal a channel of equal or greater precedence 
than the allocation precedence (ln _Pri). 


If it fails to allocate any channel combination and the no-wait flag 
(ADIOF_NOWAIT) is set ADCMD_ALLOCATE returns a zero in the unit field 
of the 1/0 request (io Unit) and an error (IOERR_ALLOCFAILED). If the 
no-wait flag is clear, it places the I/O request in a list that tries 
to allocate again whenever ADCMD_FREE frees channels or ADCMD_SETPREC 
lowers the channels' precedences. 


If the allocation is successful, ADCMD_ALLOCATE checks if any channels 
are locked (ADCMD_LOCK) and if so, replies (ReplyMsg) the lock 1/0 
request with an error (ADIOERR_CHANNELSTOLEN). Then it places the 
allocation I/O request in a list waiting for the locked channels to be 
freed. When all the allocated channels are un-locked, ADCMD_ALLOCATE: 

. resets (CMD RESET) the allocated channels, 

. generates a new allocation key (ioa_AllocKey), if it is zero, 

. copies the allocation key into each of the allocated channels 

. copies the allocation precedence into each of the allocated 

channels, and 
. copies the channel bit map into the unit field of the I/o request. 


If channels are allocated with a non-zero allocation key, 
ADCMD ALLOCATE allocates with that same key; otherwise, it generates a 
new and unique key. 


ADCMD ALLOCATE is synchronous: 
if the allocation succeeds and there are no locked channels to be 
stolen, or 
if the allocation fails and the no-wait flag is set. 
. if the allocation fails and the no-wait flag is set. 
In either case, ADCMD ALLOCATE only replies (mn_ReplyPort) if the 
quick flag (IOF_QUICK) is clear; otherwise, the allocation is 
asynchronous, so it clears the quick flag and replies the 1/0 request 
after the allocation is finished. If channels are stolen, all audio 
device commands return an error (IOERR_NOALLOCATION) when the former 
user tries to use them again. Do not use ADCMD_ALLOCATE in interrupt 
code. 


If you decide to store directly to the audio hardware registers, you 
must either lock the channels you've allocated, or set the precedence 
to maximum (ADALLOC_MAXPREC) to prevent the channels from being 
stolen. 


Under all circumstances, unless channels are stolen, you must free 
(ADCMD FREE) all allocated channels when you are finished using them. 


INPUTS 


1n_Pri - allocation precedence (-128 thru 127) 

mn_ReplyPort— pointer to message port that receives I/O request after 
the allocation completes is asynchronous or quick flag 
(ADIOF_QUICK) is set 

















io_Device —- 


io_Command — 
io Flags - 


jioa_Allockey~ 


ioa_Data - 

ioa_Length — 
OUTPUTS 

io_Unit - 

io_Flags - 


io_Error - 


ioa_AllocKey— 


pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
command number for ADCMD_ALLOCATE 
flags, must be cleared if not used: 
IOF_QUICK ~ (CLEAR) reply I/O. request 
(SET) only reply I/O request only if 
asynchronous (see above text) 
ADIOF_NOWAIT- (CLEAR) if allocation fails, wait till is 
succeeds 
(SET) if allocation fails, return error 
(ADIOERR_ALLOCFAILED) 
allocation key, zero to generate new key; otherwise, 
it must be set by (or copied from I/O block set by) 
OpenDevice function or previous ADCMD ALLOCATE command 
pointer to channel combination options (byte array, bits 
0 thru 3 correspond to channels 0 thru 3) 
length of the channel combination option array 
(0 thru 16, 0 always succeeds) 


bit map of successfully allocated channels (bits 0 thru 
3 correspond to channels 0 thru 3) 

IOF_QUICK flag cleared if asynchronous (see above text) 
error number: 
0 - no error 

ADIOERR_ALLOCFAILED - allocation failed 

allocation key, set to a unique number if passed a zero 
and command succeeds 





udio.device/ADCMD_FINISH 





audio.device/command/ADCMD_FINISH 


NAME 


ADCMD FINISH -~ abort writes in progress to audio channels 


FUNCTION 


ADCMD FINISH is a command for multiple audio channels. For each 
selected channel (io_Unit), if the allocation key (ioa_Allockey) is 
correct and there is a write (CMD_WRITE)in progress, ADCMD_ FINISH 
aborts the current write immediately or at the end of the current 
cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation 
key is incorrect. ADCMD_FINISH returns an error (ADIOERR_NOALLOCATION) . 
ADCMD_FINISH is synchronous and only replies (mn_ReplyPort) if the 
quick flag (IOF_QUICK) is clear. Do not use ADCMD FINISH in interrupt 
code at interrupt level 5 or higher. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit — bit map of channels to finish (bits 0 thru 3 correspond 


to channels 0 thru 3) 
io_Command ~ command number for ADCMD_FINISH 
io Flags — flags, must be cleared if not used: 
IOF_QUICK — (CLEAR) reply I/O request 
ADIOF_SYNCCYCLE- (CLEAR) finish immediately 
(SET) finish at the end of current 
cycle 


ioa_AllocKey- allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit — bit map of channels successfully finished (bits 0 thru 3 
correspond to channels 0 thru 3) 

io_Error — error number: 
0 - no error 


ADIOERR_NOALLOCATION - allocation key (loa_AllocKey) 
does not match key for channel 











audio.device/ADCMD_FREE 


audio.device/command/ADCMD_FREE 


NAME 


ADCMD_FREE -~ free audio channels for allocation 


FUNCTION 


ADCMD FREE is a command for multiple audio channels. For each 
selected channel (io Unit), if the allocation key (ioa_AllocKey) is 
correct, ADCMD_FREE does the following: 
restores the channel to a known state (CMD_RESET), 
. . changes the channels allocation key, and 
. makes the channel available for re-allocation. 
If the channel is locked (ADCMD_LOCK) ADCMD_FREE unlocks it and 
clears the bit for the channel (io_Unit) in the lock 1/0 request. 
If the lock I/O request has no channel bits set ADCMD_FREE replies 
the lock I/O request, and 
checks if there are allocation requests (ADCMD_ALLOCATE) waiting 
for the channel. 


Otherwise, ADCMD FREE returns an error (ADIOERR_NOALLOCATION) . 
ADCMD_FREE is synchronous and only replies (mn_ReplyPort) if the quick 
flag (IOF_QUICK) is clear. Do not use ADCMD_FREE in interrupt code. 


INPUTS 


mn_ReplyPort~ pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit - bit map of channels to free (bits 0 thru 3 correspond to 


channels 0 thru 3} 

io_Command - command number for ADCMD_FREE 

io_Plags - flags, must be cleared if not used: 
IOF_QUICK - (CLEAR) reply I/O request 

ioa_AllocKey- allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit - bit map of channels successfully freed (bits 0 thru 3 
correspond to channels o thru 3) 

io_Error - error number: 
0 — no error 


ADIOERR_NOALLOCATION — allocation key (ioa_AllocKey) 
does not match key for channel 


audio. device/ADCMD_LOCK 


NAME 





audio.device/command/ADCMD_LOCK 


ADCMD LOCK ~~ prevent audio channels from being stolen 


FUNCTION 


ADCMD_LOCK is a command for multiple audio channels. For each 
selected channel. (io Unit), if the allocation key (ioa_AllocKey) is 
correct, ADCMD_LOCK locks the channel, preventing subsequent 
allocations (ADCMD ALLOCATE or OpenDevice) from stealing the channel. 
Otherwise, ADCMD_LOCK returns an error (ADIOERR_NOALLOCATION) and will 
not lock any channels. 


Unlike setting the precedence (ADCMD_SETPREC, ADCMD_ALLOCATE or 
OpenDevice) to maximum (ADALLOC_MAXPREC) which would cause all 
subsequent allocations to fail, ADCMD_LOCK causes all higher 
precedence allocations, even no-wait (ADIOF_NOWAIT) allocations, to 
wait until the channels are un-locked. 


Locked channels can only be unlocked by freeing them (ADCMD_FREE), 
which clears the channel select bits (io_Unit). ADCMD_LOCK does not 
reply the I/O request (mn_ReplyPort) until all the channels it locks 
are freed, unless a higher precedence allocation attempts to steal one 
the locked channels. If a steal occurs, ADCMD_LOCK replies.and returns 
an error (ADIOERR_CHANNELSTOLEN). If the lock is replied 
(mn_ReplyPort) with this error, the channels should be freed as soon 
as possible. To avoid a possible deadlock, never make the freeing of 
stolen channels dependent on another allocations completion. 


ADCMD LOCK is only asynchronous if the allocation key is correct, in 

which case it clears the quick flag (IOF_QUICK); otherwise, it is 

synchronous and only replies if the quick flag (IOF_QUICK) is clear. 
Do not use ADCMD_LOCK.in interrupt code. 


INPUTS 


OUTP 


mn_ReplyPort-~ pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit — bit map of channels to lock (bits 0 thru 3 correspond to 


channels 0 thru 3) 

io_Command - command number for ADCMD_LOCK 

io_Flags - flags, must be cleared 

ioa_AllocKey— allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD ALLOCATE command 


UTS 

io Unit — bit map of successfully locked channels (bits 0 thru 3 
correspond to channels 0 thru 3) not freed (ADCMD_FREE) 

io Flags — IOF_QUICK flag cleared if the allocation key is correct 
(no ADIOERR_NOALLOCATION error) 

io Error — error number: 
0 ~- no error 


ADIOERR_NOALLOCATION —- allocation key (ioa_AllocKey) 
does not match key for channel 

ADIOERR_CHANNELSTOLEN- allocation attempting to steal 
locked channel 




















audio.device/ADCMD_PERVOL audio.device/command/ADCMD_PERVOL / audio. devi cezabcrb_seTPREC audio.device/command/ADCMD_SETPREC 
NAME NAME 

ADCMD PERVOL —~- change the period and volume for writes in progress to ADCMD_SETPREC —~ set the allocation precedence for audio channels 
audio channels 


FUNCTION 





ADCMD _PERVOL is a command for multiple audio channels. For each 
selected channel (io Unit), if the allocation key (ioa_AllocKey) is 
correct and there is a write (CMD_WRITE) in progress, ADCMD_PERVOL 
loads a new volume and period immediately or at the end of the current 
cycle depending on the sync flag (ADIOF_SYNCCYCLE). If the allocation 
key in incorrect, ADCMD_PERVOL returns an error 
(ADIOERR_NOALLOCATION). ADCMD_PERVOL is synchronous and only replies 
(mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do not use 
ADCMD PERVOL in interrupt code at interrupt level 5 or higher. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit - bit map of channels to load period and volume (bits 0 


thru 3 correspond to channels 0 thru 3) 
io Command - command number for ADCMD_PERVOL 


io_Flags - flags, must be cleared if not used: 
IOF_QUICK — (CLEAR) reply I/O request 
ADIOF_SYNCCYCLE- (CLEAR) load period and volume 
immediately 


(SET) load period and volume at the end 
of the current cycle 
ioa_AllocKey- allocation key, must be set by (or copied from 1/0 block 
set by) OpenDevice function or ADCMD_ALLOCATE command 
joa_Period - new sample period in 279.365 ns increments (124 thru 
65536, anti-aliasing filter works below 300 to 500 
depending on waveform) 
jioa_Volume ~ new volume (0 thru 64, linear) 


OUTPUTS 


io Unit -— bit map of channels that successfully loaded period and 
volume (bits 0 thru 3 correspond to channels 0 thru 3) 
io_Error — error number: 
0 —- no error 
ADIOERR_NOALLOCATION ~ allocation key (ioa_AllocKey) 
does not match key for channel 








FUNCTION ADCMD_SETPREC is a command for multiple audio channels. For each 


selected channel (io Unit), if the allocation key (ioa_Allockey) is 
correct, ADCMD_SETPREC sets the allocation precedence to a new value 
(1n_Pri) and checks if there are allocation requests (ADCMD_ALLOCATE) 
waiting for the channel which now have higher precedence; otherwise, 
ADCMD_SETPREC returns an error (ADIOERR_NOALLOCATION) . ADCMD_SETPREC 
is synchronous and only replies (mn_ReplyPort) if the quick flag 
(IOF_QUICK) is clear. Do not use ADCMD_SETPREC in interrupt code. 


INPUTS 


in_Pri ~ new allocation precedence (-128 thru 127) 
mn_ReplyPort- pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit — bit map of channels to set precedence (bits 0 thru 3 


correspond to channels 0 thru 3) 

io Command ~- command number for ADCMD_SETPREC 

io_Plags - flags, must be cleared if not used: 
IOF_QUICK - (CLEAR) reply I/O request 

ioa_AllocKey- allocation key, must. be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit — bit map of channels that successfully set precedence 
(bits 0 thru 3 correspond to channels 0 thru 3) 
io_Error — error number: 
0 -— no error 


ADIOERR_NOALLOCATION — allocation key (ioa_AllocKey) 
does not match key for channel 











ill 











audio.device/ADCMD_WAITCYCLE audio.device/CMD_CLEAR audio. device/command/CMD_CLEAR 
NAME NAME 


ADCMD_WAITCYCLE ~~ wait. for an audio channel to complete the current 
eycle of a write 


FUNCTION 
ADCMD_WAITCYCLE is a command for a single audio channel (io _Unit). 
If the allocation key (ioa_AllockKey) is correct and there is a write 
(CMD_WRITE) in progress on selected channel, ADCMD_WAITCYCLE does not 
reply (mn_ReplyPort) until the end of the current cycle. If there is 
no write is progress, ADCMD_WAITCYCLE replies immediately. If the 
allocation key is incorrect, ADCMD_WAITCYCLE returns an error 
(ADIOERR_NOALLOCATION). ADCMD_WAITCYCLE returns an error 
(IOEBRR_ABORTED) if it is canceled (AbortIO) or the channel is stolen 
(ADCMD ALLOCATE). ADCMD_WAITCYCLE is only asynchronous if it is 
waiting for a cycle to complete, in which case it clears the quick 
flag (IOF_QUICK); otherwise, it is synchronous and only replies if the 
quick flag (IOF QUICK) is clear. Do not use ADCMD_WAITCYCLE in 
interrupt code at interrupt level 5 or higher. 


INPUTS 
mn_ReplyPort- pointer to message port that receives I/O request, if 
the quick flag (IOF_QUICK) is clear, or if a write is in 
progress on the selected channel and a cycle has 


completed 

io Device -~ pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 

io_Unit - bit map of channel to wait for cycle (bits 0 thru 3 


correspond to channels 0-thru 3), if more then one bit 
is set lowest bit number channel is used 
io_Command - command number for CMD_WAITCYCLE 
jio_Flags -— flags, must be cleared if not used: 
IOF_QUICK - (CLEAR) reply I/O request 
(SET) only reply I/O request if a write is 
in progress on the selected channel 
! and a cycle has completed 
an ioa_AllocKey- allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 





OUTPUTS 

jo_Unit - bit map of channel that successfully waited for cycle 
(bits 0 thru 3 correspond to channels 0 thru 3) 

io_Flags - IOF_QUICK flag-cleared if a write is in progress on the 
selected channel 

io_Error ~ error number: 

— no error 
IOERR_ABORTED ~ canceled (AbortIO) or channel 
stolen 


ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) 
does not match key for channel 





CMD_CLEAR -- throw away internal caches 


FUNCTION 


CMD_CLEAR is a standard command for multiple audio channels. For each 
selected channel (io Unit), if the allocation key (ioa_AllocKey) is 
correct, CMD_CLEAR does nothing; otherwise, CMD_CLEAR returns an error 
(ADIOERR_NOALLOCATION). CMD_CLEAR is synchronous and only replies 
(mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request after 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit - bit map of channels to clear (bits 0 thru 3 correspond 


to channels 0 thru 3) 

io_Command -— command number for CMD_CLEAR 

io Flags - flags, must be cleared if not used: 
IOF_QUICK — (CLEAR) reply I/O request 

ioa_AllocKey- allocation key, must be set by (or copied from 1/0 block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit - bit map of channels successfully cleared (bits 0 thru 3 
correspond to channels 0 thru 3) 
io_Error - error number: 
~ 0 — no error 


ADIOERR_NOALLOCATION ~ allocation key (ioa_AllocKey) 
does not match key for channel 











audio. device/CMD_FLUSH 


NAME 





audio. device/command/CMD_FLUSH 


CMD_FLUSH -- cancel all pending 1/0 


FUNCTION 


CMD_FLUSH is a standard command for multiple audio channels. 


For each 


selected channel (io Unit}, if the allocation key (ioa_AllocKey) is 


_PPudio-devicescup READ 


NAME 


FUNCTION 
CMD_READ is a 


audio. device/command/CMD_READ 


CMD READ —— normal I/O entry point 


standard command for a single audio channel (io_Unit). 


If the allocation key (ioa_AllocKey) is correct, CMD_READ returns a 


correct, CMD FLUSH aborts all writes (CMD_WRITE) in progress or queued 
and any I/O requests waiting to synchronize with the end of the cycle 
(ADCMD_WAITCYCLE); otherwise, CMD_FLUSH returns an error 


pointer (io_Data) to the I/O block currently writing (CMD_WRITE) on 
the selected channel; otherwise, CMD_READ returns an error 
(ADIOERR_NOALLOCATION). If there is no write in progress, CMD_READ 





(ADIOERR_NOALLOCATION) . ) 
(mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. 


CMD_FLUSH is synchronous and only replies 
Do not use 


CMD_FLUSH in interrupt code at interrupt level 5 or higher. 


INPUTS 
mn_ReplyPort~ 


io Device -~- 
jo_Unit - 


io Command — 
io_Flags - 


ioa_AllocKey— 
OUTPUTS 
io_Unit - 


io Error - 


pointer to message port that receives I/O request 

if the quick flag (IOF_QUICK) is clear 

pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 

bit map of channels to flush (bits 0 thru 3 correspond 
to channels 0 thru 3) 

command number for CMD_FLUSH 

flags, must be cleared if not used: 

IOF_QUICK ~ (CLEAR) reply I/O request 

allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


bit map of channels successfully flushed (bits 0 thru 3 
correspond to channels 0 thru 3) 

error number: 
0 — no error . 
ADIOERR_NOALLOCATION — allocation key (ioa_AllocKey) 


does not match key for channel 


returns zero. 
INPUTS 
mn_ReplyPort— 
io Device — 
io_Unit - 
io Command — 
io_Flags - 
ioa_AllocKey— 
OUTPUTS 
io_Unit - 


1o_Error - 


ioa_Data - 





CMD READ is synchronous and only replies (mn_ReplyPort) 


if the quick bit (IOF_QUICK) is clear. 


pointer to message port that receives I/O request after 
if the quick flag (IOF_QUICK) is clear 

pointer to device node, must be set by (or copied from 
I/O block set. by) OpenDevice function 

bit map of channel to read (bit 0 thru 3 corresponds to 
channel 0 thru 3), if more then one bit is set lowest 
bit number channel read 

command number for CMD_READ 

flags, must be cleared if not used: 

IOF_QUICK — (CLEAR) reply I/O request 

allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


bit map of channel successfully read (bit 0 thru 3 

corresponds to channel 0 thru 3) 

error number: 

0 ~ no error 

ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) 
does not match key for channel 

pointer to I/O block for current write, zero if none is 

progress 





audio.device/CMD_RESET 


audio. device/command/CMD_RESET 





audio. device/CMD_START audio. device/command/CMD_START 


NAME NAME 


CMD_RESET ~- restore device to a known state CMD_START -- start device processing (like “Q) 


FUNCTION FUNCTION 
CMD_RESET is a standard command for multiple audio channels. For each CMD_START is a standard command. for multiple audio channels. For each 


selected channel (io_Unit), if the allocation key (ioa_AllocKey) is 
correct, CMD_RESET: 
clears the hardware audio registers and attach bits, 
. sets the audio interrupt vector, 
. cancels all pending I/O (CMD_FLUSH), and 
. un~stops the channel if it is stopped (CMD_STOP), 


Otherwise, CMD_RESET returns an error (ADIOERR_NOALLOCATION) . 
CMD_RESET is synchronous and only replies (mn_ReplyPort) if the quick 
flag (IOF_QUICK) is clear. Do not use CMD_RESET in interrupt code at 
interrupt level 5 or higher. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request 
if the quick flag (IOF_QUICK) is clear 


io_Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit ~ bit. map.of channels to reset (bits 0 thru 3 correspond 


to channels 0 thru 3) 

io-Command - command number for CMD_RESET 

io_Flags -— flags, must be cleared if not used: 
IOF_QUICK - (CLEAR) reply I/O request 

ioa_AllocKey- allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit -— bit map of channels to successfully reset (bits 0 thru 3 
correspond to channels 0 thru 3) 
io_Error ~ error number: 
~ no error 


ADIOERR_NOALLOCATION - allocation key. (ioa_Allockey) . 
does not match key for channel 





selected channel (io Unit), if the allocation key (ioa_AllocKey) is 
correct. and the channel was previously stopped (CMD_STOP), CMP_START 
immediately starts all writes (CMD_WRITE) to the channel. If the 
allocation key is incorrect, CMD_START returns an error 
(ADIOERR_NOALLOCATION). CMD _: START starts multiple channels 
simultaneously to minimize distortion if the channels are playing the 
same waveform and their outputs are mixed. CMD_START is synchronous and 


only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. Do 


not use CMD START in interrupt code at interrupt level 5 or higher. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request after 
if the quick flag (IOF_QUICK) is clear 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit — bit map of channels to start (bits 0 thru 3 correspond 


to channels 0 thru 3) 

io_Command -— command number for CMD_START 

io Flags — flags, must be cleared if not used: 
IOF_QUICK - (CLEAR) reply I/O request 

ioa_AllocKkey— allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 


OUTPUTS 


io_Unit - bit map of channels successfully started (bits 0 thru 3 
correspond to channels 0 thru 3) 
io_Error - error number: 


- no error 
ADIOERR_NOALLOCATION - allocation key (ioa_AllocKey) 
does not match key for channel 














audio.device/CMD_STOP audio. device/command/CMD_STOP audio.device/CMD_UPDATE audio.device/command/CMD_UPDATE 


NAME NAME 
CMD _STOP —- stop device processing (like “S) CMD UPDATE -- force dirty buffers out 
FUNCTION : FUNCTION 
CMD STOP is a standard command for multiple audio channels. For each CMD_UPDATE is a standard command for multiple audio channels. For 
selected channel (io Unit), if the allocation key (ioa_AllocKey) is each selected channel (io Unit), if the allocation key (ioa_AllocKey) 
correct, CMD STOP immediately stops any writes (CMD_WRITE) in is correct, CMD UPDATE does nothing; otherwise, CMD_UPDATE returns an 
progress; otherwise, CMD_STOP returns an error (ADIOERR_NOALLOCATION) . error (ADIOERR_NOALLOCATION) . CMD_UPDATE is synchronous and only 
CMD WRITE queues up writes to a stopped channel until CMD_START starts replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is clear. 
the channel or CMD RESET resets the channel. CMD_STOP is synchronous 
and only replies (mn_ReplyPort) if the quick flag (IOF_QUICK) is INPUTS 
clear. Do not use CMD STOP in interrupt code at interrupt level 5 or mn_ReplyPort- pointer to message port that receives I/O request after 
higher. if the quick flag (IOF QUICK) is clear 
io Device - pointer to device node, must be set by (or copied from 
INPUTS I/O block set by) OpenDevice function 
mn_ReplyPort- pointer to message port that receives I/O request after jio_Unit - bit map of channels to update (bits 0 thru 3 correspond 
if the quick flag (IOF_QUICK) is clear : to channels 0 thru 3) 
io Device - pointer to device node, must be set by (or copied from io Command - command number for CMD_UPDATE 
I/O block set by) OpenDevice function io_Flags ~ flags, must be cleared if not used: 
jo Unit — bit map of channels to stop (bits 0 thru 3 correspond to IOF_QUICK ~ (CLEAR) reply I/O request 
channels 0 thru 3) ioa AllocKey~ allocation key, must be set by (or copied from I/O block 
io_Command - command number for CMD_STOP set by) OpenDevice function or ADCMD_ALLOCATE command 
io_Flags ~ flags, must be cleared if not used: 
IOF QUICK — (CLEAR) reply I/O request OUTPUTS 
ioa_Allockey- allocation key, must be set by (or copied from I/O block io_Unit -— bit map of channels successfully updated (bits 0 thru 3 
set by) OpenDevice function or ADCMD_ALLOCATE command correspond to channels 0 thru 3) 
io_Error — error number: 
OUTPUTS 0 - no error 
io_Unit - bit map of channels successfully stopped (bits 0 thru 3 ADIOERR_NOALLOCATION - allocation key (ioa_Allockey) 
correspond to channels 0 thru 3) does not match key for channel 
io_Error ~ error number: 
— no error 


ADIOERR_NOALLOCATION — allocation key (ioa_AllocKey) 
does not match key for channel 














audio. device/OpenDevice audio. device/OpenDevice 


audio.device/CMD_WRITE audio. device/command/CMD_WRITE 


NAME NAME 


CMD_WRITE —- normal I/O entry point OpenDevice — open the audio device 


FUNCTION SYNOPSIS 


oT -4 


CMD WRITE is a standard command for a single audio channel (io Unit). 
If the allocation key (ioa_AllocKey) is correct, CMD_WRITE plays a 
sound using the selected channel; otherwise, it returns an error 
(ADIOERR_NOALLOCATION). CMD_WRITE queues up requests if there is 
another write in progress or if the channel is stopped (CMD_STOP). 
When the write actually starts; if the ADIOF_PERVOL flag is set, 
CMD_WRITE loads volume (ioa_Volume) and period (ioa_Period), and if 
the ADIOF WRITEMESSAGE flag is set, CMD_WRITE replies the write 
message (ioa_WriteMsg). CMD_WRITE returns an error (IOERR_ABORTED) if 
it is canceled (AbortIO) or the channel is stolen (ADCMD_ALLOCATE). 
CMD WRITE is only asynchronous if there is no error, in which case it 
clears the quick flag (IOF_QUICK) and replies the I/O request 
(mn_ReplyPort) after it finishes writting; otherwise, it is synchronous 


and only replies if the quick flag (IOF_QUICK) is clear. Do not use 
CMD WRITE in interrupt code at interrupt level 5 or higher. 


INPUTS 


mn_ReplyPort- pointer to message port that receives I/O request after 
the write completes 


io Device - pointer to device node, must be set by (or copied from 
I/O block set by) OpenDevice function 
io_Unit - bit map of channel to write (bit 0 thru 3 corresponds to 


channel 0 thru 3), if more then one bit is set lowest 
bit number channel is written 
io_Command - command number for CMD_WRITE 
io_Flags ~- flags, must be cleared if not used: 
ADIOF_PERVOL — (SET) load volume and period 
ADIOF WRITEMESSAGE ~ (SET) reply message at write start 
ioa_AllocKkey- allocation key, must be set by (or copied from I/O block 
set by) OpenDevice function or ADCMD_ALLOCATE command 
ioa_Data - pointer to waveform array (signed bytes (-128 thru 127) 
in custom chip addressable ram and word aligned) 
ioa_Length - length of the wave array in bytes (2 thru 131072, must 
be even number 
ioa_Period - sample period in 279.365 ns increments (124 thru 65536, 
anti-aliasing filter works below 300 to 500 depending on 
waveform), if enabled by ADIOF_PERVOL 
ioa_Volume - volume (0 thru 64, linear), if enabled by ADIOF _PERVOL 
ioa Cycles - number of times to repeat array (0 thru 65535, 0 for 
infinite) 
ioa_WriteMsg- message replied at start of write, if enabled by 
ADIOF_WRITEMESSAGE 


OUTPUTS 


io_Unit - bit map of channel successfully written (bit 0 thru 3 
corresponds to channel 0 thru 3) 
io_Flags — IOF_QUICK flag cleared if there is no error 
io_Error ~ error number: 
0 — no error 
IOERR_ABORTED - canceled (AbortIO) or channel 
stolen 
ADIOERR_NOALLOCATION ~ allocation key (ioa_Allockey) 
does not match key for channel 


BUGS 


If CMD_WRITE starts the write immediately after stopping a previous 
write, you must set the ADIOF_PERVOL flag or else the new data pointer 
(ioa_Data) and length (ioa_Length) may not be loaded. 


error = OpenDevice("audio.device", unitNumber, iORequest, flags); 


FUNCTION 


The OpenDevice routine grants access to.the audio device. It takes an 
I/O audio request block (iORequest) and if it can successfully open 
the audio device, it loads the device pointer (io_Device) and the 
allocation key (ioa_AllocKey); otherwise, it returns an error 
(IOERR_OPENFAIL). OpenDevice increments the open count keeping the 
device from being expunged (Expunge). If the length (ioa_Length) is 
non-zero, OpenDevice tries to allocate (ADCMD ALLOCATE) audio channels 
from a array of channel combination options (ioa_Data). If the 
allocation succeeds, the allocated channel combination is loaded into 
the unit field (ioa_Unit); otherwise, OpenDevice returns an error 
(ADIOERR_ALLOCFAILED). OpenDevice does not wait for allocation to 
succeed and closes (CloseDevice) the audio device if it fails. To 
allocate channels, OpenDevice also requires a properly initialized 
reply port (mn_ReplyPort) with an allocated signal bit. 


INPUTS 


unitNumber- not used 
iORequest - pointer to audio request block (struct IOAudio) 
in_Pri - allocation precedence (-128 thru 127), only 
necessary for allocation (non-zero length) 
mn_ReplyPort- pointer to message port for allocation, only 
necessary for allocation (non-zero length) 
ioa_AllocKey~ allocation key; zero to generate new key. 
Otherwise, it must be set by (or copied from I/O 
block that is set by) previous OpenDevice 
function or ADCMD ALLOCATE command (non~zero 
length) 
joa_Data ~ pointer to channel combination options (byte 
array, bits 0 thru 3 correspond to channels 0 
thru 3), only necessary for allocation (non-zero 


OUTPUTS 


length) 
jioa_Length - length of the channel combination option array 
: (0 thru 16), zero for no allocation 
flags ~ not used 
iORequest —- pointer to audio request block (struct IOAudio) 
io Device - pointer to device node if OpenDevice succeeds, 
otherwise -1 
io_Unit ~ bit map of successfully allocated channels (bits 
. 0 thru 3 correspond to channels 0 thru 3) 
1o_Error — error number: 
0 — no error 


IOERR_OPENFAIL ~ open failed 
ADIOERR_ALLOCFAILED - allocation failed, no open 
ioa_AllocKey~ allocation key, set to a unique number if passed 
a zero and OpenDevice succeeds 
error ~ copy of io_Error 











TT - 4 











TABLE OF CONTENTS 


clipboard. 
clipboard. 
clipboard. 
clipboard. 
.device/CMD_RESET 
clipboard. 
clipboard. 


clipboard 


device/CBD_POST 
device/CBD_CLIPREADID 
device/CBD_CLIPWRITEID 
device/CMD_READ 


device/CMD_UPDATE 
device/CMD_WRITE 





clipboard .device/CBD_POST clipboard.device/CBD_POST 


CBD_POST - post clip to clipboard 


FUNCTION 


Indicate to the clipboard device that data is available for 
use by accessors of the clipboard. This is intended to be 
used when a cut is large, in a private data format, and/or 
changing frequently, and it thus makes sense to avoid 
converting it to an IFF form and writing it to the clipboard 
unless another application wants it. The post provides a 
message port to which the clipboard device will send a satisfy 
message if the data is required. 


If the satisfy message is received, the write associated with 
the post must be performed. The act of writing the clip 
indicates that the message has been received: it may then be 
re-used by the clipboard device, and so must actually be 
removed from the satisfy message port so that the port is not 
corrupted. 


If the application wishes to determine if a post it has 
performed is still the current clip, it should check the 
post's io_ClipID with that returned by the CBD_CLIPREADID 
command. If ClipID is greater, the clip is not still 
current. 


If an application has a pending post and wishes to determine 
if it should satisfy it (e.g. before it exits), it should 
check the post's io_ClipID with that returned by the 
CBD_CLIPWRITEID command. If CurrentWriteID is greater, there 
is no need to satisfy the post. 


IO REQUEST 


RESULTS 


io_ Message mn_ReplyPort set up 

io Device preset by OpenDevice 

1o_Unit preset by OpénDevice 

jo_Command CBD_POST 

io Data pointer to satisfy message port 

io_ClipID Zero 

io_Error non-zero if an error occurred 

io_ClipID the clip ID assigned to this post, to be used 


in the write command if this is satisfied 








a 


eT 








L 





clipboard. device/CBD_CLIPREADID clipboard. device/CBD_CLIPREADID 


NAME 
CBD_CLIPREADID - determine the current read identifier. 


FUNCTION . 
CBD_CLIPREADID fills the io_ClipID with a clip identifier that 
can be compared with that of a post command: if greater than 
the post identifier then the post data held privately by an 
application is not valid for its own pasting. 


IO REQUEST 
io_Message mn_ReplyPort set up 
lo_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command CBD_CLIPREADID 
io_ClipID the ClipID of the current write is set 








clipboard. device/CBD_CLIPWRITEID clipboard. device/CBD_CLIPWRITEID 


NAME 


CBD_CLIPWRITEID — determine the current write identifier. 


FUNCTION 


CBD_CLIPWRITEID fills the io_ClipID with a clip identifier that 
can be compared with that of a post command: if greater than 
the post identifier then the post is obsolete and need never 


be satisfied. 


IO REQUEST 
io_Message 
io_Device 
io_Unit 
i1o_Command 


io_ClipID 


mn_ReplyPort set up 
preset by OpenDevice 
preset by OpenDevice 
CBD_CLIPWRITEID 


the ClipID of the current write is set 








€l -@ 








clipboard.device/CMD_READ clipboard. device/CMD_READ clipboard .device/CMD_RESET clipboard .device/CMD_RESET 


NAME NAME . 
CMD_READ ~ read clip from clipboard CMD RESET ~ reset the clipboard 
FUNCTION FUNCTION ; ; ; . 
The read function serves two purposes. CMD RESET resets the clipboard device without destroying handles 


to the open device. 
When io_Offset is within the clip, this acts as a normal read 


request, and io Data is filled with data from the clipboard. IO REQUEST 

The first read request should have a zero io_ClipID, which io_Message mn_ReplyPort set up 

will be filled with the ID assigned for this read. Normal io_Device preset by OpenDevice 

sequential access from the beginning of the clip is achieved io_Command CMD_RESET . . . . 

by setting io_Offset to zero for the first read, then leaving io_Flags IOB_QUICK set if quick I/o is possible 


it untouched for subsequent reads. If io_Data is null, then 
jo_Offset is incremented by io Actual as if io_Length bytes 
had been read: this is useful to skip to the end of file 

by using a huge io_Length. 


When io Offset is beyond the end of the clip, this acts as a 
signal to the clipboard device that the application is 
through reading this clip. Realize that while an application 
is in the middle of reading a clip, any attempts to write new 
data to the clipboard are held off. This read past the end 
of file indicates that those operations may now be initiated. 


IO REQUEST 
io_ Message mn_ReplyPort set up 
io_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command CMD_READ 
io_Length number of bytes to put in data buffer 
io_Data pointer to buffer of data to fill, or null to 
skip over data 
io offset byte offset of data to read 
i0_ClipID zero if this is the initial read 
RESULTS 
io_Error non-zero if an error occurred 
io_Actual filled with the actual number of bytes read 
io_Data (the buffer now has io_Actual bytes of data) 
io_Offset updated to next read position, which is 
beyond EOF if io_Actual != io_Length 
io_ClipID the clip ID assigned to this read: do not 


alter for subsequent reads 








Lil 





tT - ad 








clipboard. device/CMD_UPDATE 


NAME 








clipboard .device/CMD_UPDATE 


CMD_UPDATE — terminate the writing of a cut to the clipboard 


FUNCTION 


Indicate to the clipboard that the previous write commands are 
complete and can be used for any pending pastes (reads). This 
command cannot be issued while any of the write commands are 
pending. 


IO REQUEST 


io_Message mn_ReplyPort set up 


io_Device preset by OpenDevice 

io_Unit preset by OpenDevice 

io_Command CMD_UPDATE 

io_ClipID the ClipID of the write 
RESULTS 

io_Error non-zero if an error occurred 





clipboard .device/CMD_WRITE 


i 


clipboard .device/CMD_WRITE 


NAME 
CMD_WRITE ~ write clip to clipboard 
FUNCTION 
This command writes data to the clipboard. This data can be 
provided sequentially by clearing io_Offset for the initial 
write, and using the incremented value unaltered for 
subsequent writes. If io_Offset is ever beyond the current 
clip size, the clip is padded with zeros. 
If this write is in response to a SatisfyMsg for a pending 
post, then the io_ClipID returned by the Post command must 
be used. Otherwise, a new ID is obtained by clearing the 
io_ClipID for the first write. Subsequent writes must not 
alter the io_ClipID. 
IO REQUEST 
io_Message mn_ReplyPort set up 
io_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command CMD_WRITE 
io_Length number of bytes from io_Data to write 
lo_Data pointer to block of data to write 
io_offset usually zero if this is the initial write 
io_ClipID zero if this is the initial write, ClipID of 
the Post if this is to satisfy a post 
RESULTS 
io_Error non-zero if an error occurred 
io_Actual filled with the actual number of bytes written 
io_Offset updated to next write position 
io_ClipID the clip ID assigned to this write: do not 


alter for subsequent writes 





cst - 4d 








TABLE OF CONTENTS 


console. 
console 
console 
console. 
console. 
console. 
console. 
console 
console. 
console. 
console. 


device/CD_ASKDEFAULTKEYMAP 


.device/CD_ASKKEYMAP 
.device/CD_SETDEFAULTKEYMAP 


device/CD_SETKEYMAP 
device/CDInputHandler 
device/CMD_CLEAR 
device/CMD_READ 


.device/CMD_WRITE 


device/CloseDevice 
device/OpenDevice 
device/RawKeyConvert 





console. device/CD_ASKDEFAULTKEYMAP 


NAME 
CD_ASKDEFAULTKEYMAP — get the current default keymap 


FUNCTION 
Fill the io Data buffer with the current console device 
default keymap, which is used to initialize console unit 
keymaps when opened, and by RawKeyConvert with a null 
keyMap parameter. 


IO REQUEST 
io_ Message mn_ReplyPort set if quick I/O is not possible 
io Device preset by the call to OpenDevice 
io Unit preset by the call to OpenDevice 
io_Command CD_ASKDEFAULTKEYMAP 
io_Flags IOF_QUICK if quick I/O possible, else zero 
io_Length sizeof (*keyMap) 
io_Data struct KeyMap *keyMap 
pointer to a structure that describes 
the raw keycode to byte stream conversion. 
RESULTS 


This function sets the io Error field in the IostdReg, and fills 
the structure pointed to by io_Data with the current device 
default key map. 


BUGS 


SEE ALSO 
exec/io.h, devices/keymap.h, devices/console.h 











hl 





9T - da 








console.device/CD_ASKKEYMAP console. device/command/CD_ASKKEYMAP 


NAME 


CD_ASKKEYMAP ~ get the current key map structure for this console 


FUNCTION 


Fill the io_Data buffer with the current KeyMap structure in 
use by this console unit. 


IO REQUEST 
io_Message 
io_Device 
io_Unit 
io_Command 
io_Flags 
io_Length 
io_Data 


RESULTS 


mn_ReplyPort set if quick I/O is not possible 
preset by the call to OpenDevice 

preset by the call to OpenDevice 
CD_ASKKEYMAP 

IOF_QUICK if quick I/O possible, else zero 
sizeof (*keyMap) 

struct KeyMap *keyMap 

pointer to a structure that describes 

the raw keycode to byte stream conversion. 


This function sets the io_Error field in the lOStdReq, and fills 
the structure the structure pointed to by io Data with the current 


key map. 
BUGS 


SEE ALSO 


exec/io.h, devices/keymap.h, devices/console.h 








console .device/CD_SETDEFAULTKEYMAP 


NAME 
CD_SETDEFAULTKEYMAP — set the current default keymap 


FUNCTION 
This console command copies the keyMap structure pointed to 
by io_Data to the console device default keymap, which is used 
to initialize console units when opened, and by RawKeyConvert 
with a null keyMap parameter. 


IO REQUEST 
io Message mm_ReplyPort set if quick I/O is not possible 
io Device preset by the call to OpenDevice 
io_Unit preset by the call to OpenDevice 
io_Command CD_SETDEFAULTKEYMAP 
lo_Flags IOF_QUICK if quick I/O possible, else zero 
io_Length sizeof{*keyMap) 
lo Data struct KeyMap *keyMap 
pointer to a structure that describes 
the raw keycode to byte stream conversion. 
RESULTS 


This function sets the io_Error field in the IOoStdReq, and fills 
the current device default key map from the structure pointed to 
by io_Data. 


BUGS 


SEE ALSO 
exec/io.h, devices/keymap.h, devices/console.h 











it.- 4d 





console. device/CD_SETKEYMAP console. device/command/CD_SETKEYMAP 


NAME 
CD_SETKEYMAP ~— set the current key map structure for this console 


FUNCTION 
Set the current KeyMap structure used by this console unit to 
the structure pointed to by io_Data. 


IO REQUEST 
io_ Message mn_ReplyPort set if quick I/o is not possible 
io_Device preset. by the call to OpenDevice 
io Unit preset by the call to OpenDevice 
io_Command CD_SETKEYMAP 
io_Flags IOF QUICK if quick I/O possible, else zero 
io_Length sizeof (*keyMap) 
io Data struct KeyMap *keyMap 
pointer to a structure that describes 
the raw keycode to byte stream conversion. 
RESULTS 


This function sets the io Error field in the IostdReq, and fills 
the current key map from the structure pointed to by io_Data. 


BUGS 


SEE ALSO 
exec/io.h, devices/keymap.h, devices/console.h 








console.device/CDInputHandler 


NAME 
CDInputHandler - handle an input event for the console device 
SYNOPSIS 
events = CDInputHandler(events, consoleDevice) 
AO AL 
FUNCTION 


Accept input events from the producer, which is usually the 
rom input.task. 


INPUTS 
events — a pointer to a list of input events. 
consoleDevice - a pointer to the library base address of the 
console device. This has the same value as ConsoleDevice 
described. below. 


RESULTS 
events — a pointer to a list of input events not used by this 
handler. 
NOTES 


This function is available for historical reasons. It is 
preferred that input events be fed to the system via the 
WriteEvent command of the input.device. 


This function is different from standard device commands in 
that it is a function in the console device library vectors. 
In order to obtain a valid library base pointer for the 
console device (a.k.a. ConsoleDevice) call 
OpenDevice("console.device", —1, IOStdReq, 0), 

and then grab the io Device pointer field out of the IoStdReq 
and use as ConsoleDevice. 


BUGS 


SBE ALSO 
input .device 








8I -4d 








console.device/CMD_CLEAR console. device/command/CMD_CLEAR 


NAME 
CMD_CLEAR - clear console input buffer 


FUNCTION 


Remove from the input buffer any reports waiting to satisfy 
read requests. 


IO REQUEST . 
io_Message mn ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io_Unit preset by the call to OpenDevice 
io_Command CMD_CLEAR 
io_Flags IOB_QUICK set if quick I/O is possible, else 0 

BUGS 

SEE ALSO 


exec/io.h, devices/console.h 


console. device/CMD_READ 


console. device/command/CMD_READ 


CMD_READ —- return the next input from the keyboard 


FUNCTION 


Read the next input, generally from the keyboard. The form of 
this input is as an ANSI byte stream: i.e. either ASCII text 

or control sequences. Raw input events received by the 

console device can be selectively filtered via the aSRE and aRRE 
control sequences (see the write command). Keys are converted 
via the keymap associated with the unit, which is modified 

with CD_AKSKEYMAP and CD_SETKEYMAP 


If, for example, raw keycodes had been enabled by writing 
<CSID1{ to the console (where <CSI> is $9B or Esc[), keys 
would return raw keycode reports with the information from 
the input event itself, in the form: 

<CSI>1;0; <keycode> ; <qualifiers>;0;0;<seconds> ; <microseconds>q 


If there is no pending input, this command will not be 
satisfied, but if there is some input, but not as much as can 
fill io_Length, the request will be satisfied with the input 
currently available. 


IO REQUEST 

io_Message mn_ReplyPort set if quick I/O is not possible 

io Device preset by the call to OpenDevice 

io_Unit preset by the call to OpenDevice 

io_Command CMD_READ 

io_Flags IOF_QUICK if quick I/O possible, else zero 

io_Length sizeof (*buffer) 

io_Data char buffer[] 
a pointer to the destination for the characters to read 
from the keyboard. 

RESULTS 


This function sets the error field in the IOStdReq, and fills 
in the io_Data area with the next input, and io Actual with 
the number of bytes read. 


BUGS 


SEE ALSO 


exec/io.h, devices/console.h 








console. device/CMD_WRITE 


NAME 





console.device/command/CMD_WRITE 


CMD_WRITE — write text to the display 


FUNCTION 


Write a text record to the display. Note that the RPort of 
the console window is in use while this write command is 


pending. 


IO REQUEST 


io_Message 
io Device 


io_Unit 


io_Command 
io_Flags 
io_Length 


io_Data 


Code 


6T - @ 
Q 
3. 
© 
9 
5 





SrAGHIS AUN POo 
i 


Name 
BEL 
BS 
HT 
LF 
VT 
FF 
CR 


mn_ReplyPort set if quick I/O is not possible 
preset by the call to OpenDevice 

preset by the call to OpenDevice 

CMD_WRITE 

IOF_ QUICK if quick I/O possible, else zero 
sizeof(*buffer), or -1 if null terminated 
char buffer[] 

a pointer to a buffer containing the ANSI text 
to write to the console device. 


ANSI CODES SUPPORTED 


Independent Control Functions (no introducer) —— 


Definition 

BELL (actually a DisplayBeep) 
BACKSPACE 
HORIZONTAL TAB 
LINE FEED 
VERTICAL TAB 
FORM FEED 
CARRIAGE RETURN 
SHIFT OUT 

SHIFT IN 

ESCAPE 


Esc Name Definition 


INDEX: move the active position down one line 
NEXT LINE: 

HORIZONTAL TABULATION SET 

REVERSE INDEX: 

CONTROL SEQUENCE INTRODUCER: see next list 


ISO Compatable Escape Sequences (introduced by Esc) -— 
Esc Name Definition 


ce RIS RESET TO INITIAL STATE 


Control Sequences, with the number of indicated parameters. 

i.e. <CSI><parameters><control sequence letter(s)>. . Note the 
last entries consist of a space and a letter. CSI is either 
9B or Esc[. 


A minus after the number of parameters (#p) 


indicates less is valid. Parameters are seperated by 
semicolins, e.g. Esc{14;80H sets the cursor position to row 
14, column 80. 


Name Definition 


INSERT CHARACTER 

CURSOR UP 

CURSOR DOWN 

CURSOR FORWARD 

CURSOR BACKWARD 

CURSOR NEXT LINE 

CURSOR PRECEEDING LINE 

CURSOR POSITION 

CURSOR HORIZONTAL TABULATION 

ERASE IN DISPLAY (only to end of display) 
ERASE IN LINE (only to end of line) 
INSERT LINE 

DELETE LINE 





1- DCH DELETE CHARACTER 

2 CPR CURSOR POSITION REPORT (in Read stream only) 

1- su SCROLL UP 

1- sD SCROLL DOWN 

n CTC CURSOR TABULATION CONTROL 

1- CBT CURSOR BACKWARD TABULATION 

2-— HVP HORIZONTAL AND VERTICAL POSITION 

1- TBC TABULATION CLEAR 

SM SET MODE 

n RM RESET MODE 

n SGR SELECT GRAPHIC RENDITION 

l- DSR DEVICE STATUS REPORT 

1- aSLPP SET PAGE LENGTH (private Amiga sequence) 

1- aSLL SET LINE LENGTH (private Amiga sequence) 

1- aSLO SET LEFT OFFSET (private Amiga sequence) 

l1- aSTO SET TOP OFFSET (private Amiga sequence) 
aSRE SET RAW EVENTS (private Amiga sequence) 
alER INPUT EVENT REPORT (private Amiga Read sequence) 
aRRE RESET RAW EVENTS (private Amiga sequence) 
aSKR SPECIAL KEY REPORT (private Amiga Read sequence) 

- aSCR SET CURSOR RENDITION (private Amiga sequence) 
aWSR WINDOW STATUS REQUEST (private Amiga sequence) 
aWBR WINDOW BOUNDS REPORT (private Amiga Read sequence) 


we ME TORR OMEN BHD 
6 


POrRrPD OD 


Rao 


Modes, set with <CSI><mode-list>h, and cleared with 
<CST><mode-list>1, where the mode-list is one or more of the 
following parameters, seperated by semicolins —— 


Mode Name Definition 

20 LNM LINEFEED NEWLINE MODE: if a linefeed is a newline 
>1 ASM AUTO SCROLL MODE: if scroll at bottom of window 
?7 AWM AUTO WRAP MODE: if wrap at right edge of window 


BUGS 


Does not display cursor in SuperBitMap layers. 


SEE ALSO 


ROM Kernal Manual: libraries and devices, exec/io-h 





oc -da 





console. device/CloseDevice 


NAME 

Close -- close the console device 
SYNOPSIS 

CloseDevice( IOStdReq) 
FUNCTION 


This function closes software access to the console device, 

and informs the system that access to this device/unit which was 
previously opened has been concluded. The device may perform 
certain house-cleaning operations. The I/O request structure 
is now free to be recycled. 


INPUTS 
IoStdReg ~ pointer to an IOStdReq structure, set by OpenDevice 


BUGS 


SEE ALSO 
console. device/OpenDevice, exec/io.h 








console. 


device/OpenDevice console. device/function/OpenDevice 


NAME 


OpenDevice - a request to open a Console device 


SYNOPSTS 


error = OpenDevice("console.device'", unit, IOStdReq, 0 ) 
DO AO DO Al D1 


FUNCTION 


The open routine grants access to a device. There are two 
fields in the I0StdReq block that will be filled in: the 
io_Device field and possibly the io_Unit field. 


This open command differs from most other device open commands 
in that it requires some information to be supplied in the 
io_Data field of the IOStdReq block. This initialization 
information supplies the window that is used by the console 
device for output. 


The unit number that is a standard parameter for an open call 
is used specially by this device. A unit of —-l indicates that 
no actual console is to be opened, and is used to get a pointer 
to the device library vector ( which will be returned in the 

io Device field of the IoStdReq block ). A unit of zero binds 
the supplied window to a unique console. Sharing a console 
must be done at a level higher than the device. There are no 
other valid unit numbers. 


IO REQUEST 
io_Data struct Window *window 
This is the window that will be used for this 
console. It must be supplied if the unit in 
the OpenDevice call is 0 (see above). The 
RPort of this window is potentially in use by 
the console whenever there is an outstanding 
write command. 
INPUTS 
“console.device" - a pointer to the name of the device to be opened. 


unit -— the unit number to open on that device (0, or -l). 
IoStdReq - a pointer to a standard request block 
0 - a flag field of zero 


RESULTS 


error ~ zero if successful, else an error is returned. 


BUGS 


SEE 


If a console.device is attached to a SUPERBITMAP window, the cursor 
will not be displayed. In this case you are required to TURN OFF the 
console's cursor (with the standard escape sequence), and synthisize 
your own. Memory loss and compatiblity problems are possible if the 
cursor is not turned off. 


ALSO 
console.device/CloseDevice, exec/io.h, intuition/intuition.h 











console. device/RawKeyConvert 


NAME 
RawKeyConvert — decode raw input classes 

SYNOPSIS 
actual = RawKeyConvert(event, buffer, length, keyMap) 
DO AO Al DL A2 


ConsoleDevice in A6 if called from Assembly Language. 


FUNCTION 
This console function converts input events of type 
IECLASS_RAWKEY to ANSI bytes, based on the keyMap, and 
places the result into the buffer. 


INPUTS 
event — an InputEvent structure pointer. 
buffer — a byte buffer large enough to hold all anticipated 
characters generated by this conversion. 
length — maximum anticipation, i.e. the buffer size in bytes. 
keyMap ~ a KeyMap structure pointer, or null if the default 
console device key map is to be used. 





RESULTS 
actual - the number of characters in the buffer, or -] if 
a buffer overflow was about to occur. 





ERRORS 
if actual is -l, a buffer overflow condition was detected. 
Not all of the characters in the buffer are valid. 


NOTES 
This function is different from standard device commands in 
that it is a function in the console device library vectors. 
In order to obtain a valid library base pointer for the 
console device (a.k.a. ConsoleDevice) call 
OpenDevice("console.device", ~1, IOStdReq, 0), 
and then grab the io Device pointer field out of the I0StdReq 
and use as ConsoleDevice. 


tT? - 4 


BUGS 


SEE ALSO 
console.device/OpenDevice, exec/io.h, 
devices/inputevent.h, devices/keymap.h 





| Ih 


te - a 








CONTENTS 


.device/CMD_CLEAR 
.device/GPD_ASKCTYPE 
.device/GPD_ASKTRIGGER 
.device/GPD_READEVENT 
.device/GPD_SETCTYPE 
gameport. 


device/GPD_SETTRIGGER 











gameport .device/CMD_CLEAR 


NAME 


gameport .device/CMD_CLEAR 


CMD CLEAR - clear gameport input buffer 


FUNCTION 


Remove from the input buffer any gameport reports waiting to 
satisfy read requests. 


IO REQUEST 
io_ Message 
io Device 
io_Unit 
io. Command 
io_Flags 


mn _ReplyPort set if quick I/O is not possible 
preset by the call to OpenDevice 

preset by the call to OpenDevice 

CMD_CLEAR 

IOB_QUICK set if quick I/O is possible 

















gameport .device/GPD_ASKCTYPE gameport .device/GPD_ASKCTYPE gameport .device/GPD_ASKTRIGGER gameport .device/GPD_ASKTRIGGER 


NAME NAME 


GPD_ASKCTYPE — inquire the current game port controller type GPD_ASKTRIGGER ~ inquire the conditions for a game port report 


FUNCTION FUNCTION 


This command identifies the type of controller at the game 
port, so that the signals at the port may be properly 
interpreted. The controller type has been set by a previous 
GPD_SETCTYPE. 


This command inquires what conditions must be met by a game 
port unit before a pending Read request will be satisfied. 
These conditions, called triggers, are independent -~ that 
any one occurs is sufficient to queue a game port report to 


€@-a 





: : the Read queue. These conditions are set by GPD_SETTRIGGER. 
This command always executes immediately. 
This command always executes immediately. 


IO REQUEST 
io_Message mn_ReplyPort set if quick I/O is not possible IO REQUEST 
io_Device preset by the call to OpenDevice io Message mn_ReplyPort. set if quick I/O is not possible 
io_Unit preset by the call to OpenDevice io_Device preset by the call to OpenDevice 
io_Command GPD_ASKCTYPE io_Unit preset by the call to OpenDevice 
io_Flags IOB_QUICK set if quick I/O is possible io_Command GPD_ASKTRIGGER 
io_Length at least 1 io Flags JOB QUICK set if quick I/O is possible 
io_Data the address of the byte variable for the io_Length sizeof (gameportTrigger) 
result io Data a structure of type GameportTrigger, which 
has the following elements 
gpt_Keys — 


GPTB_DOWNKEYS set if button down transitions 
trigger a report, and GPTB_UPKEYS set if button up 
transitions trigger a report 
gpt_Timeout — 
a time which, if exceeded, triggers a report; 
measured in vertical blank units (60/sec) 
gpt_xXDelta — . 
a distance in x which, if exceeded, triggers a 
report 
gpt_YDelta — 
a distance in x which, if exceeded, triggers a 
report 














we- a 





gameport.device/GPD_READEVENT 





gameport .device/GPD_READEVENT 


NAME 
GPD_READEVENT ~ return the next game port event. 


FUNCTION 
Read game port events from the game port and put them in the 
data area of the iORequest. If there are no pending game port 
events, this command will not be satisfied, but if there are 
some events, but not as many as can fill IO_LENGTH, the 
request will be satisfied with those currently available. 


IO REQUEST 

jio_Message mn_ReplyPort set if quick I/O is not possible 

io_Device preset by the call to OpenDevice 

io Unit preset by the call to OpenDevice 

io_Command GPD_READEVENT 

io_Flags IOB_ QUICK set if quick I/O is possible 

io_Length the size of the io Data area in bytes: there 
are sizeof(inputEvent) bytes per input event. 

io_Data a buffer area to fill with input events. The 


fields of the input event are: 
ie _NextEvent 
links the events returned 
je Class 
is ITECLASS_RAWMOUSE 
le SubClass 
is 0 for the left, 1 for the right game port 
le Code 
contains any gameport button reports. No 
report is indicated by the value Oxff. 
le Qualifier 
only the relative and button bits are set 
ie_X, ie_Y 
the x and y values for this report, in either 
relative or absolute device dependent units. 
ie TimeStamp 
the delta time since the last report, given 
not as a standard timestamp, but as the frame 
count in the TV_SECS field. 


RESULTS 
This function sets the error field in the iORequest, and fills 


the iORequest with the next game port events (but not partial 
events). 


SEE ALSO 
gameport .device/GPD_SETCTYPE, gameport .device/GPD_SETTRIGGER 





‘Tgameport .device/GPD_SETCTYPE 











gameport .device/GPD_SETCTYPE 


NAME 
GPD_SETCTYPE - set the current game port controller type 
FUNCTION 
This command sets the type of device at the game port, so that 
the signals at the port may be properly interpreted. The port 
can also be turned off, so that no reports are generated. 
This command always executes immediately. 
IO REQUEST 


io Message mn_ReplyPort set if quick I/O is not possible 


io_Device preset by the call to OpenDevice 

io_Unit preset by the call to OpenDevice 

io_Command GPD_SE'TCTYPE 

io_Flags IOB_QUICK set if quick I/O is possible 
io_Length 1 

io_Data the address of the byte variable describing 


the controller type, as per the equates in 
the gameport include file 











Gt@- @ 








gameport .device/GPD_SETTRIGGER gameport .device/GPD_SETTRIGGER 


NAME 
GPD_SETTRIGGER — set the conditions for a game port report 
FUNCTION 
This command sets what conditions must be met by a game 
port unit before a pending Read request will be satisfied. 
These conditions, called triggers, are independent —- that 
any one occurs is sufficient to queue a game port report to 
the Read queue. These conditions are inquired with 
GPD_ASKTRIGGER. 
This command always executes immediately. 
IO REQUEST 
io_Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io_Unit preset by the call to OpenDevice 
io_Command GPD_SETTRIGGER 
io_Flags IOB_QUICK set if quick I/O is possible 
io_Length sizeof (gameportTrigger) 
io Data a structure of type GameportTrigger, which 


has the following elements 
gpt_Keys - 
GPTB DOWNKEYS set if button down transitions 
trigger a report, and GPTB_UPKEYS set if button up 
transitions trigger a report 
gpt_Timeout — 
a time which, if exceeded, triggers a report; 
measured in vertical blank units (60/sec) 
gpt_xXDelta —- 
a distance in x which, if exceeded, triggers a 
report 
gpt_YDelta —- 
a distance in x which, if exceeded, triggers a 
report 








HI 


9f - @ 


TABLE 


input. 
input. 
input. 
input. 
input. 
input. 
input. 
input. 
input. 
input. 


OF CONTENTS 


device/AddHandler 
device/RemHandler 
device/Reset 
device/SetMPort 
device/SetMTrig 
device/SetMType 
device/SetPeriod 
device/SetThresh 
device/Start 
device/WriteEvent 


input .device/AddHandler input .device/AddHandler 


NAME 
AddHandler - add an input handler to the device 


FUNCTION 
Add a function to the list of functions called to handle 
input events generated by this device. The function is called 


as 
newInputEvents = Handler(inputEvents, handlerData) ; 
DO AO Al 
IO REQUEST 
io Message mn_ReplyPort set 
io_Device preset by OpenDevice 
io Unit preset by OpenDevice 
io_Command IND_ADDHANDLER 
io_Data a pointer to an interrupt structure. 
is_Data the handlerData pointer described above 
is_ Code the Handler function address 
NOTES 


The interrupt structure is kept by the input device until a 
RemHandler command is satisfied for it. 

















input .device/RemHandler input..device/RemHandler input.device/Reset input .device/Reset 


NAME NAME 
RemHandler -— remove an input handler from the device Reset - reset the input device 
FUNCTION FUNCTION 
Remove a function previously added to the list of handler Reset resets the input device without destroying handles 
functions. to the open device. 
IO REQUEST IO REQUEST 
io_Message - mn_ReplyPort set io_Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset. by OpenDevice io Device preset by the call to OpenDevice 
io_Unit preset by OpenDevice io_Unit preset by the call to OpenDevice 
io_Command IND_REMHANDLER : io_Command CMD_RESET 
io Data a pointer to the interrupt structure. io_Flags IOB_QUICK set if quick I/O is possible 
NOTES 


This command is not immediate 


4@- 4 























input .device/SetMPort input.device/SetMPort input.device/SetMTrig input .device/SetMTrig 


NAME NAME 
SetMPort - set the current mouse port SetMTrig - set the conditions for a mouse port report 
FUNCTION FUNCTION 
This command sets the gameport port at which the mouse is This command sets what conditions must be met by a mouse 
connected. before a pending Read request will be satisfied. The trigger 
specification is that used by the gameport device. 
IO REQUEST 
io Message mn_ReplyPort set if quick I/O is not possible IO REQUEST 
io Device preset by the call to OpenDevice io_Message mn_ReplyPort set if quick I/O is not possible 
io_Unit preset by the call to OpenDevice io_Device preset by the call to OpenDevice 
io_Command IND_SETMPORT io_Unit preset by the call to OpenDevice 
io_Flags IOB_QUICK set if quick I/O is possible io_Command IND_SETMTRIG 
io_Length 1 jio_Flags IOB_QUICK set if quick I/O is possible 
io Data a pointer to a byte that is either 0 or l, io_Length sizeof (gameportTrigger ) 
indicating that mouse input should be obtained io Data a structure of type GameportTrigger, which 
from either the left or right controller port, has the following elements 
respectively. gpt_Keys — 


GPTB_DOWNKEYS set if button down transitions 
trigger a report, and GPTB_UPKEYS set if button up 
transitions trigger a report 
gpt_Timeout — 
a time which, if exceeded, triggers a report; 
measured in vertical blank units (60/sec) 
gpt_xXDelta - 
a distance in x which, if exceeded, triggers a 
report , 
gpt_YDelta —- 
a distance in x which, if exceeded, triggers a 
report 


8c - a 




















input .device/SetMType input .device/SetMType input .device/SetPeriod input. .device/SetPeriod 









NAME NAME 
SetMType - set the current mouse port controller type SetPeriod — set the key repeat period 
FUNCTION FUNCTION ; . . 
This command sets the type of device at the mouse port, so This command sets the period at which a repeating key repeats. 


the signals at the port may be properly interpreted. ' . 
This command always executes immediately. 


IO REQUEST 
io_Message mn ReplyPort set if quick I/O is not possible IO REQUEST — a timerequest . ; ; ; 
io_Device preset by the call to OpenDevice io Message mn_ReplyPort set if quick I/O is not possible 
io_Unit preset by the call to OpenDevice io_Device preset by the call to OpenDevice 
io_Command IND_SETMTYPE io Unit preset by the call to OpenDevice 
io_Flags IOB_QUICK set if quick I/O is possible io_Command IND_SETPERIOD — . . ; 
io_Length 1 io Flags IOB_QUICK set if quick I/O is possible 
io_Data the address of the byte variable describing io_tv_Secs the repeat period seconds 


the controller type, as per the equates in io_tv_Micro the repeat period microseconds 
the gameport include file 





6@ - @ 


























input.device/SetThresh input.device/SetThresh input.device/Start input .device/Start 
NAME NAME 
SetThresh - set the key repeat threshold Start — restart after stop 
FUNCTION FUNCTION 
This command sets the time that a key must be held down before Start restarts the unit after a stop command. 
it can repeat. The repeatability of a key may be restricted 
(as, for example, are the shift keys). IO REQUEST 
io _ Message mn_ReplyPort set if quick 1/0 is not possible 
This command always executes immediately. jio_Device preset by the call to OpenDevice 
io_Unit preset by the call to OpenDevice 
IO REQUEST - a timerequest io_Command CMD_START 
io_Message mn_ReplyPort set if quick I/O is not possible io_Flags IOB_QUICK set if quick I/O is possible 
io_Device preset by the call to OpenDevice 
io_Unit preset by the call to OpenDevice 
io Command IND_SETTHRESH 
io_Flags IOB_QUICK set if quick I/O is possible 
io_tv_Secs the threshold seconds 
ito_tv_Micro the threshold microseconds 





og ~ a 














T€é - a 


input .device/WriteEvent. 


input .device/WriteEvent 





NAME 
WriteEvent — propagate input event(s) to all handlers 
FUNCTION 
IO REQUEST 
io Message m_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io Unit preset by the call to OpenDevice 
io_Command IND_WRITEEVENT 
io_Flags IOB_QUICK set if quick I/O is possible 
io_Length the size of the io_Data area in bytes: there 
are sizeof(inputEvent) bytes per input event. 
io_Data a buffer area with input events(s). The 


NOTES 


The 


fields of the input event are: 
jie_NextEvent 
links the events together, the last event 
has a zero ie_NextEvent. 
ie Class 
ie SubClass 
ie_ Code 
ie Qualifier 
ie X, ie_Y 
ie_TimeStamp 
as desired 


contents of the input event(s) are destroyed. 








\h) 


ce -~ @ 





[TABLE OF 


keyboard. 
keyboard. 
keyboard. 
keyboard. 
keyboard. 
keyboard. 
keyboard. 





CONTENTS 


device/CMD_CLEAR 
device/CMD_RESET 
device/KBD_ADDRESETHANDER 
device/KBD_READEVENT 
device/KBD_READMATRIX 
device/KBD_REMRESETHANDLER 
device/KBD_RESETHANDLERDONE 


keyboard .device/CMD_CLEAR 


NAME 


keyboard. device/CMD_CLEAR 


CMD_CLEAR ~ clear keyboard input buffer 


FUNCTION 


Remove from the input buffer any keys transitions waiting to 
satisfy read requests. 


IO REQUEST 
1o_Message 
1o_Device 
io_Command 
io Flags 


mn_ReplyPort set if quick I/O is not possible 
preset by the call to OpenDevice 

CMD_CLEAR 

IOB_QUICK set if quick I/O is possible 





ee - 4a 








keyboard. device/CMD_RESET keyboard. device/CMD_RESET 


NAME 
CMD_RESET —- reset the keyboard 
FUNCTION 
CMD_RESET resets the keyboard device without destroying handles 
to the open device. 
IO REQUEST 
io Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io_Command CMD_RESET 
io_Flags IOB_QUICK set if quick I/O is possible 





keyboard. device/KBD_ADDRESETHANDER 


NAME 
KBD_ADDRESETHANDER — add a reset handler to the device 


FUNCTION 
add a function to the list of functions called to clean up 
before a hard reset: 
Handler(handlerData) ; 
Al 


Note that the A500 does not support this. CTRL-Amiga-Amiga 
on an A500 does an immediate hard processor reset. 


IO REQUEST 
io Message mn_ReplyPort set 
io Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command KBD_ADDRESETHANDLER 
io_Data a pointer to an interrupt structure. 
is Data the handlerData pointer described above 
is Code the Handler function address 
NOTES 


The interrupt structure is kept by the keyboard device until a 
KBD_REMRESETHANDLER command is satisfied for it. 














keyboard .device/KBD_READEVENT keyboard. device/KBD_READEVENT 


NAME 
KBD_READEVENT ~ return the next keyboard event. 


FUNCTION 
Read raw keyboard events from the keyboard and put them in the 
data area of the iORequest. If there are no pending keyboard 
events, this command will not be satisfied, but if there are 
some events, but not as many as can fill IO_LENGTH, the 
request will be satisfied with those currently available. 


IO REQUEST 

io_Message mn_ReplyPort set if quick I/O is not possible 

io_Device preset by the call to OpenDevice 

to_Command KBD_READEVENT 

io_Flags IOB_QUICK set if quick I/O is possible 

io_Length the size of the io Data area in bytes: there 
are sizeof(inputEvent) bytes per input event. 

io_Data a buffer area to fill with input events. The 


fields of the input event are: 
ie_NextEvent 

links the events returned 
ie_Class 

is IECLASS_RAWKEY 
ie_Code 

contains the next key up/down reports 
ie_Qualifier 

only the shift and numeric pad bits are set 
ie_SubClass, ie_X, ie_Y, ie TimeStamp 

are not used, and set to zero 


RESULTS 
This function sets the error field in the IORequest, and fills 


the IORequest with the next keyboard events (but not partial 
events). 


ve — a 





keyboard .device/KBD_READMATRIX keyboard .device/KBD_READMATRIX 


NAME 
KBD_READMATRIX — read the current keyboard key matrix 


FUNCTION 


This function reads the up/down state of every key in the 
key matrix. 


IO REQUEST 
io _ Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
10_Command KBD_READMATRIX 
io_Flags IOB_QUICK set if quick I/O is possible 
io_Length the size of the io Data area in bytes: this 
must. be big enough to hold the key matrix. 
io_Data a buffer area to fill with the key matrix: 
an array of bytes whose component bits reflect 
each keys state: the state of the key for 
keycode n is at bit (n MOD 8) in byte 
(n DIV 8) of this matrix. 
NOTE 


For V1.2/V1.3 Kickstart, io_Length must be set to exactly 13 bytes. 


RESULTS 


This function sets the error field in the IORequest, and sets 
matrix to the current key matrix. 








(keyboard. device/KBD_REMRESETHANDLER 


NAME 


KBD_REMRESETHANDLER - remove a reset handler from the device 


FUNCTION 


Remove a function previously added to the list of handler 


functions. 


IO REQUEST 
io_Message 
io Device 
io_Unit 
io_Command 
io_Data 


ce -a@ 





mn_ReplyPort. set 
preset. by OpenDevice 
preset by OpenDevice 
KBD_REMRESETHANDLER 


a pointer to the handler interrupt structure. 











keyboard . device/KBD_RESETHANDLERDONE 


NAME 


KBD _RESETHANDLERDONE — indicate that reset can occur 


FUNCTION 


Indicate that reset cleanup associated with the handler has 


completed. 


IO REQUEST 
io Message 
io_Device 
io_Unit 
io_Command 
io_Data 


mn_ReplyPort set 

preset by OpenDevice 

preset by OpenDevice 

KBD_RESETHANDLERDONE 

a pointer to the handler interrupt structure. 








9€ — 4d 











[TABLE OF 


narrator 





narrator. 
narrator. 
narrator. 
narrator. 
narrator. 
-device/CMD_START 
narrator. 
narrator. 
narrator. 


CONTENTS 


device/AbortIo 
device/CloseDevice 
device/CMD_FLUSH 
device/CMD_READ 
device/CMD_RESET 


device/CMD_STOP 
device/CMD_WRITE 
device/OpenDevice 


narrator.device/AbortIo narrator. device/AbortIo 


NAME 
AbortIO — Abort an IO request 


SYNOPSIS 
Abort IO(iORequest) 
Al 


FUNCTION 
Aborts a speech IO request. The request may be in the queue 
or currently active. 


eae yoRequest - pointer to the IORequest block of request to abort. 
RESULTS 
io_Error field of IORequest set to IOERR_ABORTED 
BUGS 
SEE ALSO 


narrator.device/BeginIO, exec/io.h 











L€ - a 








narrator.device/CloseDevice 


NAME 
CloseDevice - terminates access to the narrator device 


SYNOPSIS 
CloseDevice(i0ORequest) 
Al 


FUNCTION 
Close invalidates the io_Unit and io Device fields in the 
JORequest, preventing subsequent IO until another OpenDevice. 
CloseDevice also reduces the open count. If the count 
goes to 0 and the expunge bit is set, the device is 
expunged. If the open count goes to zero and the delayed 
expunge bit is not set, CloseDevice sets the expunge bit. 


INPUTS 
iORequest~- pointer to an IORequest block 
RESULTS 
The unit and device pointers of the [ORequest block are invalidated. 
BUGS 
SEE ALSO 


narrator.device/OpenDevice, exec/io.h 


narrator .device/CMD_FLUSH 





narrator.device/CMD_FLUSH 


NAME 

CMD FLUSH - Aborts all inprogress and queued requests 
FUNCTION 

Aborts all in-progress and queued speech requests. 
IO REQUEST . 

io_Device set by OpenDevice 

io Unit set by OpenDevice 

io_Command CMD_FLUSH 
RESULTS 

jo_Error always cleared 
BUGS 
SEE ALSO 


exec. library/SendIo, exec. library/DoIO, exec/io.h 








ge -a 


narrator.device/CMD_READ 


NAME 






FUNCTION 














CMD_READ - Return the next different mouth shape from an 
associated write. 


The read command of the narrator device returns mouth 
shapes to the user. The shape returned is guaranteed 

to be differnt from the previously returned shape 
(allowing updating to be done only when something has 
changed). Each read request is associated with a 

write request by the pseudo-unit number assigned by 

the OpenDevice call. Since the first structure in 

the read-mouth IORequest block (IORB) is a narrator 
(write) IORB, this association is easily made by copying 
the narrator IORB into the narrate_rb field fo the read IORB. 
See the .h,i files. If there is no write in progress 

or in the device input queue with the same pseudo-unit 
number as the read request, the read will be 

returned to the user with an error. This is also 

how the user knows that the write request has 

finished and that s/he should not issue any more 

reads. Note that in this case the mouth shapes may 

not be different from previously returned values. 


IO REQUEST 


with the narrator_rb structure copied from the 
associated write request except for: 


io_Message ~- message port for read request 
io Command —- CMD_READ 

io_Error - 0 

width - 0 

height - 0 


RESULTS 


IORequest block fields set: 
width - mouth width in millimeters/3.67 
(division done for scaling) 
height - mouth height in millimeters 
shape - compressed form of mouth shapes 
(internal use only) 


SEE ALSO 


narrator.device/CMD_WRITE, 
exec. library/DoIO, exec.library/SendIO, exec/io.h 


narrator .device/CMD_READ narrator .device/CMD_RESET 











narrator.device/CMD_RESET 





NAME 


CMD_RESET -— Reset the device to a known state 


FUNCTION 
Resets the device as though it has just be initialized. 
Aborts all read/write requests whether active of enqueued. 
Restarts device if it has been stopped. 


IO REQUEST 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_RESET 
RESULTS 
jio_Error always cleared 
BUGS 
SEE ALSO 


exec. library/SendIO, exec.library/DoIO, exec/io.h 














narrator .device/CMD_START narrator.device/CMD_START 


NAME 
CMD START — Restarts the device after CMD_STOP 


FUNCTION 
CMD_START restarts the currently active speech (if any) 
and allows queued requests to start. 


IO REQUEST 
io_Device set by OpenDevice 
io Unit set by OpenDevice 
io_Command CMD_START 
RESULTS 
io_ Error always cleared 
BUGS 
SEE ALSO 


exec. library/DoI0, exec. library/SendIO, exec/io.h 


6€ - 4a 








narrator.device/CMD_STOP narrator .device/CMD_STOP 


NAME 
CMD_STOP - Stops the device. 


FUNCTION 
CMD_STOP halts the currently active speech (if any) and 
prevents any queued requests from starting. 


IO REQUEST 
jio_Device set by OpenDevice 
io Unit set by OpenDevice 
io_Command CMD_STOP 
RESULTS 
io_Error always cleared 
BUGS 
SEE ALSO 


exec. Library/DoIO, exec. library/SendI10, exec/io.h 











narrator.device/CMD_WRITE narrator.device/CMD_WRITE 


NAME 
CMD_WRITE — Send speech request to the narrator device 


FUNCTION 
Performs the speech request. If there is an associated read 
request on the device input queue, write will remove it and 
return an initial mouth shape to the user. 


Note: if you are going to be doing reads, 
the mouths parameter must be set to 1. 


IO REQUEST 
narrator_rb. request block: 

ch_masks ~ array of audio channel selection masks 
(see audio device documentation for 
description of this field) 

nmmasks — number of audio channel selection masks 

mouths - 0 if no mouths are desired 
1 if mouths are to be read 

rate - speaking rate 

pitch ~ pitch 

mode — pitch mode 


0 if natural mode 

1 if robotic mode 
sex -~ 0 if male 

- 1 if female 

io_Message - message port 
io_Command — CMD_WRITE 
io Data — input string 
io_Length - length of input string 


RESULTS 
The function sets the io_Error field of the IORB. The 
io_Actual field is set to the length of the input string 
that was actually processed. If the return code indicates 
a phoneme error (ND_PhonErr), io Actual is the position in 
the input string where the error occured. 





ov -4 


BUGS 


SEE ALSO 
narrator.device/CMD_READ, devices/narrator.h 
exec. library/DoIO, exec. library/SendIo, exec/io.h 
Audio device documentation. 











narrator .device/OpenDevice 


NAME 
OpenDevice ~ open the narrator device. 
SYNOPSIS 
error = OpenDevice("narrator.device", 0 , iORequest , 0 ); 
DO AO pO Al D1 
FUNCTION 


The OpenDevice routine grants access to the narrator device. 
OpenDevice checks the unit number, and if non-zero, returns 
an error (ND_UnitErr). If this is the first time the driver 
has been opened, OpenDevice will attempt to open the audio 
device and allocate the driver's static buffers. If either 
of these operations fail, an error is returned (see the .h,i 
files for possible error return codes). Next, OpenDevice 
(done for all opens, not just the first one) initializes the 
user's IORequest block (IORB). Default values for sex, rate, 
pitch, pitch mode, sampling frequency, and mouths are set in 
the appropriate fields of the IORB. Note that if users wish 
to use non-default values for these parms, the values must 
be set after the open is done. OpenDevice then assigns a 
pseudo-unit number to the IORB for use in synchronizing read 
and write requests. See the CMD_READ command for more details. 
Finally, OpenDevice stores the device node pointer in the 
IORB and clears the delayed expunge bit. 


INPUTS 
deviceName ~ must be "narrator.device" 
unitNumber — must be 0 


iORequest - a pointer to the user's IORequest block 
( need not be initialized ) 
flags - not used 
RESULTS 


error — same as io_Error field of IORB 


IORequest block fields set: 


rate - 150 words/minute 
pitch - 110 Hz 

mode - Natural 

sex — Male 


mouths - Off 
sampfreq — 22200 
volume - 64 (max) 


BUGS 
SEE ALSO 


narrator.device/OpenDevice, narrator.device/CMD_READ, 
exec/io.h 











Ty - 4 








TABLE OF 


parallel 


parallel. 
parallel. 
.device/CMD_RESET 
.device/CMD_START 


parallel 
parallel 


parallel. 
parallel. 
.device/OpenDevice 

.device/PDCMD_QUERY 


parallel 
parallel 


parallel. 


CONTENTS 


.device/CMD_CLEAR 


device/CMD_FLUSH 
device/CMD_ READ 


device/CMD_STOP 
device/CMD_WRITE 


device/PDCMD_SETPARAMS 


parallel .device/CMD_CLEAR 


NAME 
FUNCTION 


IO REQUEST 
io Message 
jio_Device 
io_Unit 
io_Command 





parallel .device/CMD_CLEAR 


Clear —- clear the parallel port buffer 


This command just RTS's (no buffer to clear) 


mn_ReplyPort initialized 
set by OpenDevice 

set by OpenDevice 

CMD CLEAR (05) 





cy - a 








parallel.device/CMD_FLUSH parallel .device/CMD_FLUSH 


NAME 
Flush — clear all queued I/O requests for the parallel port 


FUNCTION 


This command purges the read and write request queues for the 
parallel device. 


IO REQUEST 
io_Message mn_ReplyPort. initialized 
jio_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_FLUSH (08) 











parallel .device/CMD_READ parallel .device/CMD_READ 


NAME 
Read —- read input from parallel port 


FUNCTION 
This command causes a stream of characters to be read from the 
parallel I/O register. The number of characters is specified in 
1o_Length. 
The parallel.device has no internal buffer; if no read request has 
been made, pending input (i.e. handshake request) is not 


acknowledged. 
10 REQUEST 
io_Message mn_ReplyPort initialized 
io Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_READ (02) 
io_Flags If IOF_QUICK is set, driver will attempt Quick IO 
io_Length number of characters to receive. 
io Data pointer where to put the data. 
RESULTS 
io_Error -- if the Read succeded, then io_Error will. be null. 


If the Read failed, then io_Error will contain an error code. 


SEE ALSO 
parallel .device/PDCMD_SETPARAMS 











ev - a 





[parallel .device/CMD_RESET parallel .device/CMD_RESET 


NAME 
Reset —— reinitializes the parallel device 


FUNCTION 
This command resets the parallel device to its freshly initialized 
condition. It aborts all I/O requests both queued and current and 
sets the devices's flags and parameters to their boot-up time 
default values. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 


io Command CMD RESET (01) 
RESULTS 
Error —- if the Reset succeded, then io_Error will be null. 
If the Reset failed, then the io_Error will be non-zero. 








parallel .device/CMD_START 


NAME 
Start —- restart paused I/O over the parallel port 


FUNCTION 
This command restarts the current I/O activity on the parallel 
port by reactivating the handshaking sequence. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io Device set by OpenDevice 
io_Unit set by OpenDevice 


io_Command CMD_START (07) 


SEE ALSO 
parallel .device/CMD_STOP 


parallel .device/CMD_START 








vy -~ a2 








parallel .device/CMD_STOP parallel .device/CMD_STOP 


NAME 
Stop —- pause current activity on the parallel device 


FUNCTION 
This command halts the current I/O activity on the parallel 
device by discontinuing the handshaking sequence. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_STOP (06) 

SEE ALSO 


parallel .device/CMD_START 


BUGS 
Using any other parallel.device command will restart Io. 





parallel .device/CMD_WRITE parallel .device/CMD_WRITE 


NAME 





Write —.send output to parallel port 


FUNCTION 


This command causes a stream of characters to be written to the 
parallel output register. The number of characters is specified in 
io_Length, unless -1 is used, in which case output is sent until 
a zero byte in the data: note that this is’ independent of setting 
EOFMODE in io _ParFlags and using the PTermArray to terminate the 


write. 
IO REQUEST 
io_Message mn_ReplyPort initialized 
io Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_WRITE (03) 
io_Flags If IOF_QUICK is set, driver will attempt Quick IO 
io_Length number of characters to transmit, or if set 
to -1 send until zero byte encountered 
io Data pointer to block of data to transmit 
RESULTS 
io_Error ~~ If the Write succeded, then io Error will be nuil. 


If the Write failed, then io_Error will contain an error code. 


SEE ALSO 


parallel .device/PDCMD_SETPARAMS 

















parallel.device/OpenDevice parallel.device/OpenDevice 


NAME 
Open ~- a request to open the parallel port 
SYNOPSIS 
error = OpenDevice("parallel.device", unit, ioExtPar, flags) 
DO AO DO Al D1 
FUNCTION 


This is an exec call that starts up the parallel.device. 


This function allows the requestor software access to the parallel 
device. Unless the shared-access bit (bit 5 of io_ParFlags) is 
set, exclusive use is granted and no other access is allowed 

until the owner closes the device. The PTermArray of the ioExtPar 
is initialized only if the EOFMODE bit is set in io_ParFlags. 


INPUTS 

"parallel .device" - a pointer to literal string “parallel.device" 

unit - Must be zero for future compatibility : 

ioExtPar — pointer to an IO Request block of structure IOEBxtPar 
to be initialized by the Open routine. (see devices/parallel.h for 
definition) 
The io ParFlags field must be set as desired (see shared—access 
description, above). Note that this is not a standard 10 Request. 
structure. 

flags - Must be zero for future compatibility 


RESULTS 
dO —- same as io_Error 
io Error -- if the Open succeded, then io_Error will be null. 
If the Open failed, then io_Error will be non-zero. 
SEE ALSO 
exec/CloseDevice 


St -4@ 








parallel .device/PDCMD_QUERY parallel .device/PDCMD_QUERY 


NAME 
Query -—~ query parallel port/line status 
FUNCTION 
This command return the status of the parallel port lines and 
registers. 
IO REQUEST 
io_ Message must have mn_ReplyPort initialized 
io_Device set by OpenDevice 


io Unit set by OpenDevice 
io_Command PDCMD_QUERY (09) 


RESULTS 
io Status BIT ACTIVE FUNCTION 
0 high printer busy toggle (offline) 
1 high paper out 
2 high printer selected on the A1000 
printer selected & serial. "Ring 
Indicator" on the A500/A2000 
Use care when making cables. 
3 - read=0,write=1 
4-7 reserved 
BUGS 


In a earlier version of this AutoDoc, BUSY and PSEL were reversed. 
The function has always been correct. 








9% —4@ 








ul 








parallel .device/PDCMD_SETPARAMS parallel .device/PDCMD_SETPARAMS 


NAME 
SetParams —- change parameters for the parallel device 


FUNCTION 
This command allows the caller.to change parameters for the 
parallel port device. It will disallow changes if any reads or 
writes are active or queued. The PARB_EOFMODE bit of io ParFlags 
controlls whether the io_PTermArray is to be used as an additional 
termination criteria for reads and writes. It may be set directly 
without a call to SetParams, setting it here performs the 
additional service of copying the PTermArray into the device 
default array which is used as the initial array for subsequent 
device opens. The Shared bit can be changed here, and overrides the 
current device access mode set at OpenDevice time. 


IO REQUEST 
io Message mn_ReplyPort initialized 
io_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
1o_Command PDCMD_SETPARAMS (OA) 

NOTE that the following fields of your IORequest 
are filled by Open to reflect the parallel device's 
current configuration. 

io_PExtFlags must be set to zero, unless used 
io_ParFlags see definition in parallel.i or parallel.h 

NOTE that x00 yields exclusive access, termarray 
inactive. 


io_PYermArray ASCII descending-ordered 8-byte array of 
termination characters. If less than 8 chars 
used, fill out array w/lowest valid value. 
Terminators are used only if EOFMODE bit of 
io Parflags is set. (e.g. x512F040303030303 ) 
This field is filled on OpenDevice only if the 
EOFMODE bit is set. 


RESULTS 
io Error —-— if the SetParams succeded, then io_Error will be null. 
If the SetParams failed, then io Error will be non-zero. 








4%’ -—-4 





TABLE OF CONTENTS 


printer. 
printer. 
printer. 
printer. 
printer. 
printer. 
printer. 
printer. 
printer. 
printer. 
printer. 


device/CMD_FLUSH 
device/CMD_INVALID 
device/CMD_RESET 
device/CMD_START 
device/CMD_STOP 
device/CMD_WRITE 
device/PRD_DUMPRPORT 
device/PRD_PRTCOMMAND 
device/PRD_QUERY 
device/PRD_RAWWRITE 
device/PWrite 











printer.device/CMD_FLUSH printer.device/CMD_FLUSH 


NAME 
CMD_FLUSH — abort all I/O requests (immediate) 
FUNCTION ; 
CMD_FLUSH aborts all stopped 1/0 at the unit. 
IO REQUEST . . . 
io Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io_Command CMD_FLUSH 
io Flags IOB_QUICK set if quick I/O is possible 








printer.device/CMD_INVALID printer.device/CMD_INVALID printer.device/CMD_RESET printer.device/CMD_RESET 


NAME NAME. 

CMD_INVALID — invalid command CMD RESET - reset the printer 

FUNCTION FUNCTION 
CMD_INVALID is always an invalid command, and sets the device CMD_RESET resets the printer device without destroying handles 
error appropriately. to the open device. 

IO REQUEST IO REQUEST ; 
io_Message mn_ReplyPort set if quick I/O is not possible io_ Message mn_ReplyPort set if quick I/O is not possible 
io_Command CMD_INVALID io_Device preset by the call to OpenDevice 
io Flags IOB_QUICK set if quick I/O is possible io_Command CMD_RESET 


io_Flags IOB_ QUICK set if quick I/O is possible 


8y- 4 











6b - 4d 











printer. device/CMD_START printer.device/CMD_START printer .device/CMD_STOP printer.device/CMD_STOP 
NAME . . NAME 
CMD_START - restart after stop (immediate) CMD_STOP — pause current and queued I/O requests (immediate) 
FUNCTION FUNCTION 
CMD_START restarts the unit after a stop command. CMD STOP pauses all queued requests for the unit, and tries to 
pause the current I/O request. The only commands that will 
10 REQUEST . . . . be subsequently allowed to be performed are immediate I/O 
io_Message mn_ReplyPort set if quick I/O is not possible requests, which include those to start, flush, and finish the 
io_Device preset by the call to OpenDevice I/o after the stop command. 
io_Command CMD_START 
io_ Flags IOB_QUICK set if quick I/O is possible IO REQUEST 
io Message mn_ReplyPort set if quick 1/0 is not possible 
io_Device preset by the call to OpenDevice 
io_Command CMD_STOP 
io_Flags IOB_QUICK set if quick I/o is possible 











os - 4 





printer .device/CMD_WRITE 


aRIS 
aRIN 
aIND 
aNEL 
aRI 


aSFC 
aSBC 


aSGRO 
aSGR3 
aSGR23 
aSGR4 
aSGR24 
aSGR1 
aSGR22 


aSHORPO 
aSHORP2 
aSHORP1 





printer .device/CMD_WRITE 


NAME 


CMD WRITE -- send output to the printer 


FUNCTION 


This function causes a buffer of characters to be written to the 

current printer port (usually parallel or serial). The number of 
characters is specified in io Length, unless -1 is used, in which 
case output is sent until a 0x00 is encountered. 


The Printer device, like the Console device, maps ANSI X3.64 style 
7-bit printer control codes to the control code set of the current 
printer. The ANSI codes supported can be found below. 


NOTES 


Not all printers will support all functions. In particular you may 
not assume that the MARGINS or TABS can be set. Close to half the 
supported printers don't fully implement one or the other. If you 
want the features of margins or tabs you will need to fake it 
internally by sending out spaces. 


Note that the printer device may have already sent out a “set 
margins" command to the printer. If you are faking your own 
margins, be sure to cancel the old ones first. (use the "aCAM" 
command ) 


Defaults are set up so that if a normal AmigaDOos text file 
is sent to PRT:, it has the greatest chance of working. 
(AmigaDOS text files are defined as follows: ) 


tabs — every 8 
CR (0x0D) — moves to start of current line 
LF (Ox0A) — moves to start of next line 
IO REQUEST 
io Message mn_ReplyPort set 
io_Device preset by OpenDevice 
io Unit preset by OpenDevice 
io_Command CMD_WRITE 
io_Length number of characters to process, or if —1l, 
process until 0x00 encountered 
io_Data pointer to block of data to process 
RESULTS : 
io Error : if CMD WRITE succeeded, then io_Error will be zero. 
Otherwise io Error will be non-zero. 
SEE ALSO 


printer.h, parallel.device, serial.device, Preferences 


ANSI X3.64 style COMMANDS 


ESCc hard reset 

ESC#1 initialize to defaults 
ESCD true linefeed (lf) 
ESCE return,if 

ESCM reverse lf * 
Esc {0m normal character set 
Esc [3m italics on 

ESC [23m italics off 

ESC [4m underline on 

ESC [24m underline off 

Esc [im boldface on 

ESC [22m boldface off 

SGR30-39 set foreground color 
SGR40—-49 set background color 
ESC [Ow normal pitch 

ESC [2w elite on 

ESC [lw elite off 


aSHORP4 
aSHORP 3 
aSHORP6 
aSHORP5 


aDEN6 
aDEN5 
aDEN4 
aDEN3 
aDEN2 
aDENL 


aSUS2 
asusl 
asuUs4 
aSUS3 
aSuso 
aPLU 

aPLD 


aFNTO 
aFNTL 
aFNT2 
aFNT3 
aFNT4 
aFNTS 
aFNT6 
aFNT7 
aFNT8 
aFNT9 
aFNTLO 





aPROP2 
aPROP1 
aPROPO 
aTSs 
aJFY5 
aJFY7 
aJFY6 
aJFYO 
aJFY3 
aJFYL 


aVERPO 
aVERP1L 
aSLPP 
aPERF 
aPERFO 


aLMS 
aRMS 
aTMS 
aBMS 
aSTBM 
aSLRM 
acaAM 


aHTS 
avTS 
aTBCO 
aTBC3 
aTBC1 
aTBC4 
aTBCALL 
aTBSALL 


aEXTEND 


aRAW 


ESC [4w 
ESC [3w 
ESC [6w 
ESC [5w 


ESC [6"z 
ESC[5"z 
ESC [4"2 
ESC[3"z 
ESC [2"z 
Esc(1"z 


ESC [2v 
ESC [iv 
ESC [4v 
ESC [3v 
ESC [Ov 
ESCL 

ESCK 


ESC(B 
ESC(R 
ESC(K 
ESC(A 
ESC(E 
ESC(H 
ESC(Y 
ESC(Z 
ESC(J 
ESC(6 
ESC(C 


ESC [2p 
ESC[lp 
ESC[Op 
ESC [n 
Esc{5 
ESC[7 
ESC [6 
ESC[O 
Esc [3 
ESC [1 


Ry ey ey oy A 


ESCc{0z 
Esc [1z 
ESC [nt 
ESC [ng 
ESC {0q 


ESC#9 
ESCHO 
ESC#8. 
ESC#2 
ESC[Pn1;Pn2r 
ESC[Pni;Pn2s 
ESC#3 


ESCH 
ESCI 
ESC [0g 
ESC [3g 
ESC [lg 
Esc [4g 
ESC#4 
ESC#5 


ESC [Pn"x 


ESC{Pn"r 





condensed on 
condensed off 
enlarged on 

enlarged off 


shadow print on 

shadow print off 
doublestrike on 

doublestrike off 

Near Letter Quality (NLQ) on 
NLQ off 


superscript on 
superscript off 
subscript on 
subscript off 


normalize the line * 

partial line up * 

partial line down * 

US char set (default) or Font 0 
French char set or Font 1 
German char set or Font 2 
UK char set or Font 3 
Danish I char set or Font 4 
Sweden char set or Font 5 
Italian char set or Font 6 
Spanish char set or Font 7 
Japanese char set or Font 8 
Norweign char set or Font 9 
Danish II char set or Font 10 


proportional on 
proportional off 
proportional clear 

set proportional offset 
auto left justify 

auto right justify 

auto full justify 

auto justify off 

letter space (justify) 
word fill(auto center) 


* Ht HH HO 


1/8" line spacing 

1/6" line spacing 

set form length n 

set perforation skip to n lines (n>0) 
perforation skip off 


Left margin set 
Right margin set 
Top margin set 
Bottom margin set 
set T&B margins 
set L&R margin 
Clear margins 


+ + tt 


Set horiz tab * 
Set vertical tabs * 
Clr horiz tab * 
Clear all h tab * 
Clr vertical tabs * 
Cir all v tabs * 
Clr all h & v tabs * 
Set default tabs (every 8) 

Extended commands 

This is a mechanism for printer drivers to 
support extra commands which can be called 
by ANSI control sequences 

Next 'Pn' chars are raw (ie. they are not 

parsed by the printer device, instead they 

















are sent directly to the printer. printer .device/PRD_DUMPRPORT printer .device/PRD_DUMPRPORT 


Is — 4d 








io_Message 
io_Command 
io Flags 
io RastPort 
io_ColorMap 
io_Modes 


io_Srex 
jo_SrcY 
io_SrcWidth 
io_SrcHeight 
io_DestCols 
io_DestRows 
io_Special 


NAME 
(*) indicates that sending this command may cause unexpected results PRD_DUMPRPORT - dump the specified RastPort to a graphics printer. 
on a large number of printers. 

FUNCTION 
Print a rendition of the supplied RastPort, using the supplied 
ColorMap, position and scaling information, as specified in 
the printer preferences. 

IO REQUEST 


mn_ReplyPort set if quick I/O is not possible. 
PRD_DUMPRPORT. 

IOB_QUICK set if quick I/O is possible. 

ptr to a RastPort. 
ptr to a ColorMap. 
the 'modes' flag from a ViewPort structure, 

(the upper word is reserved and should be zero). 

x offset into the RastPort to start printing from. 

y offset into the RastPort to start printing from. 

width of the RastPort to print (from io_SreX). 

height of the RastPort to print (from io_SrcY). 
width of the printout in printer pixels. 

height of the printout in printer pixels. 
flag bits 
(some of which pertain to DestCols and DestRows). 

-if SPECIAL MIL is set, then the associated 
parameter is specified in thousandths of 
an inch on the printer. ie. if DestCols = 8000, 
DestRows = 10500 and SPECIAL _MILROWS and 
SPECIAL MILCOLS is set then the printout would be 
8.000 x 10.500 inches. 

-if SPECIAL FULL is set, then the specific dimension 
is set to the maximum possible as determined 
by the printer limits or the configuration 
limits; whichever is less. 

-if SPECIAL FRAC is set, the parameter is 
taken to be a longword binary fraction 
of the maximum for that dimension. 

-if all bits for a dimension are clear, 

(ie. SPECIAL MIL/FULL/FRAC and ASPECT are NOT set) 
then the parameter is specified in printer pixels. 

-if SPECIAL CENTER is set then the image will be 
put between the left and right edge of the paper. 

-if SPECIAL ASPECT is set, one of the dimensions 
may be reduced/expanded to preserve the aspect 
ratio of the print. 

-SPECIAL_DENSITY(1-7) this allows for a maximum of 7 
different print densities. DENSITY] is the lowest 
density and the default. 

-SPECIAL NOFORMFEED — this allows for the mixing of 
text and graphics or multiple graphic dumps on page 
oriented printers (usually laser jet printers). 
When this flag is set the page will not be ejected 
after a graphic dump. If you perform another 
graphic dump without this flag set OR close the 
printer after printing text after a graphic dump, 
the page will be ejected. 

-if. SPECIAL TRUSIME is set then the printer specific 
driver is instructed to not issue a reset command 
before and after the dump. If this flag is NOT 
checked by the printer specific driver then setting 
this flag has no effect. Since we now recommend 
that printer driver writers no longer issue a reset 
command it is probably a safe idea to always set 
this flag when calling for a dump. 

-if SPECIAL NOPRINT is set then the following is done: 
Compute print size, set ‘io DestCols' and 
‘io DestRows' in the calling program's 'IODRPReq' 
structure and exit, DON'T PRINT. This allows the 
calling program to see what the final print size 
would be in printer pixels. Note that it modifies 














the 'io DestCols' and 'io_DestRows' fields of your 


'IODRPReq' structure. It also sets the print 
density and updates the 'MaxXDots', 'MaxYDots', 
'xDotsiInch'!, and 'YDotsInch' fields of the 
'PrinterExtendedData' structure. 


There following rules for the interpretation of io_DestRows and 
io _DestCols that may produce unexpected results when they are 
not greater than zero and io Special is zero. They have been 
retained for compatability. The user will not trigger these 
other rules with well formed usage of io Special. 


When io Special is equal to 0, the following rules 

(from the V1.1 printer.device, and retained for compatibility 
reasons) take effect. Remember, these special rules are 

for io_DestRows and io DestCols and only take effect 

if io Special is 0). 


a) DestCols>0 & DestRows>0 ~- use as absolute values. 
le. DestCols=320 & DestRows=200 means that the picture 
will appear on the printer as 320x200 dots. 

b) DestCols=0 & DestRows>0 - use the printers maximum number 
of columns and print DestRows lines. ie. if DestCols=0 
and DestRows=200 than the picture will appear on the 
printer as wide as it can be and 200 dots high. 


c) DestCols=0 & DestRows=0 ~ same as above except the driver 
determines the proper number of lines to print based on 
the aspect ratio of the printer. ie. This results in the 
largest picture possible that is not distorted or inverted. 
Note:. As of this writing, this is the call made by such 
program as DeluxePaint, GraphicCraft, and AegisImages. 

dad) DestCols>0 &DestRows=0 —- use the specified width and the 


driver determines the proper number of lines to print based 

on the aspect. ratio of the printer. ie. if you desire a 

picture that is 500 pixels wide and aspect ratio correct, 

use DestCols=500 and DestRows=0. 
e) DestCols<0 or DestRows>0 - the final picture is either a 
reduction or expansion based on the fraction 

|DestCols | / DestRows in the proper aspect ratio. 

Some examples: 

1) if Destcols=-2 & DestRows=1 then the printed picture will 
be 2x the AMIGA picture and in the proper aspect ratio. 
(2x is derived from |-2| / 1 which gives 2.0) 

2) if DestCols=-1 & DestRows=2 then the printed picture will 
will be 1/2x the AMIGA picture in the proper aspect ratio. 
(1/2x is derived from |-1| / 2 which gives 0.5) 


CG ~ @ 


NOTES 
The printer selected in preferences must have graphics 
capability to use this command. The error 'PDERR_NOTGRAPHICS' 
‘is returned if the printer can not print graphics. 


Color printers may not be able to print black and white or 
greyscale pictures -—- specifically, the Okimate 20 cannot print 
these with a color ribbon: you must use a black ribbon instead. 
If the printer has an input buffer option, use it. 

If the printer can be uni or bi directional, select 
uni-directional; this produces a much cleaner picture. 

Most printer drivers will attempt to set unidirectional 
printing if it is possible under software control. 





Please note that the width and height of the printable area on 
the printer is in terms of pixels and bounded by the folllowing: 
a) WIDTH = (RIGHT_MARGIN — LEFT MARGIN + 1) / CHARACTERS_PER_INCH 
b) HEIGHT = LENGTH / LINES PER INCH 

Margins are set by preferences. 


For BGR printer support, the YMC values in the printer 
specific render.c functions equate to BGR respectively, ie. 
yellow is blue, magenta is green, and cyan is red. 


Data Structures 





all 


The printer specific and non-specific data structures can be read 
ONCE you have opended the printer device. Here is a code fragment 
to illustrate how to do just that. 


#include <exec/types.h> 

#include <devices/printer .h> 
#tinclude <devices/prtbase.h> 
#include <devices/prtgfx.h> 


struct IODRPReq PReq; 
struct PrinterData *PD; 
struct PrinterExtendedData *PED; 


open the printer device / if it opended... 


if (OpenDevice("printer.device", 0, &PReq, 0) == NULL) { 
get pointer to printer data 
PD = (struct PrinterData *)PReq.io_Device; 


get pointer. to printer extended data 

PED = &PD->pd_SegmentData—>ps_ PED; 

let's see what's there 

printf("PrinterName = '%s', Version=%u, Revision=%u\n", 
PED->ped_PrinterName, PD->pd_SegmentData~>ps_Version, 
PD~>pd_ SegmentData~>ps Revision, ); 

printf("PrinterClass=%u, ColorClass—% u\n", 
PED->ped_PrinterClass, PED >ped_ | ColorClass) ; 

print£("MaxColumns=%u, NumCharSets=%u, NumRows=%u\n", 
PED->ped_MaxColumns, PED->ped_NumCharSets, PED~>ped_NumRows) ; 

printf ("MaxXDots=%lu, MaxYDots=%lu, XDotsInch=%u, YDotsInch=%u\n", 
PED->ped_MaxxDots, PED-—>ped MaxYDots, 
PED—>ped_XDotsInch, PED->ped_YDotsInch) ; 

CloseDevice( &PReq) ; 

J 


Preferences 


If you want the user to be able to access the printer preferences items 
without having to run preferences (like DPAINT II's printer requestor), 
here is what you do. You can look at the printer's copy of preferences 
by referring to 'PD->pd_Preferences' (the printer device MUST already be 
opened at this point). After you have this you could put up a requestor 
and allow the user to change whatever parameters they wanted. 

BEAR IN MIND THAT YOU ARE RESPONSIBLE FOR RANGE CHECKING THESE SELECTIONS! 
Listed below are the printer preferences items and their valid values. 


PrintPitch - PICA, ELITE,. FINE. 

PrintQuality ~ DRAFT, LETTER. 

PrintSpacing ~ SIX_LPI, EIGHT _LPI. 

PrintLeftMargin - 1 to PrintRightMargin. 
PrintRightMargin - PrintLeftMargin to 999. 

PaperLength ~ 1 to 999, 

PrintImage — IMAGE POSITIVE, IMAGE NEGATIVE. 
PrintAspect _ ASPECT ] HORIZ, ASPECT VERT. 

PrintShade - SHADE_ BW, SHADE. GREYSCALE, SHADE COLOR. 
PrintThreshold ~ ] to 15. 

PrintFlags — CORRECT RED, CORRECT_GREEN, CORRECT BLUE, CENTER _IMAGE, 


IGNORE DIMENSIONS, BOUNDED. ) DIMENSIONS, 
ABSOLUTE_DIMENSIONS, PIXEL_DIMENSIONS, 
MULTIPLY DIMENSIONS, INTEGER_SCALING, 
ORDERED_DITHERING, HALFTONE_ DITHERING. 
FLOYD_DITHERING, ANTI_ALIAS, GREY_SCALE2 


PrintMaxWidth — 0 to 65535. 
PrintMaxHeight — 0 to 65535. 
PrintDensity - lto 7. 
Printxoffset -~ 0 to 255. 


Asynchronous I/O 


The recommended way to do asynchronous i/o is... 








eg - 4 








a) To send requests for i/o. 


struct IO0Request *ioreq; 
struct MsgPort *port; 
UBYTE signal; 


port = ioreq->io_Message.mn_ReplyPort; 
signal = port->mp_SigBit; 


SendIO(ioreq); send request 

Wait(signal); wait for completion (go to sleep) 

while ((Msg = GetMsg({port)) != NULL) { get ALL messages 
} 


b) To abort a previous request for i/o. 
struct IORequest *ioreq; 


AbortIO(ioreq); abort request 
WaitIO(ioreq); wait for reply 


at this point you can re-use. ‘ioreq'. 


Note that in the above examples ‘ioreg' could be any one of... 
a) struct [ostdReq a standard i/o request 

b) struct IODRPReq a dumprport i/o request 

c) struct I0PrtCmdReq a printer command i/o request 


It is recommend that you do asynchronous i/o in. your programs 
and give the user a way of aborting all requests. 


V1.3 Printer Driver Notes 


In general densities which use more than one pass should only be 
used for B&W shade dumps. They can be used for Grey~Scale or Color Shade 
dunps BUT the output may tend to look muddy or dark. Also multiple pass 
Color dumps tend to dirty or smear the ribbon (ie. yellow will get 
contaminated with the other colors on the ribbon; you've been warned). 


Alphacom_AlphaPro_101 


1. Daisywheel printer (text only). 


Brother_HR-15XL 


1. Daisywheel printer (text only). 


CalComp_ColorMaster 

1. Thermal transfer baw/color printer (text and graphics). 

2.-Use Black ribbon for. non-color dumps; Color ribbon for color dumps. 

3. Linefeeds # of vertical dots printed. 

4. Densitie(s) supported are 203x200(1) dpi. 

5. This is a dual printer driver. Select a PaperSize of ‘Narrow Tractor' 
for use with the ColorMaster; 'Wide Tractor’ for use with the 
ColorView-5912 (which uses 11 x 17 inch paper). 


Calcomp_ColorMaster2 

1. Thermal transfer baw/color printer (text and graphics). 

2. Use Black ribbon for non-color dumps; Color ribbon for color dumps. 

3. Linefeeds # of vertical dots printed. 

4.. Densitie(s) supported are 203x200(1) dpi. 

5. This is a dual printer driver. Select a PaperSize of ‘Narrow Tractor' 
for use with the ColorMaster; ‘Wide Tractor' for use with the 
ColorView-5912 (which uses 11 x 17 inch paper). 

6. This driver is the same as the Calcomp_ColorMaster driver EXCEPT it is 
approximately 2 times faster (during color dumps) and requires LOTS of 
memory (up to 1,272,003 bytes for a full 8 x 10 inch (1600 x 2000 dot) 


color dump). Typically full~size (color) dumps are 1600 x 1149 dots and 
require 730,767 bytes. Memory requirements for the ColorView~5912 

are up to 2,572,803 bytes for a full 10 x 16 inch (2048 x 3200 dot) 
color dump. Typically full-size (color) dumps are 2048 x 2155 dots and 
require 1,732,623 bytes. The memory requirements are 1/3 when doing a 
non-color printout. (on both the ColorMaster and ColorView). 


Canon_PJ-1080A 

1. Ink jet baw/color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 

3. Densitie(s) supported are 83x84(1) dpi. 


CBM _MPS1000 


1. Dot matrix b&w printer (text and graphics). 
2. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single). *2 


3. Density XDPI YDPI XYDPI. Comments 
1 120 72 8640 
2 120 144 17280 two pass 
3 240 72 17280 *1 
4 120 216 25920 = three pass 
5 240 144 34560 two pass *1 
6 240 216 51840 three pass x1 
7 same as 6 

Diablo_630 


1. Daisywheel printer (text only). 


Diablo_Advantage_D25 


1. Daisywheel printer (text only). 
Diablo_C-150 


1. Ink. jet baw/color printer (text and graphics). 

2. Always linefeeds 4 dots (limitation of printer). 

3. A PaperSize of 'Wide Tractor' selects a maximum print width of 
8.5 inches (for wide roll paper). 

5. Densitie(s) supported are 120x120(1) dpi. 


EpsonQ (24-pin Epson compatible) 

1. Dot matrix b&w/color printer (text and graphics) . 

2. Drives all EpsonQ (LQ1500, LQ2500, etc.) compatible printers. 
3. Linefeeds # of vertical dots printed. 
4 


. Density XDPI YDPI XYDPI Comments 
1 90 180 16200 
2 120 180 21600 
3 180 180 32400 


4 360 180 64800 =¥*1 
5,6,7 same as 4 
5. A PaperSize of ‘Wide Tractor' selects a maximum print width of 
13.6 inches (for wide carriage printers). 
6. A PaperType of ‘Single’ uses only 16 of the 24 pins, whereas a Pape. 
of 'Fanfold' uses all 24 pins. The 'Single' option is useful for those 
printers which have a weak power supply and cannot drive all 24 pins 
continuously. If during a single pass of the print head you notice that 
the top two thirds of the graphics are darker than the bottom one third 
then you'll probably need to drop down to 16 pins. 


EpsonX [CBM _MPS-1250] (8/9-pin Epson compatible) 

1. Dot matrix b&w/color printer (text and graphics). 

2. Drives all EpsonX (EX/FX/JX/LX/MX/RX, etc.) compatible printers. 

3. Linefeeds # of vertical dots printed (-1/3 dot if PaperType = Single). *2 
4 


. Density XDPT YDPI XYDPI Comments 
1 120 72 8640 
2 120 144 17280 two pass 
3 240 72 17280 *1 
4 120 216 25920. three pass 








aS - a4 








5 240 144 34560 two pass *L 
6 240 216 51840 three pass *i 
7 same as 6 


5. A PaperSize of ‘Wide Tractor' selects a maximum print width of 
13.6 inches (for wide carriage printers) . 
6. Use this driver if you own a CBM_MPS~1250 (as it is EpsonX compatible). 


EpsonxOld (8/9-pin Epson compatible) 


1. Dot matrix baw printer (text and graphics). 


- Drives all very old EpsonX (EX/FX/JX/LX/MX/RX, etc.) compatible printers. 


2 
3. Linefeeds # of vertical dots printed. 
4 


. Density XDPI YDPI XYDPI Comments 
1 60 72 4320 « 
2 120 72 8640 (double speed) *1 
3 120 72 8640 
4 240 72 17280 x1 
5 120 72 8640 (for use on old Star printers) 
6 240 72 17280 (for use on old Star printers) *1 
7 240 72 17280 (same as density 4) «1 


5. A PaperSize of ‘Wide Tractor’ selects a maximum print width of 
13.6 inches (for wide carriage printers). 

6. Use this driver if the EpsonX driver doesn't work properly in graphics 
or text mode on your EpsonX compatible printer. 


generic 


1. Text only printer. 


Howtek_Pixelmaster 
1. Plastic ink jet baw/color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 


3. Density XDPI YDPI XYDPI Comments 
1 80 80 6400 
2 120 120 14400 
3 160 160 25600 


4 240 240 57600 
5,6,7 same as 4 
4. Maximum print area is 8.0 x 10.0 inches. 


HP_DeskJet. 


1. Ink jet non-color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 


3. Density XDPI YDPI XYDPI Comments 
1 75 75 5625 
2 100 100 10000 
3 150 150 22500 


4 300 300 90000 
5,6,7 same as 4 
4. Maximum print area is 8.0 x 10.0 inches. 


HP_LaserJet (LaserJet+/LaserJetII compatible) 
1. Laser engine non-color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 


3. Density XDPI YDPI XYDPI Comments 
1 75 75 5625 
2 100 100 10000 
3 150 150 22500 
4 300 300 90000 


5,6,7 same as 4 
4. Maximum print area is 8.0 x 10.0 inches. 


HP_PaintJet 

1. Ink jet b&w/color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 

3. Densitie(s) supported are 180x180(1) dpi. 








HP_ThinkJet 


1. Ink jet non-color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 


3. Density XDPT YDPI XYDPT Comments 
1 96 96 9216 
2 192 96 18432 
3,4,5,6,;7 same as 4 


Imagewriter II (Imagewriter compatible) 
1. Dot matrix béw/color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 


3. Density XDPT YDPT XYDPI Comments 
1 80 72 5760 
2 120 72 8640 
3 144 72 10368 
4 160 72 11520 
5 120 144 17280 two pass 
6 144 144 20736 two pass 
7 160 144 23040 two pass 


Nec_Pinwriter (24-wire Pinwriter compatible (P5/P6/P7/P9/P2200)) 
1. Dot matrix b&éw/color printer (text and graphics). 

2. Drives all Nec 24-wire Pinwriter. compatible printers. 

3 

4 





. Linefeeds # of vertical dots printed. 


. Density XDPI YDPI XYDPI Comments 
1 90 180 16200 
2 120 180 21600 
3 180 180 32400 
4 120 360 43200 two pass 
5 180 360 64800 two pass 
6 360 180 64800 
7 360 360 129600 two pass 


5. A PaperSize of ‘Wide Tractor' selects a maximum print width of 
13.6 inches (for wide carriage printers). 


Okidata_92 

1. Dot matrix non-color printer (text and graphics). 

2. Always linefeeds 7/72 inch (limitation of printer in graphics mode). 
3. Densitie(s) supported are 72x72 dpi. 


Okidata_293I 

1. Dot matrix béw/color printer (text and graphics). 

2. Drives 292 or 293 using the IBM interface module. _ 

3. Linefeeds # of vertical dots printed (-1/2 dot if PaperType = Single) *3 
4 


. Density XDPI YDPT XYDPTI Comments 
1 120 144 17280 
2 240 144 34560 
3 120 288 34560 two pass 
4 240 288 69120 two pass 


5,6,7 same as 4 
5. A PaperSize of 'Wide Tractor' selects a maximum print width of 
13.6 inches (for wide carriage printers). 


Okimate-20 

1. Thermal transfer bew/color printer (text and graphics). 

2. Use Black ribbon for non-color dumps; Color ribbon for color dumps. 
3. Linefeeds an even # of dots printed. (ie. if 3 printed, 4 advanced). 
4. Densitie(s) supported are 120x144(1) dpi. 


Quadram_QuadJet. 


1. Ink jet béw/color printer (text and graphics). 
2. Linefeeds # of vertical dots printed. 
3. Densitie(s) supported are 83x84(1) dpi. 


Qume_LetterPro 20 














1. Daisywheel printer (text only). 
Seiko_5300 


1. Thermal transfer b&w/color printer (graphics only). 
2. Use Black ribbon for non-color dumps; Color ribbon for color dumps. 


3. Density XDPI YDPT XYDPI Comments 
1 152 152 23104 drives CH-5301] printer 
2 203 203 41209 drives CH-5312 printer 
3 240 240 57600 drives CH-5303 printer 
4, 5,6,7 same as 3 


You must select the proper density to drive the specific printer 
that you have. 
4. This driver is not on the V1.3 Workbench or Extras disk. It is 
available on BIX and directly from Seiko. 


Seiko_5300a 


1. Thermal transfer baw/color printer (graphics only). 
2. Use Black ribbon for non-color dumps; Color ribbon for color dumps. 


3. Density XDPI YDPI XYDPI Comments 
1 152 152 23104 drives CH-5301 printer 
2 203 203 41209 drives CH-5312 printer 
3 240 240 57600 drives CH-5303 printer 
4, 5,6,7 same as 3 


You must select the proper density to drive the specific printer 
that you have. 

4. This driver is the same as the Seiko_5300 driver EXCEPT it is 
approximately 2 times faster (during color dumps) and requires LOTS of 
memory (up to 1,564,569 bytes for a full 8 x 10 inch (1927 x 2173 dot) 
color dump). Typically full-size (color) dumps are 1927 x 1248 dots 
and require 898,569 bytes. The memory requirements are 1/3 when doing 
a non-color printout. 

5. This driver is not on the V1.3 Workbench or Extras disk. It is 
available on BIX and directly from Seiko. 


Tektronix_4693D 

1. Thermal transfer baw/color printer (graphics only). 

2. Densitie(s) supported are 300x300(1) dpi 

3. Due to the way the printer images a picture none of the printer 
preferences options affect the printout with the following exceptions: 
a)Aspect — Horizontal, Vertical 
b)Shade - BaW, Grey_Scale, Color 
...as a result of this only full size pictures can be printed. 

4. Keypad menu option 3b COLOR ADJUSTMENT may be set from the keypad. 
For normal prints this option should be set to "do not adjust". 


5. Keypad menu option 3d VIDEO COLOR CORRECTION may be set from the keypad. 


For normal prints this option should be set to "do not adjust". 

6. Keypad menu option 5 BACKGROUND COLOR EXCHANGE may be set from the 
keypad. For normal prints this option should be set to “print colors 
as recieved". 

7. Once a picture has been printed additional copies may be printed 
whithout resending by using the printers keypad. 

8. This driver is not on the V1.3 Workbench or Extras disk. it is 
available on BIX and directly from Tektronix. 


Tektronix_4696 

1. Ink jet bsaw/color printer (text and graphics). 

2. Always linefeeds 4 dots (limitation of printer). 

3. Densities supported are 121x120(1), 242x120(black)(2) and 
242x120(color) (3). 
Selecting a density of 2 or higher really doesn't give you true 242 dpi 
resolution since the printer only has 121 x dots per inch. 
Instead this mode tells the printer to go into it's double pass mode. 
Here, it outputs a line of dots at 121 dpi; and outputs the line again 
(shifted to the right by 1/242 of an inch). This produces much more 
vibrate colors and gives the illusion of more resolution. One drawback 
is that large areas of solid colors (red, green, and blue specifically) 
tend to over-saturate the paper with ink. Densityl outputs all colors 








in one pass. Density 2 does a double pass on black. Density 3 does a 
double pass on all colors. Density 1 to 3 correspond to the printer's 
graphics printing modes 1 to 3 (respectively). 

4. This driver is not on the V1.3 Workbench or Extras disk. It is 
available on BIX and directly from. Tektronix. 

5. A PaperSize of 'Wide Tractor' selects a maximum print width of 
9.0 inches (for wide roll paper). 


Toshiba_P351C (24-pin Toshiba compatible) 





1. Dot matrix baw/color printer (text and graphics). 
2. Drives all Toshiba_P351C compatible printers. 
3. Linefeeds # of vertical dots printed. 
4. Density XDPI YDPI XYDPI Comments 
1 180 180 32400 
2 360 180 64800 
3,4,5,6,7 same as 2 


5. A PaperSize of 'Wide Tractor' selects a maximum print width of 
13.5 inches (for wide carriage printers). 


Toshiba _P351SX (24-pin Toshiba compatible) 

1. Dot matrix baw/color printer (text and graphics). 

2. Drives all Toshiba_P351SX (321SL, 321SLC, 341SL) compatible printers. 
3. Linefeeds # of vertical dots printed. 

4 


. Density XDPI YDPI XYDPI Comments 
1 180 180 32400 
2 360 180 64800 
3 180 360 64800 two pass 


4 360 360 
5,6,7 same as 4 
5. A PaperSize of 'Wide Tractor' selects. a maximum print width of 
13.5 inches (for wide carriage printers). 


129600 two pass 


Xerox_4020 

1. Ink jet b&éw/color printer (text and graphics). 

2. Always linefeeds 4 dots (limitation of printer). 

3. This driver is IDENTICAL to the Diablo_C-150 driver EXCEPT it outputs 
all black dots TWICE. This is a special feature of this printer and 
produces much more solid, darker black shades. Please note that some 
printing time overhead results from this feature; if you don't want it 
use the Diablo_C-150 driver. 

4. Densities supported are 121x120({1) and 242x240(2) dpi. 

Selecting a density of 2 or higher really doesn't give you true 240 dpi 
resolution since the Xerox_4020. only has 121 x dots per inch. 

Instead this mode tells the printer to go into it's pseudo 240 dpi mode. 
Here, it outputs a line of dots at 121 dpi; moves the paper up 1/240 of 
an inch and outputs the line again (shifted to the right by 1/240 of an 
inch). This produces much more vibrate colors and gives the illusion 

of more resolution. One drawback is that large areas of solid colors 
(red, green, and blue specifically) tend to over-saturate the paper with 
ink. 

5. A PaperSize of 'Wide Tractor' selects a maximum print width of 
9.0 inches (for wide roll paper). 


*0 — on most printers friction fed paper tends to produce better looking 
(ie. less horizontal banding) graphic dumps than tractor fed paper. 





x] ~— in this mode the printer cannot print two consecutive dots in a row. 
It is recommended that you only use this density for B&W Shade dumps. 


*2 - only when 72 YDPI is selected. This option is useful if you notice 
tiny white horizontal strips in your printout. 


*3 - only when 144 YDPI is selected. This option is useful if you notice 
tiny white horizontal strips in your printout. 











9S -4@ 





printer.device/PRD_PRTCOMMAND 


NAME 
PCPRD_PRTCOMMAND —- send a command to the printer 


FUNCTION 
This function sends a command to either the parallel or serial 
device. The printer device maps this command to the control 
code set of the current printer. The commands supported can 
be found. with the printer.device/Write command. All printers 
may not support all functions. 


IO REQUEST IoPrtCmdReq 
io_Message mn_ReplyPort set 
io_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command PRD_PRTCOMMAND 
io_PrtCommand the actual command number 


io_Parm0 parameter for the command 

jio_Parml parameter for the command 

io_Parm2 parameter for the command 

io_Parm3 parameter for the command 
RESULTS 


Errors: if the PRD_PRTCOMMAND succeeded, then io_Error will be zero. 
Otherwise io_Error will be non-zero. An error of —] indicates that 
the command is not supported by the current printer driver. This 
could be used to check if the connected printer supports a particular 
command (italics for example). 


SEE ALSO 
printer.device/write printer.h, parallel.device, Preferences 


printer. device/PRD_PRTCOMMAND printer.device/PRD_QUERY 












printer.device/PRD_QUERY 


NAME 
PRD_QUERY ~ query printer port/line status 
FUNCTION 
This command returns the status of the printer port's lines and 
registers. Since the printer port uses either the serial or 
parallel port for i/o, the actual status returned is either the 
serial or parallel port's status. 
IO REQUEST 
jio_Message mn_ReplyPort set if quick I/O is not possible 
io_Device preset by the call to OpenDevice 
io_Command PRD_QUERY 
io_Data ptr to 2 UBYTES where result will be stored. 
RESULTS 
io_Data BIT ACTIVE FUNCTION (SERIAL DEVICE) 
LSB 0 low reserved 
1 low reserved 
2 low reserved 
3 low Data Set Ready 
4 low Clear To Send 
5 low Carrier Detect 
6 low Ready To Send 
7 low Data Terminal Ready 
MSB 8 high read buffer overflow 
9 high break sent (most recent output) 
10 high break received (as latest input) 
it high transmit x-OFFed 
12 high receive x~-OFFed 
13-15 / reserved 
io Data BIT ACTIVE FUNCTION (PARALLEL DEVICE) 
0 hi printer busy (offline) 
1 hi paper out 
2 hi printer selected 
(WARNING: the bit 2 line is also connected 
to the serial port's ring indicator pin 
on the A500 and A2000) 
3-7 reserved 
io_Actual li-parallel, 2-serial 








iS ~ @ 





printer .device/PRD_RAWWRITE printer.device/PRD_RAWWRITE 


NAME 


PRD_RAWWRITE —- transparent write. command 


FUNCTION 


This is a non standard write command that performs no 
processing on the data passed to it. 


IO REQUEST 
io_Message 
io Command 
io_Flags 
io_Length 
io_Data 


mn_ReplyPort set if quick I/O is not possible 
PRD_RAWWRITE 

IOB_QUICK set if quick I/O is possible 

the number of bytes in io_Data 

the raw bytes to write to the printer 


printer.device/PWrite ‘ printer.device/Pwrite 
NAME 
pwWrite - internal write to printer port 
SYNOPSIS 
error = (*PrinterData~>pd_PWrite) (buffer, length); 
bo AO DO 
FUNCTION 


PWrite writes 'length' bytes directly to the printer. This 
function is generally called by printer drivers to send 
their buffer(s) to the printer. 


This function is accessed by referencing off the PrinterData (PD) 
structure. Below is a code fragment to show how to do get access 
to a pointer to the PrinterData (PD) structure. 


ftinclude <exec/types .h> 
#include <devices/printer .h> 
#include <devices/prtbase .h> 


struct IODRPReq PReq; 
struct PrinterData *PD; 
struct PrinterExtendedData. *PED; 


/* open the printer device (any version); if it opened... */ 
if (OpenDevice("printer.device", 0, &PReq, 0) == NULL) [{ 


/* get pointer to printer data strcuture */ 
PD = (struct PrinterData *)PReq.io_Device; 


/* write something directly to the printer */ 
(*PD->pd_PWrite) ("Hello world\n", 12); 


CloseDevice(&PReq); /* close the printer device */ 


8s -~ 4 


TABLE OF CONTENTS 


serial. 
serial. 
serial. 
serial. 
serial. 
serial. 
.device/CMD_READ 
.device/CMD_RESET 
.device/CMD_START 
-device/CMD_STOP 
.device/CMD_ WRITE 
.device/OpenDevice 
.device/SDCMD_QUERY 
.device/SDCMD_SETPARAMS 


device/AbortIo 
device/BeginIo 
device/CloseDevice 
device/CMD_BREAK 
device/CMD_CLEAR 
device/CMD_FLUSH 





serial .device/AbortIO serial .device/AbortIO 


NAME 
AbortIO(ioRequest) —- abort an I/O request 
Al 


FUNCTION 
This is an exec.library call. 


This function attempts to aborts a specified read or write request. 

If the request is active, it is stopped immediately. If the request is 
queued , it is painlessly removed. The request will be returned 

in the same way any completed request. it. 


After AbortIO(), you must generally do a WaitIO(). 


INPUTS 
iORequest -- pointer to the IORequest Block that is to be aborted. 


RESULTS 
jio_Frror —- if the Abort succeded, then io_Error will be #IOERR_ABORTED 


(-2) and the request will be flagged as aborted (bit 5 of 
io_Flags is set). If the Abort failed, then the Error will be zero. 
BUGS 
Previous to version 34, the serial.device would often hang when 
aborting CTS/RTS handshake requests. This was the cause of the 
incorrect assumption that AbortIO() does not need to be followed 
by a wait for a reply (or a WaitIO()). 





serial .device/BeginIO 


6s - @ 


serial.device/BeginIo 


NAME 
BeginIO(ioRequest) ,deviceNode — start up an I/O process 
Al A6 


FUNCTION 
This is a direct function call to the device. It is intended for 
more advanced programmers. See exec's DoIO() and SendIo() for 
the normal method of calling devices. 


This function initiates a I/O request made to the serial 
device. Other than read or write, the functions are performed 
synchronously, and do not depend on any interrupt handling 
logic (or it's associated discontinuities), and hence should 
be performed as IO_QUICK. 
With some exceptions, reads and writes are merely initiated by 
BeginIO, and thusly return to the caller as begun, not completed. 
Completion is signalled via the standard ReplyMsg routine. 
Multiple requests are handled via FIFO queueing. 
One exception to this non-QUICK handling of reads and writes 
is for READS when: 

~ IO QUICK bit is set 

— There are no pending read requests 

— There is already enough data in the input buffer to satisfy 

this I/O Request immediately. 

In this case, the IO QUICK flag is not cleared, and the request 
is completed by the time it returns to the caller. There is no 
ReplyMsg or signal bit activity in this case. 


INPUTS 
joRequest -~ pointer to an I/O Request Block of size 
io ExtSerSize (see serial.i for size/definition), 
containing a valid command in io_Command to process, 
as well as the command's other required parameters. 
deviceNode — pointer to the "serial.device", as found in 
the IO DEVICE of the ioRequest. 


RESULTS 
io Error ~— if the BeginIO succeded, then Error will be null. 
If the BeginIO failed, then the Error will be non-zero. 
I/O errors won't be reported until the io completes. 


SEE ALSO 
devices/serial.h 





serial .device/CloseDevice 








serial .device/CloseDevice 


NAME 
CloseDevice -- close the serial port 


SYNOPSIS 
CloseDevice(deviceNode) 
Al 


FUNCTION . . . 
This is an exec call that terminates communication with the 


serial device. Upon closing, the device's input buffer is freed. 


Note that all I0Requests MUST be complete before closing. 
If any are pending, your program must AbortI0() then WaitIO() 
to complete them. 


INPUTS . 
deviceNode ~ pointer to the device node, set by Open 


SEE ALSO 
serial .device/OpenDevice 


o9 -4 


serial .device/CMD_BREAK serial.device/CMD_BREAK serial .device/CMD_CLEAR serial .device/CMD_CLEAR 


NAME NAME . 
Break ~- send a break signal over the serial line Clear -~ clear the serial port buffers 


FUNCTION FUNCTION . . 
This command sends a break signal (serial line held low This command resets the serial port's read buffer pointers. 
for an extended period) out the serial port. This is accom— 
plished by setting the UARTBRK bit of reg ADKCON. After a IO REQUEST og 
duration (user specifiable via setparams, default 250000 io_Message mn_ReplyPort initialized 
microseconds) the bit is reset and the signal discontinued. io_Device set by OpenDevice 
If the QUEUEDBRK bit of io SerFlags is set in the io Request . io_Unit set by OpenDevice 
block, the request is placed at the back of the write-request. io_Command CMD_CLEAR 
queue and executed in turn. If the QUEUEDBRK bit is not set, 
the break is started immediately, control returns to the RESULTS . . 
caller, and the timer discontinues the signal after the Error —— If the Clear succeded, then io Error will be null. 
duration is completed. Be aware that calling BREAK may If the Clear failed, then the io_Error will be non-zero. 
affect other commands such as ABORT, FLUSH, STOP, START, etc... 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command SDCMD_BREAK 
lo_Flags set/reset IO_QUICK per above description 


RESULTS 
Error —- if the Break succeded, then Error will be null. 
If the Break failed, then the Error will be non-zero. 





serial .device/CMD_FLUSH serial .device/CMD_FLUSH serial .device/CMD_READ serial .device/CMD_READ 

NAME NAME 
Flush -- clear all queued I/O requests for the serial port Read -- read input from serial port 

FUNCTION 
This command causes a stream of characters to be read in from 
the serial port buffer. The number of characters is specified 


in io_Length. 


FUNCTION 
This command purges the read and write request queues for the 
serial device. Flush will not affect active requests. 


io_Command CMD_FLUSH 


IO REQUEST 
io_ Message mn_ReplyPort initialized The Query function can be used to check how many characters 
io_Device set by OpenDevice are currently waiting in the serial port buffer. If more characters 
io_Unit set by OpenDevice are requested than are currently available, the ioRequest 


will be queued until it can be satisfied. 


19 -@ 


RESULTS 
Error —- if the Flush succeded, then io_Error will be null. 
If the Flush failed, then the io Error will be non-zero. 


The best way to handle reads is to first Query to get the number 
of characters currently in the buffer. Then post a read request 
for that number of characters (or the maximum size of your buffer). 


If zero characters are in the buffer, post a request 
for 1 character. When at least one is ready, the device will return 
it. Now start over with another Query. 


Before the program exits, it must be sure to AbortIO() then waitI0() 
any outstanding ioRequests. 


IO REQUEST 
io_ Message A mn_ReplyPort is required 
io_Device set by OpenDevice 
io Unit set by OpenDevice 
io_Command CMD_READ 
io_Flags If the IOB QUICK bit is set, read will try 
to complete the IO quickly 
io_Length number of characters to receive. 
io_Data pointer to buffer 
RESULTS 
Error -~ if the Read succeded, then io_Error will be null. 


If the Read failed, then io_Error will be non-zero. 
io Error will indicate problems such as parity mismatch, 
break, and buffer overrun. 


SEE ALSO 
serial .device/CMD_QUERY 
serial .device/SDCMD_SETPARAMS 


BUGS 
Having multiple outstanding read IORequests at any one time will 
probably fail. 





Old documentation mentioned a mode where io Length was set to ~l. 
If you want a NULL terminated read, use the io_TermArray instead. 





c9 - @ 


serial .device/CMD_RESET serial .device/CMD_RESET 





NAME 
Reset —- reinitializes the serial port 


FUNCTION 


This command resets the serial port to its freshly initialized 
condition. It aborts all 1/0 requests both queued and current, 
relinquishes the current buffer, obtains a new default sized 
buffer, and sets the port's flags and parameters to their 
boot-up time default values. The functions places the reset 
parameter values in the ioRequest block. 


IO REQUEST 
io_Message mn_ReplyPort. initialized 
1lo_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_RESET 

RESULTS 


Error — if the Reset. succeded, then Error will be null. 
If the Reset failed, then the Error will be non-zero. 








serial .device/CMD_START 





serial .device/CMD_START 


NAME 
Start -- restart paused I/O over the serial port 


FUNCTION 
This function restarts all current I/O on the serial port by 
sending an xON to the "other side", and submitting a "logical 
xON" to "our side", if/when appropriate to current activity. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_START 

RESULTS 

SEE ALSO 


serial.device/CMD_STOP 











€9 —-@ 


serial .device/CMD_STOP 





serial .device/CMD_STOP 


NAME 
Stop — pause all current I/O over the serial port 


FUNCTION 
This command halts all current I/O on the serial port by 
sending an xOFF to the “other side", and submitting a "logical 
xOFF" to “our side", if/when appropriate to current activity. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_STOP 

RESULTS 

SEE ALSO 


serial .device/CMD_START 


serial .device/CMD_WRITE 





serial .device/CMD_WRITE 


NAME 
Write —- send output to serial port 


FUNCTION 
This command causes a stream of characters to be written out 
the serial port. The number of characters is specified in 
io Length, unless ~1 is used, in which case output is sent until 
a null(0x00) is encountered. 


IO REQUEST 
io Message must have mn_ReplyPort initialized 
io_Device set by OpenDevice 
io_Unit set by OpenDevice 
io_Command CMD_WRITE 
io Flags Set IOF_QUICK to try quick I/O 
io_Length number of characters to transmit, or if set 
to -l transmit until nuil encountered in buffer 
io_Data pointer to block of data to transmit 
RESULTS 
Error -- if the Write succeded, then io_Error will be null. 


If the Write failed, then the io_Error will be non-zero. 


SEE ALSO 
serial .device/SDCMD_SETPARAMS 


wy 
| 

a 

> 





serial .device/OpenDevice serial .device/OpenDevice 


NAME 

OpenDevice -~ Request an opening of the serial device. 
SYNOPSIS 

error = OpenDevice(SERIALNAME, unit, ioRequest, flags) 

DO AO DO Al DO 
FUNCTION 


This is an exec call. Exec will search for the serial.device, and 
if found, will pass this call on to the device. 


Unless the shared-access bit (bit 5 of io_SerFlags) is set, 
exclusive use is granted and no other access to that unit is 
allowed until the owner closes it. All the serial-specific fields 
in the ioRequest are initialized to their most recent values (or 
the Preferences default, for the first time open). 


If support of 7-wire handshaking (i.e. RS232-C CTS/RTS protocol) 
is required, set the 7WIRE bit in io _SerFlags before opening 
the serial device. 


INPUTS 
SERIALNAME - pointer to literal string “serial.device" 
unit ~ Must be zero, or a user setable unit number. 
(This field is. used by multiple port controllers) 
zero specifies the built-in serial port. 
ioRequest ~ pointer to an ioRequest block of.size io_ExtSerSize 
to be initialized by the serial.device. 
(see devices/serial.h for the definition) 
NOTE use of io SerFlags (see FUNCTION above) 
IMPORTANT: The ioRequest block MUST be of size io_ExtSerSize ! 
flags — Must be zero for future compatibility 
RESULTS 
DO - same as io_Error 
jo_Error - If the Open succeded, then io Error will be null. 


If the Open failed, then io Error will be non-zero. 
io_Device - A pointer to whatever device will handle the calls 
for this unit. This pointer may be different depending 
on what unit is requested. 


BUGS 
If 7-wire handshaking is specified, this enables a timeout “feature”. 
If the device holds off the computer for more than about 30-60 
seconds, the device will return the write request with the error 
SerErr_TimerErr. Don't depend on this, however. If you want a timeout, 
set up the timer.device and wait for either timer, or serial IO to 
complete. 


On open, the serial.device allocates the misc.resource for the 

serial port. It does not return it until the serial.device is 

expunged from memory. It should return it when no more openers 
exist. 


SEE ALSO 
serial .device/CloseDevice 
devices/serial.h 





serial .device/SDCMD_QUERY serial .device/SDCMD_QUERY 
NAME 
Query —- query serial port/line status 


FUNCTION : 
This command return the status of the serial port lines and 
registers. The number of unread bytes in the serial device's 
read buffer is shown in io Actual. 


The break send & received flags are cleared by a query, and- 
whenever a read [ORequest. is returned with a error 
in io_Error. 


IO REQUEST 
io_Message mn_ReplyPort initialized 
1to_Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io Command SDCMD_QUERY 
RESULTS 
io Status BIT ACTIVE FUNCTION 
LSB 0 — reserved 
1 —— reserved 
2 high | parallel "sel" on. the A1000 
On the A500 & A2000, "sel" is also 
connected to the serial port's 
“Ring Indicator". Be cautious when 
making cables. 
3 low Data Set Ready 
4 low Clear To Send 
5 low Carrier Detect 
6 low Ready To Send 
7 low Data Terminal Ready 
MSB 8 high hardware overrun 
9 high break sent (most recent output) 
10 high break received (as latest input) 
il high transmit x-OFFed 
12 high receive x-OFFed 
13-15 _— reserved 
io_Actual set to count of unread input characters 
io_Error -~- Query will always succeded. 


s9 -@ 


serial .device/SDCMD_SETPARAMS serial .device/SDCMD_SETPARAMS Terminators are checked only if EOFMODE bit of 
~ io Serflags is set. (e.g. x512F040303030303 ) 


NAME io_ReadLen number of bits in read word (1-8) not including parity 
SetParams —- change parameters for the serial port io_WriteLen number of bits in write word (1-8) " " " 
io_StopBits number of stop bits (0, 1 or 2) 
FUNCTION . io_SerFlags see devices/serial.h for bit equates, NOTE that x00 
This command allows the caller to change parameters for the yields exclusive access, xON/OFF-enabled, no 
serial device. Except for xON-xOFF enable/disable, it will parity checking, 3-wire protocol and TermArray 
reject a setparams call if any reads or writes are active inactive. 
or pending. 
Note specifically: RESULTS . 
Error —-~- if the SetParams succeded, then Error will be null. 
1. Valid input for io Baud is between 112 and 292000 baud inclusive; If the SetParams failed, then the Error will be non-zero. 
asynchronous i/o above 32KB (especially on a busy system) may 
be ambitious. SEE ALSO . 
2. The EOFMODE and QUEUEDBRK bits of io_SerFlags can be set/reset exec/OpenDevice 


in the io_Rqst block without a call to SetParams. The SHARED 
and 7WIRE bits of io SerFlags can be used in OpenDevice calls. 
ALL OTHER PARAMETERS CAN ONLY BE CHANGED BY THE SetParams 
COMMAND . 

. RBufLen must be at least 64. 

. If not used, io_ExtFlags MUST be set to zero. 

. XON-XOFF is by default enabled. The XDISABLED bit is the only 
parameter that can be changed via a SetParams call while the 
device is active. Note that this will return the value 
SerErr DevBusy in the io Error field. 


Ul Ww 


XON/xXOFF handshaking is inappropriate for certain binary transfer 
protocalls, such as Xmodem. The.binary data might contain the 
XON (ASCII 17) and xOFF (ASCII 19) characters. 


6. If trying to run MIDI, you should set the RAD_BOOGIE bit of 
io SerFlags to eliminate unneeded overhead. Specifically, this skips 
checks for parity, x-OFF handling, character lengths other than 
8 bits, and testing for a break signal. Setting RAD_BOOGIE will 
also set the XDISABLED bit. 
Note that writing data (that's already in MIDI format) at MIDI rates 
is easily accomplished. Using this driver alone for MIDI reads may, 
however, may not be reliable, due to MIDI timestamping requirements, 
and possibility of overruns in a busy multitasking and/or display 
intensive. environment. 
7. If you select mark or space parity (see io_ExtFlags in serial.h), 
this will cause the SERB PARTY_ON bit to be set, and the setting 
of SERB_PARTY_ODD to. be ignored. 
8. For best results, set the RAD_BOOGIE flag whenever possible. See 
#6 for details. 
9. Note that at this time parity is *not* calculated for the xON-xXOFF 
characters. If you have a system that is picky about the parity of 
these, you must set your own xON-xOFF characters in io_CtlChar. 


IO REQUEST 
io Message mn_ReplyPort initialized 
io Device preset by OpenDevice 
io_Unit preset by OpenDevice 
io_Command SDCMD_SETPARAMS (Ox0B) 


NOTE that. the following fields are filled in by Open 
to reflect the serial device's current configuration. 
io_CtlChar a longword containing byte values for the 
XON,XOFF,INQ,ACK fields (respectively) 
(INQ/ACK not used at this time) 
io_RBufen length in bytes of input buffer 
NOTE that any change in buffer size causes the 
current buffer to be deallocated and a new, 
correctly sized one to be allocated. Thusly, 
the CONTENTS OF THE OLD BUFFER ARE LOST. 


jio_ExtFlags additional serial flags (bitdefs in devices/serial.h) 
mark & space parity may be specified here. 

io_Baud baud rate for reads AND writes. (See | above) 

io_BrkTime duration of break signal in MICROseconds 


io _TermArray ASCII descending-ordered 8-byte array of 
termination characters. If less than 8 chars 
used, fill out array w/lowest valid value. 











99 -@ 





TABLE OF CONTENTS 


timer .device/-—background-- 
timer. device/AddTime 
timer .device/CmpTime 
timer .device/SubTime 
timer .device/TR_ADDREQUEST 
timer.device/TR_GETSYSTIME 
timer.device/TR_SETSYSTIME 


timer .device/—-background—— timer .device/——background-— 


TIMER REQUEST 
A time request is a non standard IO Request. It has an IORequest 
followed by a timeval structure. 


TIMEVAL 
A timeval structure consists of. two longwords. The first is 
the number of seconds, the latter is the fractional number 
of microseconds. The microseconds must always be "normalized" 
e.g. the longword must be between 0 and one million. 


UNITS 
The timer contains two units —- one that is precise but 
inaccurate, the other that has little system overhead, 
is very stable over time, but only has limitied resolution. 


UNIT_MICROHZ 
This unit uses a programmable timer in the 8520 to keep 
track of its time. It has precision down to about 2 
microseconds, but will drift as system load increases. 
The timer is typically accurate to within five percent. 


UNIT_VBLANK 
This unit is driven by the vertical blank interrupt. It 
is very stable over time, but only has a resolution of 
16667 microseconds (or 20000 microseconds in PAL land). 
The timer is very cheap to use, and should be used by 
those who are waiting for long periods of time (typically 
1/2 second or more). 


LIBRARY 
In addition to the normal device calls, the timer also supports 
three direct, library like calls. They are for manipulating 
timeval structures. Addition, subtraction, and comparison 
are supported. 


In the V1.2/V1.3 release, the timer device has problems with 
very short time requests. When one of these is made, other 
timer requests may be finished inaccurately. A side effect 
is that AmigaDOS requests such as "Delay(0);" or 
"WaitForChar(x,0);" are unreliable. 





49-4 














(timer. device/AddTime timer.device/AddTime 
NAME 
AddTime —- add one time request to another 
SYNOPSIS 
AddTime( Dest, Source ), timer.device 


AO AL a6 
void AddTime(struct *timeval, struct *timeval); 
FUNCTION 
This routine adds one timeval structure to another. The 
results are stored in the destination (Dest + Source —> Dest) 
AO and Al will be left unchanged 


INPUTS 
Dest, Source -~ pointers to timeval structures. 


EXCEPTIONS 
SEE ALSO 


BUGS 


timer .device/CmpTime 





NAME 
CmpTime —- Compare two timeval structures 
SYNOPSIS 
result = CmpTime( Dest, Source ), timer.device 
DO AO Al A6 


BYTE CmpTime(struct *timeval, struct *timeval); 


FUNCTION 
This routine compares two timeval structures. 


AO and Al will be left unchanged 


INPUTS 
Dest, Source —~ pointers to timeval structures. 
RESULTS 
result = -1 if Dest has more time than Source 
result = 0 if Dest has the same time as Source 
result = 41 if Dest has less time than Source 
EXCEPTIONS 
SEE ALSO 
BUGS 


Former versions of this AutoDoc had the sense of the result wrong. 








timer .device/CmpTime 








timer .device/SubTime timer. device/SubTime timer .device/TR_ADDREQUEST timer .device/TR_ADDREQUEST 


NAME NAME 
SubTime - subtract one time request from another TR_ADDREQUEST —- submit a request to time time 








SYNOPSIS FUNCTION 
SubTime( Dest, Source ), timer.device Ask the timer to count off a specified amount of time. The timer will 
AO Al A6 chain this request with its other requests, and will reply the message 
back to the user when the timer counts down to zero. 
void SubTime(struct *timeval, struct *timeval); 
The message may be forced to finish early with an AbortIO()/WaitIo() 
FUNCTION pair. 
This routine subtracts one timeval structure from another. The , 
results are stored in the destination (Dest ~ Source -> Dest) TIMER REQUEST 
io Message mn_ReplyPort initialized 
AO and Al will be left unchanged io_Device preset by timer in OpenDevice 
io_Unit preset by timer in OpenDevice 
INPUTS io_Command TR_ADDREQUEST 
Dest, Source —- pointers to timeval structures. io_Flags IOF_QUICK allowable 
tr_time a timeval structure specifiy how long until 
EXCEPTIONS the driver will reply 
SEE ALSO RESULTS 
tr_time will contain junk 
BUGS 
SEE ALSO 
exec/AbortIoO 
exec/WaitIO 


89 -4@ 








69 —-@ 








timer. device/TR_GETSYSTIME 





timer .device/TR_GETSYSTIME 


NAME 
TR_GETSYSTIME —- get the system time 


FUNCTION 
Ask the timer what time it is. The system time starts 
off at zero at power on, but may be initialized via 
the TR_SETSYSTIME call. 


System time is monotonically increasing, and guaranteed 
to be unique (except of someone sets the time backwards) . 
The time is incremented every vertical blank by the 
vertical blanking interval; in addition it is changed 
every time someone asks what time it is. This way 

the return value of the system time is unique 

and unrepeating. 


TIMER REQUEST 


io Message mn_ReplyPort initialized 


io_Device preset by timer in OpenDevice 
io_Unit preset by timer in OpenDevice 
io_Command TR_ADDREQUEST 
io_Flags IOF_QUICK allowable 
RESULTS 
tr_time the timeval structure will be filled in with 


the current system time 


timer .device/TR_SETSYSTIME 


timer. device/TR_SETSYSTIME 


NAME 
TR_SETSYSTIME —- set the system time 


FUNCTION 
Set the systems idea of what time it is. The system 
starts out at time "zero" so it is safe to set it 
forward to the "real" time. However care should be taken 
when setting the time backwards. System time 
is speced as being monotonically increasing. 


TIMER REQUEST 


io_Message mn_ReplyPort initialized 


io_ Device preset by timer in OpenDevice 
io Unit preset by timer in OpenDevice 
io_Command TR_ADDREQUEST 
io_Flags IOF_QUICK allowable 
tr_time a timeval structure with the current system 
time 
RESULTS 
none 


oL-a4 











TABLE OF CONTENTS 


trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 
trackdisk. 





device/TD_ADDCHANGEINT 
device/TD_CHANGENUM 
device/TD_CHANGESTATE 
device/TD_FORMAT 
device/TD_GETDRIVETYPE 
device/TD_GETNUMTRACKS 
device/TD_MOTOR 
device/TD_PROTSTATUS 
device/TD_RAWREAD 
device/TD_RAWWRITE 
device/TD_REMCHANGEINT 
device/TD_SEEK 








trackdisk.device/TD_ADDCHANGEINT trackdisk.device/TD_ADDCHANGEINT 


NAME 
TD_ADDCHANGEINT ~ add a new change software int 
SYNOPSIS 
TDUAddChangeInt( IORequest ), UnitPtr 
Al B3 
FUNCTION 


Alas, the old TDURemove call was not robust enough. This routine 
supports an extensible list of software interrupts for use by many 
different supporting drivers. 

The call does not "complete" (e.g. TermIO). The request 

is stashed until TDURemChangeInt is called, when it is 

finally replied. 


INPUTS 
TORequest — a standard IO Request block (IO_DATA-> soft int struct). 


RESULTS 
EXCEPTIONS 
SEE ALSO 


BUGS 

















TL - 4 


trackdisk.device/TD_CHANGENUM 


NAME 
TD CHANGENUM — return the current disc change number 


SYNOPSIS 
TDUChangeNum( IORequest ), UnitPtr 
Al A3 


FUNCTION 
This routine checks to see if there is a disc in the drive 
of the specified unit. 


INPUTS 
TORequest —- a standard IO Request block 


RESULTS 
EXCEPTIONS 
SEE ALSO 


BUGS 


trackdisk.device/TD_CHANGENUM trackdisk .device/TD_CHANGESTATE 


trackdisk .device/TD_CHANGESTATE 


NAME 
TD_CHANGESTATE — Return the current state of the disc 


SYNOPSIS 
TpUChangeState( IORequest ), UnitPtr 
Al A3 


FUNCTION 
This routine checks to see if there is a disc in the drive 
one the specified unit. 


INPUTS 
IORequest ~ a standard IO Request block 


RESULTS 
IO_ACTUAL ——- nonzero if there is no diskette in the drive 


EXCEPTIONS 
SEE ALSO 


BUGS 





trackdisk.device/TD_FORMAT trackdisk.device/TD_FORMAT trackdisk.device/TD_GETDRIVETYPE trackdisk.device/TD_GETDRIVETYPE 
NAME NAME 

TD_FORMAT ~—- format the entire disc TD_GETDRIVETYPE ~ return the type of the disk drive to the user 
SYNOPSIS FUNCTION 

TDUFormat( iOBlock ), DevNode This routine returns the type of the disk to the user. 

DO Al AG This number will be a small integer. It will come from 

the set of DRIVE... defines in trackdisk.h 

FUNCTION or trackdisk.i. 


The function formats the entire disc, destroying all data. 
It fills all the sectors with the contents of the iOBlock. 
The iOBlock must point to (at least) one sector worth of 
information. Any info greater than one sector is ignored. 
NO ERROR CHECKING is done 


The only way you can get to this call is if the trackdisk 
device understands the drive type of the hardware that is 
plugged in. This is because the OpenDevice call will fail 
if the trackdisk device does not understand the drive type. 
To find raw drive identifiers see the disk resource's 


DR_GETUNITID. entry point. 
INPUTS 
IO REQUEST 
io_Command TD_GETDRIVETYPE 


RESULTS RESULTS 
io_Actual the drive type connected to this unit. 


SEE ALSO SEE ALSO 
TD_GETNUMTRACKS 





cL -@ 








trackdisk.device/TD_GETNUMTRACKS trackdisk .device/TD_GETNUMTRACKS 


NAME ‘ 
TD _GETNUMTRACKS ~ return the number of tracks on this type of disk 


FUNCTION 
This routine returns the number of tracks that are available 
on this disk unit. This call obsoletes the older NUMTRACKS 
hard. coded constant. 


IO REQUEST 

io_Command TD_GETNUMTRACKS 
RESULTS 

io Actual number of tracks accessible on this unit 
SEE ALSO 


TD_GETDRIVETYPE 











trackdisk.device/TD_MOTOR trackdisk.device/TD_MOTOR 


NAME 
TD_MOTOR - user visible control for motor 
SYNOPSIS 
TDUMotor( IOBlock ), UnitPtr, DevPtr 
Al A3 A6 
FUNCTION 
This routine allows the user to control the disc motor. He 
may turn it either on or off. Note that the motor will be 
automatically ‘turned on during an I/O request, but is never 
turned of except by this command. 
INPUTS 
IOBlock - the command block for this IO operation. 
IO_ACTUAL -- returns the previous state of the motor 
IO LENGTH -- the requested state of the motor 
0 ==> turn motor off 
1 ==> turn motor on 
EXCEPTIONS 
SEE ALSO 
BUGS 


pL ~d 


trackdisk.device/TD_PROTSTATUS 


NAME 


trackdisk.device/TD_PROTSTATUS 


TD_PROTSTATUS -~ return whether the current disk is write protected 


SYNOPSIS 


TDUProtstatus( IOBlock ), UnitPtr, DevPtr 
Al A3 A6 


FUNCTION 


This routine tells whether the current disk is write protected. 


INPUTS 


IOBlock — the command block for this IO operation. 


EXCEPTIONS 
SEE ALSO 


BUGS 


IO_ACTUAL ~ nonzero if the disk is protected, 0 otherwise 
If there is no disk in the drive, then IO_ERROR is set 
to TDERR_DiskChanged 


trackdisk.device/TD_RAWREAD 


NAME 


trackdisk.device/TD_RAWREAD 


TD_RAWREAD ~ read a raw sector from the disk 


FUNCTION 


This routine performs a raw read for the track disk. 
It seeks to the specified track and reads it in to the 
user's buffer. This buffer MUST be in chip memory. 


NO PROCESSING OF THE TRACK IS DONE. It will appear exactly 

as the bits come out off the disk —- hopefully in some legal MFM 
format (if you don't know what MFM is, you shouldn't be using 
this call...). Caveat Programmer. 


This interface is intended for sophisticated programmers 
only. Commodore-Amiga may make enhancements to the disk 
format in the future. We will provide compatibility 

within the trackdisk device. Anyone who uses this routine 
is bypassing this upwards compatibility. If your application 
breaks, TOUGH! 


If this warning is not enough, then add suitable additional 
harrassment of your choice. 


IO REQUEST 


io_Flags if the IOTDB_INDEXSYNC bit is set then the driver 
will make a best effort attempt to start reading 
from the index mark. Note that there 
will be at least some delay, and perhaps a great 
deal, of delay (if, for example, interrupts have 
been Disabled()...). 


io_Command TD_RAWREAD or ETD_RAWREAD. 


io_Length Length of buffer (in bytes). The maximum allowable 
length is 32K bytes. 

io_Data Pointer to buffer in chip memory where raw track 
will be read into. , 

io_Offset The track number to read in (not this is different 


from a normal trackdisk io call which is given 

in terms of logical bytes from the beginning of 

the disk. This is because the trackdisk driver 

has no idea what the format of the disk is). 
(ETD_RAWREAD only) maximum allowable change counter 

value 


iotd_Count 


RESULTS 


io_Error non-zero if there was an error 


LIMITATIONS for synced reads and writes 


BUGS 


There is a delay between the index pulse and the start of bits 
coming in from the drive (e.g. dma started). This delay 

is in the range of 135-200 micro seconds. This delay breaks 

down as follows: 55 microsecs is software interrupt overhead 

(this is the time from interrupt to the write of the DSKLEN 
register). 66 microsecs is one horizontal line delay (remember 
that disk io is synchronized with agnus' display fetches). 

The last variable (0-65 microsecs) is an additional scan line 
since DSKLEN is poked anywhere in the horizontal line. This leaves 
15 microsecs unaccounted for... Sigh. 


In short, You will almost never get bits withing the first 135 
microseconds of the index pulse, and may not get it until 200 
microseconds. At 4 microsecs/bit, this works out to be between 
4 and 7 bytes of user data of delay. 


In V33/34 Kickstart, the length comparison depends on the 
value of a random memory location. This makes the function 
unusable unless two drives are hooked up. 


SEE ALSO 








TD_RAWWRITE trackdisk.device/TD_RAWWRITE trackdisk.device/TD_RAWWRITE 


NAME 
TD_RAWWRITE — write a raw sector to the disk 


FUNCTION 
NO PROCESSING OF THE TRACK IS DONE. ‘The disk will appear exactly 
as the bits come out of memory — hopefully in some legal MFM 
format (if you don't know what MFM is, you shouldn't be using 
this call...). Caveat Programmer. 


NO PROCESSING OF THE TRACK IS DONE. It will exactly 
as the bits come out off the disk. Caveat Programmer. 


This interface is intended for sophisticated programmers 
only. Commodore-Amiga may make enhancements to the disk 
format in the future. We will provide compatibility 

within the trackdisk device. Anyone who uses this routine 

is bypassing this upwards compatibility. If your application 
breaks, TOUGH! 


If this warning is not enough, then add suitable additional 
harrassment of your choice. 


IO REQUEST 

io_Flags if the IOTDB_INDEXSYNC bit is set then the driver 
will make a best effort attempt to start writing 
from the index mark. Note that there 
will be at least some delay, and perhaps a great 
deal, of delay (if, for example, interrupts have 
been Disabled()...). 

io_Command TD RAWWRITE or ETD _RAWWRITE. 

io_Length Length of buffer (in bytes). The maximum allowable 
length is 32K bytes. 

io_Data Pointer to buffer in chip memory where raw track 
will be read into. 

io_Offset The track number to read in (not this is different 
from a normal trackdisk io call which is given 
in terms of logical bytes from the beginning of 
the disk. This is because the trackdisk driver 
has no idea what the format of the disk is). 

iotd_Count (ETD_RAWWRITE only) maximum allowable change counter 
value 


GSi- 4 


RESULTS 
io_Error non-zero if there was an error 


LIMITATIONS for synced reads and writes 
There is a delay between the index pulse and the start of bits 
going out to the drive (e.g. write gate enabled). This delay 
is in the range of 135-200 micro seconds. This delay breaks 
down as follows: 55 microsecs is software interrupt overhead 
(this is the time from interrupt to the write of the DSKLEN 
register). 66 microsecs is one horizontal line delay (remember 
that disk io is synchronized with agnus' display fetches). 
The last variable (0-65 microsecs) is an additional scan line 
since DSKLEN is poked anywhere in the horizontal line. This leaves 
15 microsecs unaccounted for... Sigh. 


In short, You will almost never get bits withing the first 135 
microseconds of the index pulse, and may not get it until 200 
microseconds. At 4 microsecs/bit, this works out to be between 
4 and 7 bytes of user data of delay. 


In V33/34 Kickstart, the length comparison depends on the 
value of a random memory location. This makes the function 
unusable unless two drives are hooked up. 


SEE ALSO 
TD_RAWREAD 





94 -—4 


trackdisk.device/TD_REMCHANGEINT 


trackdisk.device/TD_REMCHANGEINT 


NAME 
TD_REMCHANGEINT — remove a change software int 


SYNOPSIS 
TDURemChangeInt( 1ORequest ), UnitPtr 
Al A3 


FUNCTION 
This function unlinks the IORegest stashed by AddChangeInt. 
It also replies it to the user. 


INPUTS 
TORequest ~ a standard IO Request block 


RESULTS 
EXCEPTIONS 
SEE ALSO 


BUGS 





trackdisk.device/TD_SEEK 





trackdisk.device/TD_SEEK 


NAME 
TD_SEEK - user visible control for the heads 


SYNOPSIS 
TDUSeek( IOBlock ), TDLib 
Al AG 


FUNCTION 
This routine allows the user to control the seek position. 
Note that the heads will be automatically seeked during an 
I/O request; this command allows the heads to be preseeked 
if the next position is known prior to the I/O being ready. 


INPUTS 
IOBlock - the command block for this IO operation. 
IO_OFFSET —- the location to seek to 
EXCEPTIONS 
SEE ALSO 


BUGS 


Section C 


Resource Summaries 


This section contains summaries for system resource routines. These documents have 
been extracted from the original source code and are often called autodocs. Resources 
are low-level hardware control functions that, typically, are not used directly by pro- 
grammers. Most of the resources only support access from assembly language. 









WARNING: Under the multitasking operating system, user-level 
tasks are generally NOT allowed to directly use the hardware features. 
If your program requires direct hardware access, resources provide a 
way of asking for ownership of the involved hardware components. 
Indiscriminate hardware meddling will cause problems the next time the 
hardware or operating system is upgraded. 





He HO 


_AbsExecBase 

JSRLIB MACRO 
XREF 
JSR 
ENDM 


Assembly language fragment that grabs one of the two groups of serial 
port bits (using the misc.resource). If it is successful at obtaining 
the resource, it will hang on to it forever, and never return. 


This example must be linked with "“amiga.1ib" 


INCLUDE "exec/types.i" 
INCLUDE "resources/misc.i" 


equ 4 
_LVO\1 
_LVO\1(A6) 


move.1 _AbsExecBase,a6 
lea.L MiscName(pc),al 
JSRLIB OpenResource 


tst.1 dQ 
beq.s no_open 
move.1 d0,a6 ;resource base in A6 


; We now have a pointer to a resource. 
; Call one of its library-like vectors. 
; 


move.l #MR_SERIALBITS,d0 ;We want these bits 


lea.1 MyName(pc),al ;This is our name 
jsr MR_ALLOCMISCRESOURCE (a6 ) 

tst.1 do 

bne.s no_get ;Someone else got it 


Nobody else can use the serial port, including the serial.device! 


; We just stole the serial port registers. Wait forever. 
f 
f 


no_get 
no_open 


MiscName 
MyName 


move.1 _AbsExecBase,a6 
moveq #0,d0 ;Wait for nothing (forever) 
JSRLIB Wait 

;Someone else has it, exit! 
moveq #21,d0 


rts 
dc.b 'misc.resource',0 
dc.b ‘Serial Port hog',0 


END 


An example of using the potgo.resource to read pins 9 and 5 of 
port 1 (the non-mouse port). This bypasses the gameport.device. 
When the right button on a mouse plugged into port 1 is pressed, 
the read value will change. 


HO OOF 


Use of port 0 (mouse) is unaffected. 
x 

#include "exec/types.h" 

#include "libraries/dos.h" 


APTR PotgoBase; 
ULONG potbits; 
UWORD value; 


#define UNLESS(x) if(!(x)) 
#define UNTIL(x) while(!(x)) 


#define OUTRY 1L<<15 
#define DATRY 1L<<14 
#define OUTRX 1L<<13 
#define DATRX 1L<<12 


void main() 


UNLESS ( PotgoBase=(APTR)OpenResource("potgo. resource" ) ) 
exit(RETURN_FAIL) ; 
printf("PotgoBase is at $%1x\n",PotgoBase) ; 


potbits=AllocPotBits (OUTRY | DATRY | OUTRX|DATRX) ; 
/* Get the bits for the right and middle mouse buttons 
on the alternate mouse port. */ 


if(potbits != (OUTRY|DATRY|OUTRX|DATRX) ) 


printf("Pot bits are already allocated! %1x\n",potbits); 
FreePotBits(potbits),; 

exit(RETURN_FAIL+1); 

} 


WritePotgo(OxFFFFFFFFL,potbits) ; 
/* Set all ones in the register (masked by potbits) */ 


UNTIL(SIGBREAKF_CTRL_C & SetSignal(0L,0L)) 
/* until CTRL-C is pressed */ 


value=*(UWORD *)OxOODFFO16; 

/* Read word at SDFFO16 */ 

printf("POTINP = $%1x\n",value & potbits); 

/* Show what was read (restricted to our allocated bits) */ 


} 
FreePotBits(potbits) ; 


There are currently four standard resources in the Amiga system: 


disk 


cia 


potgo 


misc 


grants temporary exclusive access to the disk hardware. (For each of the 
four possible disk /MFM units) 


grants access to specific bits and individual interrupts from each of the 
8520 CIA (Complex Interface Adapter) chips. 


There are two cia resources: ciaa.resource and ciab.resource, which 
correspond to the odd and even 8520 chips. 


manages the bits of the POTGO (write-only) and POTINP (read-only) 
registers. These custom chip registers control the proportional input pins 
on the controller ports. The pins may also be used for digital input and 
output. Intuition uses port 1 for reading the right and (optional) middle 
mouse buttons. 


grants exclusive access to functional blocks of chip registers. At this time 
definitions have been made for the serial and parallel hardware. When a 
task owns the misc resource for a port, it has control over that port’s asso- 
ciated hardware. 


See the Amiga Hardware Reference Manual for detailed information on the actual 
hardware involved. This section covers the proper arbitration under the multitasking 


system. 






Examples: 


WARNING: Resources are just one step above direct hardware 
manipulation. You are advised to try the higher level device and library 
approach before resorting to the hardware. 





TABLE OF CONTENTS 





TABLE. OF CONTENTS 


cia. resource/AbleICR 

cia. resource/AddICRVector 
cia. resource/RemICRVector 
cia. resource/SetICR 





cia. resource/AbleICR 





cla. resource/AbleICR 


NAME 

AbleICR —- enable/disable ICR interrupts 
SYNOPSIS 

oldMask = AbleICR(mask), Resource 

DO DO A6 
FUNCTION 


This function provides a means of enabling and disabling 
6526 CIA interrupt control registers. 
In addition it returns the previous enable mask. 


INPUTS 
mask ~ a bit mask indicating which interrupts to be 
modified. If bit 7 is clear the mask indicates 
interrupts to be disabled. If bit 7 is set, the 
mask indicates interrupts to be enabled. 
Bit positions are identical to those in 6526 ICR. 


RESULTS 
oldMask - the previous enable mask before the requested 
changes. To get the current mask without making 
changes, call the function with a null parameter. 


EXAMPLES 
Get the current mask: 
mask = AbleICR(0) 
Enable both timer interrupts: 
AbleICR (0x83) 
Disable serial port interrupt: 
AbleICR (0x08) 


EXCEPTIONS 
Enabling the mask for a pending interrupt will cause 
an immediate processor interrupt (that is if everything 
else is enabled). You may want to clear the pending 
interrupts with SetICRx prior to enabling them. 


SEE ALSO 
SetICR 


cia. resource/AddICRVector 


cia. resource/AddICRVector 


NAME 
AddICRVector —- attach an interrupt handler to a CIA bit 


SYNOPSYS 
interrupt = AddICRVector(iCRBit, interrupt), resource 
DO DO Al AG 


FUNCTION 
Assign interrupt processing code to a particular interrupt 
bit of the CIA ICR. If the interrupt bit has already been 
assigned, this function will fail, and return a pointer. 
to the owner interrupt. If it succeeds, a null is returned. 


This function will also enable the CIA interrupt for the given 
ICR bit. 


INPUTS 
iCRBit ~ bit number to set (0..4) 
interrupt — pointer to interrupt structure 


RESULT 
interrupt - zero if successful, otherwise returns a pointer 
to the current owner interrupt structure. 


SEE ALSO 
RemICRVector 





cia. resource/RemICRVector 


cia. resource/RemICRVector 


NAME 
RemICRVector -~ detach an interrupt handler from a CIA bit 


SYNOPSYS 
RemICRVector(iCRBit, interrupt), resource 
DO Al A6 


FUNCTION 
Disconnect interrupt processing code for a particular interrupt 
bit of the CIA ICR. 


This function will also disable the CIA interrupt for the given 
ICR bit. 


INPUTS 
icRBit — bit number to set (0..4) 
interrupt - pointer to interrupt structure 
RESULT 


SEE ALSO 
AddICRVector 


cia. resource/SetICR 


cia.resource/SetICR 


NAME 
SetICR —- cause, clear, and sample ICR interrupts 


SYNOPSIS 
oldMask = SetICR(mask), Resource 
DO DO A6 


FUNCTION 
This function provides a means of reseting, causing, and 
sampling 6526 CIA interrupt control registers. 


INPUTS 
mask — a bit mask indicating which interrupts to be 
effected. If bit 7 is clear the mask indicates 
interrupts to be reset. If bit 7 is set, the 
mask indicates interrupts to be caused. 
Bit positions are identical to those in 6526 ICR. 


RESULTS 
oldMask — the previous interrupt register status before 
making the requested changes. To sample current 
status without making changes, call the function 
with a null parameter. 


EXAMPLES 
Get the interrupt mask: 
mask = SetICR(0) 
Clear serial port interrupt: 
SetICR( 0x08) 


EXCEPTIONS 
Setting an interrupt bit for an enabled interrupt will cause 
an immediate interrupt. 


SEE ALSO 
AbleICR 





TABLE OF CONTENTS disk .resource/AllocUnit disk. resource/AllocUnit 


.resource/AllocUnit NAME 
. resource/FreeUnit AllocUnit. — allocate.a unit of the disk 
. resource/GetUnit 
. resource/GetUnitID SYNOPSIS 
-resource/GiveUnit Success = AllocUnit( unitNum ), DRResource 
DO DO A6 
FUNCTION 


This routine allocates one of the units of the disk. It should 
be called before trying to use the disk (via GetUnit). 


INPUTS 
unitNum -- a legal unit number (zero through three) 


RESULTS 
Success ~- nonzero if successful. sero on failure. 


EXCEPTIONS 
SEE ALSO 


BUGS 





disk. resource/FreeUnit disk. resource/FreeUnit 


NAME 
FreeUnit - deallocate the disk 


SYNOPSIS 
FreeUnit( unitNum ), DRResource 
DO a6 


FUNCTION 
This routine deallocates one of the units of the disk. It should 
be called when done with the disk. Do not call it if you did 
no successfully allocate the disk (there is no protection ~~ you 
will probably crash the disk system). 


INPUTS 
unitNum — a legal unit number (zero through thrze) 


RESULTS 
EXCEPTIONS 
SEE ALSO 


BUGS 





disk. resource/GetUnit disk. resource/GetUnit 


NAME 

GetUnit - allocate the disk for a driver 
SYNOPSIS 

lastDriver = GetUnit( unitPointer ), DRResource 

DO Al AG 
FUNCTION 


This routine allocates the disk to a driver. It is either 
immediately available, or the request is saved until the disk 
is available. When it is available, your unitPointer is 

sent back to you (via ReplyMsg). You may then reattempt the 
GetUnit. 


Allocating the disk allows you to use the disk's resources. 
Remember however that there are four units to the disk; you are 
only one of them. Please be polite to the other units (by never 
selecting them, and by not leaving interrupts enabled, etc.). 


When you are done; please leave the disk in the following state: 
dmacon dma bit ON 
dsklen dma bit OFF (write a #DSKDMAOFF to dsklen) 
adkcon disk bits -- any way you want 
entena:disk sync and disk block interrupts —— Both DISABLED 
CIA resource index interrupt -~- DISABLED 
8520 outputs —- doesn't matter, because all bits will be 
set to inactive by the resource. 
8520 data direction regs —~ restore to original state. 


INPUTS 
unitPtr - a pointer you your disk resource unit structure. 
Note that the message filed of the structure MUST 
be a valid message, ready to be replied to. 


RESULTS 

lastDriver - if the disk is not busy, then the last unit 
to use the disk is returned. This may be used to 
see if a driver needs to reset device registers. 
(If you were the last user, then no one has changed 
any of the registers. If someone else has used it, 
then any allowable changes may have been made). If the 
disk is busy, then a null is returned. 


EXCEPTIONS 
SEE ALSO 


BUGS 





disk. resource/GetUnitID disk. resource/GetUnitID 


NAME 
GetUnitID ~ find out what type of disk is out there 


SYNOPSIS . 
idtype = GetUnitID( unitNum ), DRResource 
DO DO A6 
FUNCTION 
INPUTS 
RESULTS 
idtype -- the type of the disk drive. Standard types are 
defined in the resource include file. 
EXCEPTIONS 
SEE ALSO 


BUGS 





disk. resource/GiveUnit disk. resource/GiveUnit 


NAME 
GiveUnit - Free the disk back up 


SYNOPSIS 
GiveUnit(), DRResource 
AG 


FUNCTION 
This routine frees the disk after a driver is done with it. 
If others are waiting, it will notify them. 

INPUTS 

RESULTS 

EXCEPTIONS 

SEE ALSO 


BUGS 








TABLE OF CONTENTS 


misc. resource/MR_ALLOCMISCRESOURCE 
misc. resource/MR_FREEMISCRESOURCE 


misc. resource /MR_ALLOCMISCRESOURCE misc. resource/MR_ALLOCMISCRESOURCE 


NAME 
MR_ALLOCMISCRESOURCE - allocate one of the misc resources 


SYNOPSIS 
CurrentUser = MR_ALLOCMISCRESOURCE ( unitNum, name ), misc.resource 
DO DO Al 


STRPTR CurrentUser; 
LONG unitNum; 
STRPTR name; 


FUNCTION 
This routine allocates one of the miscellaneous resources. 
If the resource is currently allocated, an error is returned. 
If you do get it, your name is associated with the resource 
(so a user can see who has it allocated). 


This routine may not be called from an interrupt routine 


DESCRIPTION 
There are certain parts of the hardware that a multitasking— 
friendly program may need to take over. The serial port 
is a good example. By grabbing the misc.resource for the 
serial port, the caller would "own" the hardware registers 
associated with that function. Nobody else, including the 
system serial driver is allowed to interfere. 


The misc.resource must be accessed using assembly language. The set 
of currently defined units and the function offsets from the resource 
base are listed in the resources/misc.i include file. 


INPUTS 
unitNum - the number of the resource you want to allocate 
(eg. MR_SERIALBITS). 
name — a mnenonic name that will help the user figure out 
what piece of software is hogging a resource. 
(havoc breaks out if a name of null is passed in...) 


RESULTS 
CurrentUser — if the resource is busy, then the name of 
the current user is returned. If the resource is 
free, then null is returned. 


BUGS 


SEE ALSO 
resources/mise.i 
misc. resource/MR_FREEMISCRESOURCE 








misc. resource/MR_FREEMISCRESOURCE misc. resource/MR_FREEMISCRESOURCE 


NAME 
MR_FREEMISCRESOURCE ~ make a resource available for reallocation 
SYNOPSIS 
MR_FREEMISCRESOURCE( unitNum ), misc. resource 
DO A6 


LONG unitNum; 


FUNCTION 
This routine frees one of the resources allocated 
by MR_ALLOCMISCRESOURCE. . The resource is made available 
for reuse. 


This routine may not be called from an interrupt routine. 


eNO tini tum - the number of the miscellaneous resource to be freed. 
RESULTS 
Frees the appropriate resource. 
BUGS 
SEE ALSO 


misc. resource/MR_ALLOCMISCRESOURCE 





tI 





TABLE OF CONTENTS 


potgo.resource/AllocPotBits 
potgo. resource/FreePotBits 
potgo.resource/WritePotgo 


potgo. resource/AllocPotBits potgo. resource/AllocPotBits 


NAME 

AllocPotBits - allocate bits in the potgo register 
SYNOPSIS 

allocated = AllocPotBits(bits), potgoResource 

bo DO A6 
FUNCTION 


The AllocPotBits routine allocates bits in the hardware potgo 
register that the application wishes to manipulate via 
WritePotgo. The request may be for more than one bit. A 
user trying to allocate bits may find that they are 
unavailable because they are already allocated, or because 
the start bit itself (bit 0) has been allocated, or if 
requesting the start bit, because input bits have been 
allocated: A user can block itself from allocation: i.e. 

it should FreePotgoBits the bits it. has and re-AllocPotBits if 
it is trying to change an allocation involving the start bit. 


INPUTS 
bits - a description of the hardware bits that the application 
wishes to manipulate, loosely based on the register 
description itself: 

START (bit 0) - set if. you wish to use start (i.e. start 
thr proportional controller counters) with the 
input ports you allocate (below). You must 
allocate all the DATxx ports you want to apply 
START to in this same call, with the OUTxx bit 
clear. 

DATLX (bit 8) - set if you wish to use the port associated 
with the left (0) controller, pin 5. 

OUTLX (bit 9) — set if you promise to use the LX port in 
output mode only. The port is not set to output 
for you at this time —- this bit set indicates 
that you don't mind if STARTs are initiated at any 
time by others, since ports that are enabled for 
output are unaffected by START. 

DATLY (bit 10) -.as DATLX but for the left (0) controller, 
pin 9. 

OUTLY (bit 11) - as OUTLX but for LY. 

DATRX (bit 12) --the right (1) controller, pin 5. 

OUTRX (bit 13) — OUT for RX. 

DATRY (bit 14) - the right (1) controller, pin 9. 

OUTRY (bit 15) - OUT for RY. 


RESULTS 
allocated - the START and DATxx bits of those requested that 
were granted. The OUTxx bits. are don't cares. 


oT -9 


potgo. resource/FreePotBits potgo. resource/FreePotBits 


NAME 
FreePotBits — free allocated bits in the potgo register 


SYNOPSIS 
FreePotBits(allocated), potgoResource 
DO A6 


FUNCTION 
The FreePotBits routine frees previously allocated bits in the 
hardware potgo register that the application had allocated via 
AllocPotBits and no longer wishes to use. It accepts the 
return value from AllocPotBits as its argument. 


potgo. resource/WritePotgo potgo. resource/WritePotgo 
NAME 
WritePotgo — write to the hardware potgo register 


SYNOPSIS 
WritePotgo(word, mask), potgoResource 
DO D1 A6 


FUNCTION 
The WritePotgo routine sets and clears bits in the hardware 
potgo register. Only those bits specified by the mask are 
affected —- it is improper to set bits in the mask that you 
have not successfully allocated. The bits in the high byte 
are saved to be maintained when other users write to the 
potgo register. The START bit is not saved, it is written 
only explicitly as the result of a cal] to this routine with 
the START bit set: other users will not restart it. 


INPUTS 
word - the data to write to the hardware potgo register and 
save for further use, except the START bit, which is 
not saved. 
mask — those bits in word that are to be written. Other 
bits may have been provided by previous calls to 
this routine, and default to zero. 





Section D 


C Include Files— ‘‘.h’”’ Files 


This section contains the C-language include files from the Amiga operating system 
source code. These include files define the data structures and constants used by the 
system software. Whenever the system requires that a certain structure or constant be 
passed, it will be defined in an include file. These include files are organized on a func- 
tional basis. For example, files pertinent to the graphics library are listed under 
“eraphics/itemname.h.” 


This section is for easy reference only. Similar include files generally come on disk with 
whatever C compiler you may choose to use with the Amiga. A quick example of 
include file usage follows: 





WARNING: Not all information in this section should be used in your programs. The 
include files contain definitions for some structure members and constants that are not 
supported for use by programs. In some cases these definitions are marked as private, in 
other cases they are not distinguished. Following the guidelines presented by Commodore- 
Amiga is the best way to insure compatibility with future system software releases. 


* 
* A quick example of using a C language include file. The constant 


* "ID KICKSTART_DISK" is not defined in this example; the value 
* is pulled from the "libraries/dos.h" include file. 
* 

#include "libraries/dos.h" 

void main() 


printf("ID_KICKSTART_DISK equals %1x\n",ID KICKSTART DISK) ; 
exit(RETURN_OK); 


ODNAUSPWNE 


19 20:24 1988 devices/audio.h Page 1 


#ifndef 
#define 
/* 

kk 

K* 

Kk 

x* 

Kk 

Kk 

wx 


*/ 
#ifndef 


DEVICES _AUDIO_H 
DEVICES AUDIO_H 


$Filename: devices/audio.h $ 


SRelease: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
All Rights Reserved 


EXEC_IO_H 


#include “exec/io.h" 


#endif 
#define 
#tdefine 


#tdefine 
#define 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 


AUDIONAME 
ADHARD_ CHANNELS 


ADALLOC_MINPREC 
ADALLOC_MAXPREC 


ADCMD_FREE 
ADCMD_SETPREC 
ADCMD_FINISH 
ADCMD_PERVOL 
ADCMD_LOCK 
ADCMD_WAITCYCLE 
ADCMDB_NOUNIT 
ADCMDF_NOUNIT 
ADCMD_ALLOCATE 


“audio.device" 
4 


-128 
127 


(CMD_NONSTD+0) 
(CMD_NONSTD+1 ) 
(CMD_NONSTD+2) 
(CMD_NONSTD+3) 
(CMD_NONSTD+4 ) 
(CMD_NONSTD+5) 


5 
(1<<5) 
(ADCMDF_NOUNIT+0) 


WONAUE WHE 


19 20:24 1988 devices/bootblock.h Page 1 


#ifndef DEVICES _BOOTBLOCK_H 
#define DEVICES_BOOTBLOCK_H 


* 
O $Filename: devices/bootblock.h $ 
xe $Release: 1.3 $ 
Kk 
xe BootBlock definition: 
ak 
** (C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 


*/ 


struct BootBlock [{ 
UBYTE bb_id[4]; 
LONG bb_chksum; 
LONG bb_dosblock; /* reserved for DOS patch */ 


i; 


#define BOOTSECTS 2 /* 1K bootstrap */ 
#define BBID_DOS { 'D', 'o', 'S', '\O' } 
#define BBID_KICK { 'K', 'r', ‘ct, 'K' } 


#define BBNAME_DOS 
#define BBNAME_KICK 


(('D! <<24) | (101 <<16) 18! 668) 
C('K'<<24) | (10 <<16) | (1C' $68) | (KD) 


#endif /* DEVICES _BOOTBLOCK_H */ 


/* 4 character identifier */ 
/* boot block checksum (balance) */ 


#define ADIOB_PERVOL 4 
#define ADIOF_PERVOL (1<<4) 
5 


#define ADIOB_SYNCCYCLE 

#tdefine ADIOF_SYNCCYCLE (1¢«5) 
#define ADIOB_NOWAIT 6 
#define ADIOF_NOWAIT (1<<6) 
#define ADIOB_WRITEMESSAGE 7 
#define ADIOF WRITEMESSAGE (16<7) 


#define ADIOERR_NOALLOCATION -10 
#define ADIOERR_ALLOCFAILED -li 
#define ADIOERR_CHANNELSTOLEN ~12 


struct IOAudio { 

struct IORequest ioa_Request; 
WORD ioa_Allockey; 

UBYTE *ioa_Data; 

ULONG ioa_Length; 

UWORD ioa_Period; 

UWORD ioa_Volume; 

UWORD ioa_Cycles; 

struct Message ioa_WriteMsg; 


1; 
#endif /* DEVICES AUDIO_H */ 





Sep 


OONDM PWN 


19 20:24 1988 devices/clipboard.h Page 1 


#ifndef DEVICES _CLIPBOARD_H 
#define DEVICES CLIPBOARD H 


* 


a $Filename: devices/clipboard.h $ 

aK $Release: 1.3 $ 

*“k 

aK clipboard device command definitions 
** 

Kk (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
ae All Rights Reserved 

*/ 

#ifndef EXEC_NODES_H 

#include “exec/nodes.h" 

#endif 

#ifndef EXEC_LISTS_H 

#include "exec/lists.h" 

#endif 

#ifndef EXEC_PORTS_H 

#include “exec/ports.h* 

#endif 

#define CBD_POST (CMD_NONSTD+0) 


#define CBD_CURRENTREADID 
#define CBD_CURRENTWRITEID 


(CMD_NONSTD+1) 
(CMD_NONSTD12) 


#define CBERR_OBSOLETEID 1 


struct ClipboardUnitPartial [{ 
struct Node cu_Node; /* list of units */ 
ULONG = cu_UnitNum; 7* unit number for this unit */ 
/* the remaining unit data is private to the device */ 


i; 


struct IoclipReg { 


struct Message io_Message; 
struct Device *io Device; /* device node pointer */ 
struct Unit *io Unit; /* unit (driver private)*/ 
UWORD io Command; /* device command */ 
UBYTE io_Flags; /* including QUICK and SATISFY */ 
BYTE io_Error; /* error or warning num */ 
ULONG io Actual; 7* number of bytes transferred */ 
ULONG io _Length; “* number of bytes requested */ 
STRPTR io Data; /* either clip stream or post port */ 
ULONG io Offset; /* offset in clip stream */ 
LONG io_ClipID; /* ordinal clip identifier */ 

J; 

#define PRIMARY CLIP 0 /* primary clip unit */ 

struct SatisfyMsg [{ 


struct Message sm Msg; /* the length will be 6 */ 

UWORD = sm_Unit; /* which clip unit this is */ 

LONG sm_ClipID; /* the clip identifier of the post */ 
}; 


#endif /* DEVICES _CLIPBOARD_H */ 





Sep 


WODOAINUSWNE 


19 20:24 1988 devices/console.h Page 1 


#ifndef DEVICES _CONSOLE_H 
#define DEVICES _CONSOLE_H 


* 
a $Filename: devices/console.h $ 
** $Release: 1.3 $ 
ak 
xk Console device command definitions 
ak 
*K (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ek All Rights Reserved 
*/ 
#ifndef EXEC_IO_H 
#include "exec/io.h" 
#tendif 


/x**ek** Console commands ******/ 
#define CD_ASKKEYMAP 

#define CD_SETKEYMAP 

#define CD_ASKDEFAULTKEYMAP 
#tdefine CD_SETDEFAULTKEYMAP 


(CMD_NONSTD+0) 
(CMD_NONSTD+1) 
(CMD_NONSTD+2) 
(CMD_NONSTD+3) 


/xxkee* SGR parameters ******/ 


#define SGR_PRIMARY 
#define SGR_BOLD 
#define SGR_ITALIC 
tdefine SGR_UNDERSCORE 
tdefine SGR_NEGATIVE 


sw O 


/* these names refer to the ANSI standard, not the implementation */ 
#tdefine SGR_BLACK 


#tdefine SGR_RED 31 
#define SGR_GREEN 32 
#define SGR_YELLOW 33 
#define SGR_BLUE 34 
#define SGR_MAGENTA 35 
#define SGR_CYAN 36 
#define SGR_WHITE 37 
#define SGR_DEFAULT 39 
#define SGR_BLACKBG 40 
#define SGR_REDBG 41 
#define SGR_GREENBG 42 
#define SGR_YELLOWBG 43 
#define SGR_BLUEBG 44 
#define SGR_MAGENTABG 45 
#define SGR_CYANBG 46 
#define SGR_WHITEBG 47 
#define SGR_DEFAULTBG 49 


/* these names refer to the implementation, they are the preferred x/ 
/7* names for use with the Amiga console device. */ 
#define SGR_CLRO 30 


#define SGR_CLR1 31 
#define SGR_CLR2 32 
#define SGR_CLR3 33 
#define SGR_CLR4 34 
#define SGR_CLR5 35 
#define SGR_CLR6 36 
#define SGR_CLR7 37 
#tdefine SGR_CLROBG 40 
#define SGR_CLR1BG 41 
#define SGR_CLR2BG 42 
#tdefine SGR_CLR3BG 43 
#define SGR_CLR4BG 44 


#define SGR_CLR5BG 45 








19 20:24 1988 devices/console.h Page 2 


#define SGR_CLR6BG 46 
#tdefine SGR_CLR7BG 47 


/xeeee* DSR parameters *****x/ 


#define DSR_CPR 6 
[eee CTC parameters ******/ 
#define CTC_HSETTAB 0 
#define CTC_HCLRTAB 2 


#define CTC_HCLRTABSALL 5 
/*x*e*e* TBC parameters RRKKKK/ 
#define TBC_HCLRTAB 0 
#define TBC_HCLRTABSALL 3 


/****k* SM and RM parameters ******/ 


#define M_LNM 20 /* linefeed newline mode */ 
#tdefine M_ASM "1" /* auto scroll mode */ 
#define M_AWM "27" 7* auto wrap mode */ 


#endif /* DEVICES_CONSOLE_H */ 





WONAUPWNE 


19 


#ifndef DEVICES_CONUNIT_H 
#define DEVICES_CONUNIT_H 


* 
ak 
xe 
ak 
we 
atk 
xk 
Kk 


*/ 


20:24 


1988 devices/conunit.h Page 1 







$Filename: devices/conunit.h $ 
$Release: 1.3 $ 


Console device unit definitions 


(C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 

















































#ifndef 
#include 
#endif 


#ifndef 
#include 
#endif 


#ifndef 
#include 


#endif 


#ifndef 


#include 


#endif 


#tdefine 
#define 


#define 


struct 


struct MsgPort cu_MP; 
/* ~-—— read only variables */ 


struc 


WORD 


[x 


ko 


struc 
ft 


UWORD cu_TabStops [MAXTABS] ; /* 0 at start, Oxffff at end of list */ 


* oH 
BYTE 
BYTE 
BYTE 
BYTE 
BYTE 
BYTE 
APTR 
UBYTE 
struc 
UBYTE 








EXEC_PORTS_H 
"exec/ports.h" 








DEVICES_CONSOLE_H 
"devices/console.h" 


DEVICES_KEYMAP_H 
"devices/keymap.h" 


DEVICES _INPUTEVENT_H 
"devices/inputevent.h" 


PMB_ASM (M_LNM+1 ) /7* internal storage bit for AS flag */ 
PMB_AWM (PMB_ASM+1) /* internal storage bit for AW flag */ 
MAXTABS 80 


Conunit [{ 


* Window *cu_Window; /* intuition window bound to this unit */ 
cu_XCP; /* character position */ 

cu_YCP; . 

cu_XMax; /* max character position */ 

cu_YMax; 

cu_XRSize; /* character raster size */ 

cu_YRSize; 

cu_XROrigin; /7* raster origin */ 

cu_YROrigin; 

cu_XRExtant; /7* raster maxima */ 

cu_YRExtant; 

cu_XMinShrink; /* smallest area intact from resize process */ 
eu_YMinShrink; 

cu_XCCP; /* cursor position */ 

cu_YCCP; 


—- read/write variables (writes must must be protected) */ 
—- storage for AskKeyMap and SetKeyMap */ 

t. KeyMap cu_KeyMapStruct; 

-——- tab stops * 


—— console rastport attributes */ 
cu_Mask; 
cu_FgPen; 
cu_BgPen; 
cu_AOLPen ; 
cu_DrawMode ; 
cu_AreaPtSz; 
cu_AreaPtrn; 7* cursor area pattern */ 
cu_Minterms [8] ; /* console minterms */ 
a TextFont *cu_Font; 
cu_AlgoStyle; 





Sep 19 20:24 1988 devices/conunit.h Page 2 


70 UBYTE cu_TxFlags; 

71 UWORD cu_TxHeight ; 

72 UWORD cu_TxWidth; 

73 UWORD cu_TxBaseline; 

74 UWORD cu_TxSpacing; 

75 

76 /* ~--— console MODES and RAW EVENTS switches */ 
77 UBYTE cu_Modes [ (PMB_AWM+7) /8] ; /* one bit per mode */ 
78 UBYTE cu_RawEvents [( IECLASS_MAX+7)/8]; 

79 4; 

80 


81 #endif /* DEVICES _CONUNIT_H */ 


WOONDUPWNE 


19 20:24 1988 devices/gameport.h Page 1 


#ifndef 
#define 
f* 
ak 
Kk 
kk 
Kx 
Kk 
kk 
ak 
*/ 
[ RRRERE 
#define 
#tdefine 
#define 
#define 
#define 


[RRKKKK 


DEVICES _GAMEPORT_H 
DEVICES_GAMEPORT_H 


$Filename: devices/gameport.h $ 
SRelease: 1.3 $ 


GamePort device command definitions 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


GamePort commands ******/ 

GPD_READEVENT (CMD_NONSTD+0) 
GPD_ASKCTYPE (CMD_NONSTD+1) 
GPD_SETCTYPE (CMD_NONSTD+2) 
GPD_ASKTRIGGER (CMD_NONSTD+3) 
GPD_SETTRIGGER (CMD_NONSTD+4 ) 


GamePort structures ******/ 


/* gpt_Keys */ 


#define 
#define 
#define 
#define 


GP'TB_DOWNKEYS 0 
GPTF_DOWNKEYS (1<<0) 
GPTB_UPKEYS 1 
GPTF -UPKEYS (1<<1) 


struct GamePortTrigger { 
UWORD gpt_Keys; /* key transition triggers */ 
UWORD gpt_Timeout ; /* time trigger (vertical blank units) */ 
UWORD gpt_XDelta; /* X distance trigger */ 
UWORD gpt_YDelta; /* Y distance trigger */ 


I; 


LRRERER 


#define 
#define 


#define 


#tdefine 
#tdefine 


[RRRKKK 
#tdefine 


#endif 


Controller Types ****x**/ 
GPCT_ALLOCATED -1 
GPCT_NOCONTROLLER 0 


/* allocated by another user */ 


GPCT_MOUSE 1 
GPCT_RELJOYSTICK 2 
GPCT_ABSJOYSTICK 3 


Errors ***«x*/ 


GPDERR_SETCTYPE. 1 /* this controller not valid at this time */ 


/* DEVICES GAMEPORT H */ 








[Sep 


WOnNDU RWHP 




















19 20:25 1988 devices/hardblocks.h Page 1 Sep 19 20:25 1988 devices/hardblocks.h Page 2 ‘| 
#ifndef DEVICES_HARDBLOCKS_H 70 ULONG rdb Reserved3{5]; 
#define DEVICES_HARDBLOCKS_H 71 /* logical drive characteristics */ 
/* T2 ULONG xdb RDBBlocksLo; /* low block of range reserved for hardblocks * 
xe $Filename: devices/hardblocks.h $ 73 ULONG  xdb_RDBBlocksHi; 7* high block of range for these hardblocks */ 
xe $Revision: 1.0 $ 74 ULONG rdb_LoCylinder; /* low cylinder of partitionable disk area */ 
x* $Date: 88/07/11 15:32:49 $ 75 ULONG = rdb_HiCylinder; /* high cylinder of partitionable data area «/ 
xe 76 ULONG xdb CylBlocks; * number of blocks available per cylinder */ 
** File system identifier blocks for hard disks 77 ULONG rdb AutoParkSeconds; /* zero for no auto park */ 
ak 78 ULONG rdb_Reserved4 [2]; 
** (C) Copyright 1988 Commodore-Amiga, Inc. 79 /* drive identification */ 
xx All Rights Reserved 80 char xrdb_DiskVendor [8] ; 
*/ 81 char rdb_DiskProduct [16]; 
82 char rdb_DiskRevision[4]; 
[OR 83 char rdb_ControllerVendor [8] ; 
* 84 char rdb_ControllerProduct [16] ; 
* This file describes blocks of data that exist on a hard disk 85 char rdb_ControllerRevision[4] ; 
* to describe that disk. They are not generically accessable to 86 ULONG rdb_ Reserved5[10]; 
* the user as they do not appear on any DOS drive. The blocks 87 }; . 
* are tagged with a unique identifier, checksummed, and linked 88 
* together. . The root of these blocks is the RigidDiskBlock. 89 #define IDNAME_RIGIDDISK (('R'<<24) | ('D'<<16) | ('S'<<8) | ('K')) 
* 90 
* The RigidDiskBlock must exist on the disk within the first 91 #define RDB_LOCATION_LIMIT 16 
* RDB_LOCATION LIMIT blocks. This inhibits the use of the zero 92 
* cylinder in an AmigabOS partition: although it is strictly 93 #define RDBFB_LAST 0 /* no disks exist to be configured after */ 
* possible to store the RigidDiskBlock data in the reserved 94 #define RDBFF_LAST OxO1L /* this one on this controller */ 
* area of a partition, this practice is discouraged since the 95 #define. RDBFB_LASTLUN 1 /7* no LUNs exist to be configured greater */ 
* reserved blocks of a partition are overwritten by "Format", 96 #define RDBFF_LASTLUN 0x02L ft than this one at this SCSI Target ID */ 
* "Install", "DiskCopy", ete. The recommended disk layout, 97 #define RDBFB_LASTTID 2 /7* no Target IDs exist to be configured */ 
* then, is to use the first cylinder(s) to store all the drive 98 #define RDBFF_LASTTID 0x04L /* | greater than this one on this SCSI bus */ ) 
* data specified by these blocks: i.e. partition descriptions, 99 #define RDBFB_NORESELECT 3 /* don't bother trying to perform reselection * 
* file system load images; drive bad block maps, spare blocks, 100 #define RDBFF_NORESELECT 0x08L /* when talking to this drive */ 
* etc. 101 #define RDBFB_DISKID 4 /* vdb_Disk... identification valid */ 
* 102 #define RDBFF_DISKID OxLOL 
* Though only 512 byte blocks are currently supported by the 103 #define RDBFB_CTRLRID 5 /* rdb_Controller... identification valid */ 
x file system, this proposal tries to be forward-looking by 104 #define RDBFF_CTRLRID O0x20L 
* making the block size explicit, and by using only the first 105 
* 256 bytes for all blocks but the LoadSeg data. OG a aa kf 
* 107 struct BadBlockEntry { 
Pn «/ 108 ULONG bbe _BadBlock; /* block number of bad block */ 
109 ULONG bbe_GoodBlock; /* block number of replacement block */ 
* 110 }; 
* NOTE li 
* optional block addresses below contain $ffffffff to indicate 112 struct BadBlockBlock f{ 
* a NULL address, as zero is a valid address 113 ULONG bbb_ID; 7* 4 character identifier */ 
* 114 ULONG bbb_SummedLongs ; /* size of this checksummed structure */ 
struct RigidDiskBlock { 115 LONG bbb_ChkSum; /* block checksum (longword sum to zero) */ 
ULONG rdb_ID; /* 4 character identifier */ 116 ULONG bbb HostID; /* SCSI Target ID of host */ 
ULONG  rdb_SummedLongs; /* size of this checksummed structure */ 117 ULONG bbb Next; /* block number of the next BadGBlockBlock. */ 
LONG rdb-ChkSum; /* block checksum (longword sum to zero) */ 118 ULONG bbb_Reserved; 
ULONG rxdb_HostID; /* SCSI Target. ID of host */ 119 struct BadBlockEntry bbb_BlockPairs{61]; /* bad block entry pairs */ 
ULONG rdb_BlockBytes; /* size of disk blocks */ 120 /* note [61] assumes 512 byte blocks */ 
ULONG rdb_Flags; /* see below for defines */ 121 J; 
/* block list heads */ 122 
ULONG rdb_BadBlockList; /* optional bad block list */ 123 #define IDNAME_BADBLOCK (('B'<<24) }C’A'<<16) |('D'<<B) l¢*B')) 
ULONG rdb Partitionbist; /* optional first partition block */ 124 
ULONG rdb_FileSysHeaderList; /* optional file system header block */ VQ Rm */ 
ULONG xdb DriveInit; /* optional drive-specific init code */ 126 struct PartitionBlock { 
/* DriveInit(lun,rdb,ior): "C" stk & a0/a0/al *//127 ULONG = pb_ID; /* 4 character identifier */ 
ULONG  rdb_Reserved1 [6]; /* set to $fff£fffff */ 128 ULONG  pb_SummedLongs; /* size of this checksummed structure «f/f 
/* physical drive characteristics */ 129 LONG pb_ChkSum; /* block checksum (longword sum to zero) */ 
ULONG xrdb Cylinders; /* number of drive cylinders */ 130 ULONG pb_HostID; /* SCSI Target. ID of host */ 
ULONG rdb_Sectors; 7* sectors per track */ 131 ULONG = pb_Next; /* block number of the next PartitionBlock */ 
ULONG rdb_Heads; /* number of drive heads */ 132 ULONG ‘pb_Flags; /* see below for defines */ 
ULONG rdb_Interleave; /7/* interleave */ 133 ULONG pb_Reserved] [2] ; 
ULONG = rdb_ Park; /* landing zone cylinder */ 134 ULONG pb DevFlags; /* preferred flags for OpenDevice */ 
ULONG . rdb Reserved2[3]; 135 UBYTE pb_DriveName [32] ; /* preferred DOS device name: BSTR form */ 
ULONG rdb_ WritePreComp; /* starting cylinder: write precompensation */ 136 /* (not used if this name is in use) */ 
ULONG rdb ReducedWrite; /* starting cylinder: reduced write current */ 137 ULONG pb _Reserved2{15]; /* filler to 32 longwords */ 
ULONG | rdb_StepRate; /* drive step rate */ 138 ULONG pb_Environment{17]; /* environment vector for this partition */ 








Sep 19 20:25 1988 devices/hardblocks.h Page 3 


ULONG 


pb_EReserved [15]; 


142 #define IDNAME_PARTITION 


143 


144 #define PBFB_BOOTABLE 0 


145 #define 
146 #define 
147 #define 


PBFF_BOOTABLE  1L 
PBFB_NOMOUNT = 1 
PBFF_NOMOUNT = 2L 


/* reserved for future environment vector */ 


(('P*<<24) | (1A'<626) | COR! X48) | C'T')) 


/7* this partition is intended to be bootable */ 
ft (expected directories and files exist) */ 
7* do not mount this partition (e.g. manually * 
/7* mounted, but space reserved here) */ 


4-8 8 


/* 4 character identifier */ 

/* size of this checksummed structure */ 

7* block checksum (longword sum to zero) */ 
7* SCSI Target ID of host */ 

7* block number of next FileSysHeaderBlock */ 
/* see below for defines */ 


/* file system description: match this with */ 
7* partition environment's DE_DOSTYPE entry */ 
/* release version of this code */ 

7* bits set for those of the following that */ 
/* need to be substituted into a standard */ 
7* device node for this file system: e.g. */ 
/* 0x180 to substitute SegList & GlobalVec */ 
/* device node type: zero */ 

/* standard dos "task" field: zero */ 

/* not used for devices: ‘zero */ 

7* filename to loadseg: zero placeholder */ 

7* stacksize to use when starting task */ 

/* task priority when starting task */ 

/* startup msg: zero placeholder */ 

/* first of linked list of LoadSegBlocks: */ 
7* note that this entry requires some */ 

7* processing before substitution */ 

/* BCPL global vector when starting task */ 

/* (those reserved by PatchFlags) */ 


(CTP! <<24) | ('S'<<16) | ('H'<¢8) | ('D')) 


Vn a cn ee en re ce nc HR 7 


/7* 4 character identifier */ 

7* size of this checksummed structure */ 

7* block checksum (longword sum to zero) */ 
/* SCSI Target ID of host */ 

/* block number of the next LoadSegBlock */ 
/7* data for "loadseg" */ 


148 

149 / 

150 struct FileSysHeaderBlock [ 
151 ULONG  fhb_ID; 

152 ULONG fhb_SummedLongs ; 
153 LONG fhb_ChkSum; 

154 ULONG fhb HostID; 

155 ULONG = fhb Next; 

156 ULONG fhb_Flags; 

157 ULONG fhb_Reserved1 [2]; 
158 ULONG fhb_DosType; 

159 

160 ULONG fhb_Version; 

161 ULONG fhb_PatchFlags; 
162 

163 

164 

165 ULONG = fhb_Type; 

166 ULONG fhb Task; 

167 ULONG  fhb Lock; 

168 ULONG fhb_Handler; 

169 ULONG fhb_StackSize; 

170 LONG fhb_Priority; 

171 LONG fhb_Startup; 

172 LONG fhb_SegListBlocks; 
173 

174 

175 LONG fhb_GlobalvVec; 

176 ULONG fhb_Reserved2 [23]; 
177 ULONG fhb_Reserved3(21],; 
178 3; 

179 

180 #define IDNAME_FILESYSHEADER 
181 

182 / 

183 struct LoadSegBlock { 

184 ULONG I1sb_ ID; 

185 ULONG = 1sb_SummedLongs; 
186 LONG lsb_ChkSum; 

187 ULONG I1sb_HostID; 

188 ULONG Isb_Next; 

189 ULONG I1sb_LoadData[123]; 
190 /* note [123] assumes 512 byte blocks */ 
191 j; 

192 


193 #define IDNAME_LOADSEG 
194 


195 #endif 





(('L'<<24)]('S'<<16) | ('B'<<8) | ('G*)) 


/* DBVICES_HARDBLOCKS H */ 


Sep 


WANA PWDNE 


19 20:25 1988 devices/input.h Page 1 


#ifndef DEVICES _INPUT_H 
#define DEVICES_INPUT_H 


/* 
Kk 
ak 
ak 
xk 
xk 
ak 
xk 


*/ 


#ifndef 
#include 
#endif 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 


fendif /* DEVICES INPUT_H 


$Filename: devices/input.h $ 
$ 


$Release: 1.3 


input device command definitions 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


EXEC_IO_H 
"exec/io.h" 


IND_ADDHANDLER 
IND_REMHANDLER 
IND_WRITEEVENT 
IND_SETTHRESH 
IND_SETPERIOD 
IND_SETMPORT 
IND_SETMTYPE 
IND_SETMTRIG 


(CMD_NONSTD+0) 
(CMD_NONSTD+1 ) 
(CMD_NONSTD+2) 
(CMD_NONSTD+3 ) 
(CMD_NONSTD+4) 
(CMD NONSTD+5 } 
(CMD_NONSTD+6 ) 
(CMD_NONSTD+7) 


*/ 











Sep 19 20:25 1988 devices/inputevent.h Page 1 Sep 19 20:25 1988 devices/inputevent.h Page 2 


1 #ifndef DEVICES_INPUTEVENT_H 70 

2 #define DEVICES _INPUTEVENT_H 71 /* IECLASS_ANSI */ 

3 /* 72 #define IECODE_CO_FIRST 0x00 

4% $Filename: devices/inputevent.h $ 73 define IECODE_CO LAST Ox1F 

5 eK $Release: 1.3 $ 74 #define IECODE_ASCII_FIRST 0x20 

6 ** 75 #define IBCODE_ASCII_LAST Ox7B 

7 ** input event definitions 76 #define IECODE_ASCII_ DEL Ox7F 

8 ** 77 #define IECODE_Cl_FIRST 0x80 

Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 #define IECODE_Cl_LAST Ox9F 

10 ** All Rights Reserved 79 #define IECODE_LATIN1_ FIRST OxaAd 
B */ 80 #define IECODE_LATIN1_LAST OxFF 

81 

13 #ifndef DEVICES_TIMER_H : 82 /* IECLASS_RAWMOUSE */ 

14 #include "devices/timer.h" 83 #define IECODE_LBUTTON 0x68 /* also uses IECODE_UP_PREFIX */ 
15 #endif 84 #define IECODE_RBUTTON 0x69 

16 85 #define IECODE MBUTTON Ox6A 
V7 ft constants —~~~~~---—--—-------- */ 86 #define IECODE_NOBUTTON OxFF 
18 87 
19 /*  --~- InputEvent.ie Class ——- */ 88 /* IECLASS_EVENT */ 
20 /* A NOP input event */ 89 define IECODE_NEWACTIVE 0x01 /* active input window changed */ 
21 #define IECLASS_NULL 0x00 90 
22 /* A raw keycode from the keyboard device */ 91 /* IECLASS REQUESTER Codes */ 
23 #define IECLASS_RAWKEY 0x01 92 /* REQSET is broadcast when the first Requester (not subsequent ones) opens 
24 /* The raw mouse report from the game port device */ 93 * in the Window 
25 #define IECLASS_RAWMOUSE 0x02 94 */ 
26 /* A private console event */ 95.#define IECODE_REQSET 0x01 
27 #define IECLASS_EVENT 0x03 96 /* REQCLEAR is broadcast when the last Requester clears out of the Window */ 
28 /* A Pointer Position report */ 97 #define IECODE_REQCLEAR 0x00 
29 #define IECLASS_POINTERPOS 0x04 98 
30 /* A timer event */ 99 
31 #define IECLASS_TIMER 0x06 100 /*  --- InputEvent.ie Qualifier —-~ */ 
32 /* select button pressed down over a Gadget (address in ie EventAddress) */ 101 #define IEQUALIFIER_LSHIFT 0x0001 
33.#define IECLASS_GADGETDOWN 0x07 102 #define IEQUALIFIER_RSHIFT 0x0002 

34 /* select button released over the same Gadget (address in ie EventAddress) */ |103 #define IEQUALIFIER_CAPSLOCK 0x0004 
35 #define IECLASS_GADGETUP 0x08 104 #define IEQUALIFIER_CONTROL 0x0008 
36 /* some Requester activity has taken place. See Codes REQCLEAR and REQSET */ 105 #define IEQUALIFIER_LALT 0x0010 
37 #define IECLASS_REQUESTER 0x09 106 #define IEBQUALIFIER_RALT 0x0020 
38 /* this is a Menu Number transmission (Menu number is in ie_Code) */ 107 #define IEBQUALIFIER_LCOMMAND 0x0040 
39 #define JIECLASS_MENULIST Ox0A 108 #define IEQUALIFIER_RCOMMAND 0x0080 
40 /* User has selected the active Window's Close Gadget */ 109 #define IEQUALIFIER_NUMERICPAD 0x0100 
41 #define JECLASS_CLOSEWINDOW Ox0B 110 #define IFQUALIFIER_REPEAT 0x0200 
42 /* this Window has a new size */ 111 #define IEQUALIFIER_INTERRUPT — 0x0400 
43 #define IECLASS_SIZEWINDOW Qx0C 112 #define IEQUALIFIER_MULTIBROADCAST 0x0800 
44 /* the Window pointed to by ie _EventAddress needs to be refreshed */ 113 #define IBQUALIFIER_MIDBUTTON 0x1000 
45 #define IECLASS_| REFRESHWINDOW  0x0D 114 #define IEQUALIFIER_RBUTTON 0x2000 
46 /* new preferences are available */ 115 #define IEQUALIFIER_LEFTBUTTON 0x4000 
47 #define IECLASS_NEWPREFS Ox0E 116 #define IEQUALIFIER_RELATIVEMOUSE 0x8000 
48 /* the disk has been removed */ 117 
49 #define IECLASS_DISKREMOVED Ox0F 118 #define JEQUALIFIERB_LSHIFT 0 
50 /* the disk has been inserted */ 119 #define IEQUALIFIERB_RSHIFT 1 
51 #define TECLASS_DISKINSERTED Ox10 120 #define IEQUALIFIERB_CAPSLOCK 2 
52 /* the window is about to be been made active */ 121 #define IEQUALIFIERB_CONTROL 3 
53 #tdefine IECLASS_ACTIVEWINDOW Oxll 122 #define IEQUALIFIERB_LALT 4 
54 /* the window is about to be made inactive */ 123 #define JEQUALIFIERB_RALT 5 
55 #define IECLASS_INACTIVEWINDOW Oxl2 124 #define IEQUALIFIERB_LCOMMAND 6 
56 125 #define IEQUALIFIERB_RCOMMAND 7 
57 126 #define IEQUALIFIERB_NUMERICPAD 8 
58 /* the last class */ 127 #define IEQUALIFIERB_REPEAT 9 
59 #define IECLASS_MAX 0x12 128 #define IEQUALIFIERB_INTERRUPT 10 
60 129 #define IEQUALIFIERB_MULTIBROADCAST 11 
61 130 #define IEQUALIFIERB_MIDBUTTON 12 
62 131 #define IEQUALIFIERB_RBUTTON 13 
63 /*  ~-— InputEvent.ie_Code —— */ 132 #define IEQUALIFIERB_LEFTBUTTON 14 
64 /* IECLASS_RAWKEY */ 133 #define IFQUALIFIERB_RELATIVEMOUSE 15 
65 #define IECODE_UP_PREFIX 0x80 134 
66 #define IECODE_| | KEY CODE FIRST 0x00 135 /*-—--— InputEvent a IY 
67 #define IECODE_KEY_CODE_LAST 0x77 136 
68 #define IECODE_COMM_CODE_FIRST 0x78 137 struct InputEvent { 


69 #define IECODE COMM CODE LAST Ox7F 138 struct InputEvent *ie NextEvent; /* the chronologically next event */ 


Sep 19 20:25 1988 devices/inputevent.h Page 3 19 20:25 1988 devices/keyboard.h Page 1 


UBYTE ie Class; the input event class */ 
UBYTE ie_SubClass; optional subclass of the class */ 
UWORD ie Code; the input event code */ 
UWORD ie Qualifier; qualifiers in effect for the event*/ 
union { 
struct [ 
WORD ie_x; the pointer position for the event*/ 
WORD ie_y; ae 
} ie_xy; ad (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Ine. 
APTR ie_addr; ** All Rights Reserved 
} ie_position; */ 
struct timeval ie _TimeStamp; /* the system tick at the event */ 


#ifndef DEVICES _KEYBOARD_H 

#define DEVICES_KEYBOARD_H 

* 

ee $Filename: devices/keyboard.h $ 
xk $Release: 1.3 $ 

kk 


il Keyboard device command definitions 


WOrARUPWNE 


#tifndef &XEC_IO_H 
#include "exec/io.h" 
153 #define ie X ie_position.ie xy.ie_x #endif 
154 #define ie_Y ie_position.ie_xy.ie_y 
155 #define ie_EventAddress ie _position.ie_addr #define KBD _READEVENT (CMD_NONSTD+0) 
156 #define KBD _READMATRIX (CMD_NONSTD+1) 
157 #endif /* DEVICES_INPUTEVENT_H */ #define KBD _ADDRESETHANDLER (CMD _NONSTD+2) 
#define KBD_REMRESETHANDLER (CMD_NONSTD+3) 
#define KBD.RESETHANDLERDONE (CMD_NONSTD+4) 


#endif /* DEVICES KEYBOARD _H */ 








19 20:25.1988 devices/keymap.h Page 1 Sep 19 20:25 1988 devices/keymap.h Page 2 


Ox0f /* mask for index for lst of two dead keys */ 


70 #define DP_2DINDEXMASK 
/* shift for factor for lst of two dead keys */ 


#ifndef DEVICES_KEYMAP_H 7 
71 #define DP_2DFACSHIFT 4 


#define DEVICES_KEYMAP_H 


Me 


struct KeyMapNode { 
struct Node kn_Node; 
struct KeyMap kn_KeyMap; 


i 


/7* including name of keymap */ 


/* the structure of keymap.resource */ 
struct KeyMapResource [ 
struct Node kr_Node; 
struct List kr_List; 


3 


/* Key Map Types */ 


#define 
#define 


KC_NOQUAL 0 
KC_VANILLA 7 


#define KCB SHIFT 0 
#define KCF_SHIFT 0x01 
#define KCB_ALT 1 
#define KCF_ALT 0x02 


#define 
#define 
#define 
#define 


#define 
#define 


#define 
#define 


#define 
#define 


KCB_CONTROL 2 
KCF CONTROL 0x04 
KCB_DOWNUP 3 
KCF_DOWNUP 


0x08 


KCB_DEAD 5 
KCF_DBAD 


0x20 


KCB_STRING 6 
KCF_STRING 


0x40 


KCB_NOP 7 
KCF_NOP 


0x80 


/* Dead Prefix Bytes */ 


/* a list of KeyMapNodes */ 


/* note that SHIFT+ALT+CTRL is VANILLA */ 


/* may be dead or modified by dead key: */ 
f* use dead prefix bytes x/ 


1 
2 
3 /* . 72 
4.** $Filename: devices/keymap.h $ 73 #endif /* DEVICES_KEYMAP_H */ 
5 ** $Release: 1.3 $ 
6 ** 
bi ** keymap.resource definitions and console.device key map definitions 
ak 
9 **® (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 
*/ 
ftifmdef EXEC_NODES_H 
#include “exec/nodes.h" 
#tendif 
#ifndef EXEC_LISTS_H 
#include “exec/lists.h" 
#endif 
struct KeyMap [ 
UBYTE *km_LoKeyMapTypes ; 
ULONG xkm_LoKeyMap ; 
UBYTE *km_LoCapsable; 
UBYTE *km_LoRepeatable; 
UBYTE *km_HikeyMapTypes; 
ULONG  *km_HikeyMap; 
UBYTE *km_HiCapsable; 
UBYTE *km_HiRepeatable; 





#define DPB_MOD 0 
#define DPF_MOD 0x01 
#define DPB_DEAD 3 
#define DPF_DEAD 0x08 








oT -a 


Sep 19 20:25 1988 devices/narrator.h Page 1 


Sep 19 20:25 1988 


devices/narrator.h Page 2 


1 #ifndef DEVICES_NARRATOR_H 70 UWORD pitch; /7* Baseline pitch in Hertz */ 
2 #define DEVICES _NARRATOR_H 71 UWORD mode; 7* Pitch mode */ 
3 /* 72 UWORD sex; 7* Sex of voice */ 
4 xk $Filename: devices/narrator.h $ 73 UBYTE *ch_masks; 7* Pointer to audio alloc maps */ 
5 ** $Release: 1.3 $ 74 UWORD nm_masks; 7* Number of audio alloc maps xf 
6 ** 75 UWORD = volume; /* Volume. 0 (off) thru 64 *f 
7 «x 76 UWORD = sampfreq; 7* Audio sampling freq * 
8 xx 77 UBYTE mouths; /* If non-zero, generate mouths */ 
9 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 UBYTE  chanmask; 7* Which ch mask used (internal)*/ 

ak All Rights Reserved 79 UBYTE = numchan; /7* Num ch masks used (internal) */ 

*/ 0 ) UBYTE pad; /7* For alignment * 

#ifndef EXEC_IO_H 82 

#include "exec/io.h" 83 

#endif 84 

85 /* Standard Read request */ 
f* Error Codes «f/f 86 
87 struct mouth_rb [{ 

#define ND_NoMem —2 Can't allocate memory 88 struct narrator_rb voice; /* Speech IORB */ 

#define ND_NoAudLib -3 Can't open audio device 89 UBYTE width; /* Width (returned value) xf 

#tdefine ND MakeBad -4 Error in MakeLibrary call 90 UBYTE height; /* Height (returned value) */ 

#define ND UnitErr -5 Unit other than 0 91 UBYTE shape; /* Internal use, do not modify */ 

#define ND_CantAlloc ~—6 Can't allocate audio channel(s) 92 UBYTE pad; 7* For alignment */ 

#define ND_Unimpl -7 Unimplemented command 93 ; 

#define ND_NoWrite -8 Read for mouth without write first 94 

#define ND_Expunged ~-9 Can't open, deferred expunge bit set 95 #endif /* DEVICES_NARRATOR_H */ 


#define 
#define 
#tdefine 
#define 
#define 
#define 
#tdefine 


#define 
tdefine 
#define 
#define 
#define 
#tdefine 
#tdefine 
#define 
#define 
#define 


#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#tdefine 


—20 
-21 
—22 
-23 
24 
-25 
26 


Phoneme code spelling error 
Rate out of bounds 

Pitch out of bounds 

Sex not valid 

Mode not valid 

Sampling frequency out of bounds 
Volume out of bounds 


ND_PhonErr 
ND _ RateErr 
ND_PitchErr 
ND_SexErr 

ND_ModeErr 
ND_FreqErr 
ND_VolErr 


/* Input parameters and defaults */ 


Default pitch 

Default speaking rate (wpm) 
Default volume (full) 

Default sampling frequency (Hz) 
Male vocal tract 

Female vocal tract 

Natural pitch contours 
Monotone 

Default sex 


DEFPITCH 110 /* 
DEFRATE 150 

DEFVOL 64 

DEFFREQ 22200 

MALE 0 

PEMALE 1 

NATURALFO 0. 

ROBOTICFO 1 

DEFSEX MALE 


DEFMODE 


/* 


MINRATE 
MAXRATE 
MINPITCH 
MAXPITCH 
MINFREQ 
MAXFREQ 
MINVOL 
MAXVOL 


NATURALFO 


Default mode 


Parameter bounds 


/* Minimum 
Maximum 
7* Minimum 
Maximum 
Minimum 
Maximum 
Minimum 
Maximum 


*/ 


speaking rate 
speaking rate 
pitch 

pitch 

sampling frequency 
sampling frequency 
volume 

volume 


/* Standard Write request */ 


struct narrator_rb { 
struct IOStdReq message; 
UWORD rate; 


/* Standard IORB xf 
/* Speaking rate (words/minute) */ 








Tt -d 


Sep 


WOAND US WD he 


19 20:25 1988 devices/parallel.h Page 1 


#ifndef 
#define 
/* 
kk 
w* 
kk 
Kk 
w* 
KK 
Kk 


*/ 
#ifndef 


DEVICES_PARALLEL_H 
DEVICES_PARALLEL_H 


$Filename: devices/parallel.h $ 


$Release: 1.3 $ 


external declarations for Serial Port Driver 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


EXEC_IO_H 


#include "exec/io.h" 


#fendif 


struct 


i 


!EXEC_IO_H 


IoPArray { 
ULONG PTermArray0; 
ULONG PTermArrayl; 


FO ICICI IIS IIIT IO II IO III IIT AT TOTTI AIA TIKI III I ASIA ATRIA RIK | 


/* CAUTION |! 


IF YOU ACCESS the parallel.device, you MUST (!!!!) use 


an IOExtPar-sized structure or you may overlay innocent memory !! */ 
IRI RRO IOI I IIIT ITI TOOT IOI RII IIIA IA IISA IAI IAA AAAI ITAA 


struct 


* 


mrwooroe 


12 


14 
18 
1c 
1E 
IF 


20 
24 
28 
2c 


4H OH Oe OE HO Ee EEN 


1; 


#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 


STRUCT 


STRUCT 


STRUCT 


IOExtPar [{ 
struct IostdReq I0Par; 


MsgNode 
Suce 
Pred 
Type 
Pri 
Name 
ReplyPort 
MNLength 
IOExt. 
io Device 
jio_Unit 
io_Command 
io Flags 
io_Error 
TostdExt 
io Actual 
io_Length 
io _ Data 
jio_Offset 


APTR 
APTR 
UBYTE 
UBYTE 
APTR 
APTR 
UWORD 


APTR 
APTR 
UWORD 
UBYTE 
UBYTE 


ULONG 
ULONG 
APTR 

ULONG 


30 */ 


ULONG 
UBYTE 
UBYTE 
struct 


io_PExtFlags; 
io_Status; 
io _ParFlags; 


/* 


PARB_SHARED 5 
PARF_SHARED (1<«5) 
PARB_RAD BOOGIE 3 
PARF_RAD BOOGIE (1<<3) 
PARB_EOFMODE 1 
PARF EOFMODE (1<<1) 
IOPARB QUEUED 6 
JOPARF_QUEUED (1<¢<6) 
IOPARB_ABORT 
JOPARF_ABORT  (1¢<5) 
IOPARB_ACTIVE 4 
IOPARF_ACTIVE (1<<4) 
IOPTB_RWDIR 3 
IOPTF_RWDIR (1<<3) 


(mot used) flag extension area */ 


7* status of parallel port and registers */ 
/* see PARFLAGS bit definitions below */ 
IOPArray io _PTermArray; /* termination character array */ 


/* ParFlags non-exclusive access bit */ 


/* 


non-exclusive access mask */ 
(not. yet implemented) */ 
(not yet implemented) */ 
EOF mode enabled bit */ 

EOF mode enabled mask */ 
rgqst-queued bit */ 
rqst—queued mask */ 
rqst-aborted bit */ 
rqst-aborted mask */ 
rgqst-qued-or-current bit */ 
rqst~qued-or-current mask */ 


IO_ STATUS read=0,write=1 bit */ 


read=0,write=1 mask */ 





19 20:25 1988 devices/parallel.h Page 2 


#define IOPTB_PARSEL 2 
#define IOPTF_PARSEL  (1<<2) 


#tdefine 
#tdefine 
#define 
#define 
/* Note: 


IOPTB. PAPEROUT 1 
TOPTF PAPEROUT (1<<1) 
IOPTB_PARBUSY 0 
IOPTF_PARBUSY (1<<0) 


#define PARALLELNAME 


#define 
#define 


PDCMD_QUERY 
PDCMD_SETPARAMS 


#define 
#tdefine 
#define 
#define 
#define 
#define 
#tdefine 


ParErr_DevBusy 
ParErr_BufTooBig 
ParErr_InvParam 
ParErr_LineErr 
ParErr_NotOpen 
ParErr_PortReset 
ParErr_InitErr 


#endif 


previous versions of this include 


/* DEVICES_PARALLEL_H */ 


/* " printer selected on the Al1000 */ 
/* printer selected & serial "Ring Indicator" 
on the A500 & A2000. Be careful when 
making cables */ 

* " paper out bit */ 
/* " paper out mask */ 

* " printer in busy toggle bit */ 

* " printer in busy toggle mask */ 
files had bits 0 and 2 swapped */ 


“parallel .device" 


(CMD_NONSTD) 
(CMD_NONSTD+1) 


NOU PWN 





etl -d 


Sep 19 20:25 1988. devices/printer.h Page 1 Sep 19 20:25 1988 devices/printer.h Page 2 
















1 #ifndef DEVICES_PRINTER_H 70 
2 #define DEVICES PRINTER_H 71 #define aFNTO 34 /* ESC(B US char set or Typeface 0 (default) */ 

3 /* 72 #define aFNT1L 35 /* ESC(R French char set or Typeface 1 */ 

4 *e $Filename: devices/printer.h $ 73 #define aFNT2 36 /* ESC(K German char set or Typeface 2 */ 

5 ** $Release: 1.3 $ 74 #define aFNT3 37. /* ESC(A UK char set or Typeface 3 */ 

6 ** 75 #define aFNT4 38 /* ESC(E Danish I char set or Typeface 4 */ 

7 76 #tdefine aFNTS 39 /* ESC(H Sweden char set or Typeface 5 */ 

8 kx 77 #define aFNT6 40 /* ESC(Y Italian char set or Typeface 6 */ 

Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 #tdefine aFNT7 41. /* ESC(Z Spanish char set or Typeface 7 */ 

10 ** All Rights Reserved 79 #define aFNT8 42 /* ESC(J Japanese char set or Typeface 8 */ 
ll */ 80 #define aFNT9 43 /* ESC(6 Norweign char set or Typeface 9 */ 
8] #define aFNT1O 44 /* ESC(C Danish II char set or Typeface 10 */ 






#ifndef EXEC_NODES_H 
























14 #include "exec/nodes.h" 83 /* 
15 #endif 84 Suggested typefaces are: 
85 
17 #ifndef EXEC_LISTS_H 86 0 - default typeface. 
18 #include "exec/lists.h" 87 1 - Line Printer or equiv. 
19 #endif 88 2 - Pica or equiv. 
89 3 - Elite or equiv. 
#ifndef EXEC_PORTS_H 90 4 - Helvetica or equiv. 
22 #include "exec/ports.h" 91 5 - Times Roman or equiv. 
23 #tendif 92 6 -— Gothic or equiv. 
93 7 — Script or equiv. 
#define PRD_RAWWRITE (CMD_NONSTD+0) 94 8 - Prestige or equiv. 
26 #define PRD_PRTCOMMAND (CMD_NONSTD+1) 95 9 - Caslon or equiv. 
27 #define PRD_DUMPRPORT (CMD_NONSTD+2 ) 96 10 - Orator or equiv. 
28 #define PRD_QUERY (CMD_NONSTD+3) 97 */ 
98 
7* printer command definitions */ 99 #define aPROP2 45 /* ESC{2p proportional on t+4t */ 
100 #define aPROPlL 46 /* ESC[1lp proportional off +++ */ 
#define aRIS /* ESCc reset Iso */ 101 #define aPROPO 47 /* ESC[Op proportional. clear +44 */ 





102 #define aTSs 48 /* ESC{n 
103 #define aJFY5 49 /* ESC[5 auto left justify Iso */ 
104 #define aJFY7 50 /* ESC({7 F auto right justify Iso */ 


E set proportional offset ISO */ 
F 
F 
105 #define aJFY6 51 /* ESC[6 F auto full justify Iso */ 
F 
F 
F 


33 #define aRIN 
34 #define aIND 
35 #define aNEL 


36 #define aRI 


/7* ESC#1 initialize +44 */ 
/* ESCD lf ISO */ 
/* ESCE return,1f Iso */ 
/* ESCM reverse lf Iso */ 





WOnNDUN PWHKHO 
~ 
* 






37 106 #define aJFYO 52 /* ESC[O F auto justify off Iso */ 

38 #define aSGRO ESC{Om normal char set Iso */ 107 #define aJFY3 53 /* ESC(3 F letter space (justify) ISO (special) */ 
39 #define aSGR3 /* ESC(3m italics on Iso */ 108 #define aJFY1 54 /* ESC[1 F word fill(auto center) ISO (special) */ 
40 #define aSGR23 /* ESC[23m italics off Iso */ 109 

41 tdefine aSGR4 /* ESC[4m underline on Iso */ 110 #define aVERPO 55 /* ESC[Oz 1/8" line spacing ttt */ 

42 #define aSGR24 /* ESC([24m underline off Iso */ 111 #define aVERPl 56 /* EsCc[lz 1/6" line spacing +44 */ 

43 #define aSGRl 10 /* ESC{1lm boldface on _ Iso */ 112 #define aSLPP 57 /* ESC[nt set form length n DEC */ 

44 #define aSGR22 11 /* ESC(22m boldface off Iso */ 113 #define aPERF 58 /* ESC[nq perf skip n (n>0) ttt */ 






45 #define aSFC 12  /* SGR30-39 set foreground color ISO */ 
46 #define aSBC 13. /* SGR40-49 set background color ISO */ 


114 #define aPERFO 59 /* ESC{0q perf skip off +44 */ 







116 #define aLMS 60 /* ESCO Left margin set +++ */ 


















#define aSHORPO ESC{Ow normal pitch 117 #tdefine aRMS 61 /* ESCHO Right margin set tt */ 
49 #define aSHORP2 15 /* ESC[2w elite on DEC */ 118 #define aTMS 62 /* ESCH8 Top margin set t+ 8 / 
50 #define aSHORP1 16 /* ESC{lw elite off DEC */ 119 #define aBMS 63. /* ESCH2 Bottom marg set +++ */ 
51 #define aSHORP4 17 /* ESC[4w condensed fine on DEC */ 120 #define aSTBM 64 /* ESC[Pn1;Pn2r T&B margins DEC */ 
52 #define aSHORP3 18 /* ESC[3w condensed off DEC */ 121 #define aSLRM 65 /* ESC[Pnl;Pn2s L&R margin DEC */ 
53 #define aSHORP6 19 /* ESC[6w enlarged on DEC */ 122 #define aCAM 66 /* ESCH3 Clear margins +44 4 / 
54 #define aSHORP5 20 /* ESC[5w enlarged off DEC */ 123 






124 #define aHTS 67 /* ESCH Set horiz tab Iso */ 










#define aDEN6 21 /* ESC[6"z shadow print on DEC (sort of) */ 125 #define aVTS 68 /* ESCJ Set vertical tabs ISO */ 
57 #define aDENS 22 /* ESC(5"z shadow print off DEC */ 126 #define aTBCO 69 /* ESC[Og Clr horiz tab Iso */ 
58 #define aDEN4 23 /* ESC[4"z doublestrike on DEC */ 127 #define aTBC3 70 /* ESC[3g Clear all h tab Iso */ 
59 #define aDEN3 24 /* ESC[3"z doublestrike off DEC */ 128 #define aTBCl Jl /* ESC(lg Clr vertical tabs Iso */ 
60 #define aDEN2 25 /* ESC[2"z NLQ on DEC */ 129 #define aTBC4 72 /* ESC(4g Clr all v tabs Iso */ 
61 #define aDEN1 26 /* ESC({1"z NLQ off DEC */ 130 #define aTBCALL 73 /* ESCH4 Clr alli h & v tabs a4 ok / 









131 #define aTBSALL 74 /* ESC#5 Set default tabs +4 */ 
132 #define aEXTEND 75 /* ESC[Pn"x extended commands ttt */ 





#define aSUS2 27 /* ESC{2v superscript on +++ */ 








64 #define aSUS1l 28 /* ESC{lv superscript off +44 */ 133 

65 #define asSus4 29 /* ESC[{4v subscript on +44 */ 134 #define aRAW 76 /* ESC(Pn"r Next 'Pn' chars are raw +++ */ 
66 #define aSUSs3 30 /* ESC([3v subscript off tH+ kf 135 

67 #define asusoO 31 /* ESC[Ov normalize the line +44 */ 136 struct IoPrtcmdReq { 







137 struct Message io Message; 
138 struct Device *io Device; /* device node pointer */ 


68 #define aPLU 
69 #define aPLD 


ESCL partial line up 
ESCK partial line down 













el — a 








Sep 19 20:25 1988 devices/printer.h Page 3 


139 struct Unit *io_ Unit; /* unit (driver private)*/ 

140 UWORD io Command; 7* device command */ 

141 UBYTE io Flags; 

142 BYTE io_Error; /7* error or warning num */ 

143 UWORD io _PrtCommand; /* printer command */ 

144 UBYTE io _Parm0; /* first command parameter */ 

145 UBYTE io _Parml; /* second command parameter */ 

146 UBYTE io _Parm2; /* third command parameter */ 

147 UBYTE io _Parm3; 7* fourth command parameter */ 

148 3; 

149 

150 struct IODRPReq [ 

151 struct Message io_Message; 

152 struct. Device *io_Device; /7* device node pointer */ 

153 struct Unit *jio Unit; /7* unit (driver private)*/ 

154 UWORD io Command; /* device command */ 

155 UBYTE io_Flags; 

156 BYTE io_Error; /* error or warning num */ 

157 struct RastPort *io RastPort; /* raster port */ 

158 struct ColorMap *io_ColorMap; /* color map */ 

159 ULONG io Modes; /* graphics viewport modes */ 

160 UWORD io_SreX; /* source x origin */ 

161 UWORD = io_SreyY; /* source y origin */ 

162 UWORD io_SreWidth; /* source x width */ 

163 UWORD io SrcHeight; /* source x height */ 

164 LONG io_DestCols; 7* destination x width */ 

165 LONG lo DestRows; /7* destination y height */ 

166 UWORD io_Special; /* option flags */ 

167 3; 

168 

169 #define SPECIAL _MILCOLS 0x0001 /* DestCols specified in 1/1000" */ 
170 #define SPECIAL _MILROWS 0x0002 /* DestRows specified in 1/1000" */ 
171 #define SPECIAL _FULLCOLS 0x0004 /* make DestCols maximum possible */ 
172 #define SPECIAL _FULLROWS 0x0008 /* make DestRows maximum possible */ 
173 #define SPECIAL_FRACCOLS 0x0010 /* DestCols is fraction of FULLCOLS */ 
174 #define SPECIAL FRACROWS 0x0020 /* DestRows is fraction of FULLROWS */ 
175 #define SPECIAL CENTER 0x0040 /* center image on paper */ 

176 #define SPECIAL_ASPECT 0x0080 /* ensure correct aspect ratio */ 

177 #define SPECIAL_DENSITY1 0x0100 /* lowest resolution (dpi) */ 

178 #define SPECIAL_DENSITY2 0x0200 /* next res */ 

179 #define SPECIAL _DENSITY3 0x0300 /* next res */ 

180 #define SPECIAL _DENSITY4 0x0400 /* next res */ 

181 #define SPECIAL_DENSITY5 0x0500 /* next res */ 

182 #define SPECIAL_DENSITY6 0x0600 /* next res */ 

183 #define SPECIAL. DENSITY7 0x0700 /* highest res */ 

184 #define SPECIAL NOFORMFEED 0x0800 /* don't eject paper on gfx prints */ 
185 #define SPECIAL _TRUSTME 0x1000 /* don't reset on gfx prints */ 

186 /* 

187 Compute print size, set 'io_DestCols' and ‘io DestRows' in the calling 
188 program's 'IODRPReg' structure and exit, DON'T PRINT. This allows the 
189 calling program to see what the final print size would be in printer 
190 pixels. Note that it modifies the 'io_DestCols' and ‘io DestRows' 
191 fields of your 'IODRPReq' structure. Also, set the print density and 
192 update the 'MaxxDots', 'MaxyDots', 'xDotsInch', and 'YDotsInch' fields 
193 of the 'PrinterExtendedData' structure. 

194 */ 

195 #define SPECIAL_NOPRINT 0x2000 /* see above */ 

196 

197 #define PDERR_NOERR 0 /* clean exit, no errors */ 

198 #define PDERR_CANCEL 1 /* user cancelled print */ 

199 #define PDERR_NOTGRAPHICS 2 7* printer cannot output graphics */ 
200 #define PDERR_INVERTHAM 3 /* OBSOLETE */ 

201 #define PDERR_BADDIMENSION 4 /* print dimensions illegal */ 

202 #define PDERR_DIMENSIONOVFLOW 5 /* OBSOLETE */ 

203 #define PDERR_INTERNALMEMORY 6 /* no memory for internal variables */ 
204 #define PDERR_BUFFERMEMORY 7 7* no memory for print buffer */ 

205 /* 

206 Note : this is an internal error that can be returned from the render 
207 function to the printer device. It is NEVER returned to the user. 











Sep 


208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 


19 20:25 1988 devices/printer.h Page 4 


If the printer device sees this error it converts it “PDERR_NOERR ' 


and exits gracefully. 
‘How to Write a Graphics Printer 
* 


#tdefine PDERR_TOOKCONTROL 8 


/* internal use */ 

#define SPECIAL_DENSITYMASK 

#define SPECIAL DIMENSIONSMASK \ 
SPECIAL _MILCOLS | SPECIAL MILROWS 
SPECIAL_FRACCOLS 


#endif /* DEVICES _PRINTER_H */ 


Refer to the document on 


Driver' for more info. 


/* Took control in case 0 of render */ 


0x0700 /* masks out density values */ 


| SPECIAL_FULLCOLS | SPECIAL_FULLROWS\, 


| SPECIAL_FRACROWS | SPECIAL_ASPECT) 





7T — a 


Sep 19 20:25 1988 devices/prtbase.h Page 1 


19 20:25 1988 devices/prtbase.h Page 2 


#define 
#define 


#define 
#tdefine 


1; 


struct IOExtPar pd_p0; 
struct IOExtSer pd_s0; 


} pd_ior0; 


pd_PIORO pd_ior0.pd_pod 
pd_SIORO pd_ior0.pd_s0 


7* and 1 for double buffering */ 


struct IOExtPar pd_pl; 
struct IOExtSer pd_sl; 


} pd_iorl; 


pd_PIOR1 pd_iorl.pd_pl 
pd_SIOR1 pd_iorl.pd_sl 


union { 


struct timerequest pd_TIOR; 7* timer I/O request */ 

struct MsgPort pd_IORPort; /* and message reply port */ 
struct. Task pd_TC; /* write task */ 

UBYTE pd_Stk[P_STKSIZE]; ft and stack space */ 

UBYTE pd Flags; /* device flags */ 

UBYTE pd_pad; 

struct Preferences pd_Preferences; /* the latest preferences */ 
UBYTE  pd_PWaitBnabled; /* wait function switch */ 


/* Printer Class */ 


#define 
#define 
#define 
#define 


#tdefine 
#define 
#define 
#tdefine 


graphics (bit position) */ 
graphics (and/or flag) */ 
color (bit position) */ 
color (and/or flag) */ 


PPCB_ GFX 0 
PPCF_GFX Oxl 
PPCB_COLOR 1 
PPCF_COLOR 0x2 


blackéwhite alphanumerics */ 
black&white graphics */ 
color alphanumerics */ 

color graphics */ 


0x00 
Ox01 
0x02 
0x03 


PPC_BWALPHA 
PPC_BWGFX 
PPC_COLORALPHA 
PPC_COLORGFX 


/* Color Class */ 


#tdefine 
tdefine 
#define 
#define 
#tdefine 
#define 
#tdefine 
#tdefine 
#define 
#define 


/* 


* 
#define 


0x01 
0x02 
0x03 
0x04 
0x04 
0x08 
0x09 
0x0A 
0x0B 
0x0C 


blackéwhite only */ 
yellow/magenta/cyan only */ 
yellow/magenta/cyan or blackswhite */ 
yellow/magenta/cyan/black */ 

a flag for YMCB and BGRW */ 

not ymcb but blue/green/red/white */ 
black&white only, 0 == BLACK */ 
blue/green/red */ 

blue/green/red or blackséwhite */ 
blue/green/red/white */ 


PCC_BW 
PCC_YMC 

PCC YMC_BW 
PCC_YMCB 
PCC” 4COLOR 
PCC_ADDITIVE 
PCC_WB 
PCC_BGR 
PCC_BGR_WB 
PCC_BGRW 


The picture must be scanned once for each color component, as the 


printer can only define one color at a time. ie. If 'PCC_YMC' then 
first pass sends all 'Y' info to printer, second pass sends al] 'M' 
info, and third pass sends all C info to printer. The CalComp 
PlotMaster is an example of this type of printer. 


PCC_MULTI_PASS 0x10 /* see explanation above */ 


struct PrinterExtendedData { 


printer name, null terminated */ 
called after LoadSeg */ 


char 
VOID 


*ped_PrinterName; 
(*ped_Init)(); 


1 #ifndef DEVICES_PRTBASE_H 
a ftdefine DEVICES PRTBASE_H 
/* 
4 ** $Filename: devices/prtbase.h $ 
5 *e $Release: 1.3 $ 
6 ** 
7 ** printer device data definition 
8 ** 
9 ** (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
ll */ 
12 
13 #ifndef EXEC_NODES_H 
14 #include "“exec/nodes.h" 
15 #endif 
16 #ifndef EXEC_LISTS_H 
17 #include "exec/lists.h" 
18 #endif 
19 #ifndef _EXEC_PORTS_H 
20 #include "exec/ports.h" 
21 #endif 
22 #ifndef EXEC_LIBRARIES _H 
23 #include “exec/libraries.h" 
24 #tendif 
25 #ifndef EXEC_TASKS H 
26 #include "exec/tasks.h" 
27 #endif 
28 
29 #ifndef DEVICES _PARALLEL_H 
30 #include "devices/parallel.h" 
31 #endif 
32 #ifndef . DEVICES SERIAL H 
33 #include "devices/serial.h" 
34 #tendif 
35 #ifndef DEVICES_TIMER_H 
36 #include "devices/timer.h" 
37 #endif 
38 #ifndef LIBRARIES_DOSEXTENS_I 
39 #include "libraries/dosextens.h" 
40 #tendif 
41 #ifndef INTUITION_INTUITION_H 
42 #include "intuition/intuition.h" 
43 #endif 
44 
45 
46 struct DeviceData [{ 
47 struct Library dd_Device; /* standard library node */ 
48 APTR dd_Segment,; /* AQ when initialized */ 
49 APTR dd_ExecBase; /* A6 for exec */ 
50 APTR dd_CmdVectors ; 7* command table for device commands */ 
51 APTR dd_CmdBytes; 7* bytes describing which command queue */ 
52 UWORD dd_NumCommands; 7* the number of commands supported */ 
53 }; 
54 
55 #tdefine P_STKSIZE 0x0800 /* stack size for child task */ 
56 #define P_BUFSIZE 256 7* size of internal buffers for text i/o */ 
57 #define P_SAPESIZE 128 /* safety margin for text output buffer */ 
58 
59 struct PrinterData { 
60 struct DeviceData pd Device; 
61 struct MsgPort pd_Unit; /* the one and only unit */ 
62 BPTR pd_PrinterSegment; /* the printer specific segment */ 
63 UWORD pd_PrinterType; 7* the segment printer type */ 
64 /* the segment data structure */ 
65 struct PrinterSegment *pd_SegmentData; 
66 UBYTE *pd_PrintBuf; /7* the raster print buffer */ 
67 int (*pd_PWrite)(); 7* the write function */ 
68 int (*pd_PBothReady)(); /* write function's done */ 


69 union { 


7* port I/O request 0 */ 


called before UnLoadSeg */ 

called at OpenDevice */ 

called at CloseDevice */ 

printer class */ 

color class */ 

number of print columns available */ 
number of character sets */ 

number of ‘pins' in print head */ 
number of dots max in a raster dump */ 
number of dots max in a raster dump */ 


VOID 
int 
VOID 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UWORD 
ULONG 
ULONG 


(*ped_Expunge) (); 
(*ped_Open)(); 
(*ped_Close)(); 
ped_PrinterClass; 
ped_ColorClass; 
ped_MaxColumns; 
ped_NumCharSets; 
ped_NumRows ; 
ped_MaxXDots; 
ped_MaxYDots; 





st -ad 


Sep 19 20:25 1988 devices/prtbase.h Page 3 Sep 26 18:24 1988 devices/prtgfx.h Page 1 


139 UWORD |_ XDotsInch; /* horizontal dot density */ 1 #ifndef DEVICES_PRTGFX_H 

140 UWORD |_YDotsInch; /* vertical dot density */ 2 #define DEVICES_PRTGFX_H 

141 char ***ped_Commands ; /* printer text command table */ 3 /* 

142 int (*ped_DoSpecial)(); /* special command handler */ 4 ** $Filename: devices/prtgfx.h $ 

143 int (*ped_Render) (); /* raster render function */ 5 ** $Release: 1.3 $ 

144 LONG ped_TimeoutSecs; * good write timeout */ 6 ** 

145 /* the following only exists if the segment version is >= 33 */ 7 *® 

146 char *kped 8BitChars; /* conv. strings for the extended font */ 8 ** 

147 LONG ped_PrintMode; /* set if text printed, otherwise 0 */ 9 ** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 

148 /* the following only exists if the segment version is >= 34 */ 10 ** All Rights Reserved 

149 /* ptr to conversion function for all chars */ il */ 

150 int (*ped_ConvFunc) (); 12 

151 ); 13 #define PCMYELLOW 0 /* byte index for yellow */ 

152 14 #define PCMMAGENTA 1 /* byte index for magenta */ 

153 struct PrinterSegment [ 15 #define PCMCYAN 2 /* byte index for cyan */ 

154 ULONG ps _NextSegment; 7* (actually a BPTR) */ 16 #define PCMBLACK 3 /* byte index for black */ 

155 ULONG_ ps_runAlert; /* MOVEQ #0,D0 : RTS */ 17 #define PCMBLUE PCMYELLOW 7* byte index for blue */ 

156 UWORD = ps_Version; /7* segment version */ 18 #define PCMGREEN PCMMAGENTA /* byte index for green */ 

157 UWORD _— ps_ Revision; /* segment revision */ 19 #define PCMRED PCMCYAN /* byte index for red */ 

158 struct PrinterExtendedData ps_PED; /* printer extended data */ 20 #define PCMWHITE PCMBLACK /* byte index for white */ 

159 }; 1 

160 22 union colorEntry [ 

161 #endif /* DEVICES_PRTBASE_H */ 23 ULONG colorLong; /* quick access to all of YMCB */ 
24 UBYTE colorByte[4]; /* 1 entry for each of YMCB */ 
25 BYTE colorSByte[4]; /* ditto (except signed) */ 
26 |; 
27 
28 struct PrtInfo { /* printer info */ 
29 int (*pi_render)(); /* PRIVATE — DO NOT USE! */ 
30 struct RastPort *pi_rp; /* PRIVATE ~— DO NOT USE! */ 
31 struct RastPort *pi_temprp; /7* PRIVATE — DO NOT USE! */ 
32 UWORD *pi_RowBuf; /* PRIVATE — DO NOT USE! */ 
33 UWORD *pi_HamBuf; /* PRIVATE ~- DO NOT USE! */ 
34 union colorEntry *pi_ColorMap; /* PRIVATE — DO NOT USE! */ 
35 union colorEntry *pi ColorInt; /* color intensities for entire row */ 
36 union colorEntry *pi_HamiInt; 7* PRIVATE ~ DO NOT USE! */ 
37 union colorEntry *pi_DestlInt; /* PRIVATE - DO NOT USE! */ 
38 union colorEntry *pi_Dest2Int; /* PRIVATE — DO NOT USE! */ 
39 UWORD *pi_ScaleXx; /* array of scale values for X */ 
40 UWORD *pi_ScaleXAlt; /* PRIVATE ~ DO NOT USE! */ 
41 UBYTE *pi_dmatrix; /7* pointer to dither matrix */ 
42 UWORD *pi_TopBuf; : /* PRIVATE — DO NOT USE! xf 
43 UWORD *pi_BotBuf; /* PRIVATE ~ DO NOT USE! */ 
44 
45 UWORD pi_RowBufSize; /* PRIVATE — DO NOT USE! */ 
46 UWORD pi_HamBufSize; /* PRIVATE — DO NOT USE! */ 
47 UWORD pi_ColorMapSize; /* PRIVATE ~ DO NOT USE! */ 
48 UWORD pi_ColorIntsize; /* PRIVATE — DO NOT USE! */ 
49 UWORD pi_HamIntSize; /7* PRIVATE - DO NOT USE! */ 
50 UWORD pi_DestlintSize; /* PRIVATE — DO NOT USE! */ 
51 UWORD pi_Dest2IntSize; /* PRIVATE — DO NOT USE! */ 
52 UWORD pi_ScalexSize; /* PRIVATE — DO NOT USE! */ 
33 UWORD pi ScaleXAltSize; /* PRIVATE — DO NOT USE! */ 
4 
55 UWORD pi _PrefsFlags; /* PRIVATE ~ DO NOT USE! */ 
56 ULONG pi_special; /* PRIVATE ~— DO NOT USE! */ 
57 UWORD pi_xstart; /* PRIVATE — DO NOT USE! */ 
58 UWORD pi_ystart; /* PRIVATE ~ DO NOT USE! x/ 
59 UWORD pi_width; /* source width (in pixels) */ 
60 UWORD pi_height; /* PRIVATE — DO NOT USE! */ 
61 ULONG pi_pe; 7* PRIVATE — DO NOT USE! */ 
62 ULONG pi_pr; 7* PRIVATE — DO NOT USE! */ 
63 UWORD pi_ymult; 7* PRIVATE — DO NOT USE! */ 
64 UWORD pi_ymod; /* PRIVATE — DO NOT USE! */ 
65 WORD pi_ety; /* PRIVATE — DO NOT USE! */ 
66 UWORD pi_xpos; /* offset to start printing picture */ 
67 UWORD pi_threshold; /7* threshold value (from prefs) */ 
68 UWORD pi_tempwidth; 7* PRIVATE — DO NOT USE! */ 


69 UWORD pi_flags; /* PRIVATE - DO NOT USE! */ 








9T - a 





Sep 26 18:24 1988 devices/prtgfx.h Page 2 


70 J; 
71 
72 #endif /* DEVICES PRTGFX_H */ 


Sep 


WONANA UNSW 


19 





20:25 1988 devices/scsidisk.h Page 1 


#ifndef DEVICES SCSIDISK_H 
#define DEVICES _SCSIDISK H 


f* 
ak 
xk 
ak 
xk 
kk 
KK 
xk 


*/ 


$Filename: devices/scsidisk.h $ 
$Release: 1.3 $ 


SCSI exec-level device command 


(C) Copyright 1988 Commodore-Amiga, Inc. 
All Rights Reserved 





~~ 
* 


2% % OO HO OOOO OOOO OOO OOOO 


SCSI Command 
Several Amiga SCSI controller manufacturers are converging on 
standard ways to talk to their controllers. This include 
file describes an exec-device command (e.g. for hddisk.device) 
that can be used to issue SCSI commands 


UNIT NUMBERS 
Unit numbers to the OpenDevice call have encoded in them which 
SCSI device is being referred to. The three decimal digits of 
the unit number refer to the SCSI Target ID (bus address) in 
the 1's digit, the SCSI logical unit (LUN) in the 10's digit, 
and the controller board. in the 100's digit. 


Examples: 
drive at address 0 
12 LUN 1 on multiple drive controller at address 2 
104 second controller board, address 4 
88 not valid: both logical units and addresses 
range from 0..7. 
CAVEATS 


Original 2090 code did not support this command. 


Commodore 2090/2090A unit numbers are different. The SCSI 
logical unit is the 100's digit, and the SCSI Target ID 
is a permuted 1's digit: Target ID 0..6 maps to unit 3..9 
(7 is reserved for the controller). 


Examples: 
"3 drive at address 0 
109 drive at address 6, logical unit 1 
1 not valid: this is not a SCSI unit. Perhaps 


it's an ST506 unit. 


Some controller boards generate a unique name (e.g. 2090A's 
iddisk.device) for the second controller board, instead of 
implementing the 100's digit. 


There are optional restrictions on the alignment, bus 
accessability, and size of the data for the data phase. 
Be conservative to work with all manufacturer's controllers. 


* 
| 
{ 
I 
[ 
[ 
| 
t 
| 
I 
| 
[ 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
i 
| 
t 
| 
| 
| 
| 
| 
] 
j 
{ 
| 
| 
i 
| 
{ 
{ 
| 
{ 
[ 
| 
| 
It 
[ 
| 
| 
| 
| 
| 
| 
| 
I 
( 
I 
I 
| 
{ 
] 
| 
| 
| 

* 

N 


#define HD_SCSICMD 28 /* issue a SCSI command to the unit */ 


/* io_Data points to a ScSICmd */ 
/7* io_Length is sizeof(struct Scsicmd) */ 
7* io_Actual and io Offset are not used */ 


struct ScsIcmd { 


UWORD *scsi_Data; 7* word aligned data for SCSI Data Phase */ 
/* (optional) data need not be byte aligned */ 
7* (optional) data need not be bus accessable * 
ULONG scsi_Length; 7* even length of Data area */ 
/* (optional) data can have odd length */ 


iT -da 








19 20:25 1988 devices/scsidisk.h Page 2 Sep 19 20:25 1988 devices/serial.h Page 1 











7* (optional) data length can be > 2**24 */ 1 #ifndef DEVICES_SERIAL_H 
ULONG  sesi_Actual; /7* actual Data used */ 2 #define DEVICES SERIAL _H 
UBYTE *scsi_Command; /* SCSI Command (same options as scsi_Data) */ 3 
UWORD ~~ scsi_CmdLength; /7* length of Command */ 4 /* 
UWORD -sesi_CmdActual; /* actual Command used */ 5 ** $Filename: devices/serial.h $ 
UBYTE sesi_Flags; /7* includes intended data direction */ 6 ** SRelease: 1.3 $ 
UBYTE sesi_Status; /* SCSI status of command */ 7 *® 
li 8 xx external declarations for the serial device 
9 * 
10 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
/*--——— scsi_Flags -~~~~ */ LL ** All Rights Reserved 
#define SCSIF_WRITE 0 /* intended data direction is out */ 12 */ 
#define SCSIF_READ 1 /* intended data direction is in */ 13 
14 #ifndef EXEC_IO_H 
[*- scst io Error values —_-_—*/ 15 #include "“exec/io.h" 
#define HFERR_SelfUnit 40 /7* cannot issue SCSI command to self */ | 16 #endif /* EXEC_IO_H */ 
#define HFERR_DMA 41 7* DMA error */ 17 ~ 
#define HFERR_Phase 42 /* illegal or unexpected SCSI phase */ 18 /* array of termination char's */ 
#define HFERR_Parity 43 /* SCSI parity error */ 19 /* to use,see serial.doc. setparams */ 
#define HFERR_SelTimeout 44 /* Select timed out */ 20 
#define HFERR_BadStatus 45 /* status and/or sense error */ 21 struct IoTArray { 
22 ULONG TermArray0; 
[ro OpenDevice io_Error values —-——— *f 23 ULONG TermArrayl; 
#define HFERR_NoBoard 50 /7* Open failed for non-existant board */| 24 }; 
25 
#endif /* DEVICES SCSIDISK_H */ 26 
27 #define SER_DEFAULT_CTLCHAR 0x11130000 /* default chars for xON,XxOFF */ 
28 /* You may Change these via SETPARAMS. At this time, parity is not 
29 calculated for xON/XOFF characters. You must supply them with the 
30 desired parity. */ 
1 
35 [BOI TCTCIOI I ICICI TTI I IT IIA II IIIA IIA IS IAI SSA III III 
33 /* CAUTION !! IF YOU ACCESS the serial.device, you MUST (!!!!) use an 
34 TOExtSer-sized structure or you may overlay innocent memory !! */ 
35 ICAI IIIT CIO IIR IO ICTR RAR II III IAI III IIR ITT IR SAK 
36 
37. struct IOExtSer [ 
38 struct TostdReq IOSer; 
39 
40 /* STRUCT MsgNode 
41 * 0 APTR Suce 
42 * 4 APTR Pred 
43 * 8 UBYTE Type 
44 * 9 UBYTE Pri 
45 * A APTR Name 
46 *  E  APTR ReplyPort 
47 * 12 UWORD MNLength 
48 * STRUCT IOEXt 
49 * 14 APTR io_Device 
50 * 18 APTR io Unit 
51 * 1c  UWORD 10_Command 
52 * l1E  UBYTE io_Flags 
53 * 1F  UBYTE io Error 
54 * STRUCT TOStdExt 
55 * 20 ULONG io_ Actual 
56 * 24 ULONG io_Length 
57 * 28 APTR io Data 
58 * 2C  ULONG io_Offset 
59 * 
60 * 30 */ 
61 ULONG io_Ctlchar; /* control char's (order = xON,xOFF,INQ,ACK) */ 
62 ULONG  io_RBufLen; /* length in bytes of serial port's read buffer */ 
63 ULONG io_ExtFlags; /* additional serial flags (see bitdefs below) */ 
64 ULONG io_Baud; /* baud rate requested (true baud) */ 
65 ULONG io BrkTime; /* duration of break signal in MICROseconds */ 
66 struct I0TArray io_TermArray; /* termination character array */ 
67 UBYTE io_ReadLen; /* bits per read character (# of bits) */ 


68 UBYTE  io_WriteLen; /* bits per write character (# of bits) */ 
69 UBYTE io_StopBits; /* stopbits for read (# of bits) */ 











8I -a 








138 


Sep 19 20:25 1988 devices/serial.h Page 2 


/* see SerFlags bit definitions below 


*/ 


Connected to parallel "select" on the A1000. 


Connected to. both the parallel "select" and 
serial "ring indicator" pins on the A500 «& 


Take care when making cables. 


UBYTE io _SerFlags; 

UWORD io_Status; 
li 

7* status of serial port, as follows: 
* BIT ACTIVE FUNCTION 
* 0 ———~ reserved 
* 1 -—- reserved 
* 2 high 
x 
* 
* A2000. 
* 3 low Data Set Ready 
* 4 low Clear To Send 
* 5 low Carrier Detect 
* 6 low Ready To Send 
* 7 low Data Terminal Ready 
* 8 high read overrun 
* 9 high break sent 
* 10 high break received 
* li high transmit x-OFFed 
* 12 high receive x-OFFed 
* 13-15 reserved 
*/ 
#define SDCMD_QUERY CMD_NONSTD 
#define SDCMD_BREAK (CMD_NONSTD+1) 
#define | SDCMD_SETPARAMS (CMD_NONSTD+2) 
#tdefine SERB_XDISABLED 7 


#tdefine SERF_XDISABLED (1<<7) /* 

#define SERB _EOFMODE 6 /* " 
#define SERF_EOFMODE (1<<6)/* " 
#define SERB SHARED 5 /* " 
#define SERF_SHARED (1<<5) 0 /* " 
#define SERB_RAD BOOGIE 4 /* " 
#define SERF_RAD BOOGIE (1<<4) /* " 
#define SERB_QUEUEDBRK 3 /* " 
#define SERF_QUEUEDBRK (1<<3) /* " 
#define SERB 7WIRE 2 /* " 
#define SERF_7WIRE (1<<2) /* " 
#define SERB-PARTY_ODD 1 /* " 
#define SERF_PARTY_ODD (1<<1) /* " 
#define SERB_PARTY_ON 0 /* " 
#define SERF PARTY_ON (1<<0) /* " 


/7* These now refect the actual bit 


#define I0 | STATB | XOFFREAD 12 
#define IO_STATF_XOFFREAD (1¢<<12) /* 
#define IO_STATB_XOFFWRITE 11 /* 
#define IO_STATF_XOFFWRITE (1<<1l) /* 
#define IO_STATB_READBREAK 10 /* 
#define IO_STATF READBREAK (1<<10) /* 
#define IO _STATB_WROTEBREAK 9 ~* 
#define Io: STATF | WROTEBREAK (1<<9) /* 
#tdefine IO: STATB OVERRUN 8 w* 
#define IO STATF OVERRUN (1<<8) /* 
#tdefine SEXTB_MSPON 1 /* 

/* 
#define SEXTF_MSPON (l<<l)  /* " 
#define SEXTB_MARK 0 /* " 
#tdefine SEXTF_MARK (1<<0) /* " 
#define SerErr DevBusy 1 
#define SerErr_BufErr 4 
#tdefine SerErr_InvParam 5 


io_ExtFlags. 


/* lo _SerFlags xOn-xOff feature disabled bit */ 


xOn-xOff feature disabled mask */ 
EOF mode enabled bit */ 

EOF mode enabled mask */ 
non-exclusive access bit */ 
non-exclusive access mask */ 
high-speed mode active bit */ 
high-speed mode active mask */ 
queue this Break ioRqst */ 
queue this Break ioRqst */ 
RS232 7-wire protocol */ 

RS232 7-wire protocol */ 
parity feature enabled bit */ 
parity feature enabled mask */ 
parity-enabled bit */ 
parity-enabled mask */ 


positions in the io_Status UWORD */ 
/7* io Status receive currently xOFF'ed bit * 


receive currently xOFF'ed mask * 
transmit currently xOFF'ed bit * 
transmit currently xOFF'ed mask * 
break was latest input bit */ 
break was latest input mask */ 
break was latest output bit */ 
break was latest output mask */ 
status word RBF overrun bit */ 
status word RBF overrun mask */ 


Use mark-space parity, */ 
instead of odd-even. */ 
mark-space parity mask */ 

if mark-space, use mark */ 

if mark-space, use mark mask */ 


/7* Failed to allocate new read buffer * 





140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 


19 20:25 1988 devices/serial.h Page 3 


#define 
#define 
#define 
#define 
#define 
#define 


#ifdef 

#define 
#tdefine 
#define 
#define 
#tdefine 
#define 


/* These defines refer to the HIGH ORDER byte of io_ Status. 
replaced by the new, corrected ones above */ 


been 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tendif 


tdefine 


fendif 


SerErr_LineErr 6 
SerErr_ParityErr 9 
SerErr_ TimerErr il 
SerErr_BufOverflow 12 
SerErr_NoDSR 13 


SerErr DetectedBreak 15 


DEVICES_SERIAL H_ OBSOLET' 
SerErr_BaudMismatch 2 
SerErr_InvBaud 3 
SerErr_NotOpen 7 
SerErr_PortReset 8 
SerErr_InitErr 10 
SerErr_NocTSs 14 


IOSTB_XOFFREAD 4 
IOSTF_XOFFREAD (1<<4) 
JOSTB_XOFFWRITE 3 
IOSTF_XOFFWRITE (1<<3) 
IOSTB_READBREAK 2 
IOSTF_READBREAK (1<<2) 
IOSTB_WROTEBREAK 1 
IOSTF WROTEBREAK (1<<1) 
IOSTB_OVERRUN 0 
IOSTF_OVERRUN  (1<<0) 


IOSERB_BUFRREAD 7 
IOSERF_BUFRREAD (1<<7) 


IOSERB_QUEUED. 6 
IOSERF QUEUED  (1<<6) 
IOSERB_ABORT 5 
IOSERF_ABORT (1<<5) 


IOSERB_ ACTIVE 4 
IOSERF_ACTIVE  (1<<4) 


/* DEVICES SERIAL _H OBSOLETE */ 


SERTALNAME 


/* DEVICES SERIAL H */ 


“serial .device" 













/*(See the serial/OpenDevice autodoc)*/ 


E 

unused 
unused 
unused 
unused 
unused 
* unused * 
They have 


/* iost_ hob receive currently xOFF'ed bit */ 


/* receive currently xOFF'ed mask */ 
/* " transmit currently xOFF'ed bit */ 
/* " transmit currently xOFF'ed mask */ 
/* " break was latest input bit */ 

/* " break was latest input mask */ 

/* " break was latest output bit */ 

/* " break was latest output mask */ 

f* " status word RBF overrun bit */ 

/* " status word RBF overrun mask */ 

/* io Flags from read buffer bit */ 


{* " from read buffer mask */ 


/* " rqst-queued bit */ 

/* " rqst—queued mask */ 

/* " rqst-aborted bit */ 

/* " rqst-aborted mask */ 

{* " rqst-qued-or-current bit */ 
/* " rgqst-qued-or-current mask */ 





6T - a 















OONAHANSWNE 











19 20:25 1988 devices/timer.h Page 1 


#ifndef DEVICES _TIMER_H 

#define DEVICES_TIMER_H 

/* 

ae $Filename: devices/timer.h $ 
xk $Release: 1.3 $ 

aK* 

ax 

ak 

xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 

*/ 

#ifndef EXEC_IO_H 


#include “exec/io.h" 
#endif EXEC_IO_H 


/* unit defintions */ 


#define UNIT_MICROHZ 0 
#define UNIT_VBLANK 1 
#define TIMERNAME "timer .device" 


struct timeval { 
ULONG tv_secs; 
ULONG tv_micro; 
7 


struct timerequest { 
struct IORequest tr_node; 
struct timeval tr_time; 


li 


/* IO_COMMAND to use for adding a timer */ 
#define TR_ADDREQUEST CMD_NONSTD 

#tdefine TR_GETSYSTIME (CMD_NONSTD+1 ) 
#tdefine TR_SETSYSTIME (CMD_NONSTD+2 ) 


fendif /* DEVICES TIMER _H */ 





1 
2 
3 
4 
5 
6 
7 
8 
9 


19 20:25 1988 devices/trackdisk.h Page 1 


#ifndef DEVICES_TRACKDISK_H 
#define DEVICES_TRACKDISK_H 


* 
a $Filename: devices/trackdisk.h $ 
** $Release: 1.3 $ 
Kk 
kk 
kk 
x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 
*/ 


#ifndef EXEC_IO_H 
#include "exec/io.h" 
#tendif !EXEC_IO_H 


#ifndef EXEC _DEVICES_H 
#include "“exec/devices.h" 
#endif !EXEC_DEVICES_H 





/* 
fee Aa 
* 
* Physical drive constants 
* 
i 
*/ 
/* OBSOLETE —- use the TD_GETNUMTRACKS command! */ 
/*#define NUMCYLS 80*/ /* normal # of cylinders */ 
/*#tdefine MAXCYLS (NUMCYLS+20)*/ /* max # cyls to look for during cal */ 
/*#define NUMHEADS 2*/ 
/*idefine NUMTRACKS (NUMCYLS*NUMHEADS) */ 


#define NUMSECS 11 
#define NUMUNITS 4 


/*-~ sizes before mfm encoding */ 
#define TD_SECTOR 512 


#define TD_SECSHIFT 9 /* log TD_SECTOR */ 


* Driver Specific Commands 
* 


ee mantra ee —— 


*f 


*-~ TD NAME is a generic macro to get the name of the driver. This 
*—— way if the name is ever changed you will pick up the change 
*-— automatically. 

*-—— Normal usage would be: 


*—— char internalName[] = TD_NAME; 


#define TD_NAME "trackdisk.device" 








Sep 19 20:25 1988 devices/trackdisk.h Page 2 





19 20:25 1988 devices/trackdisk.h Page 


> 


3 





oz -d 














70 139 #define TDF_ALLOW_NON_3 5 (1<<0) 
5 #define TDF_EXTCOM (1<<15) /7* for internal use only! */ WY 
/* 
73 142 ** If you set the TDB_ALLOW_NON_3_5 bit in OpenDevice, then you don't 
74 #define TD_MOTOR (CMD_NONSTD+0) /* control the disk's motor */ 143 ** know what type of disk you really got. These defines are for the 
75 #define TD_SEEK (CMD _NONSTD+1) /* explicit seek (for testing) */ 144 ** TD_GETDRIVETYPE command. In addition, you can find out how many 
76 #define TD FORMAT (CMD_NONSTD+2) /* format disk */ 145 ** tracks are supported via the TD_GETNUMTRACKS command. 
77 +#define TD_REMOVE (CMD_NONSTD+3) /* notify when disk changes */ 146 */ 
78 #define TD_CHANGENUM (CMD _NONSTD+4) /* number of disk changes */ 147 
79 #define TD_CHANGESTATE (CMD _NONSTD+5) /* is there a disk in the drive? */ 148 #define DRIVE3 5 1 
80 #define TD_PROTSTATUS (CMD_NONSTD+6) /* is the disk write protected? */ 149 #define DRIVES _25 2 
81 #define TD_RAWREAD (CMD_NONSTD+7) /* read raw bits from the disk */ 150 
82 #define TD_RAWWRITE (CMD_NONSTD+8) /* write raw bits to the disk */ 151 /* 
83 #define TD_GETDRIVETYPE (CMD_NONSTD+9) /* get the type of the disk drive */ DR 
84 #define TD_GETNUMTRACKS (CMD_NONSTD+10) /* # of tracks for this type drive */ 153. * 
85 #define TD_ADDCHANGEINT (CMD_NONSTD+11) /* TD REMOVE done right */ 154 * Driver error defines 
a7 itdefine TD_REMCHANGEINT (CMD _NONSTD+12) /* remove softint set by ADDCHANGEINT * 12? * 
156 Wo tt 
eg #define TD_LASTCOMM (CMD_NONSTD+13) pe */ 
1 
90 /* 159 #define TDERR_NotSpecified 20 /* general catchall */ 
91 * 160 #define TDERR_NoSecHdr 21 /* couldn't even find a sector */ 
92 * The disk driver has an "extended command" facility. These commands 161 #define TDERR_BadSecPreamble 22 /* sector looked wrong */ 
93 * take a superset of the normal IO Request block. 162 #define TDERR_BadSecID 23 /* ditto */ 
94 * 163 #define TDERR_BadHdrSum 24 /* header had incorrect checksum */ 
95 */ 164 #define TDERR_BadSecSum 25 /* data had incorrect checksum */ 
96 165 #define TDERR_TooFewSecs 26 /* couldn't find enough sectors */ 
97 #define ETD WRITE (CMD_WRITE | TDF_EXTCOM) 166 #define TDERR_BadSecHdr 27 /* another "sector looked wrong" */ 
98 #define ETD_READ (CMD_READ|TDF_EXTCOM) 167 #define TDERR_WriteProt 28 /* can't write to a protected disk */ 
99 tdefine ETD MOTOR (TD_MOTOR | TDF_EXTCOM) 168 #define TDERR_DiskChanged 29 /* no disk in the drive */ 
100 #define ETD_SEEK (TD_SEEK | TDF_EXTCOM) 169 #define TDERR_SeekError 30 “* couldn't find track 0 */ 
101 #define ETD_FORMAT (TD_FORMAT | TDF_EXTCOM) 170 #define TDERR_NoMem 31 /7* ran out of memory */ 
102 #define ETD UPDATE (CMD_UPDATE | TDF_EXTCOM) 171 #define TDERR_BadUnitNum 32 /* asked for a unit > NUMUNITS */ 
103 #define ETD CLEAR (CMD_CLEAR | TDF_EXTCOM) 172 #define TDERR_BadDriveType 33 /* not a drive that trackdisk groks */ 
104 #define ETD_RAWREAD (TD_RAWREAD | TDF_EXTCOM) 173 #define TDERR_DriveInUse 34 /* someone else allocated the drive */ 
105 #define ETD _RAWWRITE (TD_RAWWRITE | TDF_EXTCOM) ee #define TDERR_PostReset 35 /* user hit. reset; awaiting doom */ 
106 17 
107 /* 176 /* 
108 * TR I 
109 * extended IO has-a larger than normal io request block. 178 * 
110 * 179 * public portion of the unit structure 
lll */ 180 
112 VB Rn 
113 struct IOExtTD { 182 */ 
114 struct I0StdReq iotd_Req; 183 
115 ULONG iotd_Count; 184 struct TDU_PublicUnit [{ 
116 ULONG iotd SecLabel; 185 struct Unit tdu_Unit; /* base message port */ 
117 3; ~ 186 UWORD = tdu_Comp01Track; /7* track for first precomp */ 
118 187 UWORD = tdu_Comp10Track; /* track for second precomp */ 
119 /* 188 UWORD = tdu_Comp]]Track; 7* track for third precomp */ 
120 ** raw read and write can be synced with the index pulse. This flag 189 ULONG tdu_StepDelay; /* time to wait after stepping */ 
121 ** in io request's IO_FLAGS field tells the driver that you want this. 190 ULONG tdu_SettleDelay; /* time to wait after seeking */ 
122 */ 191 UBYTE tdu_RetryCnt; /* # of times to retry */ 
123 192 3; 
124 #define IOTDB_INDEXSYNC 4 193 
125 #define IOTDF_INDEXSYNC (1<<4) 194 #endif /* DEVICES _TRACKDISK_H */ 
126 
127 
138 /* labels are TD_LABELSIZE bytes per sector */ 
130 #define TD_LABELSIZE 16 
131 
132 /* 
133 ** This is a bit in the FLAGS field of OpenDevice. If it is set, then 
134 ** the driver will allow you to open all the disks that the trackdisk 
132 ** Griver understands. Otherwise only 3.5" disks will succeed. 
*/ 
137 
138 #define TDB_ALLOW_NON 3 5 0 











Te ~ a 





WONDUFWNE 
* 





19 20:19 1988 exec/alerts.h Page 1 


#ifndef EXEC_ALERTS_H 
#define EXEC_ALERTS_H 


/* 
* $Filename: exec/alerts.h $ 


ee SRelease: 1.3 $ 
KK 


Kk 
Kk 





ak (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 

xe All Rights Reserved 

*/ 

#define SF_ALERTWACK (1<<1) /* in ExecBase.SysFlag */ 

[RRR R IRR RK IKE R RIKER HK REE IK IK IKE RRA EERERER ER ERE ER ER EERE 
* 

* Format of the alert error number: 

* 

* app np nn 
* |p| SubSysId | General Error | SubSystem Specific Error 

* hp tt tt wa fm 
* 

* D: DeadEnd alert 

* SubSysId: indicates ROM subsystem number. 

* General Error: roughly indicates what the error was 

* Specific Error: indicates more detail 

FOR KIT RI TOTO KIT TOR IIR RI IR RR IK ITA IIR ITI II IK IIR IK IIR III IRE IIIS HIRI K 
(IIIT TIO IIIA TAI II IIIT ASIA TIAA IOI IA TAI A 
* 

* General Dead~End Alerts 

x 

FICCI IOI TORI ITO I IOI II IO II TOI RIKI IIR II IOI IKK IK IK 
a alert types */ 

#define AT_DeadEnd 0x80000000 

#define AT Recovery 0x00000000 

{t-— general purpose alert codes */ 

#define AG_NoMemory 0x00010000 

#define AG MakeLib 0x00020000 

#define AG_OpenLib 0x00030000 

#define AG_OpenDev 0x00040000 

#define AG_OpenRes 0x00050000 

#define AG I0Error 0x00060000 

#define AG_NoSignal 0x00070000 

an alert objects: */ 

#define AO_ExecLib 0x00008001 


#define AO_GraphicsLib 0x00008002 
#define AO_LayersLib 0x00008003 
#define AO_Intuition 0x00008004 
#define AO_MathLib 0x00008005 
#define AO_CListLib 0x00008006 
#define AO _DOSLib 0x00008007 
#define AO_RAMLIb 0x00008008 
#define AO_IconLib 0x00008009 


#define AO_ExpansionLib 0x0000800A 
#define AO AudioDev 0x00008010 
#define AO _ConsoleDev 0x00008011 
#define AO_GamePortDev 0x00008012 
#define AO_KeyboardDev 0x00008013 
#define AO _TrackDiskDev 0x00008014 


#define AO_TimerDev 0x00008015 
#define AO_CIARsre 0x00008020 
#define AO _DiskRsrc 0xo0008021 
#define AO_MiscRsre 0x00008022 
#define AO _BootStrap 0x00008030 





19 20:19 1988 exec/alerts.h Page 2 


#define AO_Workbench 0x00008031 


IDOI IID TOT III TOTO III IIIA IAI TIT III I IIIT III IIIA III 
* 

* Specific Dead-End Alerts: 

* 

FOR IO TOIT I TOT II IIR IIIA IIR RIA IO IR IIR IR IOI AI IIIA II ISI KIKI ILI IKEA AAI EIN 










ln exec.library */ 

#define AN_ExecLib 0x01000000 

#define AN_ExcptVect 0x81000001 7* 68000 exception vector checksum */ 
#define AN BaseChkSum 0x81000002 /* execbase checksum */ 

#tdefine AN_LibChkSum 0x81000003 /7* library checksum failure */ 
#define AN_LibMem 0x81000004 /* no memory to make library */ 
#tdefine AN MemCorrupt  0x81000005 /* corrupted memory list */ 

#define AN_IntrMem 0x81000006 /* no memory for interrupt servers */ 
#tdefine AN_InitaPtr 0x81000007 /* InitStruct() of an APTR source */ 
#define AN SemCorrupt — 0x81000008 7* a- semaphore is in illegal state */ 
#define AN_FreeTwice 0x81000009 /* freeing memory already freed */ 
#define AN_BogusExcpt 0x8100000A /* illegal 68k exception taken */ 

[ho graphics.library */ 

#define AN_GraphicsLib “}x02000000 

#define AN _GfxNoMem 0x82010000 /* graphics out of memory */ 

#define AN_LongFrame 0x82010006 /* long frame, no memory */ 

#define AN ShortFrame  0x82010007 /7* short frame, no memory */ 

#define AN TextTmpRas 0x02010009 /* text, no memory for TmpRas */ 
#define AN_B1tBitMap 0x8201000A /7* BltBitMap, no memory */ 

#define AN_RegionMemory 0x8201000B /* regions, memory not available */ 
#define AN MakevPort 0x82010030 /* MakevPort, no memory */ 

tdefine AN_GfxNoLCM 0x82011234 /* emergency memory not available */ 
ft layers.library */ 

#define AN_LayersLib 0x03000000 

#define AN _LayersNoMem 0x83010000 /7* layers out of memory */ 

[t-o intuition.library */ 

#define AN_Intuition 0x04000000 

#tdefine AN GadgetType 0x84000001 /* unknown gadet type */ 

#define AN_BadGadget 9x04000001 /* Recovery form of AN _GadgetType */ 
#define AN _CreatePort 0x84010002 /* create port, no memory */ 

#define AN_ItemAlloc 0x04010003 /* item plane alloc, no memory */ 
#tdefine AN_SubAlloc 0x04010004 /* sub alloc, no memory */ 

#define AN PlaneAlloc  0x84010005 /7/* plane alloc, no memory */ 

#define AN ItemBoxTop 0x84000006 /* item box top < RelZero */ 

#define AN_OpenScreen  0x84010007 /7* open screen, no memory */ 

#define AN OpenScrnRast. 0x84010008 /* open screen, raster alloc, no memory 
#define AN_SysScrnType 0x84000009 /* open sys screen, unknown type */ 
#define AN AddsWGadget 0x8401000A /* add SW gadgets, no memory */ 
#tdefine AN_OpenWindow 0x8401000B /* open window, no memory */ 

#define AN _BadState 0x8400000C /* Bad State Return entering Intuition * 
#define AN BadMessage 0x8400000D /* Bad Message received by IDCMP */ 
#define AN_WeirdEcho 0x8400000E /7* Weird echo causing incomprehension * 
#define AN NoConsole 0x8400000F 7* couldn't open the Console Device */ 
ft--o math. library */ 

#define AN MathLib 0x05000000 

[to clist.library */ 

#define AN CListLib 0x06000000 

fro dos.library */ 

#define AN._DOSLib 0x07000000 

tdefine AN_StartMem 0x07010001 | /* no memory at startup */ 

#define AN_EndTask 0x07000002 /* EndTask didn't */ 

#define AN_QPktFail 0x07000003 7* Qpkt failure */ 

#define AN_AsyncPkt 0x07000004 /* Unexpected packet received */ 











il 


ce - a 


Sep 19 20:19 1988 exec/alerts.h Page 3 Sep 19 20:19 1988 exec/devices.h Page 1 





139 #define AN FreeVec 0x07000005 /* Freevec failed */ 1 #ifndef EXEC_DEVICES_H 

140 #define AN_DiskBlkSeq | 0x07000006 7* Disk block sequence error */ 2 #define EXEC_DEVICES_H 

141 #define AN_BitMap 0x07000007 /* Bitmap corrupt */ 3 /* 

142 #define AN KeyFree 0x07000008 /* Key already free */ 4 ** $Filename: exec/devices.h $ 
143 #define AN_BadChkSum 0x07000009 /7* Invalid checksum */ 5 ** SRelease: 1.3 $ 

144 #define AN. DiskError 0x0700000A /* Disk Error */ 6 ** 

145 #define AN_KeyRange 0x0700000B 7* Key out of range */ 7 ** 

146 #define AN_BadOverlay 0x0700000C /* Bad overlay */ B xk 

147 Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
148 /*-----~ ramlib. library */ 10 ** All Rights Reserved 

149 #define AN_RAMLib 0x08000000 ll */ 

150 #define AN_BadSegList 0x08000001 7* no overlays in library seglists */ 12 

151 13 #ifndef EXEC_LIBRARIES_H 

152 /*---——- icon.library */ 14 #include "exec/libraries.h" 

153 #define AN_IconLib 0x09000000 15 #endif !EXEC_LIBRARIES_H 

154 16 

155 /*----~- expansion.library */ 17 #ifndef EXEC_PORTS_H 

156 #define AN_ExpansionLib 0x0A000000 18 #include "exec/ports.h" 

157 #define AN_BadExpansionFree 0x0A000001 19 #endif !EXEC_PORTS_H 

158 20 

159 /*----~- audio.device */ 21 

160 #tdefine AN_AudioDev 0x10000000 22 [REREKK Device RII RIK KIKI KR IIR RIKKI RI III IR III IAI KI EI IK IK IN 7 
161 23 

162 /%----—— console.device * 24 struct Device [{ 

163 #define AN_ConsoleDev  0x11000000 25 struct Library dd_Library; 

164 26 3; 

165 /*------ gameport.device */ 27 

166 #define AN_GamePortDev 0x12000000 28 

167 29 PEKRERE Unit FIR KR IO IR RI ITO IR IK TOR RI TR IR IIA II IIA RIOR IKI IR RIK / 
168 /*----— keyboard.device */ 30 

169 #define AN _KeyboardDev .0x13000000 31 struct Unit [ 

170 32 struct MsgPort unit_MsgPort; 7* queue for unprocessed messages */ 
171 /*-----~ trackdisk.device */ 33 7* instance of msgport is recommended * 
172 #define AN _TrackDiskDev 0x14000000 34 UBYTE unit_flags; 

173 #define AN_TDCalibSeek 0x14000001 /* calibrate: seek error */ 35 UBYTE  unit_pad; 

174 #define AN_TDDelay 0x14000002 /* delay: error on timer wait */ 36 UWORD unit_OpenCnt; /* number of active opens */ 
175 37 3; 

176 /*---——— timer.device */ 38 

177 #define AN_TimerDev 0x15000000 39 

178 #define AN_TMBadReq 0x15000001 /* bad request */ 40 #define UNITF_ACTIVE (1<<0) 

179 #define AN _TMBadSupply 0x15000002 /* power supply does not supply ticks */| 41 #define UNITF_INTASK (1<<1) 

180 42 

181 /*------ cia.resource */ 43 #endif /* EXEC_DEVICES_H */ 

182 #define AN_CIARsrc 0x20000000 

183 

184 /*-----— disk.resource */ 

185 #define AN_DiskRsre 0x21000000 

186 #define AN_DRHasDisk 0x21000001 /* get unit: already has disk */ 

187 #define AN_DRIntNoAct 0x21000002 7* interrupt: no active unit */ 

188 

189 /*----—- misc.resource */ 

190 #define AN MiscRsrce 0x22000000 

191 

192 /*----——— bootstrap */ 

193 #define AN_BootStrap 0x30000000 

194 #define AN_BootError 0x30000001 /* boot code returned an error */ 

195 

196 /%--> >> Workbench */ 

197 #define AN_Workbench 0x31000000 

198 

199 /*%----—— DiskCopy */ 

200 #define AN_DiskCopy 0x32000000 

201 


202 #endif /* EXEC_ALERTS_H */ 











Sep 19 20:19 1988 exec/errors.h Page 1 


#ifndef 
#define 
/* 
KK 
xk 
kk 
nk 
a 
“* 
10 ** 
ll */ 


WOONHUOPS WN 


13 #define 
14 #define 
15 #define 
16 #define 


18 #tendif 


€@ -—-d 


EXEC_ERRORS_H 
EXEC_ERRORS_H 


$Filename: exec/errors.h $ 
$Release: 1.3 $ 


Standard I0 Errors: 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IOERR_OPENFAIL —-l /* device/unit failed to open */ 
IOERR_ABORTED ~2 /* request aborted */ 
IOERR_NOCMD -3 /7* command not supported */ 
IOERR_BADLENGTH —4 /* not a valid length */ 


/* EXEC_ERRORS H */ 


Sep 


WODAITNUE WD 


19 20:19 


1988 exec/exec.h Page 1 


#ifndef EXEC_EXEC_H 
#tdefine EXEC_EXEC_H 


/* 
xk 
we 
Kk 
xx 
KK 
xx 
xk 


*/ 


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 


#endif 


$Filename: exec/exec.h $ 
$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
All Rights Reserved 


“exec/nodes .h" 
"exec/lists.h" 
"“exec/interrupts.h" 
"exec/memory.h" 
“exec/ports.h'" 
“exec/tasks.h" 
"exec/libraries.h" 
"exec/devices.h" 
"“exec/io.h" 


/* EXEC_EXEC_H */ 








v2 - a 





19 20:19 1988 exec/execbase.h Page 1 Sep 19 20:19 1988 exec/exechbase.h Page 2 














1 #ifndef EXEC_EXECBASE_H 70 APTR TaskExitCode; 
2 #define EXEC_EXECBASE_H 71 ULONG TaskSigAlloc; 
3 /* 72 UWORD TaskTrapAlloc; 
4 xx $Filename: exec/execbase.h $ 73 
5 ** $Release: 1.3 $ 74 
6 ** 75 /*eeee* System Lists FOR TORIIIRIIIRI RII IRI IIR RITTER IO IIIT / 
7 ** 76 
8 xx 77 struct List MemList; 
Q kK (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 struct List ResourceList; 
All Rights Reserved 79 struct List DeviceList; 
80 struct List IntrList; 
81 struct List LibbList; 
13 #ifndef EXEC_LISTS_H 82 struct List PortList; 
14 #include “exec/lists.h" 83 struct List TaskReady; 
2 #endif !EXEC_LISTS'H 84 struct List TaskWait; 
85 
17 #ifndef EXEC_INTERRUPTS_H 86 struct SoftInthist SoftInts[5]; 
18 #include “exec/interrupts.h" ~ 87 
19 #endif {EXEC_INTERRUPTS_H 88 [RRKKEK Other Globals FRI RIKKI KI IK RIK RII IK RII KTR IRI III IK IK / 
20 89 
21 #ifndef EXEC _LIBRARIES_H 90 LONG LastAlert [4]; 
22 #include "exec/libraries.h" 91 
23 #endif !EXEC_LIBRARIES_H 92 
24 93 
25 t#tifndef EXEC_TASKS_H 94 /* these next two variables are provided to allow 
26 #include "exec/tasks.h" 95 ** system developers to have a rough idea of the 
27 #endif !EXEC_TASKS H 96 ** period of two externally controlled signals —- 
28 97 x* the time between vertical blank interrupts and the 
29 98 ** external line rate (which is counted by CIA A's 
30 struct ExecBase { 99 **x "time of day" clock). In general these values 
31 struct Library LibNode; 100 ** will be 50 or 60, and may or may not track each 
32 101 ** other. These values replace the obsolete AFB PAL 
33 UWORD  SoftVer; /* kickstart release number x/ 102 ** and. AFB_50HZ flags. ~ 
34 WORD LowMemChkSum; 103 */ 
35 ULONG = ChkBase; /* system base pointer complement */ 104 UBYTE VBlankFrequency; 
36 APTR ColdCapture; /* coldstart soft vector xf 105 UBYTE  PowerSupplyFrequency; 
37 APTR CoolCapture; 106 
38 APTR WarmCapture; 107 struct List SemaphoreList; 
39 APTR SysStkUpper ; /* system stack base (upper bound) */ 108 
40 APTR SysStkLower; 7* top of system stack (lower bound) */ 109 /* these next two are to be able to kickstart into user ram. 
41 ULONG MaxLocMem; 110 ** KickMemPtr holds a singly linked list of MemLists which 
42 APTR DebugEntry ; 1ll *x will be removed from the memory list via AllocAbs. If 
43 APTR DebugData ; 112 . ** all the AllocAbs's succeeded, then the KickTagPtr will 
44 APTR AlertData; 113 *x* be added to the rom tag list. 
45 APTR MaxExtMem; /* top of extended mem, or null if none */ 114 xf 
46 115 APTR KickMemPtr ; 7* ptr to queue of mem lists */ 
47 UWORD = ChkSum; 116 APTR KickTagPtr; 7/* ptr to rom tag queue */ 
48 117 APTR KickCheckSum; /* checksum for mem and tags */ 
49 /xxxxex Interrupt Related FRI KKK RIKER KIRK IK RII IIR IRI KIRK ERE K 118 
50 119 UBYTE ExecBaseReserved [10] ; 
ot struct IntVector IntVects[16]; 120 UBYTE ExecBaseNewReserved [20]; 
2 121 J; 
53 (kee System Varlables FRA III III IIR IIIT IRR IRR IIR IIR R ICT 122 } 
54 123 #define SYSBASESIZE sizeof(struct ExecBase) 
55 struct Task *ThisTask; /* pointer to current task */ 124 
56 ULONG  IdleCount; /* idle counter */ 125 /xx*xeee* AttnFlags */ 
57 ULONG DispCount,; /* dispatch counter */ 126 /* Processors and Co~processors: */ 
58 UWORD = Quantum; 7* time slice quantum */ 127 #define AFB_68010 0 7* also set for 68020 */ 
59 UWORD = Elapsed; /* current quantum ticks */ 128 #define AFB_68020 i] 
60 UWORD = SysFlags; /* misc system flags */ 129 #define AFB_68881 4 
61 BYTE IDNestcCnt; /* interrupt disable nesting count */ 130 
62 BYTE TDNestcnt ; /* task disable nesting count */ 131 #define AFF_68010 (1<<0) 
63 132 #define AFF_68020 (1<<1) 
64 UWORD ~-- At tnFlags; /* special attention flags */ 133 #define AFF_68881 (1<<4) 
65 UWORD = AttnResched; 7* rescheduling attention */ 134 
66 APTR ResModules ; /* resident module array pointer */ 135 /* These two bits used to be AFB_PAL and AFB_50HZ. After some soul 
67 136 **. searching we realized that they were misnomers, and the information 


68 APTR TaskTrapCode; 137 ** is now kept in VBlankFrequency and PowerSupplyFrequency above. 
69 APTR TaskExceptCode; 138 ** To find out what sort of video conversion is done, look in the 











s@-d 


19 20:19 1988 exec/execbase.h Page 3 


** graphics subsytem. 
* 


#define AFB_RESERVED8 8 
#define AFB_RESERVED9 9 


tendif 


/* EXEC_EXECBASE_H */ 





Sep 


WOON DUS WHE 


19 20:19 1988. exec/execname.h Page 1 


#ifndef EXEC_EXECNAME_H 
#define EXEC_EXECNAME_H 


* 
ak 
Kk 
kk 
xk 
kk 
nk 
Kk 


*/ 


$Filename: exec/execname.h $ 
$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


#define EXECNAME "exec. library" 


#endif /* EXEC_EXECNAME_H */ 





9%@ -~ a 


Sep 


COIN WNE 


19 20:19 1988 exec/interrupts.h Page 1 


#ifndef EXEC_INTERRUPTS_H 
#define EXEC_INTERRUPTS_H 


/* 
x $Filename: exec/interrupts.h $ 


a $Release: 1.3 $ 
k 


** 

** . 

** (C) Copyright 1985,1986,1987,19 
ae All Rights Reserved 

*/ 


#ifndef EXEC_NODES_H 
#include "exec/nodes.h" 
#tendif !EXEC_NODES_H 


#ifndef EXEC_LISTS H 


#include "exec/lists-h" 
#endif !EXEC_LISTS_H 


struct Interrupt [ 


struct Node is_Node; 
APTR is Data; /* 
VOID (*is Code) (); /* 


1; 


struct IntVector { /* For 
APTR iv_Data; 
VOID (*iv_Code) (); 


struct Node *iv_Node; 


struct SoftInthist { 
struct List sh_List; 
UWORD sh_Pad; 


/* For 


i 

#define SIH_PRIMASK (0xf0) 

/* this is a fake INT definition, used 
5 


#define INTB_NMI 


1 
#define INTF_NMI (1<<15) 


fendif /* EXEC_INTERRUPTS_H */ 


88 Commodore-Amiga, Inc. 


server data segment */ 
server code entry */ 


EXEC use ONLY! */ 


EXEC use ONLY! */ 


only for AddIntServer and the like */ 





Sep 


OODNIDHDUF WHE 


19 20:19 1988 exec/io.h Page 1 


#ifndef EXEC_IO_H 
#define EXEC_IO_H 


f* 

ae $SFilename: exec/io.h $ 

kk $Release: 1.3 $ 

ak 

kk 

nk 

a (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved : 

*/ 


#ifndef EXEC_PORTS_H 
#include “exec/ports.h" 
#endif !EXEC_PORTS_H 


struct IORequest { 
struct Message io Message; 
struct Device *io Device; 
struct Unit *io Unit; 
UWORD io_Command ; 
UBYTE io_Flags; 
BYTE 1o_Error; 

li 


struct I0StdReq [{ 


struct Message io Message; 
struct Device *io_Device; 
struct Unit *io Unit; 
UWORD io_Command; 

UBYTE io_Flags; 

BYTE io_Error; 

ULONG io_Actual; 

ULONG io_Length; 

APTR io Data; 

ULONG io Offset; 


; 


7* 
/* 
/* 


device node pointer */ 
unit (driver private)*/ 
device command. */ 


error or warning num */ 


device node pointer */ 
unit (driver private) */ 
device command */ 


error or warning num */ 

actual number of bytes transferred */ 
requested number bytes transferred*/ 
points to data area */ 

offset for block structured devices */ 


/* library vector offsets for device reserved vectors */ 


#define DEV_BEGINIO 


— (—30) 
#define DEV_ABORTIO 


(~36) 


/* io_Flags defined bits */ 
#define IOB_QUICK 0 
#define IOF_QUICK (1<<0) 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 


CMD_INVALID 
CMD_RESET 
CMD_READ 
CMD_WRITE 
CMD_UPDATE 
CMD_CLEAR 
CMD_STOP 
CMD_START 
CMD_FLUSH 


WO DANAE WNE OS 


#define CMD_NONSTD 


#endif /* EXEC_IO_H */ 





4@-d 


19 20:19 1988 exec/libraries.h Page 1 
































#ifndef EXEC_LIBRARIES_H 

tdefine EXEC_LIBRARIES_H 

* 

xe $Pilename: exec/libraries.h $ 


ae $Release: 1.3 $ 
eK 


wk 

“Kk 

xk (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, 
aK All Rights Reserved 

*/ 


#ifndef EXEC_NODES_H 
#include "exec/nodes.h" 
tendif !EXEC_NODES_H 


WOrwaUN WN 


#define LIB_VECTSIZE 6 
#define LIB_RESERVED 4 
#define LIB_BASE (-LIB_VECTSIZE) 
#define LIB_USERDEF 


#define LIB_NONSTD (LIB_USERDEF) 


Ine. 


(LIB_BASE-(LIB_RESERVED*LIB_VECTSIZE) ) 





















#define LIB_OPEN (-6) 
#define LIB CLOSE (-12) 
#tdefine LIB_EXPUNGE (-18) 
#define LIB _EXTFUNC (-24) 
struct Library [ 
struct Node lib Node; 
UBYTE lib _Flags; 
UBYTE lib_pad; 
UWORD lib NegSize; /* number of bytes before library */ 
UWORD lib PosSize; 7* number of bytes after library */ 
UWORD lib_Version; 
UWORD lib_Revision; 
APTR lib. IdString; 
ULONG lib Sum; /* the checksum itself */ 
UWORD lib OpenCnt; /7* number of current opens */ 
he 
#tdefine LIBF_SUMMING (1<<0) /* we are currently checksumming */ 
#define LIBF_CHANGED (1<<1) /7* we have just changed the lib */ 
#define LIBF_SUMUSED (1<<2) 7* set if we should bother to sum */ 
#tdefine LIBF_DELEXP (1<<3) /* Qelayed expunge */ 
/* Temporary Compatibility */ 
#define lh_Node lib Node 
#define lh_Flags lib Flags 
#define lh_pad lib _pad 
#define lh_NegSize lib_NegSize 
#define lh_PosSize lib_PosSize 














#tdefine 
#define 
#tdefine 
#define 
#define 


ih_Version 
lh_Revision 
Ih_Idstring 
lh_Sum 
lh_Opencnt. 


lib Version 
lib_Revision 
lib Idstring 
lib _Sum 

lib_Opencnt. 


#endif /* EXEC LIBRARIES H */ 


Sep 


WON DUN WN 


19 20:19 1988 exec/lists.h Page 1 
#ifndef EXEC_LISTS_H 

#define EXEC_LISTS_H 

/* 

ae $Pilename: exec/lists.h $ 
xk SRelease: 1.3 $ 

ak 

nk 

K* 

xe (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ak All Rights Reserved 

*f 


#ifndef EXEC_NODES_H 
#include "exec/nodes.h" 
#endif !EXEC_NODES_H 


/* normal, full featured list */ 
struct List [ 
struct Node *lh_ Head; 
struct. Node *ih Tail; 
struct Node *lh_TailPred; 
UBYTE  lh_Type; 
UBYTE 1_pad; 
V3 


/* minimum list ~~ no type checking possible */ 
struct MinList { 

struct MinNode *mih_Head; 

struct MinNode *mlh_Tail; 

struct MinNode *mlh_TailPred; 


I; 
f#endif /* EXEC_LISTS_H */ 











gc -d 














Sep 


OOAANNPWNE 


19 20:20 1988 exec/memory.h Page 1 


#ifndef EXEC_MEMORY_H 
#define EXEC_MEMORY_H 


/* 
x $Filename: exec/memory.h $ 

aR SRelease: 1.3 $ 

Kk 

aK definitions for use with the memory allocator 

wk 

aK (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 

*/ 


#ifndef EXEC_NODES_H 
#include "exec/nodes.h" 
#endif !EXEC_NODES H 


[RARER MemChunk FRI ITO ICICI ITI IO IOI IR IIIT TOR IIR II ICIIOK IK 


struct .MemChunk [{ 
struct MemChunk *mc_Next; /* pointer to next chunk */ 
ULONG mc_Bytes; /* chunk byte size *f 
i; 


ZOCOR MemHe aden 000 IOC IC ICC IOCIGCICICICICIICTCICTCTOCIC IOI IOI TOI IK / 


struct MemHeader [ 
struct Node mh_Node; 


UWORD mh_Attributes; /* characteristics of this region */ 
struct MemChunk *mh_First; /* first free region */ 
APTR mh_ Lower; /* lower memory: bound */ 
APTR mh_Upper; /* upper memory bound+1] «f/f 
ULONG mh _ Free; /7* total number of free bytes xf 


hi 
(20000 Mem En Cry 200 GO CII TOI CII ISIOIIITTO IT I RII IK 


struct MemEntry { 


union { 
ULONG meu_Reqs; /* the AllocMem requirements */ 
APTR meu_Addr; /* the address of this memory region */ 
} me_Un; 
ULONG = me_Length; /* the length of this memory region */ 
}; 
#define me_un me_Un 7* compatability */ 
#define me_Regs me_Un.meu_Regs 
#define me_Addr me_Un.meu_Addr 


[RRRKER MemList FRI RRR RIKI RR KIKI III KKK II KIRK IRR ERIK ER KER AIK RK / 


struct MemList [{ 
struct Node ml_Node; 


UWORD = ml_NumEntries; 7* number of entries in this struct */ 
struct MemEntry ml_ME[{1]; /* the first entry */ 

1; 

#define ml_me ml_ME 7* compatability */ 

(*--- Memory Requirement Types ———————o err rr tf 


#tdefine MEMF PUBLIC (1<<0) 
#define MEMF_CHIP (1<<1) 
#define MEMF_FAST (1<<2) 


Sep 19 20:20 1988 exec/memory.h Page 2 


70 
71 
72 
73 
74 
75 
76 








tdefine MEMF_CLEAR (1<<16) 
#define MEMF LARGEST (1<<17) 


#define MEM_BLOCKSIZE 8 
#define MEM_BLOCKMASK 7 


#endif. /* EXEC_MEMORY_H */ 








6@ - a 


WOON DUPWNE 





19 20:20 1988 exec/nodes.h Page 1 19 20:20 1988 exec/ports.h Page 1 

















#tifndef EXEC_NODES_H 

#define EXEC_NODES_H 

/* 

ae $Filename: exec/nodes.h $ 


ae $Release: 1.3 $ 
ue 


w* 
nk 
** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, 
ae All Rights Reserved ** 
*/ */ 


/* 


xx 
xk 
xk 


WOnnUn WN 


#ifndef EXEC_PORTS_H 
define EXEC PORTS_H 


ax $Filename: exec/ports.h $ 
aK $Release: 1.3 $ 


x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


/* normal node */ #ifndef EXEC_NODES_H 
struct Node { #include "exec/nodes.h" 
struct Node *ln Succ; 5 #endif !EXEC_NODES_H 









struct Node *lm Pred; 
UBYTE I1n_Type; 


#ifndef EXEC_LISTS_H 


BYTE ln Pri; #include "exec/lists.h" 
char *ln_Name; #endif !EXEC_LISTS_H 








le 


#ifndef EXEC_TASKS_H 


/* stripped node -~ no type checking is possible */ #include "exec/tasks.h" 
struct MinNode [{ #endif !EXEC_TASKS_H 













struct MinNode *mln_Succ; 
struct MinNode *mln_Pred; 


[RERKKK MsgPort FOI TOI IO TR IKK IK IR IR RIK IK I IRI III KI IK IR IKI I RIB KICK / 


struct MsgPort [ 


—-——-- Node Types -------— struct. Node mp_Node; 
#define NT_UNKNOWN UBYTE mp_Flags; 
#define NT_TASK UBYTE mp_SigBit; /* signal bit number */ 
#define NT_INTERRUPT /* also for software interrupt node */ struct Task *mp_SigTask; 7* task to be signalled */ 
#define NT_DEVICE struct List mp_MsgList; /7* message linked list */ 
#define NT_MSGPORT }; 
#tdefine NT_MESSAGE 
#define NT_FREEMSG #define mp_SoftInt mp_SigTask 
#define NI_REPLYMSG 
#define NT_RESOURCE #define PF_ACTION 3 
#define NT_LIBRARY 
#define NT_MEMORY : #define PA_SIGNAL 0 
#define NT_SOFTINT /* exec private */ #define PA_SOFTINT 1 
#define NT_FONT : #define PA_IGNORE 2 









#define NT_PROCESS 

#define NTI_SEMAPHORE 

#define NT_SIGNALSEM /7* signal semaphores */ 
#define NT_BOOTNODE 


#tendif /* EXEC_NODES_H */ struct 
struct 
UWORD 
1; 


#endif /* EXEC_PORTS_H */ 


[RERKEK Message FI IRI RIKI RR IR KK IKKE RK IIR EIR KKK IKI IR IIR IK IRE IK / 


struct Message { 


Node mn_Node; 
MsgPort *mn_ReplyPort; /* message reply port */ 
mn_Length; /7* message len in bytes */ 








of -~ d 


Sep 


COND SWNF- 


be 
Ho 


12 


19 20:20 1988 exec/resident.h Page 1 
#ifndef BXEC_RESIDENT_H 

#define EXEC RESIDENT H 

/* 

** $Filename: exec/resident.h $ 
ae $Release: 1.3 $ 

kk 

Kk 

xk 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 

*/ 

#ifndef EXEC_NODES_H 


#include "“exec/nodes.h" 
#tendif !EXEC_NODES_H 


struct Resident { 


UWORD rt_MatchWord; /7* word to match on (ILLEGAL) 


struct Resident *rt_MatchTag; /* pointer to the above 
APTR xrt_Endskip; /* address to continue scan 
UBYTE rt_Flags; /* various tag flags 
UBYTE rt_Version; /* release version number 
UBYTE rt_Type; /* type of module (NT_mumble) 
BYTE rt_Pri; /* initialization priority */ 
char *rt_Name; /7* pointer to node name 
char *rt_IdString; /* pointer to ident string 

; APTR rt_Init; /* pointer to init code 

#define RTC_MATCHWORD Ox4AFC 

#define RTF_AUTOINIT (1<<7) 

#define RTF_COLDSTART  (1<<0) 

/* Compatibility: */ 

#define RTM_WHEN 3 

#tdefine RTW_NEVER 0 


#define RTW_COLDSTART 1 


ftendif /* EXEC_RESIDENT_H */ 


Sep 


WON DU PWN 


19 20:20 1988 exec/semaphores.h Page 1 


#ifndef EXEC_SEMAPHORES_H 
#define EXEC _SEMAPHORES_H 


/* 
ae $Filename: exec/semaphores.h $ 

ak $Release: 1.3 $ 

x* 

eK 

** 

xx (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 

*/ 


#ifndef EXEC_NODES_H 
#include "exec/nodes.h" 
#fendif !EXEC_NODES_H 


#ifndef BXEC_LISTS_H 
#include “exec/lists.h" 
#endif !EXEC_LISTS_H 


#tifndef EXEC_PORTS_H 
#include "exec/ports.h" 
#fendif !EXEC_PORTS_H 


#ifndef EXEC_TASKS_H 
#include "exec/tasks.h" 
f#fendif !EXEC_TASKS_H 


720000 Semaphore OCG GGICIIC IGG III IIT IIIT IIIT III II IIA 


struct Semaphore { 
struct MsgPort sm_MsgPort; 
WORD = sm_Bids; 

i 


#define sm_LockMsg mp. SigTask 


Joe Signal Semaphore OCHO GIOIA IRI IOTCIIOR II TICK I IIR / 


/* this is the structure used to request a signal semaphore */ 
struct SemaphoreRequest [ 

struct MinNode sr_Link; 

struct Task *sr_Waiter; 


li 


/* this is the actual semaphore itself */ 
struct SignalSemaphore [ 
struct Node ss_Link; 
SHORT ss_NestCount; 
struct MinList ss_WaitQueue; 
struct SemaphoreRequest ss_MultipleLink; 
struct Task *ss_Owner; 
SHORT ss_QueueCount ; 
1; 


#endif /* EXEC_SEMAPHORES_H */ 











19 20:20 1988 exec/tasks.h Page 1 19 20:20 1988 exec/tasks.h Page 2 


#ifndef EXEC_TASKS_H 

#define EXEC_TASKS H #tdefine SIGB_ABORT 0 

/* #define SIGB_CHILD 1 

ae $Filename: exec/tasks.h $ #define SIGB_BLIT 4 

x* $Release: 1.3 $ #define SIGB_SINGLE 4 

ae #define SIGB_DOSs 8 

* 

** #define SIGF_ABORT (1<<0) 

xe (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. #define SIGF_CHILD (1<<1) 

aK All Rights Reserved #define SIGF_BLIT (1<<4) 

*/ #define SIGF SINGLE (1<<4) 
#define SIGF_DOS (1<<8) 


WO~AIAUF WN 


#tifndef EXEC_NODES_H . 
f#include “exec/nodes.h" #tendif /* EXEC_TASKS_H */ 
#tendif !EXEC_NODES_H 


#ifndef EXEC_LISTS_H 
#include "exec/lists.h" 
tendif !EXEC_LISTS H 


struct Task { 
struct Node tc_Node; 
UBYTE tc_Flags; 
UBYTE te_State; 





Teé —- a 








— BYTE tc_iDNeste€nt; —/* intr disabled nesting*7 
BYTE te_TDNestCnt; /* task disabled nesting*/ 
ULONG tc_SigAlloc; sigs allocated */ 

ULONG tc_SigWait; sigs we are waiting for */ 

ULONG tce_SigRecvd; sigs we have received */ 

ULONG tc_SigExcept; sigs we will take excepts for */ 
UWORD =tc_TrapAlloc; traps allocated */ 

UWORD = tc_TrapAble; traps enabled */ 

APTR -tc_ExceptData; points to except data */ 

APTR tc_ExceptCode; points to except code */ 

APTR tc_TrapData; points to trap code */ 

APTR tc_TrapCode; points to trap data */ 

APTR tc_SPReg; stack pointer */ 

APTR tc_SPLower; stack lower bound */ 

APTR te_SPUpper; stack upper bound + 2*/ 

VOID (*tc_Switch)(); /* task losing CPU xf 

VOID (*te_Launch) (); task getting CPU */ 

struct List tc_MemEntry; allocated memory */ 

APTR tc_UserData; per task data */ 


Flag Bits --—--------—---—----—-~----~---~------——--+/ 
TB_PROCTIME 
TB_STACKCHK 
TB_EXCEPT 
TB_SWITCH 
#define TB_LAUNCH 


#define TF_PROCTIME (1<<0) 
#define TF_STACKCHK (1<<4) 
tdefine TF_EXCEPT (1<<5) 
#define TF_SWITCH (1<<6) 
#define TF_LAUNCH (1<<7) 


Task States -—— pmo tf 

#define TS_INVALID 

#define TS_ADDED 

#define TS_RUN 

#define TS_READY 

#tdefine TS_WAIT 

#define TS_EXCEPT 

#define TS_REMOVED 





Predefined Signals 


ce - 2 





Sep 


WONDUN PWN 
* 


19 20:20 1988 exec/types.h Page 1 


#ifndef EXEC_TYPES_H 
#define EXEC_TYPES_H 


/* 
* $Filename: exec/types.h $ 

ax SRelease: 1.3 $ 

** 

wk 

Kk 


x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 

ae All Rights Reserved 

*/ 

#define GLOBAL extern /* the declaratory use of an external */ 

#define IMPORT extern /* reference to an external */ 

#tdefine STATIC static /* a local static variable */ 

#define REGISTER register /* a (hopefully) register variable */ 

#define VOID void /* typedef does not seem to work here */ 
J 

typedef long LONG; /* signed 32-bit quantity */ 

typedef unsigned long  ULONG; /7* unsigned 32-bit quantity */ 

typedef unsigned long LONGBITS ; /* 32 bits manipulated individually */ 

typedef. short WORD; /* signed l6-bit quantity */ 

typedef unsigned short UWORD; /7* unsigned 16-bit quantity */ 

typedef unsigned short WORDBITS; /* 16 bits manipulated individually */ 

typedef char BYTE; /* signed 8-bit quantity */ 

typedef unsigned char  UBYTE; /* unsigned 8-bit quantity */ 

typedef unsigned char BYTEBITS; /* 8 bits manipulated individually */ 

typedef unsigned char *STRPTR; /* string pointer */ 

typedef STRPTR *APTR; /7* absolute memory pointer */ 

7* sigh. APTR was misdefined, but compatibility rules. Heres what it 


* should have been 
* 


typedef ULONG CPTR; /* absolute memory pointer */ 

/* For compatability only: (don't use in new code) */ 

typedef short SHORT; /* signed 16-bit quantity (WORD) */ 
typedef unsigned short USHORT; /* unsigned 16-bit quantity (UWORD) */ 
/* Types with specific semantics */ 

typedef float FLOAT; 

typedef double DOUBLE ; 

typedef short COUNT; 

typedef unsigned short UCOUNT; 

typedef short BOOL; 

typedef unsigned char TEXT; 

#define TRUE 1 

#define FALSE 0 

#define NULL 0 

#tdefine BYTEMASK OxFF 

#define LIBRARY_VERSION 34 


#endif /* EXEC_TYPES_H */ 











i 


€€ -a 


Sep 19 20:25 1988 -graphics/clip.h Page 1 


WON AU WE 


#ifndef GRAPHICS CLIP_H 
#define GRAPHICS CLIP_H 


/* 
ak 
K* 
ak 
xk 
zk 
aK 


$Filename: graphics/clip.h $ 
$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


#ifndef GRAPHICS _GFX_H 
#include <graphics/gfx.h> 
#endif . 

#tifndef EXEC_SEMAPHORES_H 
#include <exec/semaphores .h> 
#tendif 


7* structures used by and constructed by windowlib.a */ 
/* understood by rom software */ 


#define NEWLOCKS 


struct Layer 


I; 


struct Layer *front,*back; ignored by roms */ 
struct ClipRect *ClipRect; read by roms to find first cliprect */ 
struct RastPort *Yp; /* ignored by roms, I hope */ 
struct Rectangle bounds; /* ignored by roms */ 

UBYTE reserved [4]; 

UWORD priority; /* system use only */ 
UWORD Flags; 7* obscured ?, Virtual BitMap? */ 
struct BitMap *SuperBitMap; 
struct ClipRect *SuperClipRect; /* super bitmap cliprects if 

VBitMap != Q*/ 
/* else damage cliprect list for refresh */ 

APTR Window; /* reserved for user interface use */ 
SHORT Scroll X,Seroll_Y; 

struct ClipRect *cr,*cr2,*crnew; /* used by dedice */ 

struct ClipRect *SuperSaveClipRects; /* preallocated cr's */ 

struct ClipRect *_cliprects; /7* system use during refresh */ 

struct Layer_Info *LayerInfo; /* points to head of the list */ 

struct SignalSemaphore Lock; 

UBYTE reserved3 [8]; 

struct Region *ClipRegion; 

struct Region *saveClipRects; 7* used to back out when in trouble*/ 

UBYTE reserved2 [22]; 

/* this must stay here */ 
struct Region *DamageList; 7* list of rectangles to refresh 

through */ 


struct ClipRect 
{ 


roms used to find next ClipRect */ 
ignored by roms, used by windowlib */ 
ignored by roms, used by windowlib */ 


struct ClipRect *Next; 
struct ClipRect *prev; 
struct Layer *lobs; 
struct BitMap *BitMap; 
struct Rectangle bounds; set up by windowlib, used by roms */ 
struct ClipRect *_pl,*_p2; system reserved */ 

LONG reserved; . system use */ 


#ifdef NEWCLIPRECTS_1_1 


LONG Flags; only exists in layer allocation */ 


#tendif 


i; 


/* internal cliprect flags */ 
#define CR _NEEDS_NO_ CONCEALED _RASTERS 1 


Sep 


70 





19 20:25 1988 graphics/clip.h Page 2 


/* defines for code values for getcode */ 
#define ISLESSX 1 
#define ISLESSY 2 
#define ISGRTRX 4 
#define ISGRTRY 8 


#endif /* GRAPHICS_CLIP_H */ 





Sep 


COON DU WNP 


19 20:25 1988 graphics/collide.h Page 1 


#ifndef GRAPHICS _COLLIDE_H 
#define GRAPHICS _COLLIDE_H 


/* 
ak $Filename: graphics/collide.h $ 

ak $Release: 1.3 $ 

ak 

ae include file for collision detection and control 

“* 

ak (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc, 
** All Rights Reserved 

*/ 


/* These bit descriptors are used by the GEL collide routines. 
These bits are set in the hitMask and meMask variables of 

a GEL to describe whether or not these types of collisions 
ean affect the GEL. BNDRY_HIT is described further below; 
this bit is permanently assigned as the boundary-hit flag. 
The other bit GEL_HIT is meant only as a default to cover 

any GEL hitting any other; the user may redefine this bit. 


+ ee OF OF 


* 
#define BORDERHIT 0 


/7* These bit descriptors are used by the GEL boundry hit routines. 
* When the user's boundry-hit routine is called (via the argument 


x set by a call to SetCollision) the first argument passed to 

* the user's routine is the address of the GEL involved in the 

* boundry-hit, and the second argument has the appropriate bit(s) 
x set to describe which boundry was surpassed 

*/ 


#define TOPHIT 1 
#define BOTTOMHIT 2 
#define LEFTHIT 4 
#define RIGHTHIT 8 


#endif /* GRAPHICS_COLLIDE_H */ 





WOrnnuPuUNE 


19 20:26 1988 graphics/copper.h Page 1 


#ifndef GRAPHICS COPPER_H 
#define GRAPHICS _COPPER_H 


/* 
ae $Filename: graphics/copper.h $ 
xe $Release: 1.3 $ 

Kk 

Kk 

Kk 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 

*f 


#define COPPER_MOVE 0 /* pseude opcode for move #XXXX,dir */ 
#define COPPER _WAIT 1 /7* pseudo opcode for wait y,x */ 
#define CPRNXTBUF 2 * continue processing with next buffer */ 


#tdefine CPR_NT_LOF 0x8000 /* copper instruction only for short frames */ 
#define CPR_NT_SHT 0x4000 /* copper instruction only for long frames */ 
struct. CopIns 


short OpCode; /* 0 = move, 1 = wait */ 
union 

{ 

struct CopList *nxtlist; 
struct 

{ 
union 

{ 
SHORT VWaitPos; 
SHORT DestAddr; 

} ul; 
union 

{ 
SHORT HWaitPos; 
SHORT DestData; 

} u2; 

} u4; 

} u3; 


vertical beam wait */ 
destination address of copper move */ 


horizontal beam wait position */ 
destination immediate data to send */ 


i; 

/* shorthand for above */ 

#define NXTLIST nxtlist 
#define VWAITPOS .u4.ul.VWaitPos 
#define DESTADDR .u4.ul.DestAddr 
#define HWAITPOS .u4.u2.HWaitPos 
#define DESTDATA .u4.u2.DestData 


/7* structure of cprlist that points to list that hardware actually executes */ 
struct cprlist 


struct cprlist *Next; 
UWORD *start; 
SHORT MaxCount; 


/* start of copper list */ 
7* number of long instructions */ 
; 


struct CopList 


struct CopList *Next; /* next block for this copper list */ 

struct CopList *_CopList; /* system use */ 

struct ViewPort *_ViewPort; /* system use */ 

struct CopIns *Copins; /* start of this block */ 

struct CopiIns *CopPtr; /* intermediate ptr */ 

UWORD *CopLStart; /* mrgcop fills this in for Long Frame*/ 

UWORD = *CopSStart; /7* mrgcop fills this in for Short Frame*/ 

SHORT Count; * intermediate counter */ 

SHORT MaxCount; /* max # of copins for this block */ 

SHORT DyOffset; /* offset this copper list vertical waits */ 
d; 


struct UCopList 








Sep 19 20:26 1988 graphics/copper.h Page 2 Sep 19 20:26 1988 graphics/display.h Page 1 









70 { 1 #ifndef GRAPHICS_DISPLAY_H 
71 struct UCopList *Next; 2 #define GRAPHICS _DISPLAY_H 
72 struct CopList *FirstCopList; /* head node of this copper list */ 3 /* 
73 struct CopList *CopList; 7* node in use */ 4 ** $Filename: graphics/display.h $ 
74°); 5 ** $Release: 1.3 $ 
75 G ** 
i struct copinit 7 ** include define file for display control registers 
B xx 
78 UWORD diagstrt[4]; /* copper list for first bitplane */ Q xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
79 DWORD sprstrtup[(2*8*2)+2+(2%*2)42); 10 ** All Rights Reserved 
80 UWORD ~—s sprstop[2]; ll */ 
81 }; , 12 
82 13 /* bplcon0 defines */ 
83 f#endif /* GRAPHICS_COPPER_H */ 14 #define MODE 640  0x8000 
15 #define PLNCNIMSK 0x7 /7* how many bit planes? */ 
16 /* 0 = none, 1->6 = 1->6, 7 = reserved */ 
17 #define PLNCNTSHFT 12 7* bits to shift for bplcon0 */ 
18 #define PF2PRI 0x40 7* bplcon2 bit */ 
19 #define COLORON 0x0200 /* disable color burst */ 
20 #define DBLPF 0x400 
21 #define HOLDNMODIFY 0x800 
22 #define INTERLACE 4 /* interlace mode for 400 */ 
23 
24 /* bplconl defines */ 
25 #define PFA_FINE_SCROLL OxF 


26 #define PFB_FINE SCROLL SHIFT 4 
27 #define PF_FINE_SCROLL_MASK  0xF 


se-a 


28 

29 /* display window start and stop defines */ 

30 #define DIW_HORIZ POS Ox7F /* horizontal start/stop */ 
31 #define DIW_VRTCL_POS  Oxl1FF /* vertical start/stop */ 
32 #define DIW_VRTCL_POS_SHIFT 7 

33 

34 /* Data fetch start/stop horizontal position */ 

35 #define DFTCH_MASK OxFF 

36 

37 /* vposr bits */ 

38 #define VPOSRLOF 0x8000 

39 


40 #endif /* GRAPHICS_DISPLAY_H */ 











ge —-a 


Sep 


COONAN WNE 


19 20:26 1988 graphics/gels.h Page 1 


#ifndef GRAPHICS GELS _H 
#define GRAPHICS GELS_H 


/* 
RK $Filename: graphics/gels.h $ 

** $Release: 1.3 $ 

K* 

x* include file for AMIGA GELS (Graphics Elements) 

Kk 

xe (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 

*/ 


7* VSprite flags */ 


7* user-set VSprite flags: */ 

#define SUSERFLAGS Ox00FF 7* mask of all user-settable VSprite-flags */ 
#define VSPRITE 0x0001 /* set if VSprite, clear if Bob */ 

#define SAVEBACK 0x0002 /* set if background is to be saved/restored */ 
#define OVERLAY 0x0004 /* set to mask image of Bob onto background */ 
#define MUSTDRAW 0x0008 /* set if VSprite absolutely must be drawn */ 

/* system-set VSprite flags: */ 

#define BACKSAVED 0x0100 7* this Bob's background has been saved */ . 
#define BOBUPDATE 0x0200 /* temporary flag, useless to outside world */ 
#define GELGONE 0x0400 7* set if gel is completely clipped (offscreen) * 
#define VSOVERFLOW 0x0800 /* VSprite overflow (if MUSTDRAW set we draw!) */ 


/* Bob flags */ 

7* these are the user flag bits */ 

#tdefine BUSERFLAGS OxOOFF /7* mask of all user-settable Bob-flags */ 
#define SAVEBOB 0x0001 /* set to not erase Bob */ 

#define BOBISCOMP 0x0002 /* set to identify Bob as AnimComp */ 

/7* these are the system flag bits */ 


#define BWAITING 0x0100 7* set while Bob is waiting on ‘after' */ 
#define BDRAWN 0x0200 7* set when Bob is drawn this DrawG pass*/ 
#define BOBSAWAY 0x0400 /* set to initiate removal of Bob */ 
#define BOBNIX 0x0800 /* set when Bob is completely removed */ 
#tdefine SAVEPRESERVE 0x1000 - /* for back-restore during double-buffer*/ 
#tdefine OUTSTEP 0x2000 /* for double-clearing if double~buffer */ 


7* defines for the animation procedures */ 
#define ANFRACSIZE 6 

#define ANIMHALF 0x0020 

#define RINGTRIGGER 0x0001 


/* UserStuff definitions 
* the user can define. these to be a single variable or a sub-structure 
* if undefined by the user, the system turns these into innocuous variables 
* see the manual for a thorough definition of the UserStuff definitions 
* 
* 
#ifndef VUserStuff /* VSprite user stuff */ 
#define VUserStuff SHORT 
#tendif 
#ifndef BUserStuff /* Bob user stuff */ 
#tdefine BUserStuff SHORT 
tendif 
#ifndef AUserStuff /* AnimOb user stuff */ 
#define AUserStuff SHORT 
#endif 
S BERRIES ARERR RK IKKE IIH GEL STRUCTURES PIII IK IRR IIR IIR RR IR IR III IRR IR RII / 


struct VSprite 
t 





Sep 19 20:26 1988 graphics/gels.h Page 2 
10 /* -~----—-------+--—--—__ SYSTEM VARIABLES —~--~-------—--~-~------—~--~-~~--- */ 
71 /* GEL linked list forward/backward pointers sorted by y,x value */ 
72 struct VSprite *NextVSprite; 
73 struct VSprite  *PrevVSprite; 
74 
75 /* GEL draw list constructed in the order the Bobs are actually drawn, then 
76 * list is copied to clear list 
77 +* must be here in VSprite for system boundary detection 
78 * 
79 struct VSprite *DrawPath; /7* pointer of overlay drawing */ 
80 struct VSprite *ClearPath; /* pointer for overlay clearing */ 
81 
82 /* the VSprite positions are defined in (y,x) order to make sorting 
83  * sorting easier, since (y,x) as a long integer 
84 * 
85 WORD Oldy, O1dX; /* previous position */ 
86 
87 /* ———~--—~-———-_-—--———— COMMON VARIABLES ~-w---———- i 
88 WORD Flags; /* VSprite flags */ 
89 
90 
OL LB rr USER VARIABLES ~-——--—-—-~~-~——-——-~~———————-—--——— kf 
92 /* the VSprite positions are defined in (y,x) order to make sorting 
93 .* sorting easier, since (y,x) as a long integer 
94 */ 
95 WORD Y, X; /* screen position */ 
96 
97 WORD Height; 
98 WORD Width; /* number of words per row of image data */ 
99 WORD Depth; 7* number of planes of data */ 
100 
101 WORD MeMask ; /* which types can. collide with this VSprite*/ 
102 WORD HitMask; /* which types this VSprite can collide with*/ 
103 
104 WORD *ImageData; /* pointer to VSprite image */ 
105 
106 /* borderLine is the one-dimensional logical OR of all 
107 * the VSprite bits, used for fast collision detection of edge 
108 * 
109 WORD *BorderLine; 7* logical OR of all VSprite bits */ 
110 WORD *CollMask; /* similar to above except this is a matrix */ 
lll 
112 /* pointer to this VSprite's color definitions (not used by Bobs) */ 
113 WORD *SprColors; 
114 
115 struct Bob *VSBob; 7* points home if this VSprite is part of 
116 a Bob */ 
117 
118 /* planePick flag: set bit selects a plane from image, clear bit selects 
119 * use of shadow mask for that plane 
120 * Onoff flag: if using shadow mask to fill plane, this bit (corresponding 
121 * to bit in planePick) describes whether to fill with 0's or l's 
122 * There are two uses for these flags: 
123 * ~ if this is the VSprite of a Bob, these flags describe how the Bob 
124 * is to be drawn into memory 
125 * -.if this is a simple VSprite and the user intends on setting the 
126 * MUSTDRAW flag of the VSprite, these flags must be set too to describe 
127 —* which color registers the user wants for the image 
128 */ 
129 BYTE PlanePick; 
130 BYTE PlaneonOff; 
131 
132 VUserStuff VUserExt; /* user definable: see note above */ 
133 3; 
134 


135 struct Bob 
136 /* blitter-objects */ 





Le -d 








Sep 19 20:26 1988 graphics/gels.h Page 3 


139 

T40 [8 ee COMMON VARIABLES —rrrr 
141 WORD Flags; /* general purpose flags (see definitions below) */ 
142 

L439 8 mmr USER VARIABLES rm 
144 WORD *SaveBuffer; /* pointer to the buffer for background save */ 

145 

146 /* used by Bobs for “cookie-cutting" and multi-plane masking */ 

147 WORD *ImageShadow; 

148 

149 /* pointer to BOBs for sequenced drawing of Bobs 

150 * for correct overlaying of multiple component animations 

151 */ 

152 struct Bob *Before; /* draw this Bob before Bob pointed to by before */ 
153 struct Bob *After; /* draw this Bob after Bob pointed to by after */ 
154 

155 struct VSprite *BobVSprite; /* this Bob's VSprite definition */ 

156 

157 struct AnimComp. *BobComp; /* pointer to this Bob's AnimComp def */ 
158 

159 struct DBufPacket *DBuffer; /* pointer to this Bob's dBuf packet */ 
160 

161 BUserStuff BUserExt; /7* Bob user extension */ 

162 }; 

163 

164 struct AnimComp 

165 { 

L668 mr SYSTEM VARIABLES rrr 
167 

168 [* seo COMMON VARIABLES wr 
169 WORD Flags; /* AnimComp flags for system & user */ 
170 

171 /* timer defines how long to keep this component active: 

172 * if set non-zero, timer decrements to zero then switches to nextSeq 

173. * if set to zero, AnimComp never switches 

174 * 

175 WORD Timer; 

176 

LI [® soo oo USER VARIABLES mr 
178 /* initial value for timer when the AnimComp is activated by the system */ 





/* 


/* 


y; 


WORD TimeSet; 

pointer to next and previous components of animation object */ 

struct AnimComp *NextComp; 

struct AnimComp *PrevComp; 

pointer to component component definition of next image in sequence «f/f 
struct AnimComp *NextSeq; 

struct AnimComp *PrevSeq; 

WORD (*AnimCRoutine)(); /* address of special animation procedure */ 


WORD YTrans; /7* initial y translation (if this is a component) */ 
WORD XTrans; /7* initial x translation (if this is a component) */ 


struct AnimOb *HeadOb; 


struct Bob *AnimBob ; 


struct Animob 


* 


/* 


aoe, SYSTEM VARIABLES tam 
struct AnimOb *NextOb, *PrevOb; 


number of calls to Animate this AnimOb has endured */ 
LONG Clock; 


WORD AnOldY, AnO14dX; /* old y,x coordinates */ 





fe 19 20:26 1988 graphics/gels.h Page 4 


xf 
*/ 





208 

209 [Re COMMON VARIABLES sr x/ 
210 WORD AnY, AnX; /* y,x coordinates of the AnimOb */ 

211 

DQ fr USER VARIABLES -mrr x/ 
213 WORD YVel, XVel; /* velocities. of this object */ 

214 WORD YAccel, XAccel; /* accelerations of this object */ 

215 

216 WORD RingYTrans, RingXTrans; /* ving translation values */ 

217 

218 WORD (*AnimORoutine) (); /* address of special animation 

219 procedure */ 

220 

221 struct AnimComp *HeadComp; /* pointer to first component */ 

222 . 

223 AUserStuff AUserExt; /* AnimOb user extension */ 

224 }; 

225 

226 /* dBufPacket defines the values needed to be saved across buffer to buffer 
227 * when in double-buffer mode 

228 * 

229 struct DBufPacket 

230 

231 t WORD BufY, BufX; /* save other buffers screen coordinates */ 
232 struct VSprite *BufPath; /* carry the draw path over the gap */ 

233 

234 /* these pointers must be filled in by the user */ 


235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 
261 
262 
263 
264 





/* pointer to other buffer's background save buffer */ 
WORD *BufBuffer; 
qi 


/* FOI CI OI III ITO TIO TOTTI IITA III IAI III IIA I IAA IAAI IIASA ITA IS II ITI AIA III IER «/ 


/* these are GEL functions that are currently simple enough to exist as a 
* definition. It should not be assumed that this will always be the case 


* 
#define InitAnimate(animKey) {*(animKey) = NULL; } 
#define RemBob(b) {(b)->Flags |= BOBSAWAY; } 


J* FO IO IOI OI IIT TAD AR III TIT IRIS IAA IK ISIS AA IK IK IRE EIA AAI IKI NER IR ESE EERE xf 


#define B2NORM 0 
#define B2SWAP 1 
#define B2BOBBER 2 


/* SIRI III III IO II IAT III II IIIA I AIA IIR II IIA IA IAA AAAS IASI IAEA */ 


/* a structure to contain the 16 collision procedure addresses */ 
struct collTable 
{ 


i 
#endif /* GRAPHICS_GELS_H.*/ 


int (*collPtrs[16])(); 










ge -d 


Sep 


WON DUS WN 


19 20:26 1988 graphics/gfx.h Page 1 


#ifndef GRAPHICS _GFX_H 
#define GRAPHICS_GFX_H 


/* 
aK $Filename: graphics/gfx.h $ 

xx $Release: 1.3 $ 

Kk 

** general include file for application programs 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ak All Rights Reserved 

*/ 


#define BITSET 0x8000 
#define BITCLR 0 


#define AGNUS 
#ifdef AGNUS 
#define TOBB(a) 
#else 

#define TOBB(a) 
#endif 


( (long) (a) ) 


struct Rectangle 
{ 
SHORT MinX,Miny; 
SHORT MaxX,MaxyY; 
1; 


typedef struct tPoint 
{ 


WORD x,y; 
} Point; 


typedef UBYTE *PLANEPTR; 
struct BitMap 


UWORD BytesPerRow; 

UWORD = Rows; 

UBYTE Flags; 

UBYTE Depth; 

UWORD pad; 

PLANEPTR Planes [8] ; 
1; 


#define RASSIZE(w,h) ((h)*( (w+15)>>380xFFFE) ) 


#tendif /* GRAPHICS_GFX_H */ 


Sep 


((long)(a)>>1) /* convert Chip adr to Bread Board Adr */ 


/* 
K* 
Kk 
** 
Kk 
Kk 
Kk 
10 ** 
ll */ 


WOnNDNEPWNE 


19 20:26 1988 graphics/gfxbase.h Page 1 


#ifndef GRAPHICS_GFXBASE_H 
#define GRAPHICS_GFXBASE_H 


$Filename: graphics/gfxbase.h $ 
SRelease: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


13 #ifndef EXEC_LISTS_H 

14 #ineclude <exec/lists.h> 

15 #endif 

16 #ifndef EXEC_LIBRARIES_H 

17 #include <exec/libraries.h> 
18 #tendif 

19 #ifndef EXEC_INTERRUPTS_H 
20 #include <exec/interrupts.h> 


21 #endif 

22 

23 struct GfxBase 

24 

25 struct Library LibNode; 

26 struct View *ActiView; 

27 struct copinit *copinit; /* ptr to copper start up list */ 

28 long *xola; 7* for 8520 resource use */ 

29 long *blitter; 7* for future blitter resource use */ 

30 UWORD *LOFlist; 

31 UWORD *SHFlist; 

32 struct bltnode *blthd,*blttl; 

33 struct bltnode *bsblthd,*bsblttl; 

34 struct Interrupt vbsrv,timsrv,bltsrv; 

35 struct List TextFonts ; 

36 struct TextFont *DefaultFont; 

37 UWORD Modes; 7* copy of current first bplcon0d */ 

38 BYTE VBlank; 

39 BYTE Debug; 

40 SHORT BeamSync; 

41 SHORT system_bplcon0; /* it is ored into each bplcon0 for display */ 
42 UBYTE SpriteReserved ; 

43 UBYTE bytereserved; 

44 USHORT Flags; 

45 SHORT BlitLock; 

46 short BlitNest; 

47 

48 struct List BlitWaitaQ; 

49 struct Task *BlitoOwner; 

50 struct List TOF_WaitQ; 

51 UWORD DisplayFlags; 7* NTSC PAL GENLOC etc*/ 

52 /* Display flags are determined at power on */ 

53 struct. SimpleSprite **SimpleSprites; 

54 UWORD MaxDisplayRow; /7* hardware stuff, do not use */ 
55 UWORD MaxDisplayColumn; /* hardware stuff, do not use */ 
56 UWORD NormalDisplayRows; 

57 UWORD NormalDisplayColumns; 

58 /* the following are for standard non interlace, 1/2 wh width */ 
59 UWORD = NormalDPMX; /* Dots per meter on display */ 
60 UWORD NormalDPMY; 7* Dots per meter on display */ 
61 struct SignalSemaphore *LastChanceMemory; 

62 UWORD *LCMptr; 

63 UWORD MicrosPerLine; /* 256 time usec/line */ 

64 UWORD  MinDisplayColumn; 

65 ULONG reserved [23]; /* for future use */ 

66 y; 

67 


68 #define NTSC 1 
69 #define GENLOC 2 





Sep 19 20:26 1988 graphics/gfxbase.h Page 2 19 20:26 1988 graphics/gfxmacros.h Page 1 


70 #define PAL 4 
71 
72 #define BLITMSG_FAULT 4 
73 


#ifndef GRAPHICS_GFXMACROS_H 

#define GRAPHICS_GFXMACROS_H 

/* 

** $Filename: graphics/gfxmacros.h $ 
ee $Release: 1.3 $ 

Kk 

ak 

“Kk 

** (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, 
xe All Rights Reserved 

*/ 


#ifndef GRAPHICS RASTPORT_H 
#include <graphics/rastport .h> 
#endif 


74 #endif /* GRAPHICS _GFXBASE_H */ 


WONNDU WHR 


#define ON_DISPLAY custom. dmacon 
#define OFF_DISPLAY custom. dmacon 
#define ON_SPRITE custom. dmacon 
#define OFF_SPRITE custom. dmacon 


BITSET | DMAF_RASTER; 
BITCLR | DMAF_RASTER; 
BITSET | DMAF_SPRITE; 
BITCLR | DMAF_SPRITE; 


#define ON_VBLANK custom. intena 
#define OFF_VBLANK custom. intena 


BITSET | INTF_VERTB; 
BITCLR | INTF_VERTB; 


#define. SetOPen(w,c) {(w)->AO]Pen = c;(w)—>Flags |= AREAOUTLINE; } 

#define SetDrPt(w,p) {(w)->LinePtrn = p;(w)~>Flags |= FRST_DOT; (w)—>linpatent| 
#define SetWrMsk(w,m) {(w)->Mask = m;} 

#define SetAfPt(w,p,n) {(w)—>AreaPtrn = p;(w)—>AreaPtsz = n;} 


#tdefine BNDRYOFF(w) {(w)->Flags &= ~AREAOUTLINE; } 


#define CINIT(c,n) { UCopperListInit(c,n); } 
#define CMOVE(c,a,b) { CMove(c,&a,b);CBump(c); } 
#define CWAIT(c,a,b) { CWait(c,a,b);CBump(c); } 
#define CEND(c) { CWAIT(c,10000,255); } 


6€ -a 


#define DrawCircle(rp,cx,cy,r) DrawBllipse(rp,cx,cy,Y,r); 
#define AreaCircle(rp,cx,cy,r) AreaEllipse(rp,cx,cy,Yr,Y); 


#endif /* GRAPHICS_GFXMACROS_H */ 








ov -a 





Sep 19 20:26 1988 graphics/graphint.h Page 1 Sep 19 20:26 1988 graphics/layers.h Page 1 
1 #ifndef GRAPHICS_GRAPHINT_H 1 #ifndef GRAPHICS LAYERS H 
2 #define GRAPHICS _GRAPHINT_H 3 ygctine GRAPHICS_LAYERS_H 
3 /* * 
4 xx $Filename: graphics/graphint.h $ 4 xx $Filename: graphics/layers.h $ 
5 ** $Release: 1.3 $ 5 ex $Release: 1.3 $ 
6 ** 6 ** 
7 xk 7 xe 
8 xx QB xx 
9 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 
ll */ ll */ 
12 12 
13 #ifndef EXEC_NODES_H 13 #ifndef EXEC_LISTS_H 
14 #include <exec/nodes.h> 14 #include <exec/lists.h> 
15 #endif 15. tendif 
16 16 
17 /* structure used by AddTOFTask */ 17 #ifndef EXEC_SEMAPHORES_H 
18 struct Isrvstr 18 #inelude <exec/semaphores .h> 
19 { 19 #endif . 
20 struct Node is Node; 20 
21 struct Isrvstr *Iptr; /* passed to srvr by os */ 21 #define LAYERSIMPLE 1 
22 int (*code)(); 22 #define LAYERSMART 2 
23 int (*ccode)(); 23 #define LAYERSUPER 4 
24 int Carg; 24 #define LAYERUPDATING Ox10 
25 }; 25 #define LAYERBACKDROP 0x40 
26 26 #define LAYERREFRESH 0x80 
27 #endif /* GRAPHICS _GRAPHINT_H */ 27 #define LAYER_CLIPRECTS_LOST Oxl00 /* during BeginUpdate */ 
28 /* or during layerop */ 
29 /7* this happens if out of memory */ 
30 #define LMN_REGION ~L 
31 
32 struct Layer_Info 
33 { 
34 struct Layer *top_layer; 
35 struct Layer *check_lp; /* system use */ 
36 struct Layer *obs; /* system use */ 
37 struct MinList FreeClipRects; 
38 struct SignalSemaphore Lock; 
39 struct List gs_Head; /* system use */ 
40 LONG longreserved ; 
41 UWORD (Flags; 
42 BYTE fatten_count; 
43 BYTE LockLayersCount ; 
44 UWORD LayerInfo_extra_size; 
45 WORD *blitbuff; 
a } struct LayerInfo_extra *LayerInfo_extra; 
f 
48 


49 #define NEWLAYERINFO CALLED 1 
50 #define ALERTLAYERSNOMEM 0x83010000 


52 #endif /* GRAPHICS LAYERS H */ 





Tv - a 




















Sep 19 20:26 1988 graphics/rastport.h Page 1 Sep 19 20:26 1988 graphics/rastport.h Page 2 
1 #ifndef GRAPHICS_RASTPORT_H 70 SHORT PenWidth; 
2 #define GRAPHICS_RASTPORT_H 71 SHORT PenHeight ; 
3 /* 72 struct TextFont *Font; /* current font address x/ 
4 ** $Filename: graphics/rastport.h $ 73 UBYTE AlgoStyle; /* the algorithmically generated style */ 
5 «x SRelease: 1.3 $ 74 UBYTE TxFlags ; /* text specific flags */ 
6 ** 75 UWORD TxHeight; /* text height */ 
7 ** 76 UWORD  ‘TxWidth; /* text nominal width */ 
8 ** 77 UWORD TxBaseline; /* text baseline */ 
Q xx (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 78 WORD TxSpacing; /* text spacing (per character) «f/f 
10 ** All Rights Reserved 79 APTR *RP_User; 
il */ 80 ULONG longreserved [2] ; 
12 81 #ifndef GFX_RASTPORT_1_ 2 
13 #ifndef GRAPHICS_GFX_H 82 UWORD ~wordreserved{7]; /* used to be a node */ 
14 #include <graphics/gfx.h> 83 UBYTE reserved [8]; /* for future use */ 
15 #endif 84 #endif 
16 85 J}; 
17 struct AreaInfo 86 
18 { 87 /* drawing modes */ 
19 SHORT *VctrTbl; /* ptr to start of vector table */ 88 #define JAM] 0 /* jam 1 color into raster */ 
20 SHORT *VctrPtr; 7* ptr to current vertex */ 89 #define JAM2 1 /* jam 2 colors into raster */ 
21 BYTE *FlagTbl; /* ptr to start of vector flag table */ 90 #define COMPLEMENT 2 /* XOR bits into raster */ 
22 BYTE *FlagPtr; /7* ptrs to areafill flags */ 91 #define INVERSVID 4 /* inverse video for drawing modes */ 
23 SHORT Count; /7* number of vertices in list */ 92 
24 SHORT  MaxCount; /* AreaMove/Draw will not allow Count>MaxCount*/ 93 /* these are the flag bits for RastPort flags */ 
25 SHORT FirstX,Pirsty; /7* first point for this polygon */ 94 #define FRST_DOT 0x01 /* draw the first dot of this line ? */ 
26 J; 95 #define ONE_DOT 0x02 /* use one dot mode for drawing lines */ 
27 96 #define DBUFFER 0x04 /* flag set when RastPorts 
28 struct TmpRas 97 are double-buffered */ 
29 98 
30 BYTE *RasPtr; 99 7* only used for bobs */ 
31 LONG Size; 100 
32 4; 101 #define AREAOUTLINE 0x08 /* used by areafiller */ 
33 102 #define NOCROSSFILL 0x20 /* areafills have no crossovers */ 
34 /* unoptimized for 32bit alignment of pointers */ 103 
35 struct GelsInfo 104 /* there is only one style of clipping: raster clipping */ 
36 { 105 /* this preserves the continuity of jaggies regardless of clip window */ 
37 BYTE sprRsrvd; /* flag of which sprites to reserve from 106 /* When drawing into a RastPort, if the ptr to ClipRect is nil then there */ 
38 vsprite system */ 107 /* is no clipping done, this is dangerous but useful for speed */ 
39 UBYTE Flags; /* system use */ 108 
40 struct VSprite *gelHead, *gelTail; /* dummy vSprites for list management*/ 109 #endif /* GRAPHICS _RASTPORT_H */ 
41 /* pointer to array of 8 WORDS for sprite available lines */ 
42 WORD *nextLine; 
43 /* pointer to array of 8 pointers for color-last-assigned to vSprites */ 
44 WORD **lastColor; 
45 struct collTable *collHandler; /* addresses of collision routines */ 
46 short leftmost, rightmost, topmost, bottommost; 
47 APTR firstBlissObj,lastBlissObj; /7/* system use only */ 
48 }; 
49 
50 struct RastPort 
51 { 
52 struct Layer *Layer; 
53 struct BitMap *BitMap; 
54 USHORT *AreaPtrn; /* ptr to areafill pattern */ 
55 struct TmpRas *TmpRas; 
56 struct AreaInfo *AreaInfo; 
57 struct Gelsinfo *GelsInfo; 
58 UBYTE Mask; /* write mask for this raster */ 
59 BYTE FgPen; /7* foreground pen for this raster. */ 
60 BYTE BgPen; /* background pen */ 
61 BYTE AO1Pen; 7* areafill outline pen */ 
62 BYTE DrawMode ; 7* drawing mode for fill, lines, and text */ 
63 BYTE AreaPtSz; /* 2°n words for areafill pattern */ 
64 BYTE linpatent; /* current line drawing pattern preshift */ 
65 BYTE dummy ; 
66 USHORT Flags; /7* miscellaneous control bits */ 
67 USHORT LinePtrn; /* 16 bits for textured lines */ 
68 SHORT cp_xX, Cp_y; /* current pen position */ 
|. 69 UBYTE minterms[8]; 





ce ~- da 


OCONAMNSWNE 


19 20:26 1988 graphics/regions.h Page 1 


#ifndef GRAPHICS REGIONS H 
#define GRAPHICS REGIONS_H 
f* 


an $Filename: graphics/regions.h $ 
ax $Release: 1.3 $ 

** 

wk 

Kk 


ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


ae All Rights Reserved 
*/ 
#ifndef GRAPHICS GFX_H 


#include <graphics/gfx.h> 
#tendif 


struct RegionRectangle 

{ 
struct RegionRectangle *Next,*Prev; 
struct Rectangle bounds; 

Ll; 

struct Region 

( 


struct Rectangle bounds; 
struct RegionRectangle *RegionRectangle; 


i 


#tendif /* GRAPHICS REGIONS H */ 





Sep 


WONAUEPWNE 


19 20:26 1988 graphics/sprite.h Page 1 


#ifndef GRAPHICS_SPRITE_H 
#define GRAPHICS_SPRITE_H 


/* 

** $Filename: graphics/sprite.h $ 

** $Release: 1.3 $ 

nx 

xx 

** 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xx All Rights Reserved 

*/ 


#define SPRITE_ATTACHED 0x80 


struct SimpleSprite 

f 
UWORD *posctldata; 
UWORD height; 
UWORD X¥i 
UWORD num; 


/* current position */ 
Ji 
#endif /* GRAPHICS_SPRITE_H */ 





€% -d 











Sep 


WOnNaUPWNe 


19 20:26 1988 graphics/text.h Page 1 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


FONE Sty Les mr x/ 
normal text (no style bits set) */ 
extended face (wider than normal) */ 


italic (slanted 1:2 right) */ 


bold face text (ORed w/ shifted) */ 


underlined (under baseline) */ 


FON FLAGS mm */ 


font is in rom */ 


font is from diskfont.library */ 


designed path is reversed (e.g. left) */ 


designed for hires non-interlaced */ 


designed for lores interlaced */ 


character sizes can vary from nominal */ 


/* size is "designed", not constructed */ 


/7* the font has been removed */ 


TextAttr node, matches text attributes in RastPort KRRERIRK KK / 


name of the font */ 


height of the font */ 
intrinsic font style */ 


#ifndef GRAPHICS_TEXT_H 
#define GRAPHICS_TEXT_H 
/* 
ee $Filename: graphics/text.h $ 
ae $Release: 1.3 $ 
Kk 
ak 
xx 
ak 
x All Rights Reserved 
*/ 
#ifndef EXEC_PORTS_H 
#include "exec/ports.h" 
#endif 
4 
#define FS_NORMAL 0 /* 
#define FSB_EXTENDED 3 /* 
#define FSF_EXTENDED (1<<3) 
#define FSB_ITALIC 2 /* 
#define PSF_ITALIC (1<<2) 
#define FSB_BOLD 1 /* 
#define FSF_BOLD (1<<1) 
#define FSB_UNDERLINED 0 /* 
#define FSF_UNDERLINED (1<<0) 
*—-— 
#define FPB_ROMFONT 0 /* 
define FPF_ROMFONT (1<<0) 
#define FPB_DISKFONT 1 /* 
#define FPF_DISKFONT (1<<1) 
#define FPB_REVPATH 2 /* 
#define FPF_REVPATH (1<<2) 
#define FPB_TALLDOT 3 /* 
define FPF_TALLDOT (1<<3) 
#define FPB_WIDEDOT 4 /* 
#define FPF_WIDEDOT (1<<4) 
#tdefine FPB_PROPORTIONAL 5 /* 
#define FPF_PROPORTIONAL (1<<5) 
#define FPB_DESIGNED 6 
#define FPF_DESIGNED (1<<6) 
#define FPB_REMOVED 7 
#tdefine FPF_REMOVED (1<<7) 
[RRKEKK 
struct TextAttr [{ 
STRPTR ta_Name; ft 
UWORD = ta_YSize; /* 
UBYTE ta_Style; /* 
UBYTE ta_Flags; /* 


V; 


font preferences and flags */ 


/teeeK* TextFonts node FOI III III III IOI ITAA IO IAAI IIA | 


struct T 


struct Message tf_Message; 


extFont { 


UWORD tf_YSize; 
UBYTE tf_ Style; 
UBYTE tf Flags; 
UWORD ti _xsize; 
UWORD tf_Baseline; 
UWORD tf_Boldsmear; 
UWORD tf_Accessors; 
UBYTE tf _LoChar; 
UBYTE tf£_HiChar; 


/* xveply message for font removal */ 


* font name in LN 


font height 
font style 


preferences and flags / 
nominal font width */ 
distance from the top of char to baseline */ 


used in this */ 


order to best */ 


match a font */ 
request. */ 


smear to affect a bold enhancement */ 


access count */ 


the first character described here */ 
the last character described here */ 


he 


APTR 


UWORD 
APTR 


APTR 
APTR 


tf_CharData; 


tf_Modulo; 
tf_CharLoc; 

f* 2 words: 
tf_CharSpace; 
tf_CharKern; 


79 #endif /* GRAPHICS TEXT_H */ 


Sep 19 20:26 1988 graphics/text.h Page 2 


/* the bit character data */ 


7* the row modulo for the strike font data */ 
/* ptr to location data for the strike font */ 


bit offset then size */ 


/* ptr to words of proportional spacing data */ 
/* ptr to words of kerning data */ 


vy -— a 


Sep 19 20:26 1988 graphics/view.h Page 1 
1 #ifndef GRAPHICS_VIEW_H 
2 #define GRAPHICS VIEW_H 
3 /* 
4 xe $Filename: graphics/view.h $ 
5 ** $Release: 1.3 $ 
6 ** 
7 wk 
B xx 
Q *k (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
1Q ** All Rights Reserved 
ll. */ 
12 
13 #ifndef GRAPHICS GFX_H 
14 #include <graphics/gfx .h> 
15 #endif 
16 
17 #ifndef GRAPHICS_COPPER_H 
18 #include <graphics/copper.h> 
19 #endif 
20 
21 struct ColorMap 
22 { 
23 UBYTE Flags; 
24 UBYTE Type; 
25 UWORD Count; 
26 APTR ColorTable; 
27 3; 
28 /* if Type == 0 then ColorTable is a table of UWORDS xRGB */ 
29 
30 struct ViewPort 
31 { 
32 struct .ViewPort *Next; 
33 struct: ColorMap *ColorMap; 7/* table of colors for this viewport */ 
34 /* if this is nil, MakeVPort assumes default values */ 
35 struct CopList *DspIns; /* user by MakeView() */ 
36 struct CopList *Sprins; /* used by sprite stuff */ 
37 struct CopList *ClriIns; /7* used by sprite stuff */ 
38 struct UCopList *UCopIns; /* User copper list */ 
39 SHORT DWidth,DHeight; 
40 SHORT DxOffset ,DyOffset; 
41 UWORD Modes ; 
42 UBYTE SpritePriorities; /* used by makevp */ 
43 UBYTE reserved; 
44 struct RasInfo *RasInfo; 
45 J; 
46 
47 struct View 
48 { 
49 struct ViewPort *ViewPort; 
50 struct cprlist *LOFCprList; /7/* used for interlaced and noninterlaced */ 
51 struct cprlist *SHFCprList; /* only used during interlace */ 
52 short DyOffset,DxOffset; /* for complete View positioning */ 
53 /* offsets are +- adjustments to standard #s */ 
54 UWORD Modes ; /* such as INTERLACE, GENLOC */ 
55 }; 
56 
57 /* defines used for Modes in IVPargs */ 
58 #define PFBA 0x40 
59 #define DUALPF 0x400 
60 #define HIRES 0x8000 
61 #define LACE . 4 
62 #define HAM 0x800 
63:#define SPRITES 0x4000 /* reuse one of plane ctr bits */ 
64 #define VP_HIDE 0x2000 /7* reuse another plane crt bit */ 
65 #define GENLOCK_AUDIO Ox1L00 
66 #define GENLOCK_VIDEO 2 
67 #define EXTRA_HALFBRITE 0x80 
68 
69 struct Rasinfo /* used by callers to and InitDspC() */ 


Sep 19 20:26 1988 graphics/view.h Page 2 


71 struct 
72 struct 


RasInfo *Next; 
BitMap *BitMap; 


73 SHORT RxOffset ,RyOffset; 
74 4; 

75 

76 tendif /* GRAPHICS VIEWH */ 


/* used for dualpf */ 


/* scroll offsets in this BitMap */ 

















Sh - a 





Sep 


WON AUSWNH 





19 20:26 1988 hardware/adkbits.h Page 1 


#ifndef HARDWARE_ADKBITS_H 
#define HARDWARE_ADKBITS_H 


/* 

ae $Filename: hardware/adkbits.h $ 

ek SRelease: 1.3 $ 

K* 

xe bit definitions for adkcon register 

“* 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 

*/ 


#define ADKB_SETCLR 15 /* standard set/clear bit */ 

#define ADKB PRECOMP1] 14 /* two bits of precompensation */ 
#define ADKB_PRECOMPO 13 

tdefine ADKB_MFMPREC 12 /* use mfm style precompensation */ 
#define ADKB_UARTBRK ll ./* force uart. output to zero */ 
#define ADKB_WORDSYNC 10 /* enable DSKSYNC register matching */ 


#define ADKB_MSBSYNC 9 /* (Apple GCR Only) sync on MSB for reading */ 
#define ADKB_FAST 8 /* 1 ~> 2 us/bit (mim), 2 —> 4 us/bit (ger) */ 
#define ADKB_USE3PN 7 /* use aud chan 3 to modulate period of ?? */ 
#tdefine ADKB_USE2P3 6 /* use aud chan 2 to modulate period of 3 */ 
#tdefine ADKB_USE1P2 5 * use aud chan 1 to modulate period of 2 */ 
tdefine ADKB_USEOP] 4 /* use aud chan 0 to modulate period of 1 */ 
#define ADKB_USE3VN 3 /* use aud chan 3 to modulate volume of ?? */ 
#define ADKB_USE2V3 2 /* use aud chan 2 to modulate volume of 3 */ 
#tdefine ADKB_USE1V2 1 /* use aud chan 1 to modulate volume of 2 */ 
#define ADKB_USEOV1 0 /* use aud chan 0 to modulate volume of 1 */ 
#tdefine ADKF SETCLR (1<<15) 

#define ADKF PRECOMP] (1<<14) 

#define ADKF_PRECOMPO (1<<13) 

#define ADKF_MFMPREC (1<<12) 

#define ADKF_UARTBRK (1<<11) 

#define ADKF_WORDSYNC (1<<10) 

#define ADKF MSBSYNC  (1<<9) 

tdefine ADKF_FAST (1<<8) 

#define ADKF_USE3PN (1<<7) 

#define ADKF_USE2P3 (1<<6) 

#define ADKF_USE1P2 (1<<5) 

#define ADKF_USEOP1] (1<<4) 

#define ADKF_USE3VN (1<<3) 

#define ADKF_USE2V3 (1<<2) 

#define ADKF_USE1V2 (1<<1) 

#define ADKF_USEOV1 (1<<0) 

#define ADKF_PREOOONS 0 /* 000 ns of precomp */ 
#define ADKF_PRE140NS (ADKF_PRECOMPO) /* 140 ns of precomp */ 
#define ADKF_PRE280NS (ADKF_PRECOMP] /7* 280 ns of precomp */ 
#define ADKF_PRE560NS ADKE” PRECOMPO|ADKF_PRECOMP1 ) /* 560 ns of precomp */ 


#endif /* HARDWARE_ADKBITS_H */ 








Sep 


WON DN UNewWNHP 


19 20:26 1988 hardware/blit.h Page 1 


#ifndef HARDWARE_BLIT_H 

#define HARDWARE_BLIT_H 

/* 

eK $Filename: hardware/blit.h $ 
aK $Release: 1.3 $ 

xk 

ae include file for blitter 


bd (C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 
* All Rights Reserved 


#define HSIZEBITS 6 

#define VSIZEBITS 16-HSIZEBITS - 

#tdefine HSIZEMASK 0x3f /* 26 — 1 */ 
#define VSIZEMASK 0x3FF /* 2-10 - 1 */ 


#define MAXBYTESPERROW 128 
/* definitions for blitter control register 0 */ 


#define ABC 0x80 
#define ABNC 0x40 
#define ANBC 0x20 
#define ANBNC 0x10 
#define NABC 0x8 
#define NABNC 0x4 
#define NANBC 0x2 
#define NANBNC Oxl 


/* some commonly used operations «f/f 
#define A_OR_B ABC | ANBC | NABC | ABNC | ANBNC |NABNC 











#define A_OR_C ABC | NABC | ABNC ANBC | NANBC:| ANBNC 

¥define ALXOR_C NABC|ABNC — | NANBC}ANBNC 

#define A_TO_D ABC | ANBC | ABNC | ANBNC 

#define BCOB_ DEST 8 

#define BCOB_SRCC 9 

#define BCOB_SRCB 10 

#define BCOB_SRCA 11 

#define BCOF_DEST 0x100 

#define BCOF_SRCC 0x200 

#define BCOF_SRCB 0x400 

#tdefine BCOF_SRCA 0x800 

#define BCIF_DESC 2 /* blitter descend direction */ 
#define DEST 0x100 

define SRCC 0x200 

define SRCB 0x400 

#define SRCA 0x800 

define ASHIFTSHIFT 12 /* bits to right align ashift value */ 
#tdefine BSHIFTSHIFT 12 /* bits to right align bshift value */ 
/* definations for blitter control register 1 */ 

#define LINEMODE Oxl 

define FILL_OR 0x8 

#define FILL_XOR 0x10 

#define FILL_CARRYIN 0x4 

#define ONEDOT 0x2 /* one dot per horizontal line */ 
define OVFLAG 0x20 

#define SIGNFLAG 0x40 

#define BLITREVERSE 0x2 

#define SUD OxLdO 

define SUL 0x8 

#define AUL Ox4 





9% -a 





19 20:26 1988 hardware/blit.h Page 2 


#define OCTANT8 24 
#define OCTANT7 4 
#define OCTANT6 12 
#define OCTANTS 28 
#define OCTANT4 20 
#define OCTANT3 8 
#define OCTANT2 0 
#define OCTANTL 16 


/* stuff for blit qeuer */ 
struct bltnode 
{ 
struct bltnode *n; 
int (*function) (); 
char stat; 
short blitsize; 
short beamsync; 
int (*cleanup) (); 
I; 
/* defined bits for bltstat */ 
#define CLEANUP 0x40 
#tdefine CLEANME CLEANUP 


#endif /* HARDWARE BLIT_H */ 


Sep 


WON AUP WHE 


19 


#ifndef HARDWARE_CIA_H 
#define HARDWARE _CIA_H 


f* 
xk 
ak 
ak 
xk 
KK 
ak 
wk 


*/ 


struct CIA { 


3 


/* 


#define CIAICRB TA 
#define CIAICRB_TB 
#define CIAICRB_ALRM 
#define CIAICRB_SP 
#define CIAICRB_FLG 
#define CIAICRB_IR 
#define CIAICRB_SETCLR 7 


/* 


#define CIACRAB_START 0 
#define CIACRAB_ PBON 1 
#define CIACRAB_OUTMODE 2 


20:26 1988 hardware/cia.h Page 1 


$Filename: hardware/cia.h $ 
SRelease: 1.3 $ 





registers and bits in the Complex Interface Adapter (CIA) chip 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


ciaa is on an ODD address (e.g. the low byte) —- $bfe001 
ciab is on an EVEN address (e.g. the high byte) —- $bfd000 


do this to get the definitions: 
extern struct CIA ciaa, ciab; 


UBYTE ciapra; 
UBYTE padO[0Oxff]; 
UBYTE ciaprb; 
UBYTE padl[Oxff]; 
UBYTE ciaddra; 
UBYTE pad2 [Oxff]; 
UBYTE ciaddrb; 
UBYTE pad3 [Oxff]; 
UBYTE ciatalo; 
UBYTE pad4 [0Oxff]; 
UBYTE ciatahi; 
UBYTE pad5/[0Oxff]; 
UBYTE ciatblo; 
UBYTE pad6 [Oxff] ; 
UBYTE ciatbhi; 
UBYTE pad7 [0Oxff] ; 
UBYTE ciatodlow; 
UBYTE pad8 [0xff]; 
UBYTE ciatodmid; 
UBYTE pad9 [(Oxff]; 
UBYTE ciatodhi; 
UBYTE padi0[Oxff]; 
UBYTE unusedreg; 
UBYTE padll[Oxff]}; 
UBYTE ciasdr; 
UBYTE padl2{Oxffl; 
UBYTE ciaicr; 
UBYTE padl3(Oxff]; 
UBYTE clacra; 
UBYTE padl4[Oxff]; 
UBYTE ciacrb; 


interrupt control register bit numbers */ 


“IP WN RO 


control register A bit numbers */ 











19 20:26 1988 hardware/cia.h Page 2 19 20:26 1988 hardware/cia.h Page 3 





iv-d 

















70 #define CIACRAB_RUNMODE 3 139 #define CIAB_COMRTS (6) /* serial Request to Send* */ 
71 #define CIACRAB_LOAD 4 140 #define CIAB_COMCD (5) /* serial Carrier Detect* */ 
72 #define CIACRAB_INMODE 5 141 #define CIAB_COMCTS (4) /* serial Clear to Send* */ 
73 #define CIACRAB SPMODE 6 142 #define CIAB_COMDSR (3) /* serial Data Set Ready* */ 
74 #define CIACRAB_TODIN 7 143 #define CIAB_PRTRSEL (2) /7* printer SELECT */ 
75 144 #define CIAB_PRTRPOUT ql) /* printer paper out */ 
76 /* control register B bit numbers */ 145 #define CIAB_PRTRBUSY (0) /* printer busy */ 
77 #define CIACRBB_START 0 146 
78 #define CIACRBB_PBON 1 147 /* ciab port B (Oxbfdl100) —- disk control */ 
79 #define CIACRBB_OUTMODE 2 148 #define CIAB_DSKMOTOR (7) /* disk motorr* .*/ 
80 #define CIACRBB_RUNMODE 3 149 #define CIAB_DSKSEL3 (6) /* disk select unit 3* */ 
81 #define CIACRBB_LOAD 4 150 #define CIAB_DSKSEL2 (5) /* disk select unit 2* */ 
82 #define CIACRBB_INMODEO 5 151 #define CIAB_DSKSEL1 (4) /* disk select unit 1* */ 
83 #define CIACRBB_INMODE] 6 152 #define CIAB_DSKSELO (3) /* @isk select unit 0* */ 
84 #define CIACRBB_ALARM 7 153 #define CIAB_DSKSIDE (2) 7* disk side select* */ 
85 154 #define CIAB_DSKDIREC (1) /* disk direction of seek* */ 
86 /* interrupt control register masks */ 155 #define CIAB_DSKSTEP (0) /7* disk step heads* */ 
87 #define CIAICRF_TA (1<<CIAICRB_TA) 156 
88 #define CIAICRF_TB (1<<CIAICRB_TB) 157 /* ciaa port A (Oxbfe001) */ 
89 #define CIAICRF_ALRM (1<<CIAICRB_ALRM) 158 #define CIAF_GAMEPORT] (1<<7) 
90 #define CIAICRF_SP (1<<CIAICRB_SP) 159 #define CIAF_GAMEPORTO (1<<6) 
91 #define CIAICRF_FLG (1<<CIAICRB_FLG) 160 #define CIAF_DSKRDY (1<<5) 
92 #define CIAICRF_IR (1<<CIAICRB_IR) 161 #define CIAF_DSKTRACKO (1<<4) 
93 #define CIAICRF SETCLR (1<<CIAICRB_SETCLR) 162 #define CIAF_DSKPROT (1<<3) 
94 163 #define CIAF_DSKCHANGE (1<<2) 
95 /* control register A register masks */ 164 #define CIAF_LED (1<<1)y 
96 #define CIACRAF_START (1<<CIACRAB_START) 165 #define CIAF_OVERLAY (1<<0) 
97 #define CIACRAF_PBON (1<<CIACRAB_PBON) 166 
98 #define CIACRAF_OUTMODE (1<<CIACRAB_OUTMODE) 167 /* ciaa port B (0xbfel01) -~- parallel port */ 
99 #define CIACRAF_RUNMODE (1<<CIACRAB RUNMODE) 168 
100 #define CIACRAF_LOAD (1<<CIACRAB_LOAD) 169 /* ciab port A (Oxbfd000) -- serial and printer control */ 
101 #define CIACRAF_INMODE (1<<CIACRAB_INMODE) 170 #define CIAF_COMDTR (1<<7) 
102 #define CIACRAF_SPMODE (1<<CIACRAB_SPMODE) 171 #define CIAF_COMRTS (1<<6) 
103 #define CIACRAF_TODIN (1<<CIACRAB_TODIN) 172 #define CIAF_COMCD (1<<5) 
104 173 #define CIAF_COMCTS (1<<4) 
105 /* control register B register masks */ 174 #define CIAF_COMDSR (1<<3) 
106 #define CIACRBF_START (1<<CIACRBB_START) 175 #define CIAF_PRTRSEL (1<<2) 
107 #define CIACRBF_PBON (1<<CIACRBB_PBON) 176 #define CIAF_PRTRPOUT (1<<1) 
108 #define CIACRBF_OUTMODE (1<<CIACRBB_OUTMODE) 177 #define CIAF_PRTRBUSY (1<<0) 
109 #define CIACRBF_RUNMODE (1<<CIACRBB_RUNMODE) 178 
110 #define CIACRBF_LOAD (1<<CIACRBB_LOAD) 179 /* ciab port B (0xbfd100) -~ disk control */ 
111 #define CIACRBF_INMODEO (1<<CIACRBB_INMODEO) 180 #define CIAF _DSKMOTOR (1<<7) 
112 #define CIACRBF_INMODE1 (1<<CTACRBB_INMODE1) 181 #define CIAF_DSKSEL3 (1<<6) 
113 #define CIACRBF_ALARM  (1<<CIACRBB_ALARM) 182 #define CIAF_DSKSEL2 (1<<5) 
114 183 #define CIAF_DSKSEL1 (1<<4) 
115 /* control register B INMODE masks */ 184 #define CIAF_DSKSELO (1<<3) 
116 #define CIACRBF_IN_PHI2 0 185 #define CIAF_DSKSIDE (1<<2) 
117 #define CIACRBF_IN CNT (CIACRBF_INMODEO) 186 #define CIAF DSKDIREC (1<<1) 
118 #define CIACRBF_IN_TA  (CIACRBF_INMODE1) 187 #define CIAF_DSKSTEP (1<<0) 
119 #define CIACRBF_IN_CNT_TA (CIACRBF_INMODEO | CTACRBF_INMODE1) 188 
120 189 #endif /* HARDWARE_CIA_H */ 
121 /* 
122 * Port definitions —- what each bit in a cia peripheral register is tied to 
123 */ 
124 
125 /* ciaa port A (Oxbfe001) */ 
126 #define CIAB_GAMEPORT1 (7) /* gameport 1, pin 6 (fire button*) */ 
127 #define CIAB_GAMEPORTO (6) /* gameport 0, pin 6 (fire button*) */ 
128 #define CIAB_DSKRDY (5) /* disk ready* */ 
129 #define CIAB_DSKTRACKO (4) /7* disk on track 00* */ 
130 #define CIAB_DSKPROT (3) /* disk write protect* */ 
131 #define CIAB_DSKCHANGE (2) /7* disk change* */ 
132 #define CIAB_LED (1) /* led light control (0==>bright) */ 
133 #define CIAB_OVERLAY (0) /7* memory overlay bit */ 
134 
135 /* ciaa port B (Oxbfel01) —- parallel port */ 
136 
137 /* ciab port A (Oxbfd000) —- serial and printer control */ 
138 #define CIAB_COMDTR (7) /* serial Data Terminal Ready* */ 








8y -d 


Sep 


CONAN EWN 


19 20:26 1988 hardware/custom.h Page 1 


#ifndef HARDWARE_CUSTOM_H 
#define HARDWARE_CUSTOM_H 


/* 
x $Filename: hardware/custom.h $ 

ae $Release: 1.3 $ 

xk 

xk 

Kk 

ae (C) Copyright 1985,1986,1987,1988 Commodore—Amiga,. Inc. 
** All Rights Reserved 

xf 


* 


* do this to get base of custom registers: 


* extern struct Custom custom; 
*/ 


struct Custom [{ 
UWORD bitddat; 
UWORD = dmaconr; 
UWORD vposr; 
UWORD  -vhposr; 
UWORD dskdatr; 
UWORD = joy(Odat; 
UWORD joyldat; 
UWORD clxdat; 
UWORD = adkconr; 
UWORD. pot0Odat; 
UWORD = pot ldat; 
UWORD = pot.inp; 
UWORD _ serdatr; 
UWORD = dskbytr; 
UWORD = intenar; 
UWORD = intreqr; 
APTR dskpt; 
UWORD = dsklen; 
UWORD dskdat; 
UWORD  refptr; 
UWORD vposw; 
UWORD = vhposw; 
UWORD copcon; 
UWORD serdat; 
UWORD serper; 
UWORD pot go; 
UWORD joytest; 
UWORD strequ; 
UWORD strvbl; 
UWORD = strhor; 
UWORD = strlong; 
UWORD = bitcon0; 
UWORD bil tconl; 
UWORD_ bltafwm; 
UWORD - bltalwm; 
APTR bltept; 
APTR bltbpt; 
APTR bltapt; 
APTR bltdpt; 
UWORD bltsize; 
UWORD = pad2d [3]; 
UWORD = bl tcmod; 
UWORD bltbmod; 
UWORD bltamod; 
UWORD bltdmod ; 
UWORD pad34[4]; 
UWORD = bltcdat; 
UWORD = bithdat; 
UWORD bltadat; 
UWORD _ pad3b [4]; 


70 UWORD dsksync; 

71 ULONG = copllc; 

72 ULONG = cop2lc; 

73 UWORD = copjmp1; 

74 UWORD = cop jmp2; 

75 UWORD ~s copins; 

76 UWORD diwstrt; 

77 UWORD = diwstop; 

78 UWORD ddfstrt; 

79 UWORD ddfstop; 

80 UWORD dmacon ; 

81 UWORD = clxcon; 

82 UWORD intena; 

83 UWORD intreq; 

84 UWORD = adkcon; 

85 struct AudChannel { 

86 UWORD *ac_ptr; /* ptr to start of waveform data */ 
87 UWORD ac_len; /* length of waveform in words */ 
838 UWORD ac_per; /* sample period */ 
89 UWORD ac_vol; /7* volume * 
90 UWORD ac_dat; * sample pair */ 
91 UWORD ac_pad{2]; /* unused * 
92 } aud[4]; 

93 APTR bplpt [6]; 

94 UWORD_— pad7c[4]J; 

95 UWORD = bplcon0; 

96 UWORD = bplconi; 

97 UWORD — bplcon2; 

98 UWORD pad83; 

99 UWORD = bplimod; 

100 UWORD = bp 12mod; 

101 UWORD pad86[2]; 

102 UWORD = bpldat [6]; 

103 UWORD pad8e[2]; 

104 APTR sprpt [8] ; 

105 struct SpriteDef { 

106 UWORD pos; 

107 UWORD ctl; 

108 UWORD dataa; 

109 UWORD datab; 

110 } spr [8]; 

1i1 UWORD color [32]; 

112 3}; 

113 


Sep 19 20:26 1988 hardware/custom.h Page 2 


114 #endif /* HARDWARE_CUSTOM_H */ 








6¢ -— a 








n 
a 
© 


CONAN WHE 


19 20:26 1988 hardware/dmabits.h Page 1 


#ifndef HARDWARE_DMABITS_H 
#define HARDWARE_DMABITS_H 


* 
xk 
k* 
KK 
xk 
ak 
ak 
nk 


*/ 


$Filename: hardware/dmabits.h $ 
$Release: 1.3 $ 


include file 


(C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 


for defining dma control stuff 


All Rights Reserved 


/* write definitions 


#tdefine 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 


/* read 
7* bits 
#define 
#define 


#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 


DMAF_SETCLR 
DMAF_AUDIO 
DMAF_AUDO 
DMAF_AUD1 
DMAF_AUD2 
DMAF_AUD3 
DMAF_DISK 
DMAF_SPRITE 
DMAF BLITTER 
DMAF_COPPER 
DMAF RASTER 
DMAF_MASTER 
DMAF_BLITHOG 
DMAF_ALL 


for dmaconw */ 
0x8000 
Ox000F 
0x0001 
0x0002 
0x0004 
0x0008 
0x0010 
0x0020 
0x0040 
0x0080 
0x0100 
0x0200 
0x0400 
OxOLFF 


/* 4 bit mask */ 


/* all dma channels */ 


definitions for dmaconr */ 
0-8 correspnd to dmaconw definitions */ 


DMAF_BLTDONE 


DMAF_BLTNZERO. 


DMAB_SETCLR 
DMAB_AUDO 
DMAB_AUD1 
DMAB_AUD2 
DMAB_AUD3 
DMAB_DISK 
DMAB_ SPRITE 
DMAB_BLITTER 
DMAB COPPER 
DMAB_RASTER 
DMAB_MASTER 
DMAB_BLITHOG 
DMAB_BLTDONE 


DMAB_BLTNZERO 


0x4000 
0x2000 


PRO OANDNUPWNHROY 
ui 


oO 


13 


#endif /* HARDWARE _DMABITS_H */ 





Sep 


WONKA WN HE 





19 20:27 1988 hardware/intbits.h Page 1 


#ifndef HARDWARE_INTBITS_H 
#define HARDWARE_INTBITS_H 


/* 
xk 
Kk 
Kk 
ak 
ak 
kk 
xk 


*/ 


#define 


#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 


#tendif /* HARDWARE_INTBITS_H */ 


$Filename: hardware/intbits.h $ 


SRelease: 1.3 $ 


bits in the interrupt enable (and interrupt request) register 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


INTB_SETCLR 


(15) /* 


Set/Clear control bit. Determines if bits */ 


/* written with a 1 get set or cleared. Bits */ 
/* written with a zero are allways unchanged */ 


INTB_INTEN 
INTB_EXTER 
INTB_DSKSYNC 
INTB_RBF 
INTB_AUD3 
INTB_AUD2 
INTB_AUD1 
INTB_AUDO 
INTB_BLIT 
INTB_VERTB 
INTB_COPER 
INTB_PORTS 
INTB_SOFTINT 
INTB_DSKBLK 
INTB_TBE 


INTF_SETCLR 
INTF_INTEN 
INTF_EXTER 
INTF-DSKSYNC 
INTF_RBF 
INTF_AUD3 
INTF_AUD2 
INTF_AUDL 
INTF_AUDO 
INTF_BLIT 
INTF_VERTB 
INTF_COPER 
INTF_PORTS 
INTF_SOFTINT 
INTF_DSKBLK 
INTF ‘TBE 


(14) /* 
(13) /* 
(12) /* 
(11) /* 
(10) /* 
(9) /* 
(8) /* 
(7) /* 
(6) /* 
(5) /* 
(4) /* 
(3) 7 
(2) /* 
(1) /* 
(0) /* 


(1<<15) 
(1<<14) 
(1<¢13) 
(1<<12) 
(1<<11) 
(1<¢10) 
(1649) 
(1<<8) 
(1<<7) 
(1<<6) 
(1<<5) 
(1<<4) 
(1<63) 
(1&2) 
(11) 
(1<<0) 


Master interrupt (enable only ). */ 
External interrupt */ 

Disk re~SYNChronized */ 

serial port Receive Buffer Full */ 
Audio channel 3 block finished */ 
Audio channel 2 block finished */ 
Audio channel 1 block finished */ 
Audio channel 0 block finished */ 
Blitter finished */ 

start of Vertical Blank */ 
Coprocessor */ 

I/O Ports and timers */ 

software interrupt request */ 

Disk Block done */ 

serial port Transmit Buffer Empty */ 








os —-a 


Sep 


WOONKDUSPWNE 


19 20:27 1988 intuition/intuition.h Page 1 


#ifndef INTUITION_INTUITION_H 
#define INTUITION_INTUITION_H 


/* 
** $Filename: intuition/intuition.h $ 
** $Release: 1.3 $ 

ak 

** main intuition include 

kk 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 

*/ 


#ifndef EXEC_TYPES_H 
#include "exec/types.h" 
#endif 


#ifndef GRAPHICS_GFX_H 
#include “graphics/gfx.h" 
#tendif 


#ifndef GRAPHICS CLIP_H 
#include "graphics/clip.h" 
#endif 


#ifndef GRAPHICS VIEW_H 
#include "graphics/view.h" 
#tendif 


#ifndef GRAPHICS_RASTPORT_H 
#include "graphics/rastport.h" 
#tendif 


#ifndef GRAPHICS_LAYERS H 


Sep 19 20:27 1988 intuition/intuition.h Page 2 


70 

71 /* FLAGS SET BY BOTH THE APPLIPROG AND INTUITION */ 

72 #define MENUENABLED 0x0001 /* whether or not this menu is enabled */ 
73 

74 /* FLAGS SET BY INTUITION */ 


75 #define MIDRAWN 0x0100 /* this menu's items are currently drawn */ 



































pointer to next in chained list */ 
position of the select box */ 
dimensions of the select box */ 
see the defines below */ 


struct MenuItem *NextItem; 
SHORT LeftEdge, TopEdge; 
SHORT Width, Height; 
USHORT Flags; 


LONG MutualExclude; set bits mean this item excludes that */ 


APTR ItemFill; /* points to Image, IntuiText, or NULL */ 

/7* when this item is pointed to by the cursor and the items highlight 
* mode HIGHIMAGE is selected, this alternate image will be displayed 
* 


APTR SelectFill; /* points to Image, IntuiText, or NULL */ 


BYTE Command; 


struct MenuItem *SubItem; 


/* only if appliprog sets the COMMSEQ flag */ 


/* if non-zero, DrawMenu shows "->" */ 


#include "graphics/layers.h" 
#endif 


#ifndef GRAPHICS TEXT _H 
#include "graphics/text.h" 
#endif 


#ifndef EXEC_PORTS_H 
#include "exec/ports.h" 
#tendif 


#ifndef DEVICES_TIMER_H 
#include "devices/timer.h" 
#endif 


#ifndef DEVICES_INPUTEVENT_H 
#include "devices/inputevent.h" 
#endif 


























struct Menu 


struct Menu *NextMenu; same level */ 

SHORT LeftEdge, TopEdge; /* position of the select box */ 
SHORT Width, Height; * dimensions of the select box */ 
USHORT Flags; /* see flag definitions below */ 
BYTE *MenuName; /* text for this Menu Header */ 
struct MenuItem *FirstItem; /* pointer to first in chain */ 


/* these mysteriously—named variables are for internal use only */ 
SHORT JazzX, JazzY, BeatX, BeatY; 


/* The NextSelect field represents the menu number of next selected 
* item (when user has drag-selected several items) 


* 
USHORT NextSelect ; 
1; 


/* FLAGS SET BY THE APPLIPROG */ 
#define CHECKIT 0x0001 
#define ITEMTEXT 0x0002 
#define COMMSEQ 0x0004 
#define MENUTOGGLE 0x0008 
#define ITEMENABLED 0x0010 


/* these are the SPECIAL HIGHLIGHT 
#define HIGHFLAGS 0x00cO /* 
#define HIGHIMAGE 0x0000 /* 
#tdefine HIGHCOMP 0x0040 /* 
#define HIGHBOX 0x0080 = /* 
#define HIGHNONE 0x00co = /* 


/* FLAGS SET BY BOTH APPLIPROG AND 
#define CHECKED 0x0100 /* 


/* FLAGS SET BY INTUITION */ 

#define ISDRAWN Qx1000 /* 
#define HIGHITEM 0x2000 /* 
#define MENUTOGGLED 0x4000 /* 


whether to check this item if selected */ 
set if textual, clear if graphical item */ 
set if there's an command sequence */ 

set to toggle the check of a menu item */ 
set if this item is enabled */ 


FLAG state meanings */ 

see definitions below for these bits */ 
use the user's "select image" */ 

highlight by complementing the selectbox */ 
highlight by "boxing" the selectbox */ 
don't highlight */ 


INTUITION */ 
if CHECKIT, then set this when selected */ 


this item's subs are currently drawn */ 
this item is currently highlighted */ 
this item was already toggled */ 





138 /* sassossssesceesscasessess= 








Sep 19 20:27 1988 intuition/intuition.h Page 3 Sep 19 20:27 1988 intuition/intuition.h Page 4 



























208 * nothing to be rendered about this Gadget) 
209 * 
141 struct Requester 210 APTR GadgetRender ; 
142 [ 211 
143 /* the ClipRect and BitMap and used for rendering the requester */ 212 /* appliprog can specify "highlighted" imagery rather than algorithmic 
144 struct Requester *OlderRequest; 213 * this can point to either Border or Image data 
145 SHORT LeftEdge, TopEdge; /7* dimensions of the entire box */ 214 *f 
146 SHORT Width, Height; 7* dimensions of the entire box */ 215 APTR SelectRender; 
147 SHORT ReliLeft, RelTop; /7/* for Pointer relativity offsets */ 216 
148 217 struct IntuiText *GadgetText; /* text for this gadget */ 
149 struct Gadget *ReqGadget ; /* pointer to a list of Gadgets */ 218 
150 struct Border *ReqBorder; /* the box's border */ 219 /* by using the MutualExclude word, the appliprog can describe 


which gadgets mutually-exclude which other ones. The bits 


151 struct IntuiText *ReqText; /* the box's text */ 220 
in MutualExclude correspond to the gadgets in object containing 


* 
152 USHORT Flags; /* see definitions below */ 221 * 
153 222 * the gadget list. If this gadget is selected and a bit is set 

154 /* pen number for back-plane fill before draws */ 223 * in this gadget's MutualExclude and the gadget corresponding to 

155 UBYTE BackFiil; 224 * that bit is currently selected (e.g. bit 2 set and gadget 2 

156 /* Layer in place of clip rect xf 225 * is currently selected) that gadget must be unselected. 

157 struct Layer *ReqLayer; 226 * Intuition does the visual unselecting (with checkmarks) and 

158 227 * leaves it up to the program to unselect internally 

159 UBYTE ReqgPad1 [32]; 228 x/ 

160 229 LONG MutualExclude; /* set bits mean this gadget excludes that gadget */ 
161 /* If the BitMap plane pointers are non-zero, this tells the system 230 


TS -d 


162 * that the image comes pre-drawn (if the appliprog wants to define 231 /* pointer to a structure of special data required by Proportional, 

163 * it's own box, in any shape or size it wants!); this is OK by 232 * String and Integer Gadgets 

164 * Intuition as long as there's a good correspondence between 233 * 

165 * the image and the specified Gadgets 234 APTR SpecialInfo; 

166 *f 235 

167 struct BitMap *ImageBMap; /* points to the BitMap of PREDRAWN imagery */ |236 USHORT GadgetID; /* user-definable ID field */ 

168 struct Window *RWindow; /* added. points back to Window */ 237 APTR UserData; /* ptr to general purpose User data (ignored by In) */ 
169 UBYTE ReqPad2 [36]; 238 3; 

170 }; 239 

171 240 

172 241 /* —-- FLAGS SET BY THE APPL TPROG sor *f 
173 /* FLAGS SET BY THE APPLIPROG */ 242 /* combinations in-these bits describe the highlight technique to be used */ 
174 #define POINTREL 0x0001 /* if POINTREL set, TopLeft is relative to pointer*/ 243 #define GADGHIGHBITS 0x0003 

175 #define PREDRAWN 0x0002 /* if ReqBMap points to predrawn Requester imagery */ |244 #define GADGHCOMP 0x0000 /* Complement the select box */ 

176 define NOISYREQ 0x0004 /* if you don't want requester to filter input xf 245 #define GADGHBOX 0x0001 /* Draw a box around the image */ 

177 /* FLAGS SET BY BOTH THE APPLIPROG AND INTUITION */ 246 #define GADGHIMAGE 0x0002 /* Blast in this alternate image */ 

178 247 #tdefine GADGHNONE 0x0003 /* don't highlight */ 

179 /* FLAGS SET BY INTUITION xf 248 

180 #define REQOFFWINDOW 0xl000. /* part of one of the Gadgets was offwindow */ |249 /* set this flag if the GadgetRender and SelectRender point to Image imagery, 
181 #define REQACTIVE 0x2000 /* this requester is active */ 250 * clear if it's a Border 

182 #define SYSREQUEST 0x4000 /* this requester caused by system */ 251 * 


0x8000 this Requester stops a Refresh broadcast */ {252 #define GADGIMAGE 0x0004 

253 

254 /* combinations in these next two bits specify to which corner the gadget's 
255 * Left & Top coordinates are relative. If relative to Top/Left, 

256 * these are "normal" coordinates (everything is relative to something in 


257. * this universe) 


#define DEFERREFRESH 








258 */ 
259 #define GRELBOTTOM 0x000s /* set if rel to bottom, clear if rel top */ 
260 #define GRELRIGHT 0x0010 /* set if rel to right, clear if to left */ 








261 /* set the RELWIDTH bit to spec that Width is relative to width of screen */ 
262 #define GRELWIDTH 0x0020 


struct Gadget 
{ 263 /* set the RELHEIGHT bit to spec that Height is rel to height of screen */ 





struct Gadget *NextGadget; /* next gadget in the list */ 264 #define GRELHEIGHT 0x0040 
265 
SHORT LeftEdge, TopEdge; /* “hit box" of gadget */ - 266 /* the SELECTED flag is initialized by you and set by Intuition. It 
SHORT Width, Height; /* “hit box" of gadget */ 267 * specifies whether or not this Gadget is currently selected/highlighted 
268 * 
USHORT Flags; /* see below for list of defines */ 269 #define SELECTED 0x0080 
270 
USHORT Activation; /* see below for list of defines */ 271 
272 /* the GADGDISABLED flag is initialized by you and later set by Intuition 
USHORT GadgetType; /* see below for defines */ 273 * according to your calls to On/OffGadget(). It specifies whether or not 


274 * this Gadget is currently disabled from being selected 
/* appliprog can specify that the Gadget. be rendered as either as Border 275 */ 
* or an Image. This variable points to which (or equals NULL if there's 276 #define GADGDISABLED 0x0100 








cg - da 


Sep 


277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 
299 
300 
301 
302 
303 
304 
305 
306 
307 
308 
309 
310 
311 
312 
313 
314 
315 
316 
317 
318 
319 
320 
321 
322 
323 
324 
325 
326 
327 
328 
329 
330 
331 
332 
333 
334 
335 
336 
337 
338 
339 
340 
341 
342 
343 
344 
345 








19 20:27 1988 intuition/intuition.h Page 5 


/* ——— These are the Activation flag bits 
/* RELVERIFY is set if you want to verify that the pointer was still over 
* the gadget when the select button was released 
*x 


#define RELVERIFY 0x0001 

/* the flag GADGIMMEDIATE, when set, informs the caller that the gadget 
* was activated when it was activated. this flag works in conjunction with 
* the RELVERIFY flag 
* 


#define GADGIMMEDIATE 0x0002 
/* the flag ENDGADGET, when set, tells the system that this gadget, when 
* selected, causes the Requester or AbsMessage to be ended. Requesters or 
* BbsMessages that are ended are erased and unlinked from the system */ 
#define ENDGADGET 0x0004 
/* the FOLLOWMOUSE flag, when set, specifies that you want to receive 
reports on mouse movements (ie, you want the REPORTMOUSE function for 
your Window). When the Gadget is deselected (immediately if you have 
no RELVERIFY) the previous state of the REPORTMOUSE flag is restored 
You probably want to set the GADGIMMEDIATE flag when using FOLLOWMOUSE, 
since that's the only reasonable way you have of learning why Intuition 
is suddenly sending you a stream of mouse movement events. If you don't 
set RELVERIFY, you'll get at least one Mouse Position event. 


4 + eH OH HO 


* 


#define FOLLOWMOUSE 0x0008 


/* if any of the BORDER. flags are set in a Gadget that's included in the 
* Gadget list when a Window is opened, the corresponding Border will 
* be adjusted to make room for the Gadget 
x 


#define RIGHTBORDER 0x0010 

#tdefine LEFTBORDER 0x0020 

#define TOPBORDER 0x0040 

#define BOTTOMBORDER 0x0080 

#define TOGGLESELECT 0x0100 /* this bit for toggle~select mode */ 

#tdefine STRINGCENTER 0x0200 /* should be a Stringinfo flag, but it's OK */ 
#define STRINGRIGHT 0x0400 /* should be a StringInfo flag, but it's OK */ 
#define LONGINT 0xos00 6 /* this String Gadget is actually LONG Int */ 
#define ALTKEYMAP 0x1000 /* this String has an alternate keymap */ 
#define BOOLEXTEND 0x2000 /* this Boolean Gadget has a BoolInfo */ 

/* ~~~ GADGET TYPES me Sanat 





/* These are the Gadget Type definitions for the variable GadgetType 
* gadget number type MUST start from one. NO TYPES OF ZERO ALLOWED. 
* first comes the mask for Gadget flags reserved for Gadget typing 
* 


#define GADGETTYPE OxFc00 /* all Gadget Global Type flags (padded) */ 
tdefine SYSGADGET 0x8000 /* 1 = SysGadget, 0 = AppliGadget */ 
#define SCRGADGET 0x4000 /* 1 = ScreenGadget, 0 = WindowGadget */ 
#tdefine GZZGADGET 0x2000 /* 1 = Gadget for GIMMEZEROZERO borders */ 
#define REQGADGET 0xl1000 /* 1 = this is a Requester Gadget */ 

/* system gadgets */ 

#define SIZING 0x0010 

#define WDRAGGING 0x0020 

#define SDRAGGING 0x0030 

#define WUPFRONT 0x0040 

#define SUPFRONT 0x0050 

#tdefine WDOWNBACK 0x0060 

#define SDOWNBACK 0x0070 




















Sep 19 20:27 1988 intuition/intuition.h Page 6 

346 #define CLOSE 0x0080 

347 /* application gadgets */ 

348 #define BOOLGADGET 0x0001 

349 #define GADGETO002 0x0002 

350 #define PROPGADGET 0x0003 

351 #define STRGADGET 0x0004 

352 

353 

354 /* 

355 /* 

356 /* = = 

357 /* This is the special data needed by an Extended Boolean Gadget 

358 * Typically this structure will be pointed to by the Gadget field SpecialInfo 
359 */ 

360 struct BoolInfo 

361 [ 

362 USHORT Flags; /* defined below */ 

363 UWORD  *Mask; /* bit mask for highlighting and selecting 

364 * mask must follow the same rules as an Image 
365 x plane. It's width and height are determined 
366 * by the width and height of the gadget's 

367 * select box. (i.e. Gadget.Width and .Height). 
368 * 

369 ULONG Reserved; /* set to 0 «f/f 

370 |; 

371 

372 /* set BoolInfo.Flags to this flag bit. 

373 * in the future, additional bits might mean more stuff hanging 

374 * off of BoollInfo.Reserved. 

375 * 

376 #define BOOLMASK 0x0001 /* extension is for masked gadget */ 

377 

378 

379 

380 /* = 

381 /* this is the special data required by the proportional Gadget 

382 * typically, this data will be pointed to by the Gadget variable SpecialInfo 
383 * 

384 struct PropInfo 

385 { 

386 USHORT Flags; /* general purpose flag bits (see defines below) */ 
387 

388 /* You initialize the Pot variables before the Gadget is added to 

389 * the system. Then you can look here for the current settings 

390 * any time, ‘even while User is playing with this Gadget. To 

391 * adjust these after the Gadget is added to the System, use 

392 * ModifyProp(); The Pots are the actual proportional settings, 

393 * where a value of zero means zero and a value of MAXPOT means 

334 * that the Gadget is set to its maximum setting. 

39 */ 

396 USHORT HorizPot; /* 16-bit FixedPoint horizontal quantity percentage */ 
397 USHORT VertPot; /* 16-bit FixedPoint vertical quantity percentage */ 
398 

399 /* the 16-bit FixedPoint Body variables describe what percentage of 
400 * the entire body of stuff referred to by this Gadget is actually 
401 * shown at one time. This is used with the AUTOKNOB routines, 

402 * to adjust the size of the AUTOKNOB according to how much of 

403 * the data can be seen. This is also used to decide how far 

404 * to advance the Pots when User hits the Container of the Gadget. 
405 * For instance, if you were controlling the display of a 5-line 

406 * Window of text with this Gadget, and there was a total of 15 

407 * lines that could be displayed, you would set the VertBody value to 
408 * (MAXBODY / (TotalLines / Displaylines)) = MAXBODY / 3. 

409 * Therefore, the AUTOKNOB would fill 1/3 of the container, and 

410 * if User hits the Cotainer outside of the knob, the pot would 

411 * advance 1/3 (plus or minus) If there's no body to show, or 

412 * the total amount of displayable info is less than the display area, 
413 * set the Body variables to the MAX. To adjust these after the 

414 * Gadget is added to the System, use ModifyProp(); 


eg ~ d 





Sep 19 20:27 1988 


te 


x 


* 


*/ 
USHORT HorizBody; 
USHORT VertBody; 


USHORT CWidth; 
USHORT CHeight; 


UBYTE *Buffer; /* 
UBYTE *UndoBuffer;  /* 
SHORT BufferPos; /* 
SHORT MaxChars; /* 
SHORT DispPos; f* 


SHORT UndoPos; /* 
SHORT NumChars; 
SHORT DispCount; 
SHORT CLeft, CTop; 
struct Layer *LayerPtr; 





{* 
/* 


/* 
/* 


intuition/intuition.h Page 7 


horizontal Body */ 
vertical Body */ 


/* these are the variables that Intuition sets and maintains */ 

/* Container width (with any relativity absoluted) */ 

/* Container height (with any relativity absoluted) */ 
USHORT HPotRes, VPotRes; /* pot increments */ 

USHORT LeftBorder; 
USHORT TopBorder ; 


Container borders */ 
Container borders */ 


ee en 





/* --- FLAG BITS —------------ 
#define AUTOKNOB 0x0001 
#define FREEHORIZ 0x0002 
#define FREEVERT 0x0004 
#define PROPBORDERLESS 0x0008 
#define KNOBHIT 0x0100 
#define KNOBHMIN 6 

#define KNOBVMIN 4 

#define MAXBODY OxFFFF 
#define MAXPOT OxFFFF 


struct StringInfo 
{ 


/* 
/* 
/* 


LONG LongInt; 


struct KeyMap *AltKeyMap; 


/* 


this flag sez: gimme that old auto-knob */ 
if set, the knob can move horizontally */ 
if set, the knob can move vertically */ 

if set, no border will be rendered */ 

set when this Knob is hit */ 


minimum horizontal size of the Knob */ 
minimum vertical size of the Knob. */ 
maximum body value */ 

maximum pot value */ 





/* you initialize these variables, and then Intuition maintains them */ 
the buffer containing the start and final string */ 
optional buffer for undoing current entry */ 
character position in Buffer */ 

max number of chars in Buffer (including NULL) */ 
Buffer position of first displayed character */ 


/* Intuition initializes and maintains these variables for you */ 
character position in the undo buffer */ 

number of characters currently in Buffer */ 
number of whole characters visible in Container */ 
topleft offset of the container */ 


the RastPort containing this Gadget */ 


/* you can initialize this variable before the gadget is submitted to 
* Intuition, and then examine it later to discover what integer 
x the user has entered (if the user never plays with the gadget, 
* the value will be unchanged from your initial setting) 


If you want this Gadget to use your own Console keymapping, you 

* set the ALTKEYMAP bit in the Activation flags of the Gadget, and then 
* set this variable to point to your keymap. 
* ALTKEYMAP, you'll get the standard ASCII keymapping. 


If you don't set the 









499 
500 
501 
502 
503 
504 
505 
506 
507 
508 


513 
514 
515 
516 
517 
518 
519 
520 
521 
522 
523 
524 
525 
526 
527 
528 
529 
530 
531 
532 





19 


* 








20:27 1988 


intuition/intuition 


-h Page 8 








IntuiText 


IntuiText is a series of string: 








s that start with a screen location 


(always relative to the upper-left corner of something) and then the 


text of the string. The text 


struct IntuiText 


UBYTE FrontPen, BackPen; 
UBYTE DrawMode; 

SHORT LeftEdge; 

SHORT TopEdge; * 
struct TextAttr *ITextFont; / 
UBYTE *IText; 

struct IntuiText *NextText; /* 


* 
* 


Data type Border, used for drawing a series of lines which is intended 
use as a border drawing, but. which may, in fact, be used to render any 


is null-terminated. 


the pen numbers for the rendering */ 
the mode for rendering the text */ 
relative start location for the text */ 
relative start location for the text */ 
if NULL, you accept the default */ 
pointer to null-terminated text */ 
continuation to TxWrite another text 


*f 





The routine DrawBorder sets up the RastPort with the appropriate 
variables, then does a Move to the first coordinate, then does Draws 


/* 
* 
* arbitrary vector shape. 
x 
* 
* to the subsequent coordinates. 
* After all the Draws are done, 
* recursively 
*/ 
struct: Border 
{ 
SHORT LeftEdge, TopEdge; /* 
UBYTE FrontPen, BackPen; /* 
UBYTE DrawMode; f* 
BYTE Count; /* 
SHORT *XY; /* 
struct Border *NextBorder; /* 
q; 


if NextBorder is non-zero we call DrawBorder 


initial offsets from the origin */ 

pens numbers for rendering */ 

mode for rendering */ 

number of XY pairs */ 

vector coordinate pairs rel to LeftTop*/ 
pointer to any other Border too */ 











540 
541 
542 
543 


545 
546 
547 
548 
549 
550 
551 
552 


/* 


* 
* 


This is a brief image structure 


image data to a RastPort 


struct Image 
544 f{ 


SHORT LeftEdge; Jt 
SHORT TopEdge; ft 
SHORT Width; /* 


SHORT Height, Depth; 
USHORT *ImageData; 


/7* the PlanePick and Planeonof 
* equivalent GELS Bob variabl 


for very simple transfers of 


starting offset relative to some origin */ 

starting offsets relative to some origin */ 
pixel size (though data is word-aligned) */ 
pixel sizes */ 

pointer to the actual word-aligned bits */ 


f£ variables work much the same way as the 
es. It's a space-saving 














¥S -~ a 























Sep 19 20:27 1988 intuition/intuition.h Page 9 

553 * mechanism for image data. Rather than defining the image data 

554 * for every plane of the RastPort, you need define data only 

555 x for the planes that are not entirely zero or one. As you 

556 * define your Imagery, you will often find that most of the planes 
557 * ARE just as color selectors. For instance, if you're designing 
558 * a two-color Gadget to use colors two and three, and the Gadget 
559 * will reside in a five-plane display, bit plane zero of your 

560 * imagery would be all ones, bit plane one would have data that 

561 * describes the imagery, and bit planes two through four would be 
562 * all zeroes. Using these flags allows you to avoid wasting all 

563 * that memory in this way: first, you specify which planes you 

564 * want your data to appear in using the PlanePick variable. For 
565 * each bit set in the variable, the next "plane" of your image 

566 * data is blitted to the display. For each bit clear in this 

567 * variable, the corresponding bit in PlaneOnoff is examined. 

568 * If that bit is clear, a "plane" of zeroes will be used. 

569 * If the bit is set, ones will go out instead. So, for our example: 
570 *  Gadget.PlanePick = 0x02; 

571 * Gadget.PlaneoOnOff = 0x01; 

572 * Note that this also allows for generic Gadgets, like the 

573 * System Gadgets, which will work in any number of bit planes. 

574 * Note also that if you want an Image that is only a filled 

575 * rectangle, you can get this by setting PlanePick to zero 

576 * (pick no planes of data) and set PlaneOnOff to describe the pen 
577 * color of the rectangle. 

578 xf 

579 UBYTE PlanePick, Planeonoff; 

580 

581 7* if the NextImage variable is not NULL, Intuition presumes that 
582 * it points to another Image structure with another Image to be 

583 * rendered 

584 * 

585 struct Image *NextImage; 

586 }; 

587 

588 

589 

590 

591 

592 

593 

594 

595 /* ssssssssssssmsseass: 

596 struct IntuiMessage 

597 { 

598 struct Message ExecMessage; 

599 

600 /* the Class bits correspond directly with the IDCMP Flags, except for the 
601 * special bit LONELYMESSAGE (defined below) 

602 * 

603 ULONG Class; 

604 

605 /* the Code field is for special values like MENU number */ 

606 USHORT Code; 

607 

608 /* the Qualifier field is a copy of the current InputEvent's Qualifier */ 
609 USHORT Qualifier; 

610 

611 /* TAddress contains particular addresses for Intuition functions, like 
612 * the pointer to the Gadget or the Screen 

613 * 

614 APTR IAddress; 

615 

616 /7* when getting mouse movement reports, any event you get will have the 
617 * the mouse coordinates in these variables. the coordinates are relative 
618 * to the upper-left corner of your Window (GIMMEZEROZERO notwithstanding) 
619 * 

620 SHORT MouseX, MouseY; 


621 





19 20:27 1988. intuition/intuition.h Page 10 


/* the time values are copies of the current system clock time. Micros 


* are in units of microseconds, Seconds in seconds. 
* 


ULONG Seconds, Micros; 


/* the IDCMPWindow variable will always have the address of the Window of . 
* this IDCMP 
* 


struct Window *IDCMPWindow; 


/* system-use variable */ 
struct IntuiMessage *SpecialLink; 
Ii 


/* ~-- IDCMP Classes ~--—-—-————-- rr 
#define SIZEVERIFY 0x00000001 See Programmer's Guide 
#define NEWSIZE 0x00000002 See Programmer's Guide 
#define REFRESHWINDOW 0x00000004 See Programmer's Guide 
#define MOUSEBUTTONS 0x00000008 See Programmer's Guide 
#define MOUSEMOVE 0x00000010 See Programmer's Guide 
#define GADGETDOWN 0x00000020 See Programmer's Guide 
#define GADGETUP 0x00000040 See Programmer's Guide 
#define REQSET 0x00000080 See Programmer's Guide 
#define MENUPICK 0x00000100 See Programmer's Guide 
#define CLOSEWINDOW 0x00000200 Sée Programmer's Guide 
#define RAWKEY 0x00000400 See Programmer's Guide 
#define REQVERIFY 0x00000800 See Programmer's Guide 
#define REQCLEAR 0x00001000 Programmer's Guide 
#tdefine MENUVERIFY 0x00002000 Programmer's Guide 
#define NEWPREFS 0x00004000 Programmer's Guide 
#define DISKINSERTED 0x00008000 Programmer's Guide 
#define DISKREMOVED 0x00010000 Programmer's Guide 
#define WBENCHMESSAGE 0x00020000 Programmer's Guide 
#tdefine ACTIVEWINDOW 0x00040000 Programmer's Guide 
#tdefine INACTIVEWINDOW 0x00080000 Programmer's Guide 
#define DELTAMOVE 0x00100000 Programmer's Guide 
#define VANILLAKEY 0x00200000 Programmer's Guide 
#tdefine INTUITICKS 0x00400000 Programmer's Guide 
/* NOTEZ-BIEN: 0x80000000 is reserved for internal use 


/* the IDCMP Flags do not use this special bit, which is cleared when 
* Intuition sends its special message to the Task, and set when Intuition 
* gets its Message back from the Task. Therefore, I can check here to 
* find out fast whether or not this Message is available for me to send 
* 


#define LONELYMESSAGE 0x80000000 


[* ~-— IDCMP Codes ——----— a 
/* This group of codes is for the MENUVERIFY function */ 

#define MENUHOT 0x0001 /* IntuiWants verification or MENUCANCEL 
#define MENUCANCEL 0x0002 /* HOT Reply of this cancels Menu operation 
#define MENUWAITING 0x0003 /* Intuition simply wants a ReplyMsg({) ASAP 


/* These are internal tokens to represent state of verification attempts 
* shown here as a clue. 
*/ 

#tdefine OKOK 

#tdefine OKABORT 

#define OKCANCEL 


MENUHOT /* guy didn't care */ 
0x0004 /* window rendered question moot xf 
MENUCANCEL /* window sent cancel reply */ 


7* This group of codes is for the WBENCHMESSAGE messages */ 
#tdefine WBENCHOPEN 0x0001 
#define WBENCHCLOSE 0x0002 





ss -a 


Sep 19 20:27 1988 intuition/intuition h Page 1l 


691 /* 
692 /* 














Window 


*/ 





693 struct Window 


694 { 
695 
696 
697 
698 
699 
700 
701 
702 
703 
704 
705 
706 
707 
708 
709 
710 
711 
712 
713 
714 
715 
716 
717 
718 
719 
720 
721 
722 
723 
724 
725 
726 
727 
728 
729 
730 
731 
732 
733 
734 
735 
736 
737 
738 
739 
740 
741 
742 
743 
744 
745 
746 
747 
748 
749 
750 
751 
752 
753 
754 
755 
756 
757 
758 
759 


struct Window *NextWindow; /7* for the linked list in a screen */ 
SHORT LeftEdge; TopEdge; /* screen dimensions of window */ 
SHORT Width, Height; /* screen dimensions of window */ 


SHORT MouseY, MouseX; relative to upper-left of window */ 


SHORT MinWidth, MinHeight; 
USHORT MaxWidth, MaxHeight; 


minimum sizes */ 
maximum sizes */ 


ULONG Flags; see below for defines */ 


struct Menu *MenuStrip; the strip of Menu headers */ 


UBYTE *Title; the title text for this window */ 


struct Requester *FirstRequest ; all active Requesters */ 


struct Requester *DMRequest; double-click Requester */ 


SHORT ReqCount; count of regs blocking Window */ 


/* 
/* 
/* 


the border variables describe the window border. If you specify 
GIMMEZEROZERO when you open the window, then the upper-left of the 
ClipRect for this window will be upper-left of the BitMap (with correct 
offsets when in SuperBitMap mode; you MUST select GIMMEZEROZERO when 
using SuperBitMap). If you don't specify ZeroZero, then you save 
memory (no allocation of RastPort, Layer, ClipRect and associated 
Bitmaps), but you also must offset all your writes by BorderTop, 
BorderLeft and do your own mini-clipping to prevent writing over the 
system gadgets 


this Window's Screen */ 
this Window's very own RastPort */ 


struct Screen *WScreen; 
struct RastPort *RPort; 


~ 
* 


+ + % HH HH 


* 
BYTE BorderLeft, BorderTop, BorderRight, BorderBottom; 
struct RastPort *BorderRPort; 


/* You supply a linked-list of Gadgets for your Window. 
* This list DOES NOT include system gadgets. You get the standard 
* window system gadgets by setting flag-bits in the variable Flags (see 
* the bit definitions below) 
* 


struct Gadget *FirstGadget; 


/* these are for opening/closing the windows */ 
struct Window *Parent, *Descendant; 


/* sprite data information for your own Pointer 
* set these AFTER you Open the Window by calling SetPointer() 
* 


USHORT *Pointer; /* sprite data */ 
BYTE PtrHeight; /* sprite height (not including sprite padding) */ 
BYTE PtrWidth; * sprite width (must be less than or equal to 16) */ 


BYTE XOffset, YOffset; /* sprite offsets */ 

/* the IDCMP Flags and User's and Intuition's Message Ports */ 
ULONG IDCMPFlags; /* User-selected flags */ 

struct MsgPort *UserPort, *WindowPort; 

struct IntuiMessage *MessageKey; 

UBYTE DetailPen, BlockPen; /* for bar/border/gadget rendering */ 


/* the CheckMark is a pointer to the imagery that will be used when 


Sep 19 20:27 1988 


760 
761 
762 
763 
764 
765 
766 
767 
768 
769 
770 
771 
772 
773 
774 
775 
776 
777 
778 
7719 
780 
781 
782 
783 
784 
785 
786 
787 
788 
789 
790 
791 
792 
793 
794 
795 
796 
797 
798 
799 
800 
801 
802 
803 
804 
805 
806 
807 
808 
809 
810 
811 
812 
813 
814 
815 
816 
817 
818 
819 
820 
821 
822 
823 
824 
825 
826 
827 
828 


le 


intuition/intuition.h Page 12 


* rendering MenuItems of this Window that want to be checkmarked 
* if this is equal to NULL, you'll get the default imagery 
* 


struct Image *CheckMark; 


UBYTE *ScreenTitle; /* if non-null, Screen title when Window is active */ 
/* These variables have the mouse coordinates relative to the 
* inner-Window of GIMMEZEROZERO Windows. This is compared with the 
* MouseX and MouseY variables, which contain the mouse coordinates 
* relative to the upper-left corner of the Window, GIMMEZEROZERO 
* notwithstanding 
*/ 
SHORT GZZMousexX; 
SHORT GZZMouseY; 
/* these variables contain the width and height of the inner-Window of 
* GIMMEZEROZERO Windows 
*x 
SHORT GZZWidth; 
SHORT GZZHeight; 


UBYTE *ExtData; 
BYTE *UserData; /* general-purpose pointer to User data extension */ 
/** jimm: NEW: 11/18/85: this pointer keeps a duplicate of what 

* Window.RPort—>Layer is _supposed_ to be pointing at 

struct Layer *WhLayer; 


/* jimm: NEW 1.2: need to keep track of the font that 
* OpenWindow opened, in case user SetFont's into RastPort 
* 


struct TextFont *IFont; 


/* ~~~ FLAGS REQUESTED (NOT DIRECTLY SET THOUGH) BY THE APPLIPROG ~——-~~-~— */ 
#define WINDOWSIZING 0x0001 /* include sizing system-gadget? */ 

#define WINDOWDRAG 0x0002 7* include dragging system-gadget? */ 
#define WINDOWDEPTH 0x0004 /7* include depth arrangement. gadget? */ 
#define WINDOWCLOSE 0x0008 /* include close-box system-gadget? */ 
#define SIZEBRIGHT 0x0010 /* size gadget uses right border */ 

#define SIZEBBOTTOM 0x0020 /* size gadget uses bottom border */ 

[® AAA LELL]ST MOC 0 xf 
/* combinations of the REFRESHBITS select the refresh type */ 

#define REFRESHBITS 0x00C0 

#define SMART_REFRESH 0x0000 

#define SIMPLE REFRESH 0x0040 

#define SUPER_BITMAP 0x0080 

#define OTHER_REFRESH 0x00Cc0 

#define BACKDROP 0x0100 /* this is. an ever~popular BACKDROP window */ 
#define REPORTMOUSE 0x0200 /* set this to hear about every mouse move */ 
#define GIMMEZEROZERO 0x0400 /* make extra border stuff */ 

#define BORDERLESS 0x0800 /* set this to get a Window sans border */ 
#define ACTIVATE 0x1000 /* when Window opens, it's the Active one */ 


/* FLAGS SET BY INTUITION */ 


#define WINDOWACTIVE 0x2000 7* this window is the active one */ 
#define INREQUEST 0x4000 /* this window is in request mode */ 
#define MENUSTATE 0x8000 /* this Window is active with its Menus on */ 


9g -ad 





Sep 


829 
830 
831 
832 
833 
834 
835 
836 
837 
838 
839 
840 
841 
842 
843 
844 
845 














19 20:27 1988 intuition/intuition.h Page 13 

[® ~~ Other USK FLAgs mmm nn —- * 
#define RMBTRAP 0x00010000 /* Catch RMB events for your own */ 
#define NOCAREREFRESH  0x00020000 7* not to be bothered with REFRESH */ 
(f* ~wm Other Tat uit Lom PLAags mm x 
#define WINDOWREFRESH  0x01000000 /* Window is currently refreshing */ 
#define WBENCHWINDOW 0x02000000 7* WorkBench tool ONLY Window */ 
#define WINDOWTICKED 0x04000000 /* only one timer tick at a time */ 
#tdefine SUPER_UNUSED OxFCFCO0000 /* bits of Flag unused yet */ 

/* --- see struct IntuiMessage for the IDCMP Flag definitions ------—_-_--~ xf 





850 struct NewWindow 

851 { 

852 SHORT LeftEdge, TopEdge; 7* screen dimensions of window */ 
853 SHORT Width, Height; /* screen dimensions of window */ 
854 

855 UBYTE DetailPen, BlockPen; /* for bar/border/gadget rendering */ 
856 

857 ULONG IDCMPFlags; /* User-selected IDCMP flags */ 

858 

859 ULONG Flags; /* see Window struct for defines */ 
860 

861 /* You supply a linked-list of Gadgets for your Window. 

862 * This list DOES NOT include system Gadgets. You get the standard 





* - system Window Gadgets by setting flag-bits in the variable Flags (see 
* the bit definitions under the Window structure definition) 
* 


struct Gadget *FirstGadget; 


/* the CheckMark is a pointer to the imagery that will be used when 
* rendering MenuItems of this Window that want to be checkmarked 
x if this is equal to NULL, you'll get the default imagery 
* 


struct Image *CheckMark; 


UBYTE *Title; /* the title text for this window */ 
/7* the Screen pointer is used only if you've defined a CUSTOMSCREEN and 

* want this Window to open in it. If so, you pass the address of the 

* Custom Screen structure in this variable. Otherwise, this variable 

* is ignored and doesn't have to be initialized. 

* 


struct Screen *Screen; 


/* SUPER_BITMAP Window? If so, put the address of your BitMap structure 
* in this variable. If not, this variable is ignored and doesn't have 
* to be initialized 
* . 


struct BitMap *BitMap; 


the values describe the minimum and maximum sizes of your Windows. 
these matter only if you've chosen the WINDOWSIZING Gadget option, 
which means that you want to let the User to change the size of 
this Window. You describe the minimum and maximum sizes that the 
Window can grow by setting these variables. You can initialize 
any one these to zero, which will mean that you want to duplicate 
the setting for that dimension (if MinWidth == 0, MinWidth will be 
set to the opening Width of the Window). 

You can change these settings later using SetWindowLimits(). 


~~ 
* 


+ FH HO 

















Sep. 19 20:27 1988 intuition/intuition.h Page 14 


* If you haven't asked for a SIZING Gadget, you don't have to 
* initialize any of these variables. 

* 

SHORT MinWidth, MinHeight; 
USHORT MaxWidth, MaxHeight,; 


/* minimums */ 
/* maximums */ 


/* the type variable describes the Screen in which you want this Window to 
* open. The type value can either be CUSTOMSCREEN or one of the 
* system standard Screen Types such as WBENCHSCREEN. See the 
* type definitions under the Screen structure 
* 
USHORT Type; 
1; 


#ifndef INTUITION_SCREENS_H 
#include "intuition/screens.h" 
#endif 


#ifndef INTUITION_PREFERENCES_H 
#include "intuition/preferences.h" 
ftendif 












this structure is used for remembering what memory has been allocated 
* date by a given routine, so that a premature abort or systematic exit 
* can deallocate memory cleanly, easily, and completely 
* 
struct Remember 
{ 
struct Remember *NextRemember ; 
ULONG RememberSize; 
UBYTE *Memory; 
I; 


= Miscellaneous 


* = MACROS #s==s=ssesssecsssssss sees nse ea eee SS 
#define MENUNUM(n) (n & Ox1F) 

#define ITEMNUM(n) ((n >> 5) & 0x003F) 

#tdefine SUBNUM(n) ((n >> 11) & Ox001F) 


#define SHIFTMENU(n) (n & Oxl1F) 

¢define SHIFTITEM(n) ((n & Ox3F) << 5) 

#define SHIFTSUB(n) ((n & OxIF) << 11) 

#define SRBNUM(n) (0x08 — (n >> 4)) /* SerRWBits -> read bits per char */ 
#define SWBNUM(n) (0x08 —- (n & OxOF))/* SerRWBits ~> write bits per chr */ 
#tdefine SSBNUM(n) (Ox0l + (n >> 4)) /* SerStopBuf -> stop bits per chr */ 
#define SPARNUM(n) (n >> 4) /7* SerParShk -> parity setting */ 
tdefine SHAKNUM(n) (n & OxOF) /* SerParShk —> handshake mode */ 
/* = MENU STUFF ==s=s8=ssssssssssssses sss sass ne SSS SS SS SE SESS SEES */ 


tdefine NOMENU 0x001F 
#tdefine NOITEM 0x003F 
#tdefine NOSUB Ox001F 
#define MENUNULL OxFFFF 





a 


LS - 


Sep 


967 
968 
969 
970 
971 
972 
973 
974 
975 
976 
977 
978 
979 
980 
981 
982 
983 
984 
985 
986 
987 
988 
989 
990 
991 
992 
993 
994 


WWOWY 
WWW 
Om~Au 


WODMAAKDMNEPWNHNE OS 


BRE 
ro 


13 


19 20:27 1988 intuition/intuition.h Page 15 


/* = =RJ='s peculiarities 
#define FOREVER for(;;) 
#define SIGN(x) ( ((x) > 0) -— ((x) ¢ 0) ) 
#define NOT ! 


/* these defines are for the COMMSEQ and CHECKIT menu stuff. If CHECKIT, 
* I'll use a generic Width (for all resolutions) for the CheckMark. 

* If COMMSEQ, likewise I'll use this generic stuff 

* 


#define CHECKWIDTH 19 
#define COMMWIDTH 27 
#define LOWCHECKWIDTH 13 
#tdefine LOWCOMMWIDTH 16 


7* these are the AlertNumber defines. if you are calling DisplayAlert() 
* the AlertNumber you supply must have the ALERT_TYPE bits set to one 


* of these patterns 
* 


#define ALERT_TYPE 0x80000000 
#define RECOVERY ALERT 0x00000000 /* the system can recover from this */ 
#define DEADEND_ALERT 0x80000000 /* no recovery possible, this is it */ 


/* When you're defining IntuiText for the Positive and Negative Gadgets 

* created by a call to AutoRequest(), these defines will get you 

* reasonable-looking text. The only field without a define is the IText 
* field; you decide what text goes with the Gadget 

x/ . 


#define AUTOFRONTPEN 0 

#define AUTOBACKPEN 1 

#define AUTODRAWMODE JAM2 

#define AUTOLEFTEDGE 6 

#define AUTOTOPEDGE 3 

#define AUTOITEXTFONT NULL 

#define AUTONEXTTEXT NULL 

/* ~~~ RAWMOUSE Codes and Qualifiers (Console OR IDCMP) ---------~--——-——-~_ */ 
#define SELECTUP ( IECODE_LBUTTON | IECODE_UP_PREFIX) 
#define SELECTDOWN ( IECODE_LBUTTON) 

#define MENUUP (IECODE_RBUTTON | IECODE_UP_PREFIX) 
#define MENUDOWN ( TECODE_RBUTTON) 

#define ALTLEFT ( IEQUALIFIER_LALT) 

#define ALTRIGHT ( IEQUALIFIER_RALT) 

#define AMIGALEFT ( IEQUALIFIER_LCOMMAND ) 

#define AMIGARIGHT ( IEQUALIFIER_RCOMMAND ) 

#define AMIGAKEYS ( AMIGALEFT | AMIGARIGHT) 

#define CURSORUP Ox4C 

#define CURSORLEFT Ox4P 

#define CURSORRIGHT Ox4E 

#define CURSORDOWN Ox4D 

#define KEYCODE_Q 0x10 

tdefine KEYCODE_X 0x32 

#define KEYCODE_N 0x36 

#tdefine KEYCODE _M 0x37 

#define KEYCODE_V 0x34 

#define KEYCODE_B 0x35 


fendif /* INTUITION_INTUITION_H */ 


Sep 


WOOn~INU Se WDNr 


19 20:27 1988 intuition/intuitionbase.h Page i 


#ifndef INTUITION_INTUITIONBASE_H 
#define INTUITION _INTUITIONBASE_H 


/* 
xe $Filename: intuition/intuitionbase.h $ 

** $Release: 1.3 $ 

Kk 

Kk the. IntuitionBase structure and supporting structures 
nk 

xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xk All Rights Reserved 

*f 


#ifndef EXEC_TYPES_H 
#include <exec/types .h> 
#endif 


#ifndef EXEC_LIBRARIES_H 
#include <exec/libraries.h> 
#endif 


#ifndef INTUITION_INTUITION_H 
#tinclude <intuition/intuition.h> 
#endif 


#ifndef EXEC_INTERRUPTS_H 
#include <exec/interrupts.h> 
#endif 


#ifdef INTUITIONPRIVATE 

/* these types and constants are used in the forbidden part of IntuitionBase. 
* see below for an explanation that these are NOT supported for your use. 
* They will certainly change in subsequent releases, and are provided 
* for education, debugging, and information. 


*/ 


/7* these are the display modes for which we have corresponding parameter. 
* settings in the config arrays 
* 
#define DMODECOUNT 
#define HIRESPICK 
#define LOWRESPICK 


0x0002 /* how many modes there are */ 
0x0000 
0x0001 
#define EVENTMAX 10 /* size of event array */ 
/* these are the system Gadget defines */ 

#define RESCOUNT 
#define HIRESGADGET 
#define LOWRESGADGET 


GADGETCOUNT 
UPFRONTGADGET 
DOWNBACKGADGET 
SIZEGADGET 
CLOSEGADGET 
DRAGGADGET 
SUPFRONTGADGET, 
SDOWNBACKGADGET 
SDRAGGADGET > 


#tdefine 
#define 
#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 


NDP WNRFOM HON 


/* jimm: 1/10/86: Intuition Locking */ 

/* Let me say it again: don't even think about using this information 
* in a program. 
* 


#define ISTATELOCK 0 /* Intuition() not re-entrant */ 
#define LAYERINFOLOCK 1 /* dummy lock used to check protocol */ 
#define GADGETSLOCK 2 /7* gadget lists, refresh, flags «/ 
#define LAYERROMLOCK 3 /* (dummy) for lock layerrom «/ 
#tdefine VIEWLOCK 4 /* access to ViewLord «f/f 
#define IBASELOCK 5 7* protexts IBase pointers and lists «/ 











8s - da 











19 20:27 1988 intuition/intuitionbase.h Page 2 


#define RPLOCK 6 of IBase->RP 


#define NUMILOCKS 7 


/* use 








struct FatIntuiMessage [{ 
struct IntuiMessage; 
ULONG PrevKeys; 
i 


struct IBox [{ 
SHORT Left; 
SHORT Top; 
SHORT Width; 
SHORT. Height ; 


i 


struct Point { 
SHORT X; 
SHORT Y; 
I; 


struct PenPair [{ 
UBYTE DetailPen; 
UBYTE BlockPen; 
i; 








/* environment for a whole list of gadgets. note that information for both 


* layers of a G00 window are included. 
x 


struct GListEnv { 








struct Screen *ge_Screen; 
struct Window *ge_Window; 
struct Requester *ge_Requester; 
struct RastPort *ge_RastPort; /* xvastport used to render gadget */ 
struct Layer *ge_ Layer; /* layer for gadget (border, if G00)*/ 
struct Layer *ge_GZZLayer; 7* interior layer for G00 windows */ 
struct PenPair ge_Pens; 7* pens for rendering gadget */ 
struct IBox ge_Domain; 
/* window, screen, requester, rel. to window/screen */ 
struct IBox ge_GZZdims; 7* interior window area x/ 
/* information for a gadget in its environment. includes relatively 
* correct size, container for propgadgets, correct layer for this gadget, 
* and back pointers to the environment and gadget itself 
*x 
struct GadgetInfo [ 
struct GListEnv *gi_Environ; /* environment for this gadget */ 
struct Gadget *xgi_Gadget; /* gadget this info is for af 
struct IBox gi_Box; /7* actual dimensions of gadget */ 
struct IBox gi_Container; /* inner container dimensions */ 
struct Layer *gi_Layer; /7* correct layer for this gadget */ 
struct IBox gi_NewKnob; /* place to draw new slider knob */ 
}; 
#endif /* PRIVATE VALUES */ 
/* = 
/*t = 
/* = 
/* 


* Be sure to protect yourself against someone modifying these data as 
* you look at them. This is done by calling: 








Sep 19 20:27 1988 


139 
140 
141 
142 
143 


intuition/intuitionbase.h Page 3 


* 
* lock = LockiBase(0), which returns a ULONG. When done call 
* UnlockiBase(lock) where lock is what LockIBase() returned. 


*/ 


144 struct IntuitionBase 


145 /* IntuitionBase should never be 
146 /* even a little bit, guys/gals; 


147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 


directly modified by programs */ 
do you hear me? «/ 


{ 
struct Library LibNode; 


struct View ViewLord; 


struct Window *ActiveWindow; 
struct Screen *ActiveScreen; 


/* the FirstScreen variable points to the frontmost Screen. Screens are 
* then maintained in a front to back order using Screen.NextScreen 
* 


struct Sereen *FirstScreen; /* for linked list of all screens */ 


ULONG Flags; 
WORD MouseY, MouseX; 


/7* see definitions below */ 
/* mouse position relative to View */ 


ULONG Seconds; 
ULONG Micros; 


/* timestamp of most current input event */ 
/* timestamp of most current input event */ 
#ifdef INTUITIONPRIVATE 

The following is a snapshot of the "private" part of 
Intuition's library data: It is included for educational 
use and your debugging only. It is absolutely guaranteed 
that this structure will change from release to release. 


™~ 
* 


So: don't count on any of the values you find here 
don't even think about changing any of these fields 
(that goes for the "supported" fields above, too). 


Some work has been done to find the include files 
that these fields depend on. 


et 4 HF FH H+ FH HH 


jimm: 9/10/86. 


* 
~~ 


WORD MinXMouse, MaxXMouse; 
WORD MinYMouse, MaxYMouse; 


/* bounded X position for the mouse */ 
/* bounded Y position for the mouse */ 


ULONG StartSecs, StartMicros; /* measure double clicks */ 


* —----~--—-—--=— base vectors 
/* DO MOVE THESE OFFSETS WITHOUT ADJUSTING EQUATES IN IWORK.ASM 
* this is automatically handled by standalone program offsets.c 


*/ 
APTR SysBase; 
struct GfxBase *GfxBase; 
APTR LayersBase; 
APTR ConsoleDevice; 
[* —--------------_ Sprite Pointer ——---—---------____________--—-_ */ 
USHORT *APointer; /7* the ActiveGroup pointer sprite definition */ 
BYTE APtrHeight; /* height of the pointer */ 
BYTE APtrWidth; /* width in pixels of the pointer (<= 16!) */ 
BYTE AXOffset, AYOffset; /* sprite offsets */ 
[*® --~oc o> Menu Rendering and Operation —~------------—-—— */ 


USHORT MenuDrawn; /* menu/item/sub number of current display */ 
USHORT MenuSelected;/* menu/item/sub number of selected (and highlights)*/ 
USHORT OptionList; 7* menu selection */ 








6g - da 





Sep 19 20:27 1988 





intuition/intuitionbase.h Page 4 





Sep 19 20:27 1988 


intuition/intuitionbase.h Page 5 








208 277 BYTE IPtrHeight; /* height of the pointer */ 

209 7* this is the work RastPort used for building item and subitem displays 278 BYTE IPtrWidth; /* width in pixels of the pointer (<= 16!) */ 
210 * you can never count on it being stable, other than that it is 279 BYTE IxXOffset, IYOffset; /* sprite offsets */ 

211 * mostly a copy of the active screen's RastPort. 280 

212 */ 281 LONG DoubleSeconds, DoubleMicros; /* for testing double-click timeout */ 
213 struct RastPort MenuRPort; 282 

214 struct TmpRas MenuTmpRas ; 283 |) nae Border Widths —---—-—--—--—-3+- */ 
215 struct ClipRect ItemCRect; /* for the item's screen display */ 284 BYTE WBorLeft [DMODECOUNT] ; 

216 struct ClipRect SubCRect; /* for the subitem's screen display */ 285 BYTE WBorTop [DMODECOUNT] ; 

217 struct BitMap IBitMap; /* for the item's planes */ 286 BYTE WBorRight [DMODECOUNT] ; 

218 struct BitMap SBitMap; /* for the subitem's planes */ 287 BYTE WBorBottom[DMODECOUNT] ; 

219 288 

220 /* ~~--~--------—--_Input Device Interface ------------------------ x/ 289 BYTE BarVBorder [DMODECOUNT] ; 

221 struct IOStdReq InputRequest; 290 BYTE BarHBorder [DMODECOUNT] ; 

222 struct Interrupt InputInterrupt; 291 BYTE MenuVBorder [DMODECOUNT] ; 

223 292 BYTE MenuHBorder [DMODECOUNT] ; 

224 /* for dynamically allocated input events */ 293 

225 struct Remember *EventKey; 294 USHORT color0; 

226 struct InputEvent *IEvents; 295 USHORT colorl; 

227 296 USHORT color2; 

228 /7* for statically "allocated" input events */ 297 USHORT color3; 

229 #define NUM_IEVENTS 4 298 USHORT colorl7; 

230 SHORT EventCount; 299 USHORT color18; 

231 struct InputEvent IEBuffer[NUM_IEVENTS] ; 300 USHORT colorl9; 

232 301 

233 PR Active Gadget Information ---------------------_ */ 302 struct TextAttr SysFont; 

234 struct Gadget *ActiveGadget; 303 

235 struct PropInfo *ActivePInfo; 304 /7* WARNING: you can easily wipe out Intuition by modifying this pointer 
236 struct Image *ActiveImage; 305 * or the Preference data pointed to by this! 

237 struct GListEnv GadgetEnv; /* environment of the active gadget xf 306 

238 struct GadgetInfo GadgetInfo;/* specific information for active gadget*/ 307 struct Preferences *Preferences; 

239 struct Point KnobOffset; /* position in knob of mouse when selected*/ 308 

240 309 PR Deferred action queue —----------------—---—-— «/ 
241 7* OOO Verify Functions Support ------~---—----------——_ */ 310 struct DistantEcho *Echoes; 

242 /* hold information about getOK wait(), used for breakVerify() */ 311 ok 

243 struct Window *getOKWindow; 312 WORD ViewInitX, ViewInity; /* View initial offsets at startup */ 
244 struct IntuiMessage *getOKMessage; 313 / 

245 314 SHORT CursorDX, CursorDY; /* for accelerating pointer movement */ 
246 [Romo State Machine —---~~~~~77 7 */ 315 

247 USHORT setWExcept,, GadgetReturn, StateReturn; 316 struct KeyMap *KeyMap; /* for the active String Gadget */ 

248 317 

249 [8 Intuition's Rendering for Gadgets, Titles, ... ---—- */ 318 SHORT MouseYMinimum; /* magic */ 

250 /* This will be allocated on init */ 319 

251 struct RastPort *RP; 320 SHORT ErrorxX, ErrorY; /* for retaining mouse movement round-off */ 
252 struct TmpRas ITmpRas; 321 

253 struct Region *OldClipRegion; 7* locks with RPort */ 322 struct timerequest IOExcess; 

254 struct Point Oldscroll; /* user's Scroll _X/Y*/ 323 

255 324 SHORT HoldMinYMouse; 

256 [RT Frame Rendering for Window Size/Drag ----~~~--------— x/ 325 

257 struct IBox IFrame; /* window frame for sizing/dragging */ 326 struct MsgPort *WBPort, *igd_FNKUHDPort; 

258 SHORT hthick, vthick; /* IFrame thickness */ 327 struct IntuiMessage WBMessage; . 

259 VOID (*frameChange) (); /7* function to change IFrame xf 328 struct Screen *HitScreen; /* set by hitUpfront() routine */ 

260 VOID (*sizeDrag) (); /* either ISizeWindow or IMoveWindow */ 329 

261 struct Point FirstPt; /7* point from which s/d started */ 330 /** jimm:dale: 11/25/85, thought we'd take a chance for glory **/ 
262 struct Point OldPt; /* previous point for s/d xf 331 struct SimpleSprite *SimpleSprite; 

263 332 struct SimpleSprite *AttachedSSprite; 

264 [Ra System Gadget Templates —-----------------------~ x/ 333 BOOL GotSpritel; 

265 struct Gadget *SysGadgets [RESCOUNT] [GADGETCOUNT] ; 334 . 

266 struct Image *CheckImage[RESCOUNT], *AmigaIcon[RESCOUNT] ; 335 /** jimm: 1/6/86: Intuition contention **/ 

267 336 struct List SemaphoreList; /* chain of the below */ 
268 '/. Window Drag Rendering -------------~-------—— x/ 337 struct SignalSemaphore ISemaphore [NUMILOCKS] ; 

269 #ifdef OLDPATTERN 338 

270 USHORT apattern[3], bpattern[4]; 339 WORD MaxDisplayHeight; /* in interlaced mode: 400 or 512 */ 
271 #else 340 WORD MaxDisplayRow; /* MaxDisplayHeight ~ 1 

272 USHORT apattern[8], bpattern[4]; 341 WORD MaxDisplayWidth; /* copy of GfxBase's Normal DisplayCol * 
273 #endif 342 

274 343 ULONG Reserved [7] ; /* cause one never know, do one? */ 

275 J* ~~~ Preferences SECtLON mer es */1344 #endif /* PRIVATE VALUES */ 

276 USHORT *IPointer; /* the INTUITION pointer default sprite definition */ 345.3; 








09 ~d 


Sep 19 20:27 1988 intuition/intuitionbase.h Page 6 


346 
347 Hendif /* INTUITION _INTUITIONBASE_H */ 


Sep 19 20:27 1988 intuition/preferences.h Page 1 


1 #ifndef INTUITION_PREFERENCES_H 

2 #define INTUITION PREFERENCES _H 

3 /* 

4 xk $Filename: intuition/preferences.h $ 
5 ** $Release: 1.3 $ 

6 ** 

7 kx 

8 xk 

9 ** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
ll */ 
12 


13 #ifndef EXEC_TYPES_H 
14 #include “exec/types.h" 
15 #endif 


17 #ifndef DEVICES_TIMER_H 
18 #include "devices/timer.h" 
19 #endif 





25 /* these are the definitions for the printer configurations */ 
26 #define FILENAME SIZE 30 /* Filename size */ 


28 #define- POINTERSIZE (1 + 16 +1) * 2 /* Size of Pointer data buffer */ 


30 /* These defines are for the default font size. These actually describe .the 


31 * height of the defaults fonts. The default font type is the topaz 

32 * font, which is a fixed width font that can be used in either 

33 * eighty~column or sixty-column mode. The Preferences structure reflects 
34 * which is currently selected by the value found in the variable FontSize, 
35 * which may have either of the values defined below. These values actually 
36 * are used to select the height of the default font. By changing the 

37 * height, the resolution of the font changes as well. 

38 */ 


39 #define TOPAZ EIGHTY 8 
40 #define TOPAZ_SIXTY 9 


41 

42 struct Preferences 

43 { 

44 /* the default font height */ 

45 BYTE FontHeight; /* height for system default font */ 

46 

47 /* constant describing what's hooked up to the port */ 

48 UBYTE PrinterPort; /* printer port connection */ 

49 

50 /* the baud rate of the port. */ 

51 USHORT BaudRate; 7* baud rate for the serial port */ 

52 

53 /* various timing rates */ 

54 struct timeval KeyRptSpeed; /* repeat speed for keyboard «f/f 
55 struct timeval KeyRptDelay; /* Delay before keys repeat */ 
56 struct timeval DoubleClick; /* Interval allowed between clicks */ 
57 

58 /* Intuition Pointer data */ 

59 USHORT PointerMatrix(POINTERSIZE]; /* Definition of pointer sprite «f 
60 BYTE XOffset; /* X-Offset for active ‘bit' xf 

61 BYTE YOffset; /* Y-Offset for active ‘bit' xf 

62 USHORT colorl7; [II II IRI IRI IRIE II ERI IIH IRIE / 

63 USHORT colorl18; 7* Colours for sprite pointer */ 

64 USHORT colorl9; [ RRRIK RII IR IRR IR IR RIK IK RIK IR II / 

65 USHORT PointerTicks; /* Sensitivity of the pointer */ 

66 

67 /7* Workbench Screen colors */ 

68 USHORT color0; JERR IRI IRI IIR RK IR IR IR IIHR IK IKE RR K / 


69 USHORT color]; /* Standard default colours «f 








T9 - a 











Sep 19 20:27 1988 intuition/preferences.h Page 2 Sep 19 20:27 1988 intuition/preferences.h Page 3 





70 USHORT color2; /* Used in the Workbench */ 139 #define BAUD_110 0x00 

71 USHORT color3; [RII ROI IOI IIIT IATA ATA IAI 140 #define BAUD_300 0x01 

72 141 #define BAUD_1200 0x02 

73 /* positioning data for the Intuition View */ 142 #define BAUD_2400 0x03 

74 BYTE. ViewxOffset; /* Offset for top lefthand corner */ 143 #define BAUD_4800 0x04 

75 BYTE ViewyOffset; /* X and Y dimensions xf 144 #define BAUD_9600 0x05 

76 WORD ViewInitX, ViewInity; /* View initial offset values xf 145 #define BAUD_19200 0x06 

77 146 #define BAUD_MIDI 0x07 

78 BOOL EnablecLi; /* CLI availability switch */ 147 

79 148 /* PaperType */ 

80 /7* printer configurations */ 149 #define FANFOLD 0x00 

81 USHORT PrinterType; /* printer type */ 150 #define SINGLE 0x80 

82 UBYTE PrinterFilename[FILENAME_SIZE];/* file for printer */ 151 

83 152 /* PrintPitch */ 

84 /* print format and quality configurations */ 153 #define PICA 0x000 

85 USHORT PrintPitch; /* print pitch */ 154 #define ELITE 0x400 

86 USHORT printouality; /* print quality xf 155 #define FINE 0x800 

87 USHORT PrintSpacing; /7* number of lines per inch xf 156 

88 UWORD PrintLeftMargin; /* left margin in characters */ 157 /* PrintQuality */ 

89 UWORD PrintRightMargin; /* vight margin in characters xf 158 #define DRAFT 0x000 

90 USHORT PrintImage; /* positive or negative */ 159 #define LETTER 0x100 

91 USHORT PrintAspect ; 7* horizontal or vertical xf 160 

92 USHORT PrintShade; /* béw, half-tone, or color */ 161 /* PrintSpacing */ 

93 WORD PrintThreshold; /* darkness ctrl for b/w dumps */ 162 #define SIX_LPI 0x000 

94 163 #define EIGHT_LPI 0x200 

95 /* print paper descriptors */ 164 

96 USHORT PaperSize; /* paper size */ 165 /* Print Image */ 

97 UWORD PaperLength; 7* paper length in number of lines */ 166 #define IMAGE_POSITIVE 0x00 
98 USHORT PaperType; /* continuous or single sheet */ 167. #define IMAGE_NEGATIVE 0x01 
99 168 

100 /* Serial device settings: These are six nibble-fields in three bytes */ 169 /* PrintAspect */ 

Lol /* (these look a little strange so the defaults will map out to zero) */ 170 #define ASPECT_HORIZ 0x00 
102 UBYTE SerRWBits; /* upper nibble = (8-number of read bits) */ 171 #define ASPECT _VERT 0x01 

103 /* lower nibble = (8-number of write bits) */ 172 

104 UBYTE  SerStopBuf; 7* upper nibble = (number of stop bits — 1) */ 173 /* PrintShade */ 

105 /7* lower nibble = (table value for BufSize) */ 174 #define SHADE_BW 0x00 

106 UBYTE SerParShk ; /* upper nibble = (value for Parity setting) */ 175 #define SHADE_GREYSCALE 0x01 
107 /* lower nibble = (value for Handshake mode) */ 176 #define SHADE_COLOR 0x02 

LO8 UBYTE LaceWB; /* if workbench is to be interlaced */ 177 

109 178 /* PaperSize */ 

110 UBYTE WorkName[PILENAME SIZE]; /* temp file for printer ff 179 #define US_LETTER 0x00 

lll 180 #define US_LEGAL 0x10 

112 BYTE RowSizeChange; 181 #define N_TRACTOR 0x20 

113 BYTE ColumnSizeChange; 182 #tdefine W_TRACTOR 0x30 

114 183 #define CUSTOM 0x40 

115 UWORD PrintFlags; /* user preference flags */ 184 

116 UWORD PrintMaxWidth; /* max width of printed picture in 10ths/inch */ 185 /* PrinterType */ 

117 UWORD PrintMaxHeight; /* max height of printed picture in l0ths/inch */ 186 #define CUSTOM_NAME 0x00 
118 UBYTE PrintDensity; /* print density */ 187 #define ALPHA_P_101 0x01 
119 UBYTE PrintxoOffset ; /* offset of printed picture in l10ths/inch */ 188 #define BROTHER_15XL 0x02 
120 189 #define CBM_MPS1000 0x03 
121 UWORD = wb_Width; /* override default workbench width */ 190 #define DIAB_630 0x04 , 
122 UWORD wh Height; /* override default workbench height */ 191 #define DIAB_ADV_D25 0x05 
123 UBYTE wh Depth; /* override default workbench depth */ 192 #define DIAB_C_150 0x06 
124 193 #define EPSON 0x07 
125 UBYTE ‘ext_sizé; /* extension information -- do not touch! */ 194 #define EPSON_JX_80 0x08 
126 /* extension size in blocks of 64 bytes */ 195 #define OKIMATE_20 0x09 
127 3; 196 #define QUME_LP_20 Ox0A 
128 197 /* new printer entries, 3 October 1985 */ 
129 198 #define HP_LASERJET 0x0B 
130 /* Workbench Interlace (use one bit) */ 199 #define HP_LASERJET_PLUS 0x0C 
131 #define LACEWB 0x01 200 

132 tdefine LW_RESERVED 1 /* internal use only */ 201 /* Serial Input Buffer Sizes */ 
133 202 #define SBUF_512 0x00 
134 /* PrinterPort */ 203 #define SBUF_1024 0x01 
135 #define PARALLEL. PRINTER 0x00 204 #define SBUF_2048 0x02 
136 #define SERIAL_PRINTER 0x01 205 #define SBUF_4096 0x03 
137 206 #define SBUF_8000 0x04 


138 /* BaudRate */ 207 #define SBUF_16000 0x05 





79 - da. 





Sep 19 20:27 1988 intuition/preferences.h Page 4 Sep 19 20:27 1988 intuition/screens.h Page 1 





#ifndef INTUITION_SCREENS_H 





208 1 

209 /* Serial Bit Masks */ 2 #define INTUITION_SCREENS_H 
210 #define SREAD BITS OxFO /* for SerRWBits «/ 3 /* 

211 #define SWRITE_BITS 0Ox0F 4 ** $Filename: intuition/screens.h $ 
212 5 ** $Release: 1.3 $ 

213 #define SSTOP_BITS OxFO /* for SerStopBuf */ 6 ** 

214 #define SBUFSIZE_BITS Ox0F 7 ** 

215 B xx 

216 #define SPARITY_BITS OxFO /* for SerParShk 9 ** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
217 #define SHSHAKE_BITS OxOF 10 ** All Rights Reserved 
218 ll */ 

219 /* Serial Parity: (upper nibble, after being shifted by 12 

220 * macro SPARNUM() ) 13 #ifndef EXEC_TYPES_H 

221 */ 14 #include “exec/types.h" 

222 #define SPARITY_NONE 0 15 #endif 

223 #define SPARITY_EVEN 1 16 

224 #define SPARITY_ODD 2 17 #ifndef GRAPHICS _GFX_H 

225 18 #include "graphics/gfx.h" 

226 /* Serial Handshake Mode (lower nibble, after masking using 19 #endif 

227 * macro SHANKNUM() ) . 20 

228 */ 21 #ifndef GRAPHICS_CLIP_H 

229 #define SHSHAKE_XON 0 22 #include "graphics/clip.h" 

230 #define SHSHAKE_RTS 1 23 #endif 

231 #define SHSHAKE_NONE 2 24 

232 25 #ifndef GRAPHICS VIEW_H 

233 /* new defines for PrintFlags */ 26 #include "graphics/view.h" 

234 27 #endif 

235 #define CORRECT_RED 0x0001 /* color correct red shades */ 28 

236 #define CORRECT_GREEN 0x0002 /* color correct green shades */ 29 #ifndef GRAPHICS_RASTPORT_H 
237 #define CORRECT_BLUE 0x0004 /* color correct blue shades */ 30 #include "graphics/rastport.h" 
238 31 #endif 

239 #define CENTER_IMAGE 0x0008 /* center image on paper */ 32 

240 33 #ifndef GRAPHICS_LAYERS_H 

241 #define IGNORE DIMENSIONS 0x0000 /* ignore max width/height settings */ 34 #include "graphics/layers.h" 
242 #define BOUNDED_DIMENSIONS 0x0010 /* use max width/height as boundaries */ 35 #endif 


243 #define ABSOLUTE DIMENSIONS 0x0020 /* use max width/height as absolutes */ 
244 #define PIXEL_DIMENSIONS 0x0040 /* use max width/height as prt pixels */ 
245 #define MULTIPLY DIMENSIONS 0x0080 /* use max width/height as multipliers */ 





246 /* = 
247 #define INTEGER_SCALING 0x0100 /* force integer scaling */ 40 struct Screen 
248 41 { 
249 #define ORDERED_DITHERING 0x0000 /* ordered dithering */ 42 struct Screen *NextScreen; /* linked list of screens */ 
250 #define HALFTONE DITHERING 0x0200 /* halftone dithering */ 43 struct Window *FirstWindow; 7* linked list Screen's Windows */ 
251 #define FLOYD_DITHERING 0x0400 /* Floyd-Steinberg dithering */ 44 
252 45 SHORT LeftEdge, TopEdge; /* parameters of the screen */ 
253 #define ANTI_ALIAS 0x0800 /* anti-alias image */ 46 SHORT Width, Height; /* parameters of the screen */ 
254 #define GREY_SCALE2 0x1000 /* for use with hi-res monitor */ 47 
255 48 SHORT MouseY, MouseX; 7* position relative to upper-left */ 
256 /* masks used for checking bits */ Oo 49 
257 50 USHORT Flags; /* see definitions below */ 
258 #define CORRECT_RGB_ MASK (CORRECT_RED|CORRECT_GREEN | CORRECT _BLUE 51 
259 #define DIMENSIONS _MASK (BOUNDED_DIMENSIONS ABSOLUTE PIMENSTONS | PXEL_DIMENS| 52 UBYTE *Title; /7* null-terminated Title text */ 
260 #define DITHERING MASK (HALFTONE DITHERING | FLOYD_DITHERING) 53 UBYTE *DefaultTitle; /* for Windows without ScreenTitle */ 
261 54 
262 #endif /* INTUITION_PREFERENCES_H */ 55 /* Bar sizes for this Screen and all Window's in this Screen */ 
56 BYTE BarHeight, BarVBorder, BarHBorder, MenuVBorder, MenuHBorder; 
57 BYTE WBorfop, WBorLeft, WBorRight, WBorBottom; 
58 
59 struct TextAttr *Font; /* this screen's default font xf 
60 
61 /* the display data structures for this Screen */ 
62 struct ViewPort ViewPort; /* describing the Screen's display */ 
63 struct RastPort RastPort; /* describing Screen rendering */ 
64 struct BitMap BitMap; /* extra copy of RastPort BitMap */ 
65 struct Layer Info LayerInfo; /* each screen gets a LayerInfo */ 
66 
67 7* You supply a linked-list of Gadgets for your Screen. 
68 * This list DOES NOT include system Gadgets. You get the standard 


69 * system Screen Gadgets by default 








€9 -d 








Sep 19 20:27 1988 intuition/screens.h Page 2 . Sep 19 20:27 1988 intuition/screens.h Page 3 


70 *f 139 struct BitMap *CustomBitMap; 
71 struct Gadget *FirstGadget; 140 }; 

72 141 

73 UBYTE DetailPen, BlockPen; /* for bar/border/gadget rendering */ 142 tendif /* INTUITION_SCREENS_H */ 
74 

75 7* the following variable(s) are maintained by Intuition to support the 

76 * DisplayBeep() color flashing technique 

77 */ 

78 USHORT SaveColor0; 

79 

80 /* This layer is for the Screen and Menu bars */ 

81 struct Layer *BarLayer; 

82 

83 UBYTE *ExtData; 

84 . 

85 UBYTE *UserData; /* general-purpose pointer to User data extension */ 

86 }; 

87 

88 

89 /* ——— FLAGS SET BY LNTUL TION rrr */ 


90 /* The SCREENTYPE bits are reserved for describing various Screen types 
91 * available under Intuition. 


92 */ 

93 #define SCREENTYPE OxO00F /* all the screens types available */ 
94 /* ——— the definitions for the Screen Type ---------—------—-—---—-—---———————_ 
95 #tdefine WBENCHSCREEN 0x0001 * Ta Da! The Workbench «/ 
96 #define CUSTOMSCREEN Ox000F /* for that special look */ 
97 

98 #define SHOWTITLE 0x0010 /* this gets set by a call to ShowTitle() */ 
99 

100 #define BEEPING 0x0020 /* set when Screen is beeping */ 
101 

102 #define CUSTOMBITMAP 0x0040 /* if you are supplying your own BitMap */ 
103 

104 #define SCREENBEHIND 0x0080 /* if you want your screen to open behind 
105 * already open screens 

106 */ 

107 #define SCREENQUIET 0x0100 /* if you do not want Intuition to render 
108 * into your screen (gadgets, title) 

109 «xf 

110 

111 #define STDSCREENHEIGHT ~1 /* supply in NewScreen.Height */ 








117 struct NewScreen 


118 

119 SHORT LeftEdge, TopEdge, Width, Height, Depth; /* screen dimensions */ 
120 

121 UBYTE DetailPen, BlockPen; /* for bar/border/gadget rendering */ 
122 

123 USHORT ViewModes ; /* the Modes for the ViewPort (and View) */ 
124 

125 USHORT Type; /7* the Screen type (see defines above) */ 
126 

127 struct TextAttr *Font; /* this Sereen's default text attributes */ 
128 

129 UBYTE *DefaultTitle; /7* the default title for this Screen */ 

130 

131 struct Gadget *Gadgets; /7* your own Gadgets for this Screen */ 

132 

133 7* if you are opening a CUSTOMSCREEN and already have a BitMap 

134 * that you want used for your Screen, you set the flags CUSTOMBITMAP in 
135 * the Type field and you set this variable to point to your BitMap 

136 * structure. The structure will be copied into your Screen structure, 
137 * after which you may discard your own BitMap if you want 











79 -@ 


WOnNnUeWNE 
* 


19 


/* 
* 
ak 


xk 
kk 


20:27 1988 libraries/configregs.h Page 1 


#ifndef LIBRARIES_CONFIGREGS_H 
#define LIBRARIES_CONFIGREGS_H 


$Filename: libraries/configregs.h $ 
$Release: 1.3 $ 


register and bit definitions for expansion boards 


(C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


#ifndef EXEC_TYPES_H 
#include "exec/types.h" 


#endif 


/* 


xk 


!EXEC_TYPES _H 


Expansion boards are actually organized such that only one nibble per 
word (16 bits). are valid information. This table is structured 

as LOGICAL information. This means that it never corresponds 
exactly with a physical implementation. 


The expansion space is logically split into two regions: 
a rom portion and a control portion. The rom portion is 
actually stored in one's complement form (except for the 
er_type field). 


struct ExpansionRom { 


hi 


UBYTE 
UBYTE 
UBYTE 


er_Type; 

er Product; 

er Flags; 
er_Reserved03; 
er Manufacturer; 
er_Serial Number; 
er_InitDiagVec; 
er Reserved0c; 
er_Reserved0d; 
er Reserved0e; 
er_Reserved0f;. 


struct ExpansionControl [{ 


UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 
UBYTE 


ec_Interrupt; /* interrupt control register */ 
ec_Reservedl1; 
ec_BaseAddress; 
~ ec_Shutup; 
ec_Reserved14; 
ec_Reserved15; 
ec_Reserved16; 
ec_Reserved17; 
ec_Reserved18; 
ec_Reservedl19; 
ec_Reservedla; 
ec_Reservedlb; 
ec_Reservedlc; 
ec_Reservedld; 
ec_Reservedle; 
ec_Reservedlf; 


/* set new config address */ 
7* don't respond, pass config out */ 


many of the constants below consist of a triplet of equivalent 
definitions: xxMASK is a bit mask of those bits that matter. 
xxBIT is the starting bit number of the field. 
number of bits that make up the definition. 
used when the field is larger than one bit. 


xxSIZE is the 
This method is 


19 20:27 1988 libraries/configregs.h Page 2 


** If the field is only one bit wide then the xxB_xx and xxF_xx convention 
** is used (xxB_xx is the bit number, and xxF_xx is mask of the bit). 


/7* manifest constants */ 

#define E_SLOTSIZE 0x10000 
#define E_SLOTMASK Oxfffft 
#define E_SLOTSHIFT 16 


/* these define the two free regions of Zorro memory space. 
%** THESE MAY WELL CHANGE FOR FUTURE PRODUCTS! 

* 

#define E_EXPANSIONBASE 

#define E_EXPANSIONSIZE 

#define E_EXPANSIONSLOTS 


Oxe80000 
0x080000 
8 


#define E_MEMORYBASE 0x200000 
#define E_MEMORYSIZE 0x800000 
#define E_MEMORYSLOTS 128 


/**kxex* ec Type definitions */ 


/* board type —— ignore “old style" boards */ 
#define ERT_TYPEMASK Oxcd 

#tdefine ERT _TYPEBIT 6 

#define ERT_TYPESIZE 2 

#define ERT_NEWBOARD Oxcd 


/* type field memory size */ 
#define ERT_MEMMASK 

#define ERT_MEMBIT 

#define ERT_MEMSIZE 3 


0x07 
0 


/* other bits defined in type field */ 
#define ERTB_CHAINEDCONFIG 3 
#define ERTB_DIAGVALID 4 
#define ERTB_MEMLIST 5 


#define ERTF_CHAINEDCONFIG 
#define ERTF_DIAGVALID 
#define ERTF_MEMLIST 


(1<<3) 
(1<<4) 
(1<<5) 


/* er_Flags byte ~—- for those things that didn't fit into the type byte */ 

#define ERFB_MEMSPACE 7 /* wants to be in 8 meg space. 
** implies that board is moveable 
* 

#define ERFB_NOSHUTUP /* board can't be shut up. 
** be a board. Must be a box that 
** does not pass on the bus. 


*/ 


(1<<7) 


#define ERFF_MEMSPACE 
(1<<6) 


#define ERFF_NOSHUTUP 


/* figure out amount of memory needed by this box/board */ 
#define ERT_MEMNEEDED(t) \ 

(((€) &ERT_MEMMASK)? 0x10000 << (((t)&ERT_MEMMASK) -1) : 0x800000 ) 
/7* same as ERT_MEMNEEDED, but return number of slots */ 
#define ERT_SLOTSNEEDED(t) 


\ 
(( (©) &ERT_MEMMASK)? 1 << (((t)&ERT_MEMMASK)~1) : 0x80 ) 





138 /* interrupt control register */ 


Also 


Must not 

















19 20:27 1988 libraries/configregs.h Page 3 Sep 19 20:27 1988 libraries/configregs.h Page 4 


#tdefine ECIB_INTENA 1 208 #define DAC_BYTEWIDE 0x40 
#define ECIB_RESET 3 209 #define DAC_WORDWIDE 0x80 
#define ECIB_INT2PEND 4 210 
#define ECIB_INT6PEND 5 211 #define DAC_BOOTTIME 0x30 /* two bits for when to boot */ 
#define ECIB_INT7PEND 6 212 #define DAC_NEVER 0x00 /* obvious */ 
#define ECIB_INTERRUPTING 7 213 #define DAC_CONFIGTIME 0x10 /7* call da_BootPoint when first configing the * 
214 /* the device */ 
#define ECIF_INTENA (1<<1) 215 #define DAC_BINDTIME 0x20 /* ran when binding drivers to boards */ 
#define ECIF_RESET (1<<3) 216 
#define ECIF_INT2PEND (1<<4) 217 /* 
#define ECIF_INT6PEND (1<<5) 218 ** These are the calling conventions for Diag or Boot area 
#define ECIF_INT7PEND (1<<6) 219 ** 
#define ECIF_INTERRUPTING (1<<7) 220 ** A7 —- points to at least 2K of stack 
221 ** AG —— ExecBase 
222 ** A5 —- ExpansionBase 
/* convert a expantion slot number into a memory address. */ 223 ** A3 -—- your board's ConfigDev structure 
#define EC_MEMADDR (slot) ((slot) << (E_SLOTSHIFT) ) 224 x* A2 -- Base of diag/init area that was copied 
225 ** AQ -- Base of your board 
/* a kludge to get the byte offset of a structure */ 226 ** 
#tdefine BROFFSET(er) (({int)&( (struct ExpansionRom *)0)—~er) 227 ** Your board should return a value in D0. If this value is NULL, then 
define ECOFFSET(ec) \ 228 ** the diag/init area that was copied in will be returned to the free 
(sizeof (struct ExpansionRom)+((int)&((struct ExpansionControl *)0)~—>ec)) 229 ** memory pool. 
230 */ 
231 
IIIT OCI TO ICICI IO ICI ICICI ITOK TOR RIO IORI IIR TRI TIKI IIIA IIR IAI IK IIHS IERIE KEKE EK 232 tendif /* LIBRARIES CONFIGREGS_H «/ 


** 

x* these are the specifications for the diagnostic area. If the Diagnostic 
** Address Valid bit is set in the Board Type byte (the first byte in 

x* expansion space) then the Diag Init vector contains a valid offset. 

kk 

** The Diag Init vector is actually a word offset from the base of the 

** board. The resulting address points to the base of the DiagArea 

** structure. The structure may be physically implemented either four, 

** eight, or sixteen bits wide. The code will be copied out into 

xx ram first before being called. 

KK 

**x The da-Size field, and both code offsets (da_DiagPoint and da_BootPoint) 
x* are offsets from the diag area AFTER it has been copied into ram, and 

xx "“de-nibbleized" (if needed). Inotherwords, the size is the size of 

** the actual information, not how much address space is required to 

** store it. 

xk 

** All bits are encoded with uninverted logic (e.g. 5 volts on the bus 

*x* is a logic one). 

ak 

** If your board is to make use of the boot facility then it must leave 

x* its config area available even after it has been configured. Your 

** boot vector will be called AFTER your board's final address has been 

** set. 

** 

FOI IO III OIG IOI ICICI COO III I IO III III IK IIA IR | 


struct DiagArea [ 


UBYTE da_Config; /* see below for definitions */ 

UBYTE da_Flags; /* see below for definitions */ 

UWORD da_Size; /* the size (in bytes) of the total diag area * 
UWORD da_DiagPoint; /* where to start for diagnostics, or zero */ 
UWORD da_BootPoint; /* where to start for booting */ 

UWORD da_Name; /* offset in diag area where a string */ 


/* identifier can be found (or zero if no */ 
/* identifier is present). */ 


UWORD da_Reserved01; /* two words of reserved data. must be zero. * 
UWORD da_Reserved02; 
yi 


/* da_Config definitions */ 
#define DAC_BUSWIDTH Oxcod /* two bits for bus width */ 
#define DAC_NIBBLEWIDE 0x00 








99 -da 


Sep 


WON NUP WN 
* 


19 20:27 1988 libraries/configvars.h Page l 


#ifndef LIBRARIES CONFIGVARS_H 
#define LIBRARIES _CONFIGVARS H 


/* 
* $Filename: libraries/configvars.h $ 

RK $Release: 1.3 $ 

Kk 

xe software structures for configuration subsystem 
Kk 

*K (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 

*/ 

#ifndef EXEC_TYPES_H 

#include "exec/types.h" 

#endif !EXEC_TYPES_H 


#ifndef EXEC_NODES H 
#include "exec/nodes.h" 
#endif !EXEC_NODES H 


#ifndef LIBRARIES_CONFIGREGS_H 
#include "libraries/configregs.h" 
#endif !LIBRARIES_CONFIGREGS_H 


struct ConfigDev [{ 
struct Node cd_Node; 
UBYTE ed_Flags; 
UBYTE ed_Pad; 
struct ExpansionRom cd_Rom; /7* image of expansion rom area */ 
APTR cd_BoardaAddr; 7* where in memory the board is */ 
APTR cd_BoardSize; /* size in bytes */ 
UWORD ed_SlotAddr; /* which slot number */ 
UWORD ed_SlotSize; /* number of slots the board takes */ 
APTR cd_Driver; /7* pointer to node of driver */ 
struct ConfigDev * cd_NextCD; /7* linked list of drivers to config */ 
ULONG cd_Unused [4]; /* for whatever the driver whats */ 


hi 


/* cd Flags */ 
#define CDB_SHUTUP 
#define CDB_CONFIGME 


#define CDF_SHUTUP 
#define CDF_CONFIGME 


0 /7* this board has been shut up */ 

1 /7* this board needs a driver to claim it */ 
0x01 

0x02 


/* this structure is used by GetCurrentBinding() and SetCurrentBinding() */ 


struct CurrentBinding { 
struct Configbev * 
UBYTE * 
UBYTE * 
UBYTE ** 

3 


cbh_ConfigDev; 


cb FileName; 


cb_ProductString; 


cbh_ToolTypes; 


7* first configdev in chain */ 
/* file name of driver */ 

7* product # string */ 

/* tooltypes from disk object * 


struct ConfigDev *AllocConfigDev(), *FindConfigDev(); 


tendif /* LIBRARIES _CONFIGVARS_H */ 





Sep 


WONHAUNS WHE 


19 20:27 1988 libraries/diskfont.h Page 1 


#ifndef LIBRARIES_DISKFONT_H 
#define LIBRARIES_| | DISKFONT_} H 


/* 
** $Filename: libraries/diskfont.h $ 

xe $Release: 1.3 $ 

Kk 

ae diskfont library definitions 

** 

** (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
xe All Rights Reserved 

*/ 

#ifndef EXEC_NODES_H 

#include “exec/nodes.h" 

#endif 

#ifndef EXEC_LISTS_H 

#include "exec/lists.h" 

tendif 

#ifndef GRAPHICS TEXT _H 

#include "graphics/text.h" 

#endif 

#define MAXFONTPATH 256 /7* including null terminator */ 


struct FontContents [ 
char fc_FileName[MAXFONTPATH] ; 
UWORD fc_YSize; 
UBYTE fc_Style; 
UBYTE fe_Flags; 
1; 
#define FCH_ID 0x0£00 
struct FontContentsHeader [ 
UWORD fch_FileID; /* FCH_ID */ 
UWORD fch_NumEntries; 7* t 
/* struct FontContents fch_FC[]; */ 
q; 


#tdefine 
#define 


DFH_ID 0x0£80 
MAXFONTNAME 32 /* font name including ".font\0" */ 


struct DiskFontHeader { 


/* the following 8 bytes are not actually considered a part of the */ 
/7* DiskFontHeader, but immediately preceed it. The NextSegment is 
/* supplied by the linker/loader, and the ReturnCode is the code 


/* at the beginning of the font in case someone runs it. 

/* ULONG dfh_NextSegment;/* actually a BPTR */ 

/* ULONG dfh ReturnCode; /* MOVEQ #0,D0 : RTS */ 

7* here then is the official start of the DiskFontHeader. 
struct Node dfh_DF; /* node to link disk fonts */ 
UWORD dfh_FileID; “7 DFH_ID */ 

UWORD dfh_ Revision; /* the font revision */ 
LONG dfh_Segment; /7* the segment address when loaded */ 
char dfh_Name [MAXFONTNAME] ; 


struct TextFont dfh_TF;/*. loaded TextFont structure */ 
5 
#define AFB MEMORY 0 
#define AFF_MEMORY 1 
#define AFB DISK 1 
#define AFF_DISK 2 


struct AvailFonts [{ 
UWORD af_Type; /* MEMORY or DISK */ 
struct TextAttr af_Attr; /* text attributes for font */ 


yi 





the number of FontContents elements */ 


/7* the font name (null terminated) */ 


49-4 





Sep 19 20:27 1988 libraries/diskfont.h Page 2 


70 
71 
72 
73 
74 
75 





struct AvailFontsHeader { 


UWORD afh_NumEntries; 


f* 
1; 


#endif 


/* LIBRARIES_DISKFONT_H */ 


/7* number of AvailFonts elements */ 


struct AvailFonts afh_AF[]; */ 


Sep 


WOON HDU PWN 


19 20:27 1988 libraries/dos.h Page l 


#ifndef 
#define 
/* 
**k 
ak 
Kk 
xx 
Kk 
xk 
uk 


*/ 
#ifndef 


LIBRARIES _DOS_H 
LIBRARIES_DOS_H 


$Filename: libraries/dos.h $ 
$Release: 1.3 $ 


Standard C header for AmigaDOS 
(C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


EXEC_TYPES_H 


#include "“exec/types.h" 


#endif 


#define 


DOSNAME "“dos.library" 


/* Predefined Amiga DOS global constants */ 


#define DOSTRUE (-1L) 
#define DOSFALSE (OL) 
/* Mode parameter to Open() */ 
#define MODE. OLDFILE 1005 /* Open existing file read/write 
* positioned at beginning of file. */ 
#define MODE_NEWFILE 1006 /* Open freshly created file (delete 
* old file) read/write 

#define MODE_READWRITE 1004 /* Open old file w/exclusive lock */ 
/* Relative position to Seek() */ 
#tdefine OFFSET_BEGINNING ~1 /* relative to Begining Of File */ 
#define OFFSET_CURRENT 0 /7* velative to Current file position */ 
#define OFFSET_END 1 /7* relative to End Of File */ 
#define OFPSET_BEGINING OFFSET_BEGINNING /* ancient compatibility */ 
#define BITSPERBYTE 8 
#define BYTESPERLONG 
#define BITSPERLONG 32 
#tdefine MAXINT Ox7FFEFFFF 
#define MININT 0x80000000 
/* Passed as type to Lock() */ 
#define SHARED_LOCK -2 /7* File is readable by others */ 
#define ACCESS_READ -2 7* Synonym */ 
#define EXCLUSIVE_LOCK -1 7* No other access allowed */ 
#define ACCESS WRITE -1 /* Synonym */ 
struct DateStamp [{ 

LONG ds_Days; /* Number of days since Jan. 1, 1978 */ 

LONG ds_ Minute; /7* Number of minutes past midnight */ 

LONG ds_Tick; /* Number of ticks past minute */ 
}; /* DateStamp */ 
#define TICKS_PER_SECOND 50 /* Number of ticks in one second */ 


/* Returned by Examine() and ExInfo(), must be on a 4 byte boundary */ 
struct FileInfoBlock { 


LONG 
LONG 


char 
LONG 
LONG 
LONG 
LONG 


fib_DiskKey; 

fib DirEntryType; /* Type of Directory. If < 0, then a plain file. 
* If > 0 a directory */ 

fib FileName[108}; /* Null terminated. Max 30 chars used for now */ 


fib Protection; /* bit mask of protection, rwxd are 3-0. */ 
fib_EntryType; 

fib Size; /* Number of bytes in file */ 

fib y NumBlocks ; /* Number of blocks in file */ 


struct DateStamp fib Date;/* Date file last changed */ 


char 
char 


fib Comment [80] ; /7* Null terminated comment associated with file */ 
fib_Reserved [36] ; 


}; /* FileInfoBlock */ 


g9 -d 











Sep 19 20:27 1988 libraries/dos.h Page 2 19 20:27 1988 libraries/dos.h Page 3 
70 #define ERROR_OBJECT_IN_USE 202 
71 /* FIB stands for FileInfoBlock */ #define ERROR_OBJECT_ EXISTS 203 
72 #define ERROR_DIR_NOT_FOUND 204 
73 /* FIBB are bit definitions, FIBF are field definitions */ #define ERROR OBJECT _NOT_FOUND 205 
74 #define FIBB_SCRIPT 6 /* program is a script (execute) file */ 143 #define ERROR_BAD STREAM NAME 206 
75 #define FIBB_PURE 5 /7* program is reentrant and rexecutable*/ 144 #define ERROR_OBJECT_TOO_LARGE 207 
76 #define FIBB_ARCHIVE 4 * cleared whenever file is changed */ |145 #define ERROR_ACTION_NOT_KNOWN 209 
77 #define FIBB_READ 3 7* ignored by old filesystem */ J46 #define ERROR_INVALTD_COMPONENT NAME 210 
78 #define FIBB_WRITE 2 7* ignored by old filesystem */ 147 #define ERROR_INVALID LOCK 211 
79 #define FIBB EXECUTE 1 /* ignored by system, used by Shell */ [148 #define ERROR_OBJECT_WRONG TYPE 212 
80 #define FIBB_DELETE 0 /7* prevent file from being deleted */ 149 #define ERROR_DISK_NOT_VALIDATED 213 
81 #define FIBF_SCRIPT (1<<FIBB_SCRIPT) 150 #define ERROR_DISK_WRITE_PROTECTED 214 
82 #define FIBF_PURE (1<<FIBB_PURE) 151 #define ERROR_RENAME ACROSS DEVICES 215 
83 #define FIBF_ARCHIVE (1<<FIBB_ARCHIVE) 152 #define ERROR_DIRECTORY_NOT EMPTY 216 
84 #define FIBF_READ (1<<FIBB_ READ) 153 #define ERROR_TOO_MANY_LEVELS 217 
85 #define FIBF_WRITE (1<<PFIBB_WRITE) 154 #define ERROR_DEVICE_NOT_MOUNTED 218 
86 #define FIBF_EXECUTE (1<<FIBB_EXECUTE) 155 #define ERROR_SEEK_ERROR 219 
87 #define FIBF_DELETE (1<<PIBB_DELETE) 156 #define ERROR_COMMENT 'TOO_BIG 220 
88 157 #define ERROR _| DISK_] FULL 221 
89 158 #define ERROR_| DELETE | PROTECTED 222 
90 /* All BCPL data must be long word aligned. BCPL pointers are the long word 159 #define ERROR WRITE PROTECTED 223 
91 * address (i.e byte address divided by 4 (>>2)) */ 160 #define ERROR_READ_ PROTECTED 224 
92 typedef long BPTR; /* Long word pointer */ 161 #define ERROR_NOT_A_DOS_DISK 225 
93 typedef long BSTR; /* Long word pointer to BCPL string */ 162 #define ERROR_NO_DISK 226 
94 163 #define ERROR NO_MORE_ ENTRIES 232 
95 /* Convert BPTR to typical C pointer */ 164 
96 #ifdef OBSOLETE LIBRARIES DOS H 165 /* These are the return codes used by convention by AmigaDOS commands 7 
97 #define BADDR( bptr ) (((ULONG)bptr) << 2) 166 /* See FAILAT and IF for relvance to EXECUTE files 
98 ftelse 167 #define RETURN_OK 0 /* No problems, success */ 
99 /* This one has no problems with CASTing */ 168 #define RETURN_WARN 5 /* A warning only */ 
100 #define BADDR(x) ( (APTR) ((ULONG)x << 2)) 169 #define RETURN_ERROR 10 /* Something wrong */ 
101 #endif in #define RETURN_FAIL 20 /* Complete or severe failure*/ 
102 17 
103 /* BCPL strings have a length in the first byte and then the characters. 172 /* Bit numbers that signal you that a user has issued a break */ 
104 * For example: s[0]=3 s[l]=S s{2]=Y¥ s[3]=S */ 173 #define SIGBREAKB CTRL _C 12 
105 174 #define SIGBREAKB_CTRL_D 13 
106 /* returned by Info(), must be on a 4 byte boundary */ 175 #define SIGBREAKB CTRL_E 14 
107 struct InfoData [ 176 #define SIGBREAKB CTRL_F 15 
108 LONG id_NumSoftErrors; /* number of soft errors on disk */ 177 
109 LONG  id_UnitNumber; 7* Which unit disk is (was) mounted on */ 178 /* Bit fields that signal you that a user has issued a break */ 
110 LONG id_DiskState; /* See defines below */ 179 /* for example: if (SetSignal(0,0) & BREAK_CTRL CF) cleanup_and_exit(); */ 
lili LONG  id_NumBlocks; /* Number of blocks on disk */ 180 #define SIGBREAKF_CTRL_C  (1<<SIGBREAKB CTRL C) 
112 LONG id_NumBlocksUsed; /* Number of block in use */ 181 #define SIGBREAKF_CTRL_D (1<<SIGBREAKB_CTRL_D) 
113 LONG id_BytesPerBlock; 182 #define SIGBREAKF_CTRL_E  (1<<SIGBREAKB_CTRL_E) 
114 LONG id _DiskType; /* Disk Type code */ 183 #define SIGBREAKF_CTRL_ F  (1<<SIGBREAKB_CTRL_F) 
115 BPTR id_VolumeNode; /* BCPL pointer to volume node */ 184 
116 LONG id_InUse; /* Flag, zero if not in use */ 185 #endif /* LIBRARIES_DOS_H */ 
117 }; /* InfoData */ 
118 
119 /* ID stands for InfoData */ 
120 /* Disk states */ 
121 #define ID_WRITE_PROTECTED 80 /* Disk is write protected */ 
122 #define ID_VALIDATING 81 /* Disk is currently being validated */ 
123 #define ID VALIDATED 82 /* Disk is consistent and writeable */ 
124 
125 /* Disk types */ 
126 #define ID_NO_DISK_PRESENT (-1) 
127 #define ID_UNREADABLE_DISK (('B'<<24) | (tA'<<16) | ('D'<<8B)) 
128 #define ID_DOS_ DISK (('D'<<24) ('0'<<16) ('S'<<8)) 
129 #define ID_NOT REALLY DOS CC'N' <<24) | ('D'<<16) | ('0'K<8) | ('S')) 
130 #define ID_KICKSTART_DISK (('K'<<a4) | ('r'<<16ey | ('c'<<8) ('K')) 
131 
132 /* Errors from IoErr(), etc. */ 
133 #define ERROR_NO_FREE_STORE 103 
134 #define ERROR TASK TABLE FULL 105 
135 #define FBRROR_LINE TOO_LONG 120 
136 #define ERROR_FILE_NOT_OBJECT 121 
137 #define ERROR. INVALID _RESIDENT_LIBRARY 122 
138 #define ERROR_NO DEFAULT DIR 201 











69 - a 











Sep 19 20:28 1988 libraries/dosextens.h Page 1 Sep 19 20:28 1988 libraries/dosextens.h Page 2 























1 #ifndef LIBRARIES_DOSEXTENS_H 70 LONG fh_Func2; 

2 #define LIBRARIES_DOSEXTENS_H 71 LONG fh_Func3; 

3 /* 72 LONG fh_Args; 

4 ** $Filename: libraries/dosextens.h $ 73 #define fh_Argl fh_Args 

5 ** $Release: 1.3 $ 74 LONG fh_Arg2; 

6 ** 75 3; /* FileHandle */ 

7 ** DOS structures not needed for the casual AmigaDOS user 76 

8 xx 77 /* This is the extension to EXEC Messages used by DoS xf 

9 ** (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 78 

10 ** All Rights Reserved 79 struct DosPacket { 

ll */ 80 struct Message *dp_Link; /* EXEC message «f 

12 81 struct MsgPort *dp_ Port; 7* Reply port for the packet */ 

13 #ifndef EXEC_TYPES_H 82 /* Must be filled in each send. */ 

14 #include "exec/types.h" 83 LONG dp_Type; /7* See ACTION_... below and 

15 #endif 84 * 'R' m@ans Read, 'W' means Write to the 
16 #ifndef EXEC_TASKS: H 85 * file system */ 

17 #include "exec/tasks.h" 86 LONG dp Res1; /* For file system calls this is the result 
18 #endif 87 * that would have been returned by the 
19 #ifndef EXEC_PORTS_H 88 * function, e.g. Write ('W') returns actual 
20 #include “exec/ports.h" 89 * length written */ 

21 #endif 90 LONG dp_Res2; /* For file system calls this is what would 
22 #ifndef EXEC_LIBRARIES_H 91 * have been returned by IoErr() */ 

23 #include "exec/libraries.h" 92 /* Device packets. common equivalents */ 

24 #endif 93 #define dp Action dp_Type 

25 “ 94 #define dp_Status dp_Resl 

26 #ifndef LIBRARIES_DOS_H 95 #define dp Status2 dp_Res2 

27 #include "libraries/dos.h" 96 #define dp BufAddr dp_Argl 

28 #tendif 97 LONG dp_Argl; 

29 98 LONG dp_Arg2; 

30 /* All DOS processes have this structure */ 99 LONG dp_Arg3; 

31 /* Create and Device Proc returns pointer to the MsgPort in this structure */ 100 LONG dp_Arg4; 

32 /* dev_proc = (struct Process *) (DeviceProc(..) - sizeof(struct Task)); */ 101 LONG dp Arg5; 

33 102 LONG dp Arg6; 

34 struct Process [ 103 LONG dp_Arg7; 

35 struct Task pr_Task; 104 j; /* DosPacket */ 

36 struct MsgPort pr MsgPort; /* This is BPTR address from DOS functions */ |105 

37 WORD pr_Pad; /7* Remaining variables on 4 byte boundaries */ |106 /* A Packet does not require the Message to be before it in memory, but 
38 BPTR pr_Seghist; /* Array of seg lists used by this process */ {107 * for convenience it is useful to associate the two. 

39 LONG pr_StackSize; /* Size of process stack in bytes */ j108 * Also see the function init_std_pkt for initializing this structure */ 
40 APTR pr_GlobVec; /* Global vector for this process (BCPL) xf |109 

41 LONG pr_TaskNum; /7* CLI task number of zero if not a CLI xf {110 struct StandardPacket [ 

42 BPTR pr_StackBase; /* Ptr to high memory end of process stack */ [lll struct Message sp_Msg; 

43 LONG pr_Result2; /* Value of secondary result from last call */ {112 struct DosPacket sp_Pkt; 

44 BPTR pr_CurrentDir; /* Lock associated with current directory */ {113 }; /* StandardPacket */ 

45 BPTR pr_Cis; /* Current CLI Input Stream : */ |114 

46 BPTR pr_Cos; /* Current CLI Output Stream * 115 /* Packet types */ 

47 APTR pr_ConsoleTask; /* Console handler process for current, window*/ |116 #define ACTION_NIL 0 

48 APTR pr_FileSystemTask; /* File handler process for current drive ¥*/ [117 #define ACTION_GET_BLOCK 2 /* OBSOLETE */ 

49 BPTR pr_CLI; 7* pointer to ConsoleLineInterpreter xf 1118 #define ACTION_SET_MAP 4 

50 APTR pr_ReturnAddr; /* pointer to previous stack frame * 119 #define ACTION_DIE 5 

51 APTR pr_PktWait; /7* Function to be called when awaiting msg */ {120 #define ACTION_EVENT 6 

52 APTR pr_WindowPtr; 7* Window for error printing */ 121 #define ACTION_CURRENT_VOLUME 7 

53 }; /* Process */ 122 #define ACTION_LOCATE_OBJECT 8 

54 123 #define ACTION_RENAME DISK 9 

55 /* The long word address (BPTR) of this structure is returned by 124 #define ACTION_WRITE ‘w! 

56 * Open() and other routines that return a file. You need only worry 125 #define ACTION _READ 'R' 

57 * about this struct to do async io's via PutMsg() instead of 126 #define ACTION_FREB_LOCK 15 

58 * standard file system calls */ 127 #define ACTION_DELETE_OBJECT 16 

59 128 #define ACTION_RENAME_OBJECT 17 

60 struct FileHandle [ 129 #define ACTION_MORE_CACHE 18 

61 struct Message *fh_Link; /* EXEC message xf 130 #define ACTION_COPY_DIR 19 

62 struct MsgPort *fh_ Port; /* Reply port for the packet */ 131 #define ACTION_WAIT_ CHAR 20 

63 struct MsgPort *fh_Type; * Port to do PutMsg() to 132 #define ACTION_SET_ PROTECT 21 

64 * Address is negative if a plain file */ 133 #define ACTION_CREATE_DIR 22 

65 LONG fh Buf; 134 #define ACTION EXAMINE OBJECT 23 

66 LONG fh_Pos; 135 #define ACTION EXAMINE NEXT 24 

67 LONG fh_End; 136 #define ACTION _DISK_INFO 25 

68 LONG fh_Funcs; 137 #define ACTION_INFO 26 

69 #define fh_Funcl fh_Funcs 138 #define ACTION FLUSH 27 

















19 20:28 1988 libraries/dosextens.h Page 3 Sep 19 20:28 1988 libraries/dosextens.h Page 4 











139 #define ACTION_SET_COMMENT 28 208 LONG cli_Interactive; /* Boolean; True if prompts required */ 
140 #define ACTION PARENT 29 209 LONG = cli_Background; /* Boolean; True if CLI created by RUN */ 
141 #define ACTION_TIMER 30 210 BPTR cli_CurrentOutput; /* Current CLI output x/ 
142 #define ACTION_INHIBIT 31 211 LONG cli _DefaultStack; /* Stack size to be obtained in long words */ 
143 #define ACTION_DISK_TYPE 32 212 BPTR cli ~Standardoutput; /7* Default (terminal) CLI output */ 
144 #define ACTION_DISK_CHANGE 33 213 BPTR cli Module; 7* SegList of currently loaded command */ 
tae #define ACTION_SET_DATE 34 214 }; /* CommandLineInterface */ 
46 215 
147 #define ACTION_SCREEN_MODE 994 216 /* This structure can take on different values depending on whether it is 
148 217 * a device, an assigned directory, or a volume. Below is the structure 
149 #define ACTION_READ RETURN 1001 218 * reflecting volumes only. Following that is the structure representing 
150 #define ACTION_WRITE_RETURN 1002 219 * only devices. Following that is the unioned structure representing all 
151 #define ACTION _SEEK 1008 220 * the values 
152 #define ACTION _FINDUPDATE 1004 221 */ 
153 #define ACTION_FINDINPUT 1005 222 
154 #define ACTION_FINDOUTPUT 1006 223 /* structure representing a volume */ 
155 #define ACTION_END 1007 224 
156 #define ACTION_TRUNCATE 1022 /* fast file system only */ 225 struct DevicelList { 
157 #define ACTION _WRITE_PROTECT 1023 /* fast file system only */ 226 BPTR dl_Next; 7* bptr to next device list */ 
158 227 LONG dl_Type; /* see DLT below */ 
159 /* DOS library node structure. 228 struct MsgPort * dl_Task; /* ptr to handler task */ 
160 * This is the data at positive offsets from the library node. 229 BPTR dl_Lock; /* not for volumes */ 
161 * Negative offsets from the node is the jump table to Dos functions 230 struct DateStamp dl_VolumeDate; /* creation date */ 
162 * node = (struct DosLibrary *) OpenLibrary( "dos.library" .. ) xf 231 BPTR dal_LockList ; /* outstanding locks */ 
163 232 LONG dl_DiskType; /* ‘DOS', etc */ 
164 struct DosLibrary [ 233 LONG di_unused; 
165 struct Library dl_lib; 234 BSTR * dl_Name; /* bptr to bepl name */ 
166 APTR dl_Root; /* Pointer to RootNode, described below */ 235 j; . 
167 APTR dl_Gv; /* Pointer to BCPL global vector */ 236 
168 LONG dl_A2; /* Private register dump of DOS */ 237 /* device structure (same as the DeviceNode structure in filehandler.h) */ 
169 LONG dl_as; 238 
170 LONG dl_ a6; 239 struct Devinfo { 
Si171 3; /* DosLibrary */ 240 BPTR dvi_Next; 
1)172 ‘ 241 LONG dvi_Type; 
3/173 /* */ 242 APTR dvi_Task; 
©1174 243 BPTR dvi_Lock; 
175 struct RootNode { 244 BSTR dvi_Handler; 
176 BPTR rn_TaskArray; 7* [0] is max number of CLI's 245 LONG dvi_StackSize; 
177 * [1] is APTR to process id of CLI 1 246 LONG avi Priority; 
178 * [n] is APTR to process id of CLI n */ 247 LONG dvi_Startup; 
179 BPTR rn_ConsoleSegment; /* SegList for the CLI af 248 BPTR dvi_SegList; 
180 struct DateStamp rn_Time; /* Current time */ 249 BPTR dvi_GlobVec; 
181 LONG rn_RestartSeg; /7* SegList for the disk validator process ¥*/ 250 BSTR dvi_Name; 
182 BPTR xm_Info; /* Pointer ot the Info structure */ 251. 4; 
183 BPTR rn_FileHandlerSegment; /* segment for a file handler */ 252 
184 }; /* RootNode */ 233 /* combined structure for devices, assigned directories, volumes */ 
185 254 
186 struct DosInfo { 255 struct DosList [ 
187 BPTR di_McName ; /7* Network name of this machine; currently 0 */ [256 BPTR dol_Next; 7* bptr to next device on list */ 
188 BPTR di_DevInfo; /* Device List xf 1257 LONG dol _' ; /7* see DLT below */ 
189 BPTR di_Devices; /* Currently zero */ (258 struct MsgPort *xdol_ Task; /* ptr to handler task */ 
190 BPTR di_Handlers; /* Currently zero «f/f 1259 BPTR dol_Lock; 
191 APTR di_NetHand; /* Network handler processid; currently zero */ [260 union { 
192 }; /* DosInfo */ 261 struct { 
193 262 BSTR dol_Handler; /* file name to load if seglist is null */ 
194 /* DOS Processes started from the CLI via RUN or NEWCLI have this additional 263 LONG dol_StackSize; /* stacksize to use when starting process */ 
195 * set to data associated with them */ 264 LONG dol_Priority; /* task priority when starting process */ 
196 265 ULONG. dol_Startup; /7* startup msg: FileSysStartupMsg for disks */ 
197 struct CommandLineInterface { 266 BPTR dol_Seglist; /7* already loaded code for new task */ 
LONG cli_Result2; /* Value of IoErr from last command *f/ 267 BPTR dol_GlobVec; /* BCPL global vector to use when starting 
BSTR  cli_SetName; /* Name of current directory */f 268 * a process. ~] indicates a C/Assembler 
BPTR cli _CommandDir; /* Lock associated with command directory */ 269 * program. */ 
LONG cli_ReturnCode; /* Return code from last command  *f 270 } dol_handler; 
BSTR cl1i_CommandName ; /* Name of current command */ 271 
LONG eli_Faillevel; /* Fail level (set by FAILAT) */ 272 struct [ 
BSTR cli_Prompt; /* Current prompt (set by PROMPT) x/ 273 struct DateStamp dol_VolumeDate; /* creation date */ 
BPTR cli StandardiInput; /* Default (terminal) CLI input */ 274 BPTR dol_LockList; /7* outstanding locks */ 
BPTR eli_CurrentInput; /7* Current CLI input */ 275 LONG dol_DiskType; /* ‘DOS', etc */ 





BSTR cli_CommandFile; /* Name of EXECUTE command file xf 276 } dol_volume; 





TL - a 





277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 
294 
295 
296 
297 
298 





19 20:28 1988 libraries/dosextens.h Page 5 


} dol_misc; 


BSTR 


} dol_Name; /* 


/* definitions for dl_Type */ 
#define DLT_DEVICE 0 
#define DLT DIRECTORY 1 
#define DLT_VOLUME 2 


/* a lock structure, as returned by Lock() 
struct FileLock { 


BPTR fl_Link; /* 
LONG fi_Key; /* 
LONG fl_Access; /* 
struct MsgPort * f1_Task; /* 
BPTR f1_Volume; /* 


Li 
#tendif /* LIBRARIES_DOSEXTENS_H */ 


bptr to bepl name */ 


or DupLock() */ 


bepl pointer to next lock */ 
disk block number */ 
exclusive or shared */ 
handler task's port */ 

bptr to a DeviceList */ 





Sep 


WON AUF WNP 


19 20:28 1988 libraries/expansion.h Page 1 


#ifndef LIBRARIES_EXPANSION_H 
#define LIBRARIES_EXPANSION_H 


* 
ue $Filename: libraries/expansion.h $ 
ak $Release: 1.3 $ 
“* 
ae external definitions for expansion. library 
aK 
x (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 
*/ 


#define EXPANSIONNAME “expansion. library" 


/* flags for the AddDosNode() call */ 
#define ADNB_STARTPROC 0 


#define ADNF_STARTPROC (1<<0) 


/* correct types for C programs */ 


struct ConfigDev *AllocConfigDev() ; 
CPTR AllocExpansionMem( ) ; 

struct ConfigDev *FindConfigDev(); 
struct DeviceNode *MakeDosNode( ); 


#tendif /* LIBRARIES _EXPANSION_H */ 





ei -d 


Sep 19 20:28 1988 libraries/expansionbase.h Page 1 


#ifndef LIBRARIES _EXPANSIONBASE_H 

#define LIBRARIES_EXPANSIONBASE_H 

/* 

xk $Filename: libraries/expansionbase.h $ 


CON DUPWN ey 





ae $SRelease: 1.3 $ 
Kk 


kk 
aK 


** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 


xe All Rights Reserved 
*f 


#ifndef EXEC _ TYPES_H 
#include "exec/types.h" 
#endif !EXEC_TYPES H 


#ifndef EXEC_LIBRARIES H 
ftinclude "exec/libraries.h" 
#endif !EXEC_LIBRARIES H 


#ifndef EXEC_INTERRUPTS_H 
#include "exec/interrupts.h" 
#endif !EXEC_INTERRUPTS_H 


#ifndef EXEC_| SEMAPHORES_H 
#include "exec/semaphores.h" 
#fendif !EXEC_SEMAPHORES H 


#ifndef LIBRARIES | CONFIGVARS_H 
#include "libraries/configvars.h" 
#endif !LIBRARIES_CONFIGVARS_H 


#define TOTALSLOTS 256 
struct ExpansionInt 


UWORD IntMask; 
UWORD ArrayMax; 
UWORD = ArraySize; 


struct ExpansionBase 


struct Library LibNode; 

UBYTE Flags; 

UBYTE pad; 

APTR ExecBase; 

APTR Seghist; 

struct CurrentBinding CurrentBinding; 
struct List BoardList; 

struct List Mounthist; 

UBYTE AllocTable[TOTALSLOTS] ; 

struct SignalSemaphore BindSemaphore; 


struct Interrupt Int2List; 
struct Interrupt Int6List; 
struct Interrupt Int7List; 


3 
#endif /* LIBRARIES EXPANSIONBASE_H */ 





Sep 


WOANDUNSPWNH 








19 20:28 1988 libraries/filehandler.h Page 1 


#ifndef LIBRARIES_FILEHANDLER_H 
#define LIBRARIES | | FILEHANDLER_H 





/* 
aK $Filename: libraries/filehandler.h $ 

ee $Release: 1.3 $ 

ws 

ae device and file handler specific code for AmigaDOS 
kK 

ae (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 

*/ 

#ifndef EXEC_TYPES H 


#inelude "exec/types.h" 


#fendif 
#ifndef 


{EXEC_TYPES H 


EXEC_PORTS_H 


#include "exec/ports.h" 


#tendif 
#ifndef 


1EXEC_ PORTS H 


LIBRARIES _DOS_H 


#include "libraries/dos.h" 


#fendif 


! LIBRARIES _DOS_H 


/7* The disk "environment" is a longword array that describes the 


* disk 


geometry . 


It is variable sized, with the length at the beginning. 


* Here are the constants for a standard geometry. 


*/ 


struct DosEnvec [{ 
ULONG de_TableSize; 
ULONG de_SizeBlock; 
ULONG de_SecOrg; 
ULONG de_Surfaces; 


ULONG de_SectorPerBlock; 
ULONG de_BlocksPerTrack; 


ULONG de_Reserved; 
ULONG de_] “PreAlloc; 
ULONG de_Interleave; 
ULONG de_LowCyl; 
ULONG de_HighCyl; 
ULONG de_NumBuffers; 
ULONG de_BufMemType; 
ULONG de_MaxTransfer; 
ULONG de_Mask; 

LONG de _BootPri; 
ULONG de_DosType; 


}; 


Size of Environment vector */ 

in longwords: standard value is 128 */ 

not used; must be 0 */ 

# of heads (surfaces). drive specific */ 

not used; must be 1 */ 

blocks per track. drive specific */ 

DOS reserved blocks at start of partition. */ 
DOS reserved blocks at end of partition */ 
usually 0 */ 

starting cylinder. typically 0 */ 

max cylinder. drive specific */ 

Initial # DOS of buffers. */ 

type of mem to allocate for buffers */ 

Max number of bytes to transfer at a time */ 
Address Mask to block out certain memory */ 
Boot priority for autoboot */ 

ASCII (HEX) string showing filesystem type; 
0X444F5300 is old filesystem, 

0X444F5301 is fast file system */ 


/* these are the offsets into the array */ 


usually 2 */ 


typically 5 */ 


#tdefine DE_TABLESIZE 0 /* standard value is 1] */ 

#define DE_SIZEBLOCK 1 7* in longwords: standard value is 128 */ 
#define DE_SECORG 2 7* not used; must be 0 */ 

#define DE_NUMHEADS 3 7* # of heads (surfaces). drive specific */ 
#define DE_SECSPERBLK 4 7* not used; must be 1 */ 

#define DE_BLKSPERTRACK 5 /* blocks per track. drive specific */ 
#define DE_RESERVEDBLKS 6 /* unavailable blocks at start. 

#tdefine DE_PREFAC 7 7* not used; must be 0 */ 

#define DE_INTERLEAVE 8 /* usually 0 *f/ 

#define DE_LOWCYL 9 /* starting cylinder. typically 0 */ 
#tdefine DE_UPPERCYL 10 7* max cylinder. drive specific */ 
#define DE_NUMBUFFERS 11 /* starting # of buffers. 

#tdefine DE_MEMBUPTYPR 12 /7* type of mem to allocate for buffers. */ 
#define DE_BUFMEMTYPE 12 7* same as above, better name 


* 1 is public, 3 is chip, 5 is fast */ 





19 20:28 1988 libraries/mathffp.h Page 1 










Sep 19 20:28 1988 libraries/filehandler.h Page 2 


70 ¥define DE_MAXTRANSFER 13 /* Max number bytes to transfer at a time */ 1 #ifndef LIBRARIES_MATHFFP_H 
71 #define DE_MASK 14 7* Address Mask to block out certain memory */ 2 #define LIBRARIES_MATHFFP_H 
72 #define DE_BOOTPRI 15 /* Boot priority for autoboot */ 3 /* 
73 #define DE_DOSTYPE 16 /* ASCII (HEX) string showing filesystem type; 4 ** $Filename: libraries/mathffp-.h $ 
74 * 0X444F5300 is old filesystem, 5 ** $Release: 1.3 $ 
75 * 0X444F5301 is fast file system */ 6 ** 
76 : 7 ** general floating point declarations 
17 /* The file system startup message is linked into a device node's startup 8 ** 
78 ** field. It contains a pointer to the above environment, plus the Q xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
19 ” information needed to do an exec OpenDevice(). 10 ** All Rights Reserved 
*/ 






81 struct FileSysStartupMsg [ 




















82 ULONG fssm_Unit; /7* exec unit number for this device */ #ifndef PI 

83 BSTR fssm_Device; 7* null terminated bstring to the device name */| 14 #define PI ((float) 3.141592653589793) 
84 BPTR fssm_Environ; /7* ptr to environment table (see above) */ 15 #tendif 

85 ULONG fssm_Flags; /* flags for OpenDevice() */ 16 #define TWO_PI (((float) 2) * PI) 

86 }; 17 #define PI2 (PI / ((float) 2)) 

87 18 #define PI4 (PI / ((float) 4)) 

88 . 19 #ifndef E 

89 /* The include file "libraries/dosextens.h" has a DeviceList structure. 20 #define E ((float) 2.718281828459045) 
90 * The "device list" can have one of three different things linked onto 21 #endif 

91 ¥* it. Dosextens defines the structure for a volume. UCLT_DIRECTORY 22 #define LOG1O ((float) 2.302585092994046) 
92 * is for an assigned directory. The following structure is for 23 

33 “7 a dos "device" (DLT _DEVICE). 24 #define FPTEN (float) 10.0) 


(float) 0.5) 
(float) 0.0) 


26 #define FPHALF 


( 

25 #define FPONE ((float) 1.0) 
( 

27 #define FPZERO ( 


96 struct DeviceNode { 

97 BPTR dn_Next.; /7* singly linked list */ 

98 ULONG dn_Type; /* always 0 for dos "devices" */ 

99 struct MsgPort *dn_Task; /* standard dos "task" field. If this is 


29 #define trunc(x) ({int) (x)) 
30 #define round(x) ((int) ((x) + 0.5)) 















€lL-d 













100 x null when the node is accesses, a task #define itof(i) ({float) (1)) 
101 * will be started up */ 

102 BPTR dn_Lock; /* not used for devices -- leave null */ 33 #define fabs SPAbs 

103 BSTR dn_Handler; 7* filename to loadseg (if seglist is null) */ 34 #define floor SPFloor 

104 ULONG dn_StackSize; /* stacksize to use when starting task */ #define ceil sPCeil 

105 LONG dn_ Priority; /* task priority when starting task */ 














106 BPTR dn_Startup; /* startup msg: FileSysStartupMsg for disks */ #define tan spTan 
107 BPTR dn_Seghist; 7* code to run to start new task (if necessary). 38 #define atan SPAtan 
108 * if null then dn Handler will be loaded. */ 39 #define cos SPCos 
109 BPTR dn_Globalvec; /7* BCPL global vector to use when starting 40 #define acos SPAcos 
110 * a task. -l means that dn_SegList is not 41 #define sin sPSin 
lili * for a bepl program, so the dos won't 42 #define asin SPAsin 
112 * try and construct one. 0 tell the 43 #define exp SPExp 
113 x dos that you obey BCPL linkage rules, 44 #define pow(a,b) SPPow((b),(a)) 
1i4 * and that it should construct a global 45 #define log SPLog 
115 * vector for you. 46 #define loglO  SPLogl0 
116 * #define sgrt spSqrt 





ia ; BSTR dn_Name; /* the node name, e.g. ‘N3', (DI, TB','3! */ 








#define sinh SPSinh 
50 #define cosh SPCosh 
51 #define tanh sPTanh 





120 #endif /* LIBRARIES_FILEHANDLER_H */ 












54 int SPFix(); /* Basic math functions */ 
55 float SPF1t(); 
56 int sPcmp(); 
57 int SPTst(); 


58 float SPAbs(); 

59 float SPFloor(); 

60 float SPCeil(); 

61 #ifndef abs 

62 float abs(); 

63 #endif 

64 float SPNeg(); 

65 float SPAdd(); 

66 float SPSub(); 
di 
di 










67 float SPMul ( 
float 





tL —-—ad 





19 20:28 1988 libraries/mathffp.h Page 2 Sep 19 20:28 1988 libraries/mathieeedp.h Page 1 








70 float SPAsin(), SPAcos(), SPAtan(); /* Transcendental math functions */ 1 fifndef LIBRARIES_MATHIEEEDP_H 
71 float SPSin(), SPCos(), SPTan(), SPSincos(); 2 #define LIBRARIES _MATHIEEEDP_H 
72 float SPSinh(), SPCosh(), SPTanh(); 3 /* . . . . 
73 float SPEXxp(), SPLOg(), SPLOg10(), SPPow(); 4 ** $Filename: libraries/mathieeedp.h $ 
74 float SPSqrt(), SPFieee(); 2 ** $Release: 1.3 $ 
75 
76 float afp({), dbf (); /7* Math conversion functions */ i ** 
77 
78 #endif /* LIBRARIES MATHFFP_H */ Q ** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
~ 10 x* All Rights Reserved 
ll */ 
12 
13 #ifndef PI 
14 #define PI ( (double) 3.141592653589793) ) 
15 #endif PI 
16 
17 #define TWO_PI (((double) 2) * PT) 
18 #define PI2 (PI/((double)2)) 
19 #define PI4 (PI/( (double) 4)) 
20 
21 #ifndef E 
22 #define E ( (double) 2.718281828459045) 
23 tendif E 
24 
25 #define LOG10 ( (double) 2. 302585092994046) 
26 #define FPTEN ( (double) 10.0) 
27 #define FPONE ( (double) 1.0) 
28 #define FPHALF ( (double) 0.5) 
29 #define FPZERO ((double) 0.0) 
30 #define trunc(x) ((int) (x)) 
31 #define round(x) ((int) ((x) + 0.5)) 
32 #define itof(i) ((double) (1)) 
33 
34 #define fabs IEEEDPAbs 
35 #define floor IEEEDPFloor 
36 #define ceil IEBEDPCeil 
37 
38 #define tan TEEEDPTan 
39 #define atan IBEEDPAtan 
40 #define cos TEEEDPCos 
41 #define acos IEEEDPAcos 
42 #define sin IEBEEDPSin 
43 #define asin IEEEDPAsin 
44 #define exp IEEEDPExp 
45 #define pow(a,b) IEEEDPPow((b),(a)) 
46 #define log IEEEDPLog 


47 #define logl0 IEEEDPLogl0 
48 #define sqrt IEEEDPSqrt 


50 #define sinh IEEEDPSinh 
51 #define cosh IEEEDPCosh 
52 #define tanh IEEEDPTanh 


55 double IEEEDPTan(),IEEEDPAtan(); 

56 double IEEEDPCos(),IEEREDPACos(); 

57 double IEEEDPSin(),IEEEDPASin(); 

58 double IEEEDPExp(),IEEEDPLog(); 

59 double IEEEDPSgqrt(); 

60 double IEEEDPLogl0(),IEEEDPPow(); 

61 double IEEEDPSincos(); 

62 double IEEEDPSinh(),IEEEDPCosh() , IEEEDPTanh( ); 
63 float IEEEDPTieee( ); 

64 double IEEEDPFieee(); 





65 
66 int IEEEDPFix(); 
67 int IEEEDPCmp( ) , IEEEDPTst () ; 


68 double IBEEDPF1t(); 
69 double IBEEDPAbS(); 








GL-d 








19 20:28 1988 libraries/mathieeedp.h Page 2 


double 
double 
double 
double 
double 
double 
double 


#tendif 





IREEDPNeg(); 
IEEEDPAdd({ ) ; 
IEEEDPSub({ ) ; 
IEEEDPMul ( ) ; 
TEEEDPDiv(); 
JEEEDPFloor(); 
IEEEDPCeil (); 


/* LIBRARIES MATHIEEEDP_H */ 





WDIANSWNHY 


19 20:28 1988 libraries/mathlibrary.h Page 1 


tifndef LIBRARIES_MATHLIBRARY_H 
#define LIBRARIES_MATHLIBRARY_H 


/* 

*e $Filename: libraries/mathlibrary.h $ 

ee $Release: 1.3 $ 

xk 

xk 

Kk 

** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
x* All Rights Reserved 

*/ 


#ifndef EXEC_TYPES_H 
#include <exec/types.h> 
#endif 


#ifndef EXEC_LIBRARIES_H 
#include <exec/libraries.h> 
ftendif 


struct MathIEEEBase 


struct Library MathIEEEBase_LibNode; 

unsigned char MathIEEEBase_Flags; 

unsigned char MathIEEEBase_reserved1; 

unsigned short *MathIEEEBase_68881; 

APTR MathIEEEBase_SysLib; 

APTR MathIEEEBase_SegList; 

struct MathIEEEResource *MathIEEEBase_Resource; 


int (*MathIEEEBase_TaskOpenLib) (); 
int. (*MathIEBEBase_TaskCloseLib)(); 
/* This structure may be extended in the future */ 


eu 


Math resources may need to know when a program opens or closes this 
library. The functions TaskOpenLib and TaskCloseLib are called when 

a task opens or closes this library. They are initialized to point to 
local initialization pertaining to 68881 stuff if 68881 resources 

are found. To override the default the vendor must provide appropriate 
hooks in the MathIEEEResource. If specified, these will be called 
when the library initializes. 


*/ 
#endif /* LIBRARIES_MATHLIBRARY_H */ 


a 











94 -a 


Sep 


Re 
HOWVONDUEWUNE 


12 








19 20:28 1988 libraries/romboot_base.h Page 1 


#ifndef LIBRARIES ROMBOOT_BASE_H 
#define LIBRARIES ROMBOOT BASE_H 


/* 
ae $Filename: libraries/romboot_base.h $ 

xk $Release: 1.3 $ 

kk 

kK 

kk 

ae (C) Copyright 1987,1988 Commcdore-Amiga, Inc. 
xe All Rights Reserved 

*/ 


#ifndef EXEC_TYPES H 
#include <exec/types.h> 
tendif 

#ifndef EXEC_NODES_H 
#include <exec/nodes.h> 
#endif 

#ifndef EXEC_LISTS_H 
#include <exec/lists.h> 
#tendif 

#ifndef EXEC_LIBRARIES_H 
#include <exec/libraries.h> 
#endif 

#ifndef EXEC_EXECBASE_H 
#include <exec/execbase.h> 
#endif 

#tifndef EXEC_EXECNAME_H 
#include <exec/execname .h> 
#endif 


struct RomBootBase 


struct Library LibNode; 
struct ExecBase *ExecBase; 
struct List BootList; 
ULONG Reserved [4]; /* for future expansion */ 


1; 
struct. BootNode 
{ 
struct Node bn_Node; 
UWORD bn Flags; 
CPTR bn. DeviceNode; 
y; 
#define ROMBOOT_NAME "romboot. library" 


#tendif /* LIBRARIES ROMBOOT BASE_H */ 





Sep 


WDMAIDMNPWNE 


19 20:28 1988 libraries/translator.h Page 1 


#ifndef 
#define 
/* 
Kk 
*k 
K* 
Kk 
Kk 
xk 
ak 


*/ 


#define 
#tdefine 
#tdefine 


#tendif 


LIBRARIES_TRANSLATOR_H 
LIBRARIES TRANSLATOR_H 


$Pilename: libraries/translator.h $ 
SRelease: 1.3 $ 


Translator error return codes 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


TR_NotUsed ~l /* This is an oft used system re */ 
TR_NoMem -2 /* Can't allocate memory */ 
TR_MakeBad -4 /7* Error in MakeLibrary call */ 


/* LIBRARIES TRANSLATOR_H */ 


iL - a 








Sep 


WOnNRAUEWNE 


19 20:28 1988 resources/cia.h Page 1 


#ifndef RESOURCES_CIA_H 
#define RESOURCES _CIA_H 


ae (C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 


/* 

** $Pilename: resources/cia.h $ 
xe $Release: 1.3 $ 

Kx 

kk 

xk 

“x All Rights Reserved 

*/ 


tdefine CIAANAME "ciaa.resource" 
#define CIABNAME "ciab.resource" 


#endif /* RESOURCES_CIA_H */ 


|sep 


WOnNAUNS WHE 





19 20:28 1988 resources/disk.h Page 1 


#ifndef RESOURCES _DISK_H 
#define RESOURCES _DISK_H 
/* 


* $Filename: resources/disk.h $ 

xe $Release: 1.3 

xk 

ae external declarations for disc resources 

ae 

xe (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 

*/ 


#ifndef EXEC_TYPES_H 
#include "exec/types.h" 
#endif !EXEC_TYPES_H 


#ifndef EXEC_LISTS_H 
#include "exec/lists.h" 
#fendif !EXEC_LISTS_H 


#ifndef EXEC_PORTS_H 
#include "exec/ports.h" 
fendif !EXEC_PORTS_H 


#ifndef EXEC_INTERRUPTS H 
tinclude "exec/interrupts.h" 
#endif !EXEC_INTERRUPTS_H 


#ifndef EXEC_LIBRARIES_H 
#include "“exec/libraries.h" 
#endif !EXEC_LIBRARIES_H 


DOIG III TOI TCI III TTI TIO I IIIT IIIT II ITA ITS IT III I III III OI IIIA 


* 


* Resource structures 
* 


FOI CII III III ITO I III III TOI ITOK IOI AIK IAA IKK IK IOI IIR IIA KIA AK f 


struct DiscResourceUnit [ 
struct Message dru_Message; 


struct Interrupt dru_DiscBlock; 
struct Interrupt dru_DiscSync; 


struct Interrupt dru_Index; 


i 


struct DiscResource { 
struct Library 
struct DiscResourceUnit 
UBYTE 
UBYTE 
struct Library 
struct Library 
ULONG 
struct List 
struct Interrupt 
struct Interrupt 
struct Interrupt 


Le 


/* ar Flags entries */ 
#define DRB_ALLOCO 
#define DRB_ALLOCL 
#define DRB_ALLOC2 
#define DRB_ALLOC3 
#define DRB_ACTIVE 


SEWN O 


#define DRF_ALLOCO (1<<0) 


dr_Library; 
*dr_Current; 
dr_ Flags; 
dr_pad; 
*dar_SysbLib; 
*xdr_CiaResource; 
dr_UnitID[4]; 
dr Waiting; 
dr. DiscBlock; 
dr_DiscSync; 
dr_Index; 


/* unit zero is allocated */ 

/* unit one is allocated */ 

/7* unit two is allocated */ 

/* unit three is allocated */ 

/* is the dise currently busy? */ 


/* unit zero is allocated */ 








8L-a 











19 20:28 1988 resources/disk.h Page 2 


#define DRF_ALLOC] 
#define DRF_ALLOC2 
#define DRF_ALLOC3 
#define DRF_ACTIVE 


(1<<1) /* unit one is allocated */ 
(1<<2)) /* unit two is allocated */ 
(1<<3)  /* unit three is allocated */ 
(1<<7) /* is the disc currently busy? */ 


IORI III ICO RIOT TOO IO I IOI III AIO IIIA OR 
* 

* Hardware Magic 

* 

JARIOISISISI IOC COCIIOEICI III IICIOCIOIOICTOIGTOOICITIIRICCICC CITT IOI ICT TOC O II IIH 


#tdefine DSKDMAOFF 0x4000 /* idle command for dsklen register */ 


SBR RIKI KR IRR IIR IR KI IRR IORI RIOR ITO IIR IORI RIOR IORI IOI OR IO IA III 
x 

* Resource specific commands 

* 

JACI IOI CICIOIO ICICI ICICI CTIOOI ICCC IOI CICCCICO ICO TORII IOI ITI AIO III 


/* 
* DISKNAME is a generic macro to get the name of the resource. 
* This way if the name is ever changed you will pick up the 
* change automatically. 

*/ 


#define DISKNAME "disk.resource" 


#define DR_ALLOCUNIT 
#define DR_FREEUNIT 
#define DR_GETUNIT 
#define DR_GIVEUNIT 
#define DR_GETUNITID 


(LIB_BASE -— 0*LIB_VECTSIZE) 
(LIB_BASE — 1*LIB_VECTSIZE) 
(LIB_BASE ~ 2*LIB_VECTSIZE) 
(LIB_BASE — 3*LIB_VECTSIZE) 
(LIB_BASE — 4*LIB VECTSIZE) 


#define DR_LASTCOMM (DR_GIVEUNIT) 


J RRR I IIR KIRKE R ERR IRB IR RIK IOI IORI ROI IIR IORI OIC IO IT 
x 


*x drive types 
* 


FRCIGOCIOICIOIIOICIC ICICI IIIOICICGICIICTCICIICTICOICTCICIOC TOCCOA TOI I TOR IAI IO 


#define DRT_AMIGA (0x00000000) 
#define DRT_37422D2S (0x55555555) 
#define DRT_EMPTY (OXFFFFFFFF ) 


#endif /* RESOURCES DISK_H */ 


Sep 


WOON ADUSPWDNE 


53 


19 20:28 1988 resources/filesysres.h Page 1 


#ifndef RESOURCES_FILESYSRES_H 
#define RESOURCES_FILESYSRES_H 





/* 
** $Filename: resources/filesysres.h $ 

xe $Revision: 1.0 $ 

we $Date: 88/07/11 15:32:08 $ 

KK 

ak FileSystem. resource description 

K* 

* (C) Copyright 1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 

*/ 

#ifndef EXEC_NODES H 

#include "exec/nodes.h"' 

tendif 

#ifndef EXEC_LISTS_H 

#include "exec/lists.h" 

#endif 

#ifndef LIBRARIES DOS_H 

#include "lLibraries/dos.h" 

#tendif 


#define FSRNAME "FileSystem. resource" 


struct FileSysResource { 


struct Node fsr_Node; /* on resource list */ 


char *fsr_Creator; /* name of creator of this resource */ 
struct List fsr_FileSysEntries; /* list of FileSysEntry structs */ 
i; 
struct FileSysEntry [{ 

struct Node fse Node; 7* on fsr FileSysEntries list */ 
/* In Name is of creator of this entry */ 

ULONG  fse_DosType; 7* DosType of this FileSys */ 

ULONG fse_Version; 7* Version of this FileSys */ 

ULONG fse_PatchFlags; /* bits set for those of the following that */ 
f* need to be substituted into a standard */ 
/* device node for this file system: e.g. */ 
ft 0x180 for substitute Seghist & GlobalVec * 

ULONG fse' i 7* device node type: zero */ 

CPTR fse_Task; 7* standard dos "task" field */ 

BPTR fse_Lock; /* not used for devices: zero */ 

BSTR fse_Handler; /* filename to loadseg (if Seghist is null) */ 

ULONG fse_StackSize; /* stacksize to use when starting task */ 

LONG fse_Priority; 7* task priority when starting task */ 

BPTR fse_Startup; /* startup msg: FileSysStartupMsg for disks */ 

BPTR fse_SegList; /* code to run to start new task */ 

BPTR fse_GlobalvVec; /* BCPL global vector when starting task */ 


/* no more entries need exist than those implied by fse_PatchFlags */ 


#endif /* RESOURCES FILESYSRES H */ 





64 -—a 





Sep 


WODNADUSWNE 








19 20:28 1988 resources/mathresource.h Page 1 


#tifndef 
#tdefine 
/* 
xk 
xk 
kek 
kk 
Kn 
xk 
Kk 


*/ 
#ifndef 


RESOURCES_MATHRESOURCE_H 
RESOURCES_MATHRESOURCE_H 


$Filename: resources/mathresource.h $ 
$Release: 1.3 $ 


(C) Copyright 1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


EXEC_TYPES_H 


#include <exec/types.h> 


#endif 
#ifndef 


EXEC_NODES_H 


#include <exec/nodes.h> 


#endif 
/* 


* 


ee eH HH OH 


* 
~N 


The 'Init' entries are only used if the corresponding 
bit is set in the Flags field. 


So if you are just a 68881, you do not need the Init stuff 
just make sure you have cleared the Flags field. 


This should allow us to add Extended Precision later. 
For Init users, if you need to be called whenever a task 


opens this library for use, you need to change the appropriate 
entries in MathIEEELibrary. 


struct MathIEEEResource 
{ 


Li 


struct Node MathiIEEEResource_ Node; 
unsigned short MathIEEEResource_Flags; 


unsigned short *MathIEEEResource_BaseAddr; /* ptr to 881 if exists */ 


void (*MathIEEEResource_DblBasInit)(); 
void (*MathIEEEResource_DblTransInit)(); 
void (*MathiIEEEResource_SglBasInit)(); 
void (*MathIEEEResource_SglTransInit)(); 
void (*MathIEEEResource_ExtBasInit)(); 
void (*MathIEEEResource_ExtTransInit)(); 


/* definations for MathIEEEResource_FLAGS */ 


#define 
#define 
#define 
#define 
#define 
#define 


fendif 


MATHIEEERESOURCEF_DBLBAS (1<<0) 
MATHIEEERESOURCEF_DBLTRANS (1<<1) 
MATHIEEERESOURCEF_SGLBAS (1<<2) 
MATHIEEERESOURCEF_SGLTRANS (1<<3) 
MATHIEEERESOURCEF _EXTBAS (1<<4) 
MATHIEEERESOURCEF_EXTTRANS (1<<5) 


/* RESOURCES_MATHRESOURCE_H */ 


% 
~ 


WONAUNS WHE 





19 20:29 1988 resources/misc.h Page 1 


#ifndef RESOURCES_MISC_H 
#define RESOURCES MISC_H 


* 
G $Filename: resources/misc.h $ 
ak SRelease: 1.3 $ 
Kk 
«x external declarations for misc system resources 
xk 
** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 
*/ 


#ifndef EXEC_TYPES_H 
#include “exec/types.h" 
#endif !EXEC_TYPES_H 


#ifndef EXEC_LIBRARIES_H 
#include “exec/libraries.h" 
#endif !EXEC_LIBRARIES_H 


ICICI RTO ITO IT IT TOI TTI I IIIT AIA IO TO IT III IIT III IAI ISSIR IIR 
* 

* Resource structures 

*x 

HOR IA IRI III IIIT III IKI II KIA IKI AAI IR IR IIE IIR EAI III IRI IRR IRIS IIIA 


#define MR_SERIALPORT 0 
#define MR_SERIALBITS 1 
#define MR_PARALLELPORT 2 
#define MR_PARALLELBITS 3 


#define NUMMRTYPES 4 


struct MiscResource [{ 
struct Library mr_Library; 
ULONG mr_AllocArray [NUMMRTYPES] ; 
hi 


#tdefine MR_ALLOCMISCRESOURCE 
#define MR_FREEMISCRESOURCE 


(LIB_BASE) 
_(LIB_BASE + LIB_VECSIZE) 


#define MISCNAME "misc.resource" 


#endif /* RESOURCES_MISC_H */ 





os -d 





sep 


ke 
FPOVOANDUSFWNH 


BREE 
Ul Go ND 


19 20:29 1988 resources/potgo.h Page 1 


#ifndef RESOURCES_POTGO_H 
#define RESOURCES_POTGO_H 


f* 
kk 
xk 
xk 
kK 
Kk 
xe 
xk 


*/ 


$Filename: resources/potgo.h $ 
SRelease: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


#define POTGONAME "potgo. resource" 


#endif /* RESOURCES_POTGO_H */ 





Mi 


18 -d 








Sep 


WOH Ue WN 


19 20:29 1988 workbench/icon.h Page 1 Sep 
#ifndef WORKBENCH_ICON_H 1 
#define WORKBENCH_ICON_H 2 
/* 3 
ae SPilename: workbench/icon.h $ 4 
x $Release: 1.3 $ 5 
ak 6 
xe external declarations for workbench support library 7 
*k 8 
ae (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 9 
xk All Rights Reserved 10 
*/ 11 

12 
OCICS III TOI IIIT III IIIT II TOTS AT IIIT IT IAI IT III I IIIS IS III ISIS 13 
* 14 
* library structures 15 
* 16 
FOO IOI OGIO IOI I ICO IOI IIIT IO IIIA IIIT IIT IA IK 17 

18 

19 
#define ICONNAME "icon. library" 20 

21 
BOI IO ITO III ICICI TOTTI TT OTS II IIIT II IIA ITI III IIIA IIIA. 22 
* 23 
* function types 24 
* 25 
OI IO II III III III OO IO III OAT IAI IAA I ASAT III / 26 

27 
struct WBObject *GetWBObject(), *AllocWBObject(); 28 
struct DiskObject *GetDiskobject(); 29 
LONG PutWBObject(), PutIcon(), GetIcon(), MatchToolValue(); 30 
VOID FreeFreeList(), FreeWBObject(), AddFreeList(); 31 
char *FindToolType(); 32 

33 
#endif /* WORKBENCH_ICON_H */ 34 

35 

36 

37 

38 

39 











19 20:29 1988 workbench/startup.h Page 1 


#ifndef WORKBENCH_STARTUP_H 


#tdefine WORKBENCH_STARTUP_H 
* 


a $Filename: workbench/startup.h $ 

** $Release: 1.3 $ 

Kk 

Kk 

Kx 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 

*/ 


#ifndef EXEC_TYPES_H 
#include "exec/types.h" 
#endif !EXEC_TYPES H 


#ifndef EXEC_PORTS_H 
#include "exec/ports.h" 
#endif !EXEC_PORTS H 


#ifndef LIBRARIES _DOS_H 
#include “libraries/dos.h" 
#endif !LIBRARIES_DOS_H 


struct WBStartup [{ 


struct Message sm_Message; /* a standard message structure */ 
struct MsgPort * sm_Process; /* the process descriptor for you */ 
BPTR sm_Segment ; /7* a descriptor for your code */ 

LONG sm_NumArgs ; /7* the number of elements in ArgList */ 
char * sm_ToolWindow; /* description of window */ 

struct WBArg * sm_ArgList ; 7* the arguments themselves */ 


yi 


struct WBArg [ 
BPTR wa_Lock; /* a lock descriptor */ 
BYTE * wa_Name; /* a string relative to that lock */ 


yi 


#endif /* WORKBENCH_STARTUP_H */ 








cs -d 








Sep 


WODMNDUBE WN 








19 20:29 1988 workbench/workbench.h Page 1 


#ifndef WORKBENCH_WORKBENCH_H 
#define WORKBENCH_WORKBENCH_H 


/* 
ak $Filename: workbench/workbench.h $ 

*e SRelease: 1.3 $ 

wk 

w* 

xk 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
x All Rights Reserved 

*/ 


#ifndef EXEC_TYPES H 
#include "exec/types.h" 
#endif !EXEC_TYPES_H 


#tifndef EXEC_NODES_H 
#include "exec/nodes.h" 
#endif !EXEC_NODES_H 


#ifndef EXEC_LISTS_H 
#include "exec/lists.h" 
#endif !EXEC_LISTS H 


#ifndef EXEC_TASKS H 
#include “exec/tasks:h" 
#endif !EXEC_TASKS H 


#ifndef INTUITION_INTUITION _H 
#include "intuition/intuition.h" 
#fendif ! INTUITION _INTUITION_H 


WBDISK 
WBDRAWER 
WBTOOL 
WBPROJECT 
WBGARBAGE 
WBDEVICE 
WBKICK 


#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 





SOUT WN} 


struct DrawerData [ 
struct NewWindow 
LONG 
LONG 


dd_NewWindow; 
dd_Currentx; 
dd@_Currenty; 


/* args to open window */ 
/* current x coordinate of origin */ 
/* current y coordinate of origin */ 


Ie 


/7* the amount of DrawerData actually written to disk */ 
#define DRAWERDATAFILESIZE (sizeof( struct DrawerData )) 


struct DiskObject { 


UWORD do_Magic; /* a magic number at the start of the file */ 
UWORD do_Version; /* a version number, so we can change it */ 
struct Gadget do_Gadget ; /* a copy of in core gadget */ 

UBYTE do_Type; 

char * do_DefaultTool; 

char ** do_ToolTypes; 

LONG do_CurrentX; 

LONG do_CurrentyY; 

struct DrawerData * do_DrawerData; 

char * do_ToolWindow; /* only applies to tools */ 

LONG do_StackSize; /* only applies to tools */ 


le 


#define WB_DISKMAGIC Oxe310 /* a magic number, not easily impersonated */ 
#define WB_DISKVERSION 1 /7* our current version number */ 


struct FreeList { 





19 20:29 1988 workbench/workbench.h Page 2 


WORD 
struct List 


f1_NumF ree; 
fl_MemList ; 
m7 


/* each message that comes into the WorkBenchPort must have a type field 


* in the preceeding short. These are the defines for this type 

*/ 

#define MTYPE_PSTD 1 /* a "standard Potion" message */ 
#define MTYPE_TOOLEXIT 2 /* exit message from our tools */ 
#define MTPYPE_DISKCHANGE 3 /* dos telling-us of a disk change */ 
#define MTYPE_TIMER 4 /* we got a timer tick */ 

#define MTYPE_CLOSEDOWN 5 /* <Sunimplemented> */ 

#define MTYPE_IOPROC 6 7* Sunimplemented> */ 
/* workbench does different complement modes for its gadgets. 

x It supports separate images, complement mode, and backfill mode. 

* The first two are identical to intuitions GADGIMAGE and GADGHCOMP. 

* backfill is similar to GADGHCOMP, but the region outside of the 

* image (which normally would be color three when complemented) 

* is flood-filled to color zero. 

* 

#define GADGBACKFILL 0x0001 


7* if an icon does not really live anywhere, set its current position 


* to here 

* 

#tdefine NO_ICON_ POSITION (0x80000000) 
#tendif /* WORKBENCH WORKBENCH_H */ 








Section E 


Assembly Include Files— ‘“‘.i”’ Files 


This section contains the 68000 assembly language include files from the operating sys- 
tem source code. Whenever the system software requires that a certain structure or con- 
stant be passed, it will be defined here. Each subsystem has its own include files. A 
quick example of include file usage is provided below. 


This section is for reference only. Similar include files generally come on disk with what- 
ever assembler you may choose to use with the Amiga. 





WARNING: Not all information in this section should be used in your programs. The 
include files contain definitions for some structure members and constants that are not 
supported for use by programs. In some cases these definitions are marked as private, in 
other cases they are not distinguished. Following the guidelines presented by Commodore- 
Amiga is the best way to insure compatibility with future system software releases. 





* 


* A quick example of using an assembly language include file. The 
constant "RETURN FAIL" is not defined in this example, instead the 


* 


* value is pulled from the "libraries/dos.i" include file. This is 
* equivalent to: 

* 

* moveq #20,d0 

x rts 

* 


INCLUDE "libraries/dos.i" 


moveq #RETURN_FAIL,DO 
rts 








(Nov 28 18:28 1988 TOC Page 1 


TABLE OF CONTENTS 


devices: E-1 

audio.i conunit.i 
bootblock.i gameport.i 
clipboard.i hardblocks.i 
console.i input .i 

exec: E-22 

ables.i exec_lib.i 
alerts.i execbase.i 
devices.i execname.i 
errors .i initializers.i 
exec.i interrupts.i 
graphics: E-40 

clip.i gels.i 
copper.i gfx.i 
display.i gfxbase.i 
hardware: E-49 

adkbits.i cla.i 

blit.i custom. i 
intuition: E-54 
intuition.i intuitionbase.i 
libraries: E-66 
configregs.i dos.i ~ 
configvars.i dos_lib.i 
diskfont.i- dosextens.i 
resources: E-78 

cia.i filesysres.i 
disk.i mathresource.i 
workbench: E-82 

icon.i startup.i 


inputevent.i 
keyboard.i 
keymap.i 
narrator.i 


io.i 
libraries.i 
lists.i 
memory. i 
nodes .i 


layers.i 
rastport.i 
regions.i 


dmabits.i 
intbits.i 


preferences .i 


expansion. i 
expansionbase.i 
filehandler.i 


misc.i 
potgo.i 


workbench. i 





parallel.i 
printer.i 
prtbase.i 
prtgfx.i 


ports.i 
resident.i 
semaphores. i 
strings.i 
tasks.i 


sprite.i 
text oi 
view.i 


screens.i 


mathlibrary.i 
romboot._base.i 
translator.i 





scesidisk.i 
serial.i 
timer.i 
trackdisk.i 


types.i 





Nov 28 18:28 1988 TOC Page 2 

















28 17:07 1988 devices/audio.i Page 1 Sep 28 17:07 1988 devices/bootblock.i Page 1 








1 IFND DEVICES _AUDIO_T 1 IFND DEVICES BOOTBLOCK TI 
2 DEVICES AUDIO I SET i 2 DEVICES_BOOTBLOCK_I SET 1 
3 Kk 3 a* 
4 x $Filename: devices/audio.i $ 4 ** $Filename: devices/bootblock.i $ 
5 ** $Release: 1.3 $ 5 ** $Release: 1.3 $ 
6 ** 6 ak 
7 ** 7 ** BootBlock definition: 
8 xk 8 Kk 
g ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. Q *k (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 
LL ** lL ** 
12 12 
13 IFND EXEC_IO_T 13 STRUCTURE BB,O 
14 INCLUDE "exec/io.i" 14 STRUCT BB_ID,4 * 4 character identifier 
i5 ENDC i5 LONG BB_CHKSUM * boot block checksum. (balance) 
16 16 LONG BB_DOSBLOCK * reserved for DOS patch 
17 AUDIONAME MACRO 17 LABEL BB_ENTRY * bootstrap entry point 
18 DC.B ‘audio.device',0 18 LABEL  BB_SIZE 
19 ENDM 19 
20 20 BOOTSECTS equ 2 * 1K bootstrap 
21 ADHARD_CHANNELS EQU 4 21 
22 22 BBID_DOS macro * something that is bootable 
23 ADALLOC_MINPREC EQU -128 23 de.b 'pos' ,0 
24 ADALLOC_MAXPREC EQU 127 24 endm 
25 25 
26 ADCMD FREE EQU CMD_NONSTD+0 26 BBID_KICK macro * firmware image disk 
27 ADCMD SETPREC EQU CMD_NONSTD+1 27 de.b 'KICK' 
28 ADCMD_FINISH EQU CMD_NONSTD+2 28 endm 
29 ADCMD_PERVOL EQU CMD_NONSTD+3 29 
30 ADCMD_LOCK EQU CMD_NONSTD+4 30 
31 ADCMD_WAITCYCLE EQU CMD_NONSTD+5 31 BBNAME_DOS EQU (('D'<<24)!('O'<K16) 1 ('S'<<8)) 
32 ADCMDB_NOUNIT EQU 5 32 BBNAME KICK EQU (CK S624) CTE KK16) EC 'C' KKB) IC 'K')) 
33 ADCMDF_NOUNIT EQU 1<<5 33 
34 ADCMD ALLOCATE EQU ADCMDF_NOUNIT+0 34 ENDC 3 DEVICES BOOTBLOCK_T 
35 
36 ADIOB_PERVOL EQU 4 
37 ADIOF_PERVOL EQU 1<<4 
38 ADIOB_SYNCCYCLE EQU 5 
39 ADIOF_SYNCCYCLE EQU 1<<5 
40 ADIOB_NOWAIT EQU 6 
4] ADIOF_NOWAIT EQU 1<<6 
42 ADIOB_WRITEMESSAGE EQU 7 
43 ADIOF_WRITEMESSAGE EQU 1<<7 
44 
45 ADIOERR_NOALLOCATION EQU -10 
46 ADIOERR_ALLOCFAILED EQU -ll 
47 ADIOERR_CHANNELSTOLEN EQU -12 
48 
49 STRUCTURE IOAudio, IO_SIZE 
50 WORD ioa_Allockey 
51 APTR ioa_Data 
52 ULONG ioa_Length 
53 UWORD ioa_Period 
54 UWORD = ioa_Volume 
55 . UWORD ioa_Cycles 
56 STRUCT ioa_WriteMsg,MN_SIZE 
57 LABEL ioa_SIZEOF 
58 
59 ENDC ; DEVICES AUDIO_I 











sep 


WONKDUPWNE 


28 17:07 1988 devices/clipboard.i Page 1 


IFND DEVICES_CLIPBOARD_I 
DEVICES_CLIPBOARD_I SET 1 
** 
ee $Filename: devices/clipboard.i $ 
xe $Release: 1.3 $ 
kk 
xe clipboard device command definitions 
xk 
x* (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 
ak 


IFND EXEC_NODES_I 
INCLUDE "exec/nodes .i 
ENDC 

IFND EXEC_LISTS_T 
INCLUDE "exec/lists.i" 
ENDC 

IEND EXEC_PORTS_I 
INCLUDE "exec/ports.i 
ENDC 

TEND EXEC_IO_I 
INCLUDE "“exec/io.i" 
ENDC 


DEVINIT 


DEVCMD CBD_POST 
DEVCMD CBD_CURRENTREADID 
DEVCMD CBD_CURRENTWRITEID 


CBERR_OBSOLETEID EQU 1 


STRUCTURE ClipboardUnitPartial ,0 

STRUCT cu_Node,LN_SIZE; ; list of units 

ULONG  cu_UnitNum; ; unit number for this unit 
the remaining unit data is private to the device 


, 


STRUCTURE I0ClipReg,0 
sTRUCT io Message,MN_SIZE 
APTR 1lo_Device ; device node pointer 
APTR io_Unit unit (driver private) 
UWORD = io_Command device command 
UBYTE io_Flags including QUICK and SATISFY 
BYTE io_Error error or warning num 
ULONG io _Actual number of bytes transferred 
ULONG io_Length number of bytes requested 
APTR io_Data either clip stream or post port 
ULONG io _Offset offset in clip stream 
LONG io_ClipID ordinal clip identifier 
LABEL iocr_SIZEOF 


PRIMARY_CLIP EQU 0 ; primary clip unit 
STRUCTURE SatisfyMsg,0 
STRUCT sm _Msg,MN_SIZE ; the length will be 6 
UWORD = sm_Unit ; which clip unit this is 


LONG sm_ClipID ; the clip identifier of the post 


LABEL satisfyMsg_SIZEOF 


ENDC ; DEVICES_CLIPBOARD_I 





1 
2 
3 
4 
5 
6 
7 
8 
9 








28 17:07 1988 devices/console.i Page 1 


IFND DEVICES _CONSOLE_I 
DEVICES _CONSOLE_I SET 1 
nk 
ad $Filename: devices/console.i $ 
xe $Release: 1.3 $ 
kk 
«x Console device command definitions 
ke 
ak (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 
K* 
IFND EXEC_IO I 
INCLUDE "“exec/io.i" 
ENDC 
xxkkxkk Console commands ****x*x** 
DEVINIT 
DEVCMD CD_ASKKEYMAP 
DEVCMD CD_SETKEYMAP 
DEVCMD CD_ASKDEFAULTKEYMAP 
DEVCMD CD_SETDEFAULTKEYMAP 
xxx*ekx*x SGR parameters 
SGR_PRIMARY EQU 0 
SGR_BOLD EQU 1 
SGR_ITALIC EQU 3 
SGR_UNDERSCORE EQU 4 
SGR_NEGATIVE ~  EQU 7 
* these names refer to the ANSI standard, not the implementation 
SGR_BLACK EQU 30 
SGR_RED EQU 31 
SGR_GREEN EQU 32 
SGR_YELLOW RQU 33 
SGR_BLUE EQU 34 
SGR_MAGENTA EQU 35 
SGR_CYAN EQU 36 
SGR_WHITE EQU 37 
SGR_DEFAULT EQU 39 
SGR_BLACKBG EQU 40 
SGR_REDBG EQU 41 
SGR_GREENBG EQU 42 
SGR_YELLOWBG EQU 43 
SGR_BLUEBG EQU 44 
SGR_MAGENTABG EQU 45 
SGR_CYANBG EQU 46 
SGR_WHITEBG EQU 47 
SGR_DEFAULTBG EQU 49 
x these names refer to the implementation, they are the preferred 
x names for use with the Amiga console device. 
SGR_CLRO EQU 30 
SGR_CLR1 EQU. 31 
SGR_CLR2 EQU 32 
SGR_CLR3 EQU 33 
SGR_CLR4 EQU 34 
SGR_CLR5 EQU 35 
SGR_CLR6 EQU 36 
SGR_CLR7 EQU 37 
SGR_CLROBG EQU 40 
SGR_CLR1BG EQU 41 
SGR_CLR2BG EQU 42 
SGR_CLR3BG EQU 43 























28 17:07 1988 devices/console.i Page 2 
SGR_CLR4BG EQU 44 
SGR_CLR5BG EQU 45 
SGR_CLR6BG EQU A6 
SGR_CLR7BG EQU 47 
HRKKKK DSR parameters 
DSR_CPR EQU 6 
KAKKKK CTC parameters 
CTC_HSETTAB EQU 0 
CTC_HCLRTAB EQU 2 
CTC_HCLRTABSALL EQU 5 
RRKKEK TBC parameters 
TBC_HCLRTAB EQU 0 
TBC_HCLRTABSALL EQU 3 
RRKKKK SM and RM parameters 
M_LNM EQU 20 ; linefeed newline mode 
M_ASM MACRO 
p.B '>1' ; auto scroll mode 
ENDM 
M_AWM MACRO 
DC.B. '?7' ; auto wrap mode 
ENDM 
ENDC ; DEVICES _CONSOLE_I 








Sep 


WODNDUFWNE 


28 17:07 1988 devices/conunit.i Page 1 
IFND DEVICES _CONUNIT_I 
DEVICES_CONUNIT_I SET 1 
Kx 
*K $SFilename: devices/conunit.i $ 
ae $Release: 1.3 $ 
KK 
xe Console device unit definitions 
K* 
xx (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 
K* 
IFND EXEC_PORTS_I 
INCLUDE 'exec/ports.i" 
ENDC 
IFND DEVICES _CONSOLE_T 
INCLUDE "devices/console. i" 
ENDC 
IFND DEVICES _KEYMAP_ I 
INCLUDE "devices/keymap.i" 
ENDC 
IFND DEVICES_INPUTEVENT_I 
INCLUDE '"devices/inputevent.i" 
ENDC 
PMB_ASM EQU) M_LNM+1 ; internal storage bit for AS flag 
PMB_ AWM EQU PMB_ASM+1 ; internal storage bit for AW flag 
MAXTABS EQU 80 
STRUCTURE ConUnit,MP_SIZE 
jcc read only variables 
APTR cu_Window ; intuition window bound to this unit 
WORD cu_XCP ; character position 
WORD cu_YCP 
WORD cu_XMax ; Max character position 
WORD cu_YMax 
WORD cu_XRSize ; character raster size 
WORD cu_YRSize 
WORD cu_XROrigin ; raster origin 
WORD cu_YROrigin 
WORD cu_XRExtant ; raster maxima 
WORD cu_YRExtant 
WORD cu_XMinShrink ; smallest area intact. from resize process 
WORD cu_YMinShrink 
WORD cu_XCCP ; cursor position 
WORD cu_YCCP 
ccc read/write variables (writes must must be protected) 
wlll storage for AskKeyMap and SetKeyMap 
STRUCT cu_KeyMapStruct ,km_SIZEOF 
; 77 tab stops 
STRUCT  cu_TabStops,2*MAXTABS ; O at start, Oxffff at end of list 
poco console rastport attributes 
BYTE cu_Mask ; these must appear as in RastPort 
BYTE cu_FgPen ; 
BYTE cu_BgPen ; 
BYTE cu_AOLPen i + 
BYTE cu_DrawMode ; these. must appear as in RastPort 
BYTE cu_AreaPtSz i + 
APTR cu_AreaPtrn 7; cursor area pattern 
STRUCT  cu_Minterms,8 ; console minterms 
APTR cu_Font ; 
UBYTE cu_AlgoStyle ; these must appear as in RastPort 
UBYTE cu_TxFlags i + 














Sep 


28 17:07 1988 devices/conunit.i Page 2 


UWORD cu_TxHeight ; these must appear as in RastPort 
UWORD cu_TxWidth ; 

UWORD cu_TxBaseline i 

UWORD cu_TxSpacing ; + 

po console MODES and RAW EVENTS switches 

STRUCT  cu_Modes, <(PMB_AWM+7) /8> j; one bit per mode 


STRUCT cu_RawEvents , <( IECLASS_MAX+7) /8> 


prc ensure the ConsUnit structure is even 
ODDEVEN EQU  ((PMB_AWM+7)/8)+( (IECLASS_MAX+7)/8) 
IFNE ODDEVEN-((ODDEVEN/2) *2) 
UBYTE cu_pad 
ENDC 


LABEL ConUnit_SIZEOF 


ENDC ; DEVICES_CONUNIT_I 








Sep 


ODNIAUPWN 


28 17:07 1988 devices/gameport.i Page 1 


IFND DEVICES_GAMEPORT_I 


DEVICES_GAMEPORT_I SET 

RK 

x $Filename: devices/gameport.i $ 

ae SRelease: 1.3 $ 

Kk 

xe Game Port device command definitions 

xk 

** (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
sd All Rights Reserved 


xk 


IFND EXEC_IO_ I 
INCLUDE "exec/io.i" 
ENDC 


axkeeke GamePort commands ******* 
DEVINIT 


DEVCMD GPD_READEVENT 
DEVCMD GPD_ASKCTYPE 
DEVCMD GPD_SETCTYPE 
DEVCMD GPD_ASKTRIGGER 
DEVCMD GPD_SETTRIGGER 


axkekKK GamePort structures *****k* 


* gpt_Keys 
BITDEF GPT , DOWNKEYS , 0 
BITDEF GPT, UPKEYS, 1 


STRUCTURE GamePortTrigger ,0 
UWORD gpt_Keys 
UWORD = gpt_Timeout 
UWORD = gpt._XDelta 
UWORD gpt_YDelta 
LABEL gpt_SIZEOF 


j;key transition triggers 

;time trigger (vertical blank units) 
;X distance trigger 

7Y distance trigger 


xxkkkk* Controller Types ****** 
GPCT_ALLOCATED EQU 1 
GPCT_NOCONTROLLER EQU 


; allocated by another user 


GPCT_RELJOYSTICK EQU - 


0 
GPCT_MOUSE EQU) 1 
2 
GPCT_ABSJOYSTICK EQU 3 


KKAKKKEKK Errors eK EK 
GPDERR_SETCTYPE EQU) 1 ; this controller not valid at this time 


ENDC ; DEVICES_GAMEPORT_I 

















28 17:07 1988 devices/hardblocks.i Page 1 





Sep 28 17:07 1988 devices/hardblocks.i Page 2 


1 IFND DEVICES_HARDBLOCKS_T 70 STRUCT rdb_Reserved3 ,5*4 
2 DEVICES_HARDBLOCKS_I SET 1 71 ; logical drive characteristics 
3 xe 72 ULONG = rdb_RDBBlocksLo ; low block of range reserved for hardblocks 
4 kk $Filename: devices/hardblocks.i $ 73 ULONG  rdb_RDBBlocksHi ; high block of range for these hardblocks 
5 ** $Revision: 1.0 $ 74 ULONG _ rdb_LoCylinder ; low cylinder of partitionable disk area 
6 ** $Date: 88/07/11 15:32:58 $ 75 ULONG rdb HiCylinder ; high cylinder of partitionable data area 
7 xe 76 ULONG rdb_CylBlocks ; number of blocks available per cylinder 
8 ** File System identifier blocks for hard disks 77 ULONG rdb AutoParkSeconds ; zero for no auto park 
Q xk 78 STRUCT rdb_ Reserved4 ,2*4 
10 ** (C) Copyright 1988 Commodore~Amiga, Inc. 79 ; Grive identification 
ll ** All Rights Reserved 80 STRUCT xrdb_DiskVendor,8 
12 ** 81 STRUCT rdb_DiskProduct,16 
13 82 STRUCT rdb_DiskRevision,4 
YLT 83 STRUCT rdb_ControllerVendor,8 
15 ; 84 STRUCT rdb_ControllerProduct ,16 
16 ; This file describes blocks of data that exist on a hard disk 85 STRUCT rdb ControllerRevision,4 
“17; to describe that disk. They are not generically accessable to 86 STRUCT rdb Reserved5,10*4 
18 ; the user as they do not appear on any Dos drive. The blocks 87 
19 ; are tagged with a unique identifier, checksummed, and linked 88 LABEL RigidDiskBlock_SIZEOF 
20 ; together. The root of these blocks is the RigidDiskBlock. 89 
21 . 90 IDNAME_RIGIDDISK EQU CCIR' £24) 1 ('D' S16) 1 ('S' KKB) I CIK')) 
22 ; The RigidDiskBlock must exist on the disk within the first 91 
23 ; RDB LOCATION LIMIT blocks. This inhibits the use of the zero 92 RDB_LOCATION_LIMIT EQU 16 
24 ; cylinder in an AmigaboOS partition: although it is strictly 93 
25 ; possible to store the RigidDiskBlock data in the reserved 94 BITDEF RDBF,LAST,0O ; no disks exist to be configured after 
26 ; area of a partition, this practice is discouraged since the 95 ; this one on this controller 
27 ; reserved blocks of a partition are overwritten by "Format", 96 BITDEF RDBF,LASTLUN,1 ; no LUNs exist to be configured greater 
28 ; "Install", “DiskCopy", etc. The recommended disk layout, 97 j than this one at this SCSI Target ID 
29 ; then, is to use the first cylinder(s) to store all the drive 98 BITDEF RDBF,LASTTID,2 ; no Target IDs exist to be configured 
30 ; data specified by these blocks: i.e. partition descriptions, 99 ; greater than this one on this SCSI bus 
31 ; file system load images, drive bad block maps, spare blocks, 100 BITDEF RDBF,NORESELECT , 3 ; don't bother trying to perform reselection 
32 ; etc. 101 ; when talking to this drive 
33; 102 BITDEF RDBF,DISKID,4 ; rdb_Disk... identification valid 
34 ; Though only 512 byte blocks are currently supported by the 103 BITDEF -RDBF,CTRLRID,5 ; rdb_Controller... identification valid 
35 ; file system, this proposal tries to be forward-looking by 104 
36 ; making the block size explicit, and by using only the first 105 
37 ; 256 bytes for all blocks but the LoadSeg data. 106 ;---------------- ++ - - 
38 5 107 STRUCTURE BadBlockEntry , 0 
BQ gm a I 108 ULONG  bbe_BadBlock ; block number of bad block 
40 109 ULONG bbe_GoodBlock ; block number of replacement block 
4l ; 110 LABEL BadBlockEntry_SIZEOF 
42; NOTE dil 
43 ; optional block addresses below contain $ffffffff to indicate 112 STRUCTURE BadBlockBlock , 0 
44 ; a NULL address : 113 ULONG  bbb_ID ; 4 character identifier 
45 ; 114 ULONG bbb_SummedLongs ; size of this checksummed structure 
46 STRUCTURE RigidDiskBlock,0 115 LONG bbb_ChkSum ; block checksum (longword sum to zero} 
47 ULONG rdb_ID ; 4 character identifier 116 ULONG bbb HostID ; SCSI Target ID of host 
48 ULONG  rdb_ SummedLongs ; size of this checksummed structure 117 ULONG = bbb _ Next j; block number of the next BadBlockBlock 
49 LONG rdb_ChkSum ; block checksum (longword sum to zero) 118 ULONG bbb Reserved 
50 ULONG  rdb HostID ; SCSI Target. ID of host 119 STRUCT bbb_BlockPairs,61*BadBlockEntry_SIZEOF ; bad block entry pairs 
51 ULONG  rdb_BlockBytes ; size of disk blocks 120 ; note 61 assumes 512 byte blocks 
52 ULONG rdb Flags ; see below for defines 121 ; there is no BadBlockBlock_SIZEOF: try rdb_BlockBytes 
53 ; block list heads 122 
54 ULONG rdb_BadBlockList ; optional bad block list 123 IDNAME_BADBLOCK EQU (('B' S424) 1C°A' C416) 1 ('D' £8) 1('°B')) 
55 ULONG rdb PartitionList ; optional first partition block 124 
56 ULONG rdb_ FileSysHeaderList ; optional fule system header block Lp 
57 ULONG rdb DrivelInit ; optional drive-specific init code 126 STRUCTURE PartitionBlock,0 
58° ~ ; DriveInit(lun,rdb,ior): "C" stk & d0/a0/al 127 ULONG pb_ID ; 4 character identifier 
59 STRUCT rdb_Reserved1,6*4 ; set to $ffffffff 128 ULONG pb_SummedLongs ; Size of this checksummed structure 
60 ; physical drive characteristics 129 LONG pb_ChkSum i block checksum (longword sum to zero) 
61 ULONG rdb Cylinders ; number of drive cylinders 130 ULONG pb_HostID ; SCSI Target ID of host 
62 ULONG rdb_Sectors ; sectors per track 131 ULONG pb Next ; block number of the next PartitionBlock 
63 ULONG rdb Heads ; number of drive heads 132 ULONG pb _ Flags ; see below for defines 
64 ULONG  rdb_Interleave ; interleave 133 STRUCT pb Reservedl ,2*4 
65 ULONG  rdb Park ; landing zone cylinder 134 ULONG pb DevFlags ; preferred flags for OpenDevice 
66 STRUCT rdb_ Reserved2,3*4 135 STRUCT pb_DriveName , 32 ; preferred DOS device name: BSTR form 
67 ULONG = rdb_WritePreComp ; starting cylinder: write precompensation 136 ; (not used if this name is in use) 
68 ULONG rdb_ReducedWrite ; starting cylinder: reduced write current 137 STRUCT pb_Reserved2,15*4 ; filler to 32 longwords 
69 ULONG rdb_StepRate ; drive step rate 138 STRUCT pb Environment,17*4 ; environment vector for this partition 














Sep 28 17:07 1988 devices/hardblocks.i Page. 3 Sep 28 17:07 1988 devices/input.i Page 1 








STRUCT pb FReserved,15*4 ; reserved for future environment vector 1 IFND DEVICES_INPUT_I 
LABEL PartitionBlock_SIZEOF 2 DEVICES_INPUT_I SET 1 
: 3 ex 
IDNAME_PARTI'TION EQU (CT P'KK24)1('A'KK16) 1 (RI CKB) ECT) 4 xs $Filename: devices/input.i $ 
5 ** $Release: 1.3 $ 
BITDEF PBF,BOOTABLE,0 ; this partition is intended to be bootable 6 ** — 
a (expected directories and files exist) 7 ** input device command definitions 
BITDEF PBE,NOMOUNT,1 ; do not mount this partition (e.g. manually 8 K* , . 
; mounted, but space reserved here) 9 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
J ll ** 
STRUCTURE PileSysHeaderBlock , 0 12 
ULONG fhb_ID ; 4 character identifier 13 IFND EXEC_I0_I 
ULONG fhb_SummedLongs ; size of this checksummed structure 14 INCLUDE “exec/io.i" 
LONG fhb_ChkSum ; block checksum (longword sum to zero) 15 ENDC 
ULONG = fhb_HostID ; SCSI Target ID of host 16 
ULONG = fhb_Next ; block number of the next FileSysHeaderBlock 7 DEVINIT 
ULONG fhb_Flags ; see below for defines 18 
STRUCT fhb Reserved] ,2*4 19 DEVCMD IND_ADDHANDLER 
ULONG fhb_DosType ; file system description: match this with 20 DEVCMD IND_REMHANDLER 
; partition environment's DE_DOSTYPE entry val DEVCMD IND_WRITEEVENT 
ULONG fhb_Version ; release version of this code 22 DEVCMD IND_SETTHRESH 
ULONG fhb_PatchFlags ; bits set for those of the following that 23 DEVCMD IND_SETPERIOD 
; need to be substituted into a standard 24 DEVCMD IND_SETMPORT 
device node for this file system: e.g. 25 DEVCMD IND_SETMTYPE 
$180 to substitute SegList & GlobalVec 26 DEVCMD IND_SETMTRIG 
ULONG fhb_Type ; device node type: zero 27 
ULONG fhb_Task ; standard dos "task" field: zero 28 ENDC ; DEVICES_INPUT_I 


ULONG fhb_Handler ; filename to loadseg: zero placeholder 
ULONG  fhb_StackSize ; stacksize to use when starting task 
LONG fhb Priority ; task priority when starting task 
LONG fhb_Startup ; startup msg: zero placeholder 
LONG fhb_SegListBlocks ; first of linked list of LoadSegBlocks: 
; note that this entry requires some 
processing before substitution 
; BCPL global vector when starting task 
(those reserved by PatchFlags) 


LONG fhb_GlobalVec 

STRUCT fhb_Reserved2,23*4 
STRUCT fhb_Reserved3,21*4 
LABEL FileSysHeader_SIZEOF 


; 
i 
; 
i 
i 
i 
i 
i 
; 
ULONG = fhb_Lock ; not used for devices: zero 
i 
i 
i 
i 
i 
; 
; 
i 
i 


IDNAME_ FILESYSHEADER EQU (CTP! <€24)!('S'<616) 1 ('H'<<B) 1('D')) 


STRUCTURE LoadSegBlock ,0 
ULONG  Isb_ID 
ULONG isb_SummedLongs 
LONG isb_Chksum 


4 character identifier 

; Size of this checksummed structure 
block checksum (longword sum to zero) 
ULONG isb_HostID SCSI Target ID of host 

ULONG = lsb_Next ; block number of the next FileSysBlock 
STRUCT lsb_LoadData,123*4 ; data for "loadseg" 

; note 123 assumes 512 byte blocks 

; there is no LoadSegBlock_SIZEOF: try rdb_BlockBytes 


IDNAME_LOADSEG EQU (('L'<<24)1('S'<K16) 1 ('B'<<B) 1('G')) 


ENDC 









































(Sep 28 17:08 1988 devices/inputevent.i Page 1 Sep 28 17:08 1988 devices/inputevent.i Page 2 

1 IFND DEVICES_INPUTEVENT_I 70 IECODE_COQ_FIRST EQU $00 

2 DEVICES _INPUTEVENT_I SET 1 71 IECODE_CO_ LAST EQU S1F 

3 x 72 IECODE_ASCII_FIRST EQU $20 

4 *x SFilename: devices/inputevent.i $ 73 IECODE_ASCII_LAST EQU STE 

5 ** $SRelease: 1.3 $ 74 IECODE_ASCII_DEL EQU S7F 

6 ** 75 IECODE_Cl FIRST EQU $80 

7 ** input event definitions 76 JECODE_Cl_LAST EQU SOF 

B ** 77 IECODE_ LATIN] FIRST FOU SAO 

Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 TECODE_LATIN]_LAST EQU SFF 

10 ** All Rights Reserved 79 

11 ** 80 * JECLASS_RAWMOUSE 

12 81 IECODE_LBUTTON EQU $68 ; also uses IECODE UP PREFIX 
13 IFND DEVICES _TIMER_I 82 IECODE_RBUTTON EQU $69 =; 

14 INCLUDE "devices/timer.i" 83 IECODE_MBUTTON EOQU S6A ; 

15 ENDC 84 IECODE_NOBUTTON EQU SFF 

16 85 

17 *-----~ COTS CIES rr a 86 * TECLASS EVENT 

18 87 IECODE_NEWACTIVE EQU) $01 ; active input window changed 
19 * --= InputEvent.ie_Class ——— 88 
20 * A NOP input event 89 * JECLASS REQUESTER Codes 
21 IECLASS NULL EQU $00 90 * REQSET is broadcast when the first Requester (not subsequent ones) opens 
22 * A raw keycode from the keyboard device 91 * in the Window 

23 IECLASS RAWKEY EQU SOL 92 IECODE_REQSET EQU sol 
24 * A raw mouse report from the game port device 93 * REQCLEAR is broadcast when the last Requester clears out of the Window 
25 L[ECLASS RAWMOUSE EQU $02 94 IECODE_REQCLEAR EQU $00 

26 * A private console event 95 

27 IECLASS_EVENT EQU $03 96 
28 * A Pointer Position report 97 * -—-- InputEvent.ie Qualifier —-—- 
29 IECLASS_POINTERPOS EQU $04 98 IEQUALIFIER_LSHIFT EQU $0001 

30 * A timer event 99 IJEQUALIFIERB_LSHIFT EQU) O 

31 IECLASS TIMER EQU $06 100 IEQUALIFIER_RSHIFT EQU $0002 

32 * select button pressed down over a Gadget (address in ie_EventAddress) 101 ITEQUALIFIERB_RSHIFT FOU) OL 

33 IECLASS_GADGETDOWN EQU $07 102 IEQUALIFIER_CAPSLOCK EQU $0004 

34 * select button released over the same Gadget (address in ie _EventAddress) 103 IEBQUALIFIERB_CAPSLOCK EFQU 2 

35 IECLASS GADGETUP EQU $08 104 TEQUALIFIER_CONTROL EQU $0008 

36 * some Requester activity has taken place. See Codes REQCLEAR and REQSET 105 IEQUALIFIERB_CONTROL EQU) 3 

37 IECLASS_REQUESTER EQU $09 106 IRQUALIFIER_LALT EQU $0010 

38 * this is a Menu Number transmission (Menu number is in ie Code) 107 TEQUALIFIERB_LALT EQU 4 

39 IECLASS_MENULIST EQU SOA 108 IJEQUALIFIER_RALT EQU $0020 

40 * User has selected the active Window's Close Gadget 109 IEQUALIFIERB_RALT EQU 5 

4] IECLASS_CLOSEWINDOW EQU SOB 110 IBQUALIFIER_LCOMMAND EQU $0040 

42 * this Window has a new size lil IEQUALIFIERB_LCOMMAND EQU 6 

43 IECLASS_SIZEWINDOW EQU $0c 112 IBQUALIFIER_RCOMMAND EQU $0080 

44 * the Window pointed to by ie_EventAddress needs to be refreshed 113 IEQUALIFIERB_RCOMMAND EQU 7 

45 IECLASS REFRESHWINDOW EQU SOD 114 IEQUALIFIER_NUMERICPAD EQU $0100 

46 * new preferences are available 115 ITEQUALIFIERB NUMERICPAD EQU 8 

47 IBECLASS NEWPREFS EQU SOE 116 IEQUALIFIER_REPEAT EQU $0200 

48 * the disk has been removed 117 IEQUALIFIERB_REPEAT EQU 9 

49 IECLASS DISKREMOVED EQU SOF 118 IEQUALIFIER_INTERRUPT EQU $0400 

50 * the disk has been inserted 119 IEQUALIFIERB_INTERRUPT EQU 10 

51 IECLASS_DISKINSERTED EQU $10 120 IEQUALIFIER MULTIBROADCAST EQU $0800 

52 * the window is about to be been made active 121 IEQUALIFIERB_MULTIBROADCAST EQU li 

53 IECLASS_ACTIVEWINDOW EQU $11 122 IEQUALIFIER_MIDBUTTON EQU $1000 

54 * the window is about to be made inactive 123 IEQUALIFIERB_ MIDBUTTON EQU 12 

55 IECLASS INACTIVEWINDOW  EQU $12 124 IEQUALIFIER_RBUTTON EQU $2000 

56 ~ 125 IEQUALIFIERB_RBUTTON EQU 13 

57 * the last class 126 IEQUALIFIER_LEFTBUTTON EQU $4000 

58 IECLASS MAX EQU $12 127 IEQUALIFIERB_LEFTBUTTON EQU 14 

59 ~ 128 IEQUALIFIER_RELATIVEMOUSE EQU $8000 

60 * -—-- InputEvent.ie Code -—— 129 JEQUALIFIERB_RELATIVEMOUSE EQU 15 

61 * IECLASS RAWKEY 130 

62 IECODE_UP_PREFIX EQU = $80 131 *----—- InputEvent —------~-—~-----------~---------- +--+ ------------- 
63 IECODEB_UP_PREFIX EQU 7 132 

64 IECODE_KEY CODE FIRST EQU $00 133 STRUCTURE InputEvent,0 

65 IECODE_KEY CODE LAST EQU $77 134 APTR ie NextEvent ; the chronologically next event 
66 IECODE_COMM_CODE FIRST EQU $78 135 UBYTE ie_Class ; the input. event class 

67 ITECODE_COMM CODE LAST EQU S7F 136 UBYTE ie_SubClass 7 Optional subclass of the class 
68 _ a 137 UWORD ie_Code ; the input event code 

69 * JECLASS ANSI 138 UWORD ie Qualifier ; qualifiers in effect for the event 





139 
140 
141 
142 
143 
144 
145 











Sep 28 17:08 1988 devices/inputevent.i Page 3 Sep 28 17:08 1988 devices/keyboard.i Page 1 
LABEL ie_EventAddress ; a pointer parameter for an event 1 IFND DEVICES _KEYBOARD_I 
WORD ie_X ; the pointer position for the event, 2 DEVICES_KEYBOARD_I SET 
WORD ie_Y i usually in canvas relative coords 3 ** 
STRUCT ie TimeStamp,TV_SIZE ; the system tick at the event 4 ** $Filename: devices/keyboard.i $ 
LABEL ie_SIZEOF 5 ** SRelease: 1.3 $ 
6 ** 
ENDC ; DEVICES_INPUTEVENT_I 7 ** Keyboard device command definitions 
8 ** 
Q xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
Ll ** 
12 
13 IFND EXEC_IO_I 
14 INCLUDE "“exec/io.i" 
15 ENDC 
16 
17 DEVINIT 
18 
19 DEVCMD KBD_READEVENT 
20 DEVCMD KBD_READMATRIX 
al DEVCMD KBD_ADDRESETHANDLER 
22 DEVCMD KBD_REMRESETHANDLER 
23 DEVCMD KBD_RESETHANDLERDONE 
24 
25 ENDC 7; DEVICES _KEYBOARD_I 















oT - a4 









































kk 
wk 
kk 
tk 
aK 
tk 
a*k 
10 ** 
LL ** 


WONAO EWN 








APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 


IFND 


DEVICES_KEYMAP_I 


$Filename: devices/keymap.i $ 
$Release: 1.3 $ 


keymap.resource definitions and console.device key map definitions 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND 
INCLUDE 
ENDC 
IFND 
INCLUDE 
ENDC 


28 17:08 1988 devices/keymap.i Page 1 


DEVICES KEYMAP_I 70 
SET 1 71 ENDC ; DEVICES_KEYMAP_I 


EXEC_NODES_I 
"Nexec/nodes. i" 


EXEC. LISTS_I 
"“exec/lists.i" 


20 STRUCTURE KeyMap,0 
km_LoKeyMapTypes 


km_LoKeyMap 


km_LoCapsable 
km_LoRepeatable 
km_HikeyMapTypes 


km_HikeyMap 


km_HiCapsable 
km_HiRepeatable 


LABEL km_SIZEOF 


STR 
STR 


31 STRUCTURE 


KeyMapNode , 0 
UCT kn_Node,LN_SIZE ; including name of keymap 
UCT kn_KeyMap,km_SIZEOF 


LABEL kn_SIZEOF 


37 “ STRUCTURE 


STR 


the structure of keymap. resource 
KeyMapResource , 0 

STRUCT kr_Node,LN_SIZE 

UCT kr_List,LH_SIZE ; a list of KeyMapNodes 


LABEL kr _SIZEOF 


43 KCB_NOP 
44 KCF_NOP 


EQU 
EQU 


46 KC_NOQUAL QU 
47 KC_VANILLA EQU 
48 KCB SHIFT QU 
49 KCF SHIFT EQU 
50 KCB_ALT EQU 
51 KCF_ALT EQU 
52 KCB_CONTROL EQU 
53 KCF CONTROL EQU 
54 KCB_DOWNUP EQU 
55 KCF_DOWNUP EQU 
56 KCB_DEAD QU 
57 KCF DEAD QU 


59 KCB_STRING EQU 
60 KCF_STRING EQU 


Dead Prefix Bytes 
63 DPB_MOD 
64 DPF_MOD 
65 DPB_DEAD 
66 DPF_DEAD 


DP_2DINDEXMASK 
DP_2DFACSHIFT 


7 
$80 


0 
7 
0 
$01 
1 
$02 
2 
$04 
3 
$08 
5 
$20 


6 
$40 


EQU 
EQU 
EQU 
EQU 


EQU 
EQU 


Sep 28 17:08 1988 devices/keymap.i Page 2 












; note that SHIFT+ALT+CTRL is VANILLA 


; May be dead or modified by dead key: 
i use dead prefix bytes 


0 
$ol 
3 
$08 


SOF ; mask for index for lst of two dead keys 
; shift for factor for lst of two dead keys 


Tl -a 





28 17:08 1988 devices/narrator.i Page 1 Sep 28 17:08 1988 

























































devices/narrator.i Page 2 


1 IFND DEVICES_NARRATOR_I 70 UWORD NDI_VOLUME 
2 DEVICES_NARRATOR_I SET 1 71 UWORD NDI_SAMPFREQ 
3 x* 72 UBYTE NDI_MOUTHS 
4 ** $Filename: devices/narrator.i $ 73 UBYTE NDI_CHANMASK 
5 xx $Release: 1.3 $ 74 UBYTE NDI_NUMCHAN 
6 ** 75 UBYTE NDI_PAD 
7 ** 76 LABEL NDI_SIZE 
8 xx 77 
Q *x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 
10 ** All Rights Reserved 79 * aT Mouth read IORB 
11 ** 80 STRUCTURE MRB,NDI_SIZE 
12 81 UBYTE MRB_WIDTH 
13 IFND EXEC_IO_ TI 82 UBYTE MRB_HEIGHT 
14 INCLUDE "exec/io.i" 83 UBYTE MRB_SHAPE 
15 ENDC 84 UBYTE MRB_ PAD 
16 85 LABEL MRB_SIZE 
17 *----—-——- DEFAULT VALUES, USER PARMS, AND GENERAL CONSTANTS 86 
18 87 ENDC ; DEVICES_NARRATOR_I 
19 DEFPITCH EQU 110 ;DEFAULT PITCH 
20 DEFRATE EQU 150 ;DEFAULT RATE 
21 DEFVOL EQU 64 ;DEFAULT VOLUME (FULL) 
22 DEFFREQ EQU 22200 ;DEFAULT SAMPLING FREQUENCY 
23 NATURALFO EQU O- ;NATURAL FO CONTOURS 
24 ROBOTICFO EQU 1 ;MONOTONE FO 
25 MALE EQU 0 ;MALE SPEAKER 
26 FEMALE EQU 1 ;FEMALE SPEAKER 
27 DEFSEX EQU MALE ;DEPAULT SEX 
28 DEFMODE EQU NATURALFO ;DEFAULT MODE 
29 
30 * Parameter bounds 
31 
32 MINRATE EQU 40 ;MINIMUM SPEAKING RATE 
33 MAXRATE EQU 400 ;MAXIMUM SPEAKING RATE 
34 MINPITCH EQU 65 ;MINIMUM PITCH 
35 MAXPITCH EQU 320 ;MAXIMUM PITCH 
36 MINFREQ EQU 5000 ;MINIMUM SAMPLING FREQUENCY 
37 MAXFREQ EQU 28000 ;MAXIMUM SAMPLING FREQUENCY 
38 MINVOL EQU 0 ;MINIMUM VOLUME 
39 MAXVOL EQU 64 7MAXIMUM VOLUME 
40 
41 * Driver error codes 
42 
43 ND_NotUsed EQU -l ; 
44 ND_NoMem EQU —2 ;Can't allocate memory 
45 ND_NoAudLib EQU ~3 ;Can't open audio device 
46 ND_MakeBad EQU -4 ;Error in MakeLibrary call 
47 ND_UnitErr EQU -5 ;Unit other than 0 
48 ND _CantAlloc EQU -6 ;Can't allocate the audio channel 
49 ND Unimpl EQU -7 ;Unimplemented command 
50 ND_NoWrite EQU -8 ;Read for mouth shape without write 
51 ND_Expunged EQU ~9 ;Can't open, deferred expunge bit set 
52 ND_Phon&rr EQU —20 ;Phoneme code spelling error 
53 ND _RateErr EQU -21 j;Rate.out of bounds 
54 ND PitchErr EQU -22 ;Pitch out of bounds 
55 ND_SexBrr EQU -23 ;Sex not valid 
56 ND_ModeErr EQU -24 j;Mode not valid 
57 ND_FreqBrr EQU -25 ;Sampling freg out of bounds 
58 ND _VolErr EQU ~26 ;Volume out of bounds 
59 
60 
61 
62 * a Write IORequest block 
STRUCTURE NDI,IOSTD_SI2ZE 
UWORD NDI_RATE ;Speaking rate in words/minute 
UWORD NDI_PITCH ;Baseline pitch in Hertz 
UWORD  NDI_MODE ;FO mode 
UWORD NDI_SEX ;Speaker sex 
APTR NDI_CHMASKS ;Pointer to audio channel masks 
UWORD  NDI_NUMMASKS ;Size of channel masks array 











;Channel volume 

;Sampling frequency 

;Generate mouths? (Boolean value) 
j;Actual channel mask used (internal use) 
;Number of channels used (internal use) 
;For alignment 

;Size of Narrator IORequest block 


;Mouth width 
;Mouth height 
;Compressed shape (height/width) 
Alignment 


et - a 





Sep 


CON AUB WN RE 


28 17:08 1988 devices/parallel.i Page 1 


IFND DEVICES_PARALLEL TI 
DEVICES PARALLEL I SET L 
wk 


*k 
Kk 
xk 
nk 
ak 
ux 
ak 
xk 


$Filename: devices/parallel.i $ 
$Release: 1.3 $ 


external declarations for Serial Port Driver 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND EXEC_IO_I 
include "exec/io.i" 
ENDC 7; EXEC_IO_T 








ParErr_DevBusy EQU 1 

ParErr_BufTooBig EQU 2 

ParErr_InvParam EQU 3 

ParErr_LineErr EQU 4 

ParErr_NotOpen EQU 5 

ParErr_PortReset ROU 6 

ParErr_InitErr EQU 7 

*-— 
* 

* Useful constants 

* 

He rn ne en ne a —. ee 
* 

PDCMD QUERY EQU CMD_NONSTD 

PDCMD_SETPARAMS EQU CMD _NONSTD+1 

Par_DEVFINISH EQU 10 ; number of device comands 





* 
Yn i i i a et ce ee i te A 
PARALLELNAME : MACRO 
de.b ‘parallel.device' ,0 
ds.w : 
ENDM 
BITDEF PAR,SHARED,5 ; PARFLAGS non-exclusive access 
BITDEF PAR,RAD_BOOGIE,3 ; " (not yet implemented) 
BITDEF PAR,EOFMODE,1 ; " EOF mode enabled bit 
BITDEF IOPAR,QUEUED,6 ; IO_FLAGS rgst-queued bit 
BITDEF IOPAR,ABORT,5 ; " rqst-aborted bit 
BITDEF IOPAR,ACTIVE,4 i " rgqst-qued-or~current bit 
BITDEF IOPT,RWDIR,3 ; IO_STATUS read=0,write=1 
BITDEF IOPT,PARSEL,2 i " printer selected on the A1000 
; printer selected & serial "Ring Indicator" 
; on the A500/A2000. Be careful when making 
; cables. 
BITDEF JOPT,PAPEROUT,1 i " paper out 
BITDEF IOPT,PARBUSY, 0 i " printer in busy toggle 


sNote: Previous versions of this include file had bits 0 and 2 swapped 
* 
PRK KIRK KR IKK II KIKI IK IK KIKI RII KA IIR KEKE ER EKER KEKE KEE KEKE KEKE REKE 


STRUCTURE PTERMARRAY ,0 


112 


28 17:08 1988 devices/parallel.i Page 2 


ULONG PTERMARRAY_ 0 
ULONG PTERMARRAY_ 1 
LABEL PTERMARRAY_ SIZE 


HK KIKI KKK KIKI KK KIKI IKK KK KKK KIKI KK KA KE KK IKE K EKER ER KIKKKEE 


* CAUTION !!! IF YOU ACCESS the parallel.device, you MUST (!!!!) use an 


* TOEXTPAR-sized structure or you may overlay innocent memory, okay ?! 
KKK IK KKK KKK KI IKK KAR IKK RI RK KKK ERR IKK KIRK RK KK EI KK KKK KKK KIKIEKI KEK 


STRUCTURE IOEXTPAR, IOSTD_SIZE 


* STRUCT MsgNode 

* 0 APTR Suce 

* 4 APTR Pred 

* 8 UBYTE Type 

* 9 UBYTE Pri 

* A APTR Name 

* E  APTR ReplyPort 

* 12 UWORD MNLength 

* STRUCT IOExt. 

* 14 APTR IO_DEVICE 

x 18 APTR IO_UNIT 

* 1c UWORD IO_COMMAND 

x JE UBYTE IO_FLAGS 

* IF UBYTE IO_ERROR 

* STRUCT IOStaBxt 

x 20 ULONG TO_ACTUAL 

* 24 ULONG IO_LENGTH 

* 28 APTR IO_DATA 

* 2c ULONG IO_OFFSET 

* 

* 

* 30 
ULONG IO_PEXTFLAGS ;- (not used) flag extension area 
UBYTE IO_PARSTATUS ; device status (see bit defs above) 
UBYTE I0_PARFLAGS ; see PARFLAGS bit definitions above 
STRUCT I0_PTERMARRAY,PTERMARRAY SIZE ; termination char array 
LABEL IOEXTPar_SIZE 


KKK RIKER IK RK RHR ER RRR KIRKE KK KKK KR RIKKI IK KIKI KIRK IK III IKI IKKE KTR III KE 


ENDC i; DEVICES PARALLEL_1 





€t -4 


Sep 


WOOTNNMN PWN 


ISO 
+44 
ISO 
Iso 
ISO 


Iso 
Iso 
Iso 
ISO 
ISO 
Iso 
ISO 
ISo 
ISo 


DEC 
DEC 
DEC 
DEC 
DEC 
DEC 
DEC 


DEC 
DEC 
DEC 
DEC 
DEC 
DEC 


+++ 
+++ 





(sort of) 


28 17:08 1988 devices/printer.i Page l 
IFND DEVICES _PRINTER_I 

DEVICES_PRINTER_I SET L 
Kk 
ak $Filename: devices/printer.i $ 
xe $Release: 1.3 $ 
Kk 
ae printer device command definitions 
Kk 
ae {C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 
ak 

IFND EXEC_NODES_I 

INCLUDE "“exec/nodes.i" 

ENDC 

IFND EXEC_LISTS I 

INCLUDE "“exec/lists.i" 

ENDC 

IFND EXEC_PORTS_I 

INCLUDE "“exec/ports.i" 

ENDC 

IFND EXEC_IO_I 

INCLUDE '"exec/io.i" 

ENDC 

DEVINIT 

DEVCMD PRD_RAWWRITE 

DEVCMD PRD_PRTCOMMAND 

DEVCMD PRD_DUMPRPORT 

DEVCMD PRD_QUERY 
j*xeexe printer definitions 
aRIS EQU 0; ESCc reset 
aRIN EQU 1 ; ESC#1 initialize 
aIND EQU 2; ESCD lf 
aNEL EQU 3; ESCE return,lf 
aRI EQU 4 ; ESCM reverse lf 
aSGRO EQU 5 ; Esc({Om normal char set 
aSGR3 EQU 6 ; ESC{3m italics on 
aSGR23 EQU 7 ; BSC{23m italics off 
aSGR4 EQU 8 ; ESC[4m underline on 
aSGR24 EQU 9 ; ESC[24m underline off 
aSGR1l EQU 10 ; ESC[lm boldface on 
aSGR22 FOU 11 ; ESC[22m boldface off 
aSFC EQU 12 ; SGR30-39 set foreground color 
aSBC EQU 13 ; SGR40-49 set background color 
aSHORPO EQU 14 ; ESC[Ow normal pitch 
aSHORP2 EQU 15 ; ESC[2w elite on 
aSHORP1 EQU 16 ; ESC[lw elite off 
aSHORP4 EQU 17 ; ESC[4w condensed fine on 
aSHORP3 EQU 18 ; ESC[3w condensed off 
aSHORP6 EQU 19 ; ESC{6w enlarged on 
aSHORP5 EQU 20 ; ESC[5w enlarged off 
aDEN6 EQU 21 ; ESC[6"z shadow print on 
aDEN5S EQU) 22 ; ESC[5"z shadow print off 
aDEN4 EQU) 23 ; ESC[4"z doublestrike on 
aDEN3 EQU 24 ; ESC[3"z doublestrike off 
aDEN2 EQU 25 ; ESC(2"2 NLQ on 
aDEN1 EQU) 26 ; ESC[1"z NLQ off 
aSUS2 EQU 27 ; ESC[2v superscript on 
aSUS1 FQU 28 ; ESC[lv superscript off 


109 
110 
lll 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 


28 17:08 1988 


aSuUSs4 
aSUS3 
aSUSO 
aPLU 
aPLD 


aFNTO 
aFNTL 
aFNT2 
aFNT3 
aFNT4 
aFNTS 
aFNT6 
aFNT7 
aFNT8 
aFNT9 
aFNT10 


Se Se Se Se Se Se Ne Ne NE ME 


aPROP2 
aPROP1 
aPROPO 
aTSS 
aJFY5 
aJFY7 
aJFY6 
aJFYO 
aJFY2 
aJFY3 


aVERPO 
aVERPL 
aSLPP 
aPERP 
aPERFO 


aLMS 
aRMS 
aTMS 
aBMS 
aSTBM 
aSLRM 
aCAM 


aHTS 
avVTS 
aTBCO 
aTBC3 
aTBCl] 
aTBC4 
aTBCALL 
aTBSALL 
aEXTEND 


aRAW 





devices/printer.i Page 2 


ESC[4v subscript on +44 
ESC(3v subscript off +44 
ESC{Ov normalize the line +4 
ESCL partial line up Iso 
ESCK partial line down Iso 
ESC(B US char set or Typeface 
ESC(R French char set or Typeface 
ESC(K German char set or Typeface 
ESC(A UK. char set or Typeface 
ESC(E Danish I char set or Typeface 
ESC(H Sweden char set or Typeface 
ESC(Y Italian char set or Typeface 
ESC(Z Spanish char set or Typeface 
ESC(J Japanese char set or Typeface 
ESC(6 Norweign char set or Typeface 


ESC(C Danish II char set or Typeface 1 


typefaces are: 


default typeface. 
Line Printer or equiv. 
Pica or equiv. 

Elite or equiv. 
Helvetica or equiv. 
Times Roman or equiv. 
Gothic or equiv. 
Script or equiv. 
Prestige or equiv. 
Caslon or equiv. 
Orator or equiv. 


EQU 29 
EQU 30 
EQU 31 
EQU) 32 
EQU) (33 
EQU = 34 
EQU 35 
EQU 36 
EQU 37 
EQU 38 
EQU) 39 
EQU 40 
EQU) 41 
EQU 42 
EQU 43 
EQU) 44 
Suggested 
Oo- 
1- 
2- 
3- 
4- 
5 - 
6- 
T- 
g8- 
9- 
10 - 
EQU 45 
EQU 46 
EQU 47 
EQU 48 
EQU) 49 
EQU 50 
EoU 51 
EQU 52 
EQU 53 
EQU (54 
EQU 55 
EQU 56 
EQU 57 
EQU 58 
EQU 59 
EQU 60 
EQU 61 
EQU 62 
EQU 63 
EQU 64 
BQU 65 
EQU 66 
EQU 67 
EQU 68 
EQU 69 
EQU 70 
EQU) 71 
EQU 72 
EQU: 73 
EQU) 74 
EQU) 75 
76 


EQU 


proportional on 
proportional off 
proportional clear 


ESC[2p 
ESC [1p 
ESC [Op 


ESC{n E set proportional offset 
ESC[5 F auto left justify 

ESC[7 F auto right justiy 

ESc{6 F auto full justify 

ESC[O F auto justify off 

Esc([2 F word space(auto center) 
ESC[3 F letter space (justify) 
ESC{0z 1/8" line spacing 
ESC{lz 1/6" line spacing 
ESC[nt set form length 1 
ESC[nq perf skip n (n>0) 
ESC{[O0q perf skip off 

ESC#9 Left margin set 


ESCH#O Right margin set 
ESC#8 Top margin set 
ESC#2 Bottom marg set 
ESC[Pnl;Pn2r TsB margins 


EsC[Pnl;Pn2s L&R margin 


ESC#3 Clear margins 

ESCH Set horiz tab 
ESCJ Set vertical tabs 
ESC[Og Clr horiz tab 
ESC[3g Clear all h tab 
ESC{lg Clr vertical tabs 
ESC{4g Clr all v tabs 
ESC#H4 Clr all h «& v tabs 
ESC#5 Set default tabs 


ESC[Pn"x extended commands 


; ESC(Pn"r Next ‘Pn' chars are raw 


(default) 


0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
0 


(special) 
(special) 


tl - da 


Sep 28 17:08 1988 devices/printer.i Page 3 Sep 28 17:08 1988 devices/printer.i Page 4 


139 208 SPECIAL _DENSITYMASK EQU $0700 + Masks out density values 








140 209 SPECIAL DIMENSIONSMASK EQU SPECIAL MILCOLS! SPECIAL MILROWS! SPECIAL FULLCOLS! SPE 
141 STRUCTURE IoPrtcmdReq,10_SIZE 210 
142 UWORD io_PrtCommand ; printer command 211 ENDC ; DEVICES_PRINTER_I 
143 UBYTE io_Parm0 ; first command parameter 

144 UBYTE io Parml 7; second command parameter 

145 UBYTE io_Parm2 ; third command parameter 

146 UBYTE io_Parm3 ; fourth command parameter 

147 LABEL  ioper_SIZEOF 

148 

149 STRUCTURE IODRPReqg , IO_SIZE 

150 APTR io_RastPort j; raster port 

151 APTR io_ColorMap ; color map 

152 ULONG io Modes ; graphics viewport modes 

153 UWORD io_Srcx ; source x origin 

154 UWORD io _SrcyY 7; source y origin 

155 UWORD. io _SrcWidth ; source x width 

156 UWORD io_SrcHeight 7 source x height 

157 LONG io_Destcols ; destination x width 

158 LONG io_DestRows ; destination y height 

159 UWORD io Special ; option flags 

160 LABEL iodrpr_SI ZEOF 

161 

162 SPECIAL MILCOLS EQU $0001 ; DestCols specified in 1/1000" 

163 SPECIAL_MILROWS EQU $0002 ; DestRows specified in 1/1000" 

164 SPECIAL FULLCOLS EQU $0004 ; make DestCols maximum possible 

165 SPECIAL FULLROWS EQU $0008 ; make DestRows maximum possible 

166 SPECIAL FRACCOLS EQU $0010 ; DestCols is fraction of FULLCOLS 
167 SPECIAL_FRACROWS EQU $0020 ; DestRows is fraction of FULLROWS 
168 SPECIAL CENTER EQU $0040 7 center image on paper 

169 SPECIAL ASPECT EQU $0080 ; ensure correct aspect ratio 

170 SPECIAL_DENSITY1 EOU $0100 ; lowest resolution (dpi) 

171 SPECIAL DENSITY2 EQU $0200 ; next res 

172 SPECIAL_DENSITY3 EQU $0300 ; next res 

173 SPECIAL DENSITY4 EQU $0400 ; next res 

174 SPECIAL DENSITY5 EQU $0500 ; next res 

175 SPECIAL DENSITY6 EQU $0600 7 next res 

176 SPECIAL_DENSITY7 EQU $0700 ; highest res 

177 SPECIAL_NOFORMFEED EQU $0800 ; don't eject paper after gfx prints 
178 SPECIAL _TRUSTME EQU $1000 ; don't reset on gfx prints 

179 ; 

180 ; Compute print size, set 'io DestCols' and 'io DestRows' in the calling 
181 ; program's 'IODRPReq' structure and exit, don't print. This allows the 
182 ; calling program to see what the final print size would be in printer 
183 ; pixels. Note that it modifies the ‘io_DestCols' and 'io_DestRows' 
184 ; fields of your ‘IODRPReq' structure. Also, set the print density and 
185 ; update the 'MaxXDots', 'MaxYDots', 'XDotsInch', and 'YDotsInch' fields 
186 ; of the 'PrinterExtendedData' structure. 

187 ; 

188 SPECIAL NOPRINT EQU $2000 7; see above 

189 . 

190 PDERR_NOERR EQU 0 ; clean exit, no errors 

191 PDERR_CANCEL EQU 1 ; user cancelled print 

192 PDERR_NOTGRAPHICS EQU 2 ; printer cannot output graphics 

193 PDERR_INVERTHAM EQU 3 ; OBSOLETE 

194 PDERR_BADDIMENSION EQU 4 ; print dimensions illegal 

195 PDERR_DIMENSIONOVFLOW EQU 5 7 OBSOLETE 

196 PDERR_INTERNALMEMORY EQU 6 7; no memory for internal variables 
197 PDERR_BUFFERMEMORY EQU 7 ; no memory for print buffer 

198°; 

199 ; Note : this is an internal error that can be returned from the render 
200 ; function to the printer device. It is NEVER returned to the user. 
201 ; If the printer device sees this error it converts it 'PDERR_NOERR' 
202 ; and exits gracefully. Refer to the document on 

203 ; "How to Write a Graphics Printer Driver' for more info. 

204 ; 

205 PDERR_TOOKCONTROL EQU 8 ; I took control in case 0 of render 
206 


207 ; internal use 











st -a 








Sep 


WON AUF WHE 


28 17:08 1988 devices/prtbase.i Page 1 


IFND DEVICES_PRTBASE_T 


DEVICES_PRTBASE_I SET 1 


KK 
xk 
nk 
ex 
ak 
nk 
zk 
kk 
xk 


$Pilename: devices/prtbase.i $ 
$Release: 1.3 $ 


printer device data definition 


(C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND EXEC_NODES_I 
INCLUDE '"exec/nodes.i" 
ENDC 

IFND EXEC_LISTS_I 
INCLUDE "exec/lists.i" 
ENDC 

IFND EXEC _PORTS_I 
INCLUDE "“exec/ports.i" 
ENDC 

IFND EXEC_LIBRARIES_I 
INCLUDE "“exec/libraries.i" 
ENDC 

IFND EXEC_TASKS_I 
INCLUDE "exec/tasks.i" 
ENDC 


IFND DEVICES_PARALLEL T 
INCLUDE "devices/parallel.i" 
ENDC 

IFND DEVICES_SERIAL_I 

INCLUDE "devices/serial.i" 
ENDC 

IFND DEVICES_TIMER_I 

INCLUDE "“devices/timer.i" 

ENDC 

IFND LIBRARIES_DOSEXTENS_I 
INCLUDE "libraries/dosextens.i" 
ENDC 

IFND INTUITION_INTUITION_I 
INCLUDE “intuition/intuition.i" 
ENDC 


STRUCTURE DeviceData,LIB_SIZE 


du_Flags EQU  LN_PRI ; various unit flags 
j-~-—-— IO_FLAGS 
BITDEF I10,QUEUED,4 ; command is queued to be performed 


APTR dd_Segment ; AO when initialized 
APTR dd_ExecBase ; A6 for exec 
APTR dd_CmdVectors 


UWORD dd_NumCommands 


LABEL DeviceData_SIZEOF (was dd_SIZEOF) 


—--~—- device driver private variables oor 


BITDEF I0,CURRENT,5 
BITDEF I0,SERVICING,6 
BITDEF 10,DONE,7 


command is being performed 


command is done 


—--— du_Flags 


BITDEF DU,STOPPED,0 ; commands are not to be performed 


Zz ; command table for device commands 
APTR dd_CmdBytes ; bytes describing which command queue 
; the number of commands supported 


command is being actively performed 





Sep 


70 
71 
72 
73 
74 
75 


77 
78 


126 


128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 


28 17:08 1988 devices/prtbase.i Page 2 
BR COTS EAE 
P_PRIORITY EQU 0 
P_STKSIZE EQU $0800 ; stack size for child task 
P_BUFSIZE EQU 256 ; size of internal buffers for text i/o 
P_SAFESIZE EQU 128 ; safety margin for text output buffer 
ke pd Flags —---— 
BITDEF P,IORO,O ; IORO is in use 
BITDEF P,IOR1,1 ; IOR1 is in use 
BITDEF P,EXPUNGED,7 ; device to be expunged when all closed 
STRUCTURE PrinterData,DeviceData_SIZEOF 
STRUCT | Unit ,MP_SI2E ; the one and only unit 
BPTR pd_PrinterSegment ; the printer specific segment 
UWORD = pd_PrinterType ; the segment printer type 
APTR pd_SegmentData ; the segment data structure 
APTR pd_PrintBuf ; the raster print buffer 
APTR pd_PWrite ; the parallel write function 
APTR pd_PBothReady ; the parallel write function's done 
IFGT IOEXTPar_SIZE-IOEXTSER_SIZE 
STRUCT pd_IORO, IOEXTPar_SIZE ; port I/O request 0 
STRUCT pd_IOR1,IOEXTPar_SIZE i and 1 for double buffering 
ENDC 
IFLE IOEXTPar_SIZE-IOEXTSER_SITZE : 
STRUCT pd_IORO, IORXTSER_SIZE ; port I/O request 0 
STRUCT pd_IOR1, 1OEXTSER_SIZE i and 1 for double buffering 
ENDC 
STRUCT pd_TIOR, IOTV_SIZE ; timer I/O request 
STRUCT pd_IORPort ,MP_SIZE i and message reply port 
STRUCT pd_TC,TC_SIZE j write task 
STRUCT pd_Stk,P_STKSIZE i and stack space 
UBYTE pd_Flags ; device flags 
UBYTE pd_pad 
sTRUCT pd Preferences,pf SIZBOF ; the latest preferences 
UBYTE pd_PWaitEnabled ; wait function switch 
LABEL  pd_SIZEOF ; warning! this may be odd 
BITDEF PPC,GFX,0 graphics (bit position) 
BITDEF PPC,COLOR,1 7color (bit position) 
PPC_BWALPHA EQU $00 jblackawhite alphanumerics 
PPC_BWGFX EQU $Ol jblackswhite graphics 
PPC_COLORALPHA EQU $02 j;color alphanumerics 
PPC_COLORGFX EQU $03 j;color graphics 
PCC_BW EQU 1 ;blackéwhite only 
PCC_YMC EQU 2 7yellow/magenta/cyan only 
PCC_YMC_BW EQU 3 7yellow/magenta/cyan or black&white 
PCC_YMCB EQU 4 yellow/magenta/cyan/black 
PCC_4COLOR EQU $4 ja flag for YMCB and BGRW 
PCC_ADDITIVE EQU $8 jnot ymcb but blue/green/red/white 
PCC_WB EQU $9 jblackéwhite only, 0 == BLACK 
PCC_BGR EQU Sa ;blue/green/red 
PCC_BGR_WB EQU $b jblue/green/red or black&white 
PCC_BGRW EQU Se jblue/green/red/white 
; The picture must be scanned once for each color component, as the 
; printer can only define one color at a time. ie. If 'PCC_YMC' then 
; first pass sends all 'Y' info to printer, second pass sends all 'M' 
i info, and third pass sends all C info to printer. The CalComp 
; PlotMaster is an example of this type of printer. 
PCC_MULTI_PASS EQU $10 j;see explanation above 
STRUCTURE PrinterExtendedData ,0 
APTR ped_PrinterName ; printer name, null terminated 
APTR ped_Init ; called after LoadSeg 





9T -a 


Sep 28 17:08 1988 devices/prtbase.i Page 3 











139 APTR ped_Expunge ; called before UnLoadSeg 

140 APTR ped_Open ; called at OpenDevice 

141 APTR ped_Close ; called at CloseDevice 

142 UBYTE ped_PrinterClass ; printer class 

143 UBYTE ped _ColorClass 7; color class 

144 UBYTE  ped_MaxColumns ; number of print columns available 

145 UBYTE  ped_NumCharSets ; number of character sets 

146 UWORD ped_NumRows ; number of ‘pins' in print head 

147 ULONG ped MaxXDots ; number of dots maximum in a raster dump 
148 ULONG  ped_MaxYDots ; number of dots maximum in a raster dump 
149 UWORD = ped__XDotsInch ; horizontal dot density 

150 UWORD = ped_YDotsInch ; vertical dot density 

151 APTR ped_Commands ; printer text command table 

L52 APTR ped_DoSpecial ; special command handler 

153 APTR ped_Render ; raster render function 

154 LONG ped_TimeoutSecs ; good write timeout 

155 j------ the following only exists if the segment version is 33 or greater 
156 APTR ped_8BitChars ;conversion strings for the extended font 
157 LONG ped_PrintMode ;set if text printed, otherwise 0 

158 ;~---—- the following only exists if the segment. version is 34 or greater 
159 APTR ped_ConvFunv ; ptr to conversion function for all chars 
160 LABEL ped SIZEOF 

161 

162 STRUCTURE PrinterSegment ,0 

163 ULONG ps_NextSegment ; (actually a BPTR) 

164 ULONG ps_runAlert ; MOVEQ #0,D0 : RTS 

165 UWORD  ps_Version j; segment version 

166 UWORD_ ps_ Revision ; segment revision 

167 LABEL  ps_PED ; printer extended data 

168 

169 ENDC ; DEVICES_PRTBASE_T 


Sep 


WOMAN UE WHE 


28 20:33 1988 devices/prtgfx.i Page 1 





IFND 


DEVICES _PRTGFX_I 


Kk 
xk 
xx 
xk 
xk 





DEVICES PRTGFX_I 


SET 1 


$Filename: devices/prtgfx.i $ 
$ 


$Release: 1.3 


ak 


we (C) Copyright 1987,1988 Commodore-Amiga, Inc. 


** 
x* 


PCMYELLOW 
PCMMAGENTA 
PCMCYAN 
PCMBLACK 
PCMBLUE 
PCMGREEN 
PCMRED 
PCMWHITE 


EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 


STRUCTURE 


LABEL 
LABEL 
STRUCT 
LABEL 


STRUCTURE 


APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 
APTR 


UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 


UWORD 
ULONG 
UWORD 
UWORD 
UWORD 
UWORD 
ULONG 
ULONG 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 
UWORD 


All Rights Reserved 


WN OS 


PCMYELLOW 
PCMMAGENTA 
PCMCYAN 
PCMBLACK 


colorEntry ,0 
colorLong 
colorsByte 
colorByte,4 
ce_SIZEOF 


PrtInfo,0 
pi_render 
pi_rp 
pi_temprp 
pi_RowBuf 
pi_HamBuf 
pi_ColorMap 
pi_ColorInt 
pi_HamInt 
pi_DestlInt 
pi_Dest2Int 
pi_Scalex 
pi_ScalexAlt 
pi_dmatrix 
pi_TopBuf 
pi_BotBuf 


pi_RowBufSize 
pi_HamBufSize 


pi_ColorMapSize 
pi_ColorIntSize 


pi_HamIntSize 


pi_DestlIntSize 
pi_Dest2IntSize ; 


pi_ScalexSize 


pi_ScaleXAltSize 


pi_PrefsFlags 
pi_special 
pi_xstart 
pi_ystart 
pi_width 
pi_height 
pi_pe 

pi_pr 
pi_ymult 
pi_ymod 
pi_ety 
pi_xpos 
pi_threshold 
pi_tempwidth 
pi_flags 


; 
, 


i 


f 
i 
i 
i 
é 
i 
i 


i 
i 
i 
; 
i 


é 


i 


byte index for yellow 
byte index for magenta 
byte index for cyan 
byte index for black 
byte index for blue 
byte index for green 
byte index for red 
byte index for white 


quick access to all of YMCB 
l entry for each of YMCB 
ditto (except signed) 


; PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 
; PRIVATE — DO NOT. USE! 
PRIVATE — DO NOT USE! 
PRIVATE ~ DO NOT USE! 
PRIVATE — DO NOT USE! 


color intensities for entire row 
PRIVATE ~— DO NOT USE! 


; PRIVATE — DO NOT USE! 

; PRIVATE — DO NOT USE! 

; array of scale values for X 
; PRIVATE — DO NOT USE! 

; pointer to dither matrix 


PRIVATE — DO NOT USE! 


7; PRIVATE ~ DO NOT USE! 
; PRIVATE — DO NOT USE! 
; PRIVATE ~ DO NOT USE! 
7 PRIVATE — DO NOT USE! 
; PRIVATE — DO NOT USE! 
7 PRIVATE — DO NOT USE! 
; PRIVATE — DO NOT USE! 
; PRIVATE — DO NOT USE! 
; PRIVATE — DO NOT USE! 


i 
: 


i 


Me Me Se ee ee 


i PRIVATE — DO NOT USE! 


PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 
source width (in pixels) 
PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 


PRIVATE — DO NOT USE! 
PRIVATE — DO NOT USE! 
PRIVATE ~— DO NOT USE! 
PRIVATE ~ DO NOT USE! 


offset to start printing from 

copy of threshold value (from prefs) 
PRIVATE ~ DO NOT USE! 

PRIVATE — DO NOT USE! 








iT - 4 





[Sep 28 20:33 1988 devices/prtgix.i Page 2 


70 
71 
72 





ENDC 


LABEL prtinfo_SIZEOF 


; DEVICES_PRTGFX_I 


~ [Sep 


WDMTANEWNL 





28 17:08 1988 devices/scsidisk.i Page 1 


IFND DEVICES_SCSIDISK_I 


DEVICES_SCSIDISK_I EQU 1 

*k 

ae $Filename: devices/scsidisk.i $ 

** $Revision: 1.0 $ 

xk $Date: 88/07/11 15:33:14 $ 

kk 

xe SCSI exec-level device command 

Kk 

xe (C) Copyright 1988 Commodore-Amiga, Inc. 
xx All Rights Reserved 


ak 


SCSI Command 
Several Amiga SCSI controller manufacturers are converging on 
standard ways to talk to their controllers. This include 
file describes an exec-device command (e.g. for hddisk.device) 
that can be used to issue SCSI commands 


UNIT NUMBERS 
Unit numbers to the OpenDevice call have encoded in them which 
SCSI device is being referred to. The three decimal digits of 
the unit number refer to the SCSI Target ID (bus address) in 


the L's digit, the SCSI logical unit (LUN) in the 10's digit, 
and the controller board in the 100's digit. 
Examples: 
drive at address 0 
12 LUN 1 on multiple drive controller at address 2 
104 second controller board, address 4 
88 not valid: both logical units and addresses 
range from 0..7. 
Original 2090 code did not support this command . 
Commodore 2090/2090A unit numbers are different. The SCSI 
logical unit is the 100's digit, and the SCsI Target ID 
is a permuted 1's digit: Target ID 0..6 maps to unit 3..9 
(7 is reserved for the controller). 
Examples: 
drive at address 0 
109 drive at address 6, logical unit 1 
1 not valid: this is not a SCSI unit. Perhaps 
it's an ST506 unit. 


Some controller boards generate a unique name (e.g. 2090A's 
iddisk.device) for the second controller board, instead of 
implementing the 100's digit. 


There are optional restrictions on the alignment, bus 
accessability, and size of the data for the data phase. 
Be conservative to work with all manufacturer's controllers. 


i 
; 
i 
i 
i 
i 
; 
; 
i 
i 
i 
i 
i 
; 
i 
i 
; 
i 
i 
i 
; 
i 
; CAVEATS 
; 
; 
i 
; 
; 
i 
; 
i 
i 
; 
; 
i 
i 
i 
i 
i 
; 
i 
i 
i 
i 


HD_SCSICMD EQU 28 ; issue a SCSI command to the unit 

io Data points to a scsIcmd 

io Length is sizeof(struct scsIcmd) 
; io Actual and io Offset are not used 


STRUCTURE scsicmd ,0 
APTR sesi_Data word aligned data for SCSI Data Phase 

(optional) data need not be byte aligned 

(optional) data need not be bus accessable 


even length of Data area 


ULONG — scsi_Length 





il 


8. -a 








Sep 28 17:08 1988 devices/scsidisk.i 


70 
71 


; 
; 
ULONG scsi_Actual i 
APTR scsi_Command i 
UWORD = scsi_CmdLength ; 
UWORD = scsi_CmdActual ; 
UBYTE sesi_Flags i 
UBYTE scsi_Status ; 
LABEL scsi_SIZEOF 
;T TT scsi_Flags ~--—--- 
SCSIF ‘ WRITE EQU 0 
SCSIF_READ EQU 1 
i777T-~ «~SCSI io_Error values —---—— 
HFERR_SelfUnit EQU 40 
HFERR_DMA EQU 41 
HFERR_Phase EQU 42 
HFERR_Parity EQU 43 
HFERR_Sel Timeout EQU 44 
HFERR_BadStatus EQU 45 


TTT OpenDevice io_Error values ------ 


HFERR . NoBoard EQU 50 


ENDC — ; DEVICES SCSIDISK_I 


Page 2 


we 


(optional) data can have odd length 
(optional) data length can be > 2**24 
actual Data used 

SCSI Command (same options as scsi_Data) 
length of Command 

; actual Command used 

; includes intended data direction 

; SCSI status of command 


intended data direction is out 
intended data direction is in 


cannot issue SCSI command to self 
DMA error 

illegal or unexpected SCSI phase 
SCSI parity error 


; Select timed out 
; status and/or sense error 


Open failed for non-existant board 





Sep 


WOnNDUBFEWDNH 


BH 
HO 


12 


28 17:08 1988 devices/serial.i Page 1 


IFND DEVICES _SERIAL I 


DEVICES_SERIAL I SET 1 
*k 


ae $Filename: devices/serial.i $ 

xx $Release: 1.3 $ 

Kk 

ex external declarations for the serial device 

kk 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
aK All Rights Reserved 

Kk 

LEND EXEC_IO_I 

include "exec/io.i" 

ENDC 7 EXEC_IO_T 
Pn 
* 

* Useful constants * 
* 
he 


SER_DEFAULT_CTLCHAR EQU $11130000 ; 
7 You may change these via SETPARAMS. 
; calculated for xON/xXOFF characters. 
; desired parity. 


default chars for xON,xOFF 
At this time, parity is not 
You must supply them with the 


* Driver Specific Commands 


SDCMD_QUERY EQU 
SDCMD_BREAK EQU 
SDCMD_SETPARAMS EQU 


CMD_NONSTD 
CMD_NONSTD+1 
CMD_NONSTD+2 


SER_DEVFINISH  EQU CMD_NONSTD+2 ; number of device comands 
Pe 
SERIALNAME MACRO 
dc.b ‘serial .device',0 
dc.w 0 
ENDM 
BITDEF SER, XDISABLED,7 i SERFLAGS xOn-xOff feature disabled bit 
BITDEF SER,EOFMODE,6 i EOF mode enabled bit 
BITDEF SER,SHARED;,5 ; " non-exclusive access 
BITDEF SER,RAD } BOOGIE, 4; " high-speed mode active 
BITDEF SER,QUEUEDBRK, 3 ; " queue this Break ioRqst 
BITDEF SER, 7WIRE,2 ; " RS232 7-wire protocol 
BITDEF SER, PARTY. ODD, 1 i " use-odd-parity bit 
BITDEF SER,PARTY_ON,0O i " parity-enabled bit 
;WARNING: The next series of BITDEFs refer to the HIGH. order BYTE of 
;10_STATUS. Example usage: "BTST.B #IOST_XOFFWRITE,IO_STATUS+1(AX)" 
i 
BITDEF IOST,XOFFREAD,4 ; IOST_HOB receive currently xOFF'ed 
BITDEF IOST,XOFFWRITE,3 ; w transmit currently xOFF‘ed 
BITDEF IOST,READBREAK,2 ; " break was latest input 
BITDEF IOST,WROTEBREAK,1 ; " break was latest output 
BITDEF IOST,OVERRUN,0O j " status word RBF overrun 
i 
i BITDEF's in a longword field) 
i Example usage: BSET.B #SEXT'B_MSPON, IO_EXTFLAGS+3(AX) 
;IO_EXTFLAGS (extended flag longword) 
BITDEF SEXT,MSPON,1 ; " use mark-space parity,not odd-even 
BITDEF SEXT,MARK,0O ; " if mark-space, use mark 
* 


RRR KKK KK KEK RK KKK KERR KK RK KR KKK KE KKK KKK KKK RR KKK KK KE KKK KKK EK RK KKK KKK KK KKK KK 





6T -a 





124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 





28 17:08 1988 devices/serial.i Page 2 


STRUCTURE TERMARRAY , 0 
ULONG TERMARRAY_0O 
ULONG TERMARRAY_1 
LABEL TERMARRAY_SIZE 


FOO I IOI IO IO II IO TO II IOI IIA TO III II IIIA IR IAI ARIA IIA ANAT AKI 


* CAUTION !! IF YOU ACCESS the serial.device, you MUST (!!!!) use an 


* IOEXTSER-sized structure or you may overlay innocent memory, okay ?! 
FORO IOI OI III TOI TOR IOI II IOI IR ITO IIIA III IITA IIA KIKI IRI AK IRE IK 


STRUCTURE IOEXTSER, IOSTD_SIZE 


STRUCT MsgNode 


Q  APTR Succ 

4 APTR Pred 

8 UBYTE Type 

9 UBYTE Pri 

A APTR Name 

E  APTR ReplyPort 
12 UWORD MNLength 

STRUCT IOEXt 

14 APTR IO_DEVICE 
18 APTR IO_UNIT 


ic UWORD IO_COMMAND 
LE UBYTE IO_FLAGS 
1F UBYTE IO_ERROR 
STRUCT IOStdExt 

20 ULONG Io_ACTUAL 
24 ULONG IO_LENGTH 
28 APTR I0Q_DATA 

2c ULONG 10_OFFSET 


ee OO Oe OE HH OOOO 


30 
ULONG IO_CTLCHAR 
ULONG IO0_RBUFLEN 
ULONG TO_EXTFLAGS 


control char's (order = xON ,XOFF , rsvd,rsvd) 
length in bytes of serial port's read buffer 
additional serial flags {see bitdefs above) 
ULONG I0_BAUD baud rate requested (true baud) 

ULONG 10 _BRKTIME duration of break signal in MICROseconds 
STRUCT IO TERMARRAY,TERMARRAY SIZE ; termination character array 
UBYTE IO_READLEN ; bits per read char (bit count) 

UBYTE IO_WRITELEN ; bits per write char (bit count) 

UBYTE IO0_STOPBITS ; stopbits for read (count) 

UBYTE I0_SERFLAGS ; see SERFLAGS bit definitions above 

UWORD I0_STATUS ; status of serial port, as follows: 


BIT ACTIVE FUNCTION 
0 —~— reserved 
1 — reserved 


2 high Connected to parallel "select" on the A1000. 
Connected to both the parallel "select" and 
serial “ring indicator" pins on the A500 & 
A2000. ‘Take care when making cables. 

3 low Data Set Ready 

4 low Clear To Send 

5 low Carrier Detect 

6 low Ready To Send 

7 low Data Terminal Ready 

8 high read overrun 

9 high break sent 

10 high break received 

il high transmit x-OFF'ed 

12 high receive x-OFF'ed 
13-15 reserved 


a a a 


LABEL IOEXTSER_SIZE 


FORO IIIT III IIIT III II AT IORI AI IK IIIA AAI SK IAAI SAA IATA IAI IA ANITA II ISA E. 








Sep 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 


28 17:08 1988 devices/serial.i Page 3 


* 


* Driver error definitions 


SerErr_DevBusy EQU 1 
SerErr_BufErr EQU 4 
SerErr_InvParam EQU 5 
SerErr_ LineErr EQU 6 
SerErr ParityErr EQU 9 
SerErr_TimerErr EQU 11 
SerErr_BufOverflow EQU 12 
SerErr_NoDSR EQU 13 


SerErr_ DetectedB 


IFD  DEVICES_: 


reak EQU 15 


SERIAL I_OBSOLETE 
9 


;Failed to allocate new read buffer 


;(See the serial/OpenDevice autodoc) 


SER_DBAUD EQU 600 ; unused 
SerErr_BaudMismatch EQU 2 j unused 
SerErr_InvBaud EQU 3 ;unused 
SerErr_NotOpen EQU 7 junused 
SerErr_PortReset EQU 8 ; unused 
SerErr_InitErr EQU 10 j; unused 
SerErr_NoCTS EQU 14 ;unused 
BITDEF IOSER,QUEUED,6 ; IO_FLAGS rgqst-queued bit 
BITDEF IOSER,ABORT,5 i " rgqst-aborted bit 
BITDEF IOSER,ACTIVE,4 i " rqst~-qued-or-current bit 
ENDC 
ENDC ; DEVICES SERIAL I 





Of - a 








sep 


WONADUEPWNHE 


28 17:08 1988 devices/timer.i Page 1 


IFND DEVICES_TIMER_I 


DEVICES TIMER I SET 1 


xk 
xk 
kk 
kk 
wk 
ae 
wk 
“Kk 
Kk 


$Filename: devices/timer.i $ 
$SRelease: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


IFND EXEC_IO_I 
INCLUDE "exec/io.i" 


ENDC ; EXEC_IO_1 
* unit defintions 
UNIT_MICROHZ EQU 0 
UNIT VBLANK EQU 1 
TIMERNAME MACRO 
De.B 'timer.device',0 
DS.W 0 
ENDM 


STRUCTURE TIMEVAL,0 


ULONG TV_SECS 
ULONG  TV_MICRO 
LABEL TV_SIZE 


STRUCTURE TIMEREQUEST,IO_ SIZE 


STRUCT JIOTV_TIME,TV_SIZE 
LABEL IOTV_SIZE 


* IO_COMMAND to use for adding a timer 


DEVINIT 

DEVCMD TR_ADDREQUEST 
DEVCMD TR_GETSYSTIME 
DEVCMD TR_SETSYSTIME 


ENDC ; DEVICES TIMER_I 





hh 
MOO MANNDMNEPWNE 


Bb 
dD 


28 17:08 1988 devices/trackdisk.i Page 1 


IFND DEVICES_TRACKDISK_I 





DEVICES_TRACKDISK_I SET 1 

zk 

** $Filename: devices/trackdisk.i $ 

xk SRelease: 1.3 $ 

Kk 

xk 

Kk 

xe (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
** All Rights Reserved 


ak 


IFND EXEC_IO I 
INCLUDE "exec/io.i" 
ENDC ; EXEC_IO I 


IFND EXEC_DEVICES_I 


INCLUDE "exec/devices.i" 
ENDC ; EXEC_DEVICES_I 


* OBSOLETE -- only valid for 3 1/4" drives. 
* 


*NUMCYLS EQU 80 

*MAXCYLS EQU NUMCYLS+20 

* 

*NUMHEADS EQU 2 

*NUMTRACKS EQU NUMCYLS *NUMHEADS 
NUMSECS EQU ll 

NUMUNITS EQU 4 

Po 
* 


*—— sizes before mfm encoding 


TD_SECTOR EQU 512 

TD_SECSHIFT EQU 9 

* 

W—-——-- 
* 

* Driver Specific Commands 


Use the TD_GETNUMTRACKS command! 


; normal # of cylinders 
; max # of cyls to look for 
i during a calibrate 


*-~ TD_NAME is a generic macro to get the name of the driver. This 
*—— way if the name is ever changed you will pick up the change 


x-- automatically. 
k= 


*—— Normal usage would be: 
*— 


*-- internalName: TD_NAME 

+ 

TD_NAME: MACRO 
DC.B ‘trackdisk.device' ,0 
DS.W 0 








Te -a 














Sep 28 17:08 1988 devices/trackdisk.i Page 2 Sep 28 17:08 1988 devices/trackdisk.i Page 3 

70 ENDM 139 * 

71 140 DRIVE3_5 EQU 1 

72 BITDEF TD,EXTCOM,15 141 DRIVES 25 EQU 2 

73 142 

74 DEVINIT YG Re 
75 DEVCMD TD_MOTOR ; control the disk's motor 144 * 

76 DEVCMD TD_SEEK ; explicit seek (for testing) 145 * Driver error defines 

77 DEVCMD TD_FORMAT ; format disk 146 * 

78 DEVCMD TD_REMOVE ; notify when disk changes YT 
79 DEVCMD TD_CHANGENUM ; number of disk changes 148 

80 DEVCMD TD_CHANGESTATE ; is there a disk in the drive? 149 TDERR_NotSpecified EQU 20 ; general catchall 

81 DEVCMD 'TD_PROTSTATUS ; is the disk write protected? 150 TDERR_NoSecHdr EQU 2i ; couldn't even find a sector 
82 DEVCMD TD_RAWREAD ; read raw bits from the disk 151 .TDERR_BadSecPreamble EQU 22 ; sector looked wrong 

83 DEVCMD 'TD_RAWWRITE ; write raw bits to the disk 152 TDERR_BadSecID EQU 23 ; ditto 

84 DEVCMD ‘TD_GETDRIVETYPE ; get the type of the disk drive 153 TDERR_BadHdrSum EQU 24 ; header had incorrect checksum 
85 DEVCMD TD_GETNUMTRACKS ; get the # of tracks on this disk 154 TDERR_BadSecSum EQU 25 ; data had incorrect checksum 
86 DEVCMD TD_ADDCHANGEINT ; TD_REMOVE done right 155 TDERR_TooFewSecs EQU 26 ; couldn't find enough sectors 
87 DEVCMD TD_REMCHANGEINT ; removes softint set by ADDCHANGEINT 156 TDERR_BadSecHdr EQU 27 ; another "sector looked wrong" 
88 DEVCMD TD_LASTCOMM ; dummy placeholder for end of list 157 TDERR_WriteProt EQU 28 ; can't write to a protected disk 
89 158 TDERR_DiskChanged EQU 29 ; no disk in the drive 

90 159 TDERR_SeekError EQU 30 ; couldn't find track 0 

91 * 160 TDERR_NoMem EQU 31 ; ran out of memory 

92 * 161 TDERR_BadUnitNum EQU 32 ; asked for a unit > NUMUNITS 
93 * The disk driver has an “extended command" facility. These commands 162 TDERR_BadDriveType EQU 33 ; not a drive that trackdisk groks 
94 * take a superset of the normal IO Request block. 163 TDERR_DriveInUse EQU 34 ; someone else allocated the drive 
95 * 164 TDERR_PostReset EQU 35 ; user hit reset; awaiting doom 
96 ETD_WRITE EQU (CMD_WRITE! TDF_EXTCOM) 165 

97 ETD READ EQU (CMD_READ! TDF_EXTCOM) YG EE 
98 ETD MOTOR EQU (TD_MOTOR!TDF_EXTCOM) 167 * 

99 ETD_SEEK EQU (TD_SEEK! TDF_EXTCOM) 168 * Public portion of unit structure 

100 ETD FORMAT EQU (TD_FORMAT !' TDF_EXTCOM) 169 * 

101 ETD_UPDATE EQU (CMD_UPDATE! TDF_EXTCOM) DT 
102° ETD_CLEAR EQU. (CMD_CLEAR ! TDF_EXTCOM) 171 

103 ETD_RAWREAD EQU (TD_RAWREAD! TDF_EXTCOM) 172 STRUCTURE TDU_PUBLICUNIT, UNIT_SIZE 

104 ETD_RAWWRITE EQU (TD_RAWWRITE!TDF_EXTCOM) 173 UWORD ~~ TDU_COMPO1TRACK ; track for first precomp 

LOS 174 UWORD DU _COMP1OTRACK ; track for second precomp 
106 175 UWORD TDU_COMP11TRACK ; track for third precomp 

107 * 176 ULONG TDU_STEPDELAY ; time to wait after stepping 
108 * extended IO has a larger than normal io request block. 177 ULONG TDU_SETTLEDELAY ; time to wait after seeking 
109 * 178 UBYTE TDU_RETRYCNT ; # of times to retry 

110 179 LABEL TDU_PUBLICUNITSIZE 

lll STRUCTURE IOEXTTD, IOSTD_SIZE 180 

112 ULONG TOTD_COUNT j; removal/insertion count 181 ENDC 7; DEVICES_TRACKDISK_T 

113 ULONG IOTD_SECLABEL ; sector label data region 

114 LABEL IOTD_SIZE 

115 

116 * 

117 * raw read and write can be synced with the index pulse. This flag 

118 * in io request's I0_FLAGS field tells the driver that you want this. 

119 * 

120 BITDEF IOTD,INDEXSYNC,4 

121 

122 * labels are TD_LABELSIZE bytes per sector 

123 

124 TD_LABELSIZE EQU 16 

125 

126 * 

127 * This is a bit in the FLAGS field of OpenDevice. If it is set, then 

128 * the driver will allow you to open all the disks that the trackdisk 

129 * driver understands. Otherwise only 3.5" disks will succeed. 

130 * 

131 * 

132 BITDEF TD,ALLOW_NON_3_5,0 

133 

134 * 

135 * If you set the TDB_ALLOW_NON_3_5 bit in OpenDevice, then you don't 

136 * know what type of disk you really got. These defines are for the 

137 * TD GETDRIVETYPE command. In addition, you can find out how many 

138 * tracks are supported via the TD_GETNUMTRACKS command. 





ct -~ a 













28 17:12 1988 exec/ables.i Page 1 Sep 28 17:12 1988 exec/ables.i Page 2 















1 IEND EXEC_ABLES_I 70 * INCLUDE "execbase.i" for TDNestCnt offset 
2 EXEC_ABLES_I SET 1 71 XREF _LvoPermit 

3 ** 72 ENDM 

4 ** $Filename: exec/ables.i $ 73 

5 ** $Release: 1.3 $ 74 

6 ** 75 FORBID MACRO 

7 ** 76 IFC Nit, t 

8 ** 77 ADDQ.B #1,TDNestCnt(A6) 
Q *K (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 ENDC 

10 ** All Rights Reserved 79 IFNC NL, 

ll ** 80 MOVE.L 4,\1 

12 81 ADDO.B #1,TDNestCnt(\1) 
13 IFND EXEC_TYPES_I 82 ENDC 

14 INCLUDE "exec/types.i" 83 ENDM 

i5 ENDC ; EXEC_TYPES T 84 








IFND EXEC_EXECBASE_I 86 PERMIT MACRO 


























18 INCLUDE "exec/execbase. i" 87 IFC "1,1! 

19 ENDC 7 EXEC _EXECBASE_I 88 JSR _LVOPermit(A6) 
20 89 ENDC 

21 90 IFNC “N10! 

220 kee + 91 MOVE.L A6,-(SP) 

23 * 92 MOVE.L 4,A6 

24 * Interrupt Exclusion Macros | 93 JSR _LvoPermit (A6) 
25 * 94 MOVE.L (SP)+,A6 

DR en en 95 ENDC 

27 96 ENDM 

28 INT_ABLES MACRO * externals for dis/enable 97 

29 XREF _intena : 98 ENDC ; EXEC_ABLES I 

30 ENDM 













DISABLE MACRO * [scratchReg] 
34 IFC Nit,t! 
35 MOVE.W #$04000, intena *(NOT IF_SETCLR)+IF_INTEN 
36 ADDO.B #1,IDNestCnt(A6) 
37 ENDC 
38 IFNC AL, ft! 
39 MOVE.L 4,\1 
40 MOVE.W #$04000, intena *(NOT IF_SETCLR)+IF_INTEN 
41 ADDQ.B #1,IDNestCnt(\1) 






42 ENDC 
ENDM 




















46 ENABLE MACRO * [scratchReg] 
47 IFC Nl, 

48 SUBQ.B #1,IDNestCnt(A6) 
49 BGE.S ENABLE\@ 

50 MOVE.W #S0C000,_intena *IF_SETCLR+IF_INTEN 
51 ENABLE\@: . 

52 ENDC 

53 IFNC NT 

54 MOVE.L 4,\1 

55 SUBQ.B #1,IDNestCnt(\1) 
56 BGE.S ENABLE\@ 

57 MOVE.W #$0C000, intena 
58 ENABLE\G: 

59 ENDC 








Tasking Exclusion Macros 







ee 


TASK ABLES MACRO 





€@ - a 








Sep 


WM~TNU SF WN 


2 


E 
* 
* 
* 
* 
* 
* 
* 
* 
* 


KI IOI III IOI TOR TOOK II IK IR IR IKK IK IK IT IIR IIR KICK KIKI KI KK II K EE KEI KERR 


* 
* Format of the alert error number: 
* 
* 4-—---- fa pa + 
* IpD| SubSysId | General Error | SubSystem Specific Error 
* ter 4—~- ch + 
* 
* D: DeadEnd alert 
* SubSysId: indicates ROM subsystem number. 
* General Error: roughly indicates what the error was 
* Specific Error: indicates more detail 
FOR FOR OOO IOI IORI IOFOTO TOI I TO TOR FOR IRR RR III IR AIK RIKI KR RK RAI RK 
x 
x Use this macro for causing an alert. THIS MACRO MAY CHANGE! 
x It is very sensitive to memory corruption.... like stepping on 
* location 4! But it should work for now. 
* 
ALERT macro (alertNumber, paramArray, scratch) 
movem. 1 di fas/as, —(Sp) 
move.l #\1,d 
IFNC ae 
lea \2,a5 
ENDC 
move.1 4,a6 (use proper name!!!) 
jsr _LVOAlert (a6) 


FOO III III ROO OR TOR TOI IR IIR II III IOI TOI RE IOI IOI KIKI KEK 


* 
* 
* 
* 
* 
* 
* 
x 








8 17:12 1988 exec/alerts.i Page 1 


IFND EXEC_ALERTS_I 
XEC_ALERTS I SET 1 
* 
* $Pilename: exec/alerts.i $ 
* $Release: 1.3 $ 
* 
* 
* 
* (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
x All Rights Reserved 


* 


BITDEF S,ALERTWACK,1 


movem.1 (sp)+,d7/a5/a6 
endm 


General Dead-End Alerts 
For example: 


ALERT 


FRR IO SO TOTO TOT RI IOI IOI ROR ROI IOI III OI RIT TOR FOTO K FOR IORI IK RII KE IRE 


ae alert types 


AT DeadEnd 
AT Recovery 


Ac , NoMemory 


equ $80000000 
equ $00000000 


—--- general purpose alert codes 
equ $00010000 


AG_MakeLib equ $00020000 
AG OpenLib equ $00030000 
AG_OpenDev equ $00040000 
AG_OpenRes equ $00050000 
AG_TOBrror equ $00060000 


AG _NoSignal 


equ $00070000 


* in ExecBase. SysFlags 


timer.device cannot open math. library: 


(AN _TimerDev!AG_OpenLib!AO_MathLib),(A0),Al 








28 17:12 1988 exec/alerts.i Page 2 


joc alert objects: 


AO] ExecLib 
AO_GraphicsLib 
AO_LayersLib 
AO_Intuition 
AO MathLib 
AO_CListLib 
AO _DOSLib 
AO_RAMLib 
AO_IconLib 


AO_ExpansionLib 


AO_AudioDev 
AO_ConsoleDev 
AO_GamePortDev 
AO_KeyboardDev 


AO_TrackDiskDev 


AO_TimerDev 
AO_CIARsre 

AO_DiskRsre 
AO_MiscRsre 
AO] ) BootStrap 
AO_Workbench 


equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 


$00008001 
$00008002 
$00008003 
$00008004 
$00008005 
$00008006 
$00008007 
$00008008 
$00008009 
$0000800A 
$00008010 
$00008011 
$00008012 
$00008013 
$00008014 
$00008015 
$00008020 
$00008021 
$00008022 
$00008030 
$00008031 


FORK FOR TOI TOK II IK KR IT RK TOK TOK RIK KR IIR IR KIKI KKK RI IK KIKI KE RIK IKK KKK KICK KEK 


* 
* 
* 
* 
* 
x 
* 
* 


For example: 


Specific Dead-End Alerts: 


exec. library -- corrupted memory list 


joctco exec. library 


AN] ExecLib 
AN _ExcptVect 
AN_BaseChksSum 
AN_LibChksSum 
AN_LibMem 

AN MemCorrupt 
AN_IntrMem 
AN_InitaAPtr 
AN_SemCorrupt 
AN_FreeTwice 
AN_BogusExcpt 


equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 


$01000000 


$81000001 , 


$81000002 
$81000003 
$81000004 
$81000005 
$81000006 
$81000007 
$81000008 
$81000009 
$8100000A 


poss graphics. library 


AN | GraphicsLib 
AN_GfxNoMem 
AN_LongFrame 
AN_ShortFrame 
AN_TextTmpRas 
AN_B1tBitMap 


AN_RegionMemory 


AN_MakevPort 
AN_Gf£xNoLCM 


equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 
equ 


$02000000 
$82010000 
$82010006 
$82010007 
$02010009 
$8201000A 
$8201000B 
$82010030 
$82011234 


;-----— layers. library 


AN | LayersLib 


equ 


$03000000 


AN_LayersNoMem equ $83010000 


jcc intuition. library 


AN_ Intuition 
AN_GadgetType 
AN_BadGadget 
AN_CreatePort 
AN_ItemAlLloc 
AN_SubAlloc 


equ 
equ 
equ 
equ 
equ 
equ 


$04000000 
$84000001 
$04000001 
$84010002 
$04010003 
$04010004 


Me Ne Se Se Ne ee 


ALERT AN_MemCorrupt, (A0),Al 


KK RIK KK IK IIR IKK KKK RK IH KK IK KEE KK KERRIER ERE EER EERE KEK ERE KEREKK 


68000 exception vector checksum 
execbase checksum 

library checksum failure 

no memory to make library 

corrupted memory list 

no memory for interrupt servers 
TnitStruct(} of an APTR source 

a semaphore is in illegal state 
freeing memory that is already free 
illegal 68k exception taken 


graphics out of memory 
long frame, no memory 


; short frame, no memory 


text, no memory for TmpRas 


; BltBitMap, no memory 
; regions, memory not available 


MakeVPort, no memory 


; emergency memory not available 


layers out of memory 


unknown gadet type 

Recovery form of AN_GadgetType 
create port, no memory 

item plane alloc, no memory 
sub alloc, no memory 


Wi 





wi - a 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
L77 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 











AN _PlaneAlloc 
AN_ItemBoxTop equ $84000006 
AN_OpenScreen equ $84010007 
AN_OpenScrnRast equ $84010008 
AN_SysScrnType equ $84000009 
AN_AddsWGadget equ $8401000A 


equ $84010005 


AN_OpenWindow equ $8401000B 
AN_BadState equ $8400000C 
AN_BadMessage equ $8400000D 
AN_WeirdEcho equ $8400000E 
AN_NoConsole equ $8400000F 
ae math. library 

AN | Mathhib equ $05000000 
ae clist. library 

AN | ClListhib equ $06000000 
proccss dos. library 

AN | DOSLib equ $07000000 
AN_StartMem equ $07010001 
AN_EndTask equ $07000002 
AN_OPktFail equ $07000003 
AN_AsynePkt equ $07000004 
AN_FreeVec equ $07000005 
AN_DiskBlkSeq equ $07000006 
AN_BitMap equ $07000007 
AN_KeyFree equ $07000008 
AN_BadChksum equ $07000009 
AN _DiskError equ $0700000A 
AN_KeyRange equ $0700000B 
AN_BadOverlay equ $0700000C 
ae ramlib. library 

AN | RAMLib equ $08000000 
AN _BadSegList equ $08000001 
a icon. library 

AN_ IconLib equ w $09000000 
ja expansion. libra 

AN | .ExpansionLib equ $0A000000 


AN_BadExpansionFree 
jo audio.device 
AN | AudioDev equ $10000000 


~——~-— console.device 

AN | ConsoleDev equ $11000000 
jo gameport. device 

AN | GamePortDev equ $12000000 
po keyboard. device 

AN | KeyboardDev equ $13000000 
ae trackdisk. device 

AN | TrackDiskDev equ $14000000 
AN_TDCalibSeek equ $14000001 
AN_TDDelay equ $14000002 
jos timer.device 

AN | TimerDev equ $15000000 
AN_TMBadReq equ $15000001 
AN_TMBadSupply equ $15000002 
joss cia. resource 
AN |] CIARSre equ $20000000 


i 


: 


, 


7 


Sep 28 17:12 1988 exec/alerts.i Page 3 


plane alloc, no memory 

item box top ¢ RelZero 

open screen, no memory 

open screen, raster alloc, no memory 
open sys screen, unknown type 

add SW gadgets, no memory 

open window, no memory 

Bad State Return entering Intuition 
Bad Message received by IDCMP 

Weird echo causing incomprehension 


; couldn't open the Console Device 


no memory at startup 
EndTask didn't 

Qpkt failure 

Unexpected packet received 
Freevec failed 

Disk block sequence error 
Bitmap corrupt 

Key already free 

Invalid checksum 


; Disk Error 


Key out of range 


; Bad overlay 


overlays are illegal for library segments 


equ $0A000001 


calibrate: seek error 
delay: error on timer wait 


bad request 
power supply does not supply ticks 


Sep 


208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 











28 17:12 1988 exec/alerts.i Page 4 


jocceoo «disk. resource 

AN | DiskRsre egu $21000000 
AN_DRHasDisk equ $21000001 
AN_DRIntNoAct equ $21000002 


j77———- misc. resource 
aN] MiscRsre equ $22000000 
ae bootstrap 

AN | BootStrap equ $30000000 
AN_BootError equ $30000001 


en workbench 
AN | Workbench equ $31000000 


DiskCopy 
AN | DiskCopy equ $32000000 


ENDC i 


EXEC_ALERTS_I 


: get unit: already has disk 
; interrupt: no active unit 


i; boot code returned an error 





c@-a4 











Sep 


WOODNIAUPWNE 


28 17:12 1988 exec/devices.i Page l 


TEND EXEC _DEVICES_I 


EXEC_DEVICES_I SET 1 
** 


ak 
ak 
Kk 
xk 
Kk 
aK 
Kk 
xk 


$Filename: exec/devices.i $ 


$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commoedore-Amiga, Inc. 


All Rights Reserved 


IFND EXEC_LIBRARIES_T 
INCLUDE "“exec/libraries.i" 


ENDC ; EXEC_LIBRARIES_I 


IFND EXEC_PORTS_I 
INCLUDE "exec/ports.i" 
ENDC ; EXEC PORTS_I 


STRUCTURE DD,LIB_SIZE 


LABEL DD_SIZE 


STRUCTURE UNIT,MP_SIZE 


UBYTE UNIT_FLAGS 
UBYTE UNIT_pad 
UWORD UNIT_OPENCNT 
LABEL UNIT_SIZE 


*x—----- UNIT _FLAG definitions: 


BITDEF UNIT,ACTIVE,0 
BITDEF UNIT, INTASK,1 


ENDC ; EXEC_DEVICES_I 


queue for requests 


driver is active 
running in driver's task 





Sep 


WONAU PWN 


28 17:12 1988 exec/errors.i Page 1 


IFND EXEC_ERRORS_I 

EXEC_ERRORS_I SET 1 

** 

xe $Filename: exec/errors.i $ 

xe $Release: 1.3 $ 

kk 

** Standard IO Errors: 

ak 

x (C) Copyright 1985,1986,1987,1988 

«x All Rights Reserved 

** 

IOERR_OPENFAIL EQU ~l * 

IOERR_ABORTED EQU —2 * 

IOERR_NOCMD EQU -3 * 

IOERR_BADLENGTH EQU -4 * 

ERR_OPENDEVICE EQU IOERR_OPENFAIL * 
ENDC ; EXEC_ERRORS_I 


commodore-Amiga, Inc, 


device/unit failed to open 
request aborted 

command not supported 

not a valid length 


REMOVE !1!! 











9 -d 











Sep 


CDNA UE WN 





28 17:12 1988 exec/exec.i Page 1 


IFND EXEC_EXEC_I 


EXEC_EXEC_I SET 1 

kk 

ae $Filename: exec/exec.i $ 

** $Release: 1.3 $ 

Ke 

Kk 

ak 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xx All Rights Reserved 


xk 


INCLUDE "“exec/nodes.i" 
INCLUDE "exec/lists.i" 
INCLUDE "exec/interrupts.i" 
INCLUDE "exec/memory. i" 
INCLUDE "exec/ports.i"' 
INCLUDE "exec/tasks.i" 
INCLUDE "exec/libraries.i" 
INCLUDE "exec/devices.i" 
INCLUDE "exec/io.i" 





ENDC ; EXEC_EXEC_I 





28 17:12 1988 exec/exec_lib.i Page 1 


Sep 


COONAN SWNE 


He 
HO 


12 








IFND EXEC_EXEC_LIB_I 
BXEC_EXEC_LIB_I SET i 
*k 


** $Filename: exec/exec_lib.i $ 
** $Release: 1.3 $ 

Kk 

x 

Kk 


** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ax All Rights Reserved 
Kk 


FUNC. 
FUNC 


DEF Supervisor 

) 
FUNCD) 

D 

D 


FE 

F Exitintr 

F Schedule 
Reschedule 
F Switch 

£ Dispatch 
FE 


FUNC. 
FUNC. 
FUNCD 
FUNCDEF Exception 
FUNCD Initcode 
FUNCDEF InitStruct 
FUNCDEF MakeLibrary 
FUNCDEF MakeFunctions 
FUNCDEF FindResident 
FUNCDEF InitResident 
FUNCDEF Alert 
FUNCDEF Debug 
FUNCDEF Disable 
UNCDEF Enable 
UNCDEF Forbid 
UNCDEF Permit 
UNCDEF SetSR 

UNCDEF SuperState 
UNCDEF UserState 
UNCDEF SetIntVector 
UNCDEF AddIntServer 
DEF RemIntServer 
UNCDEF Cause 

UNCDEF Allocate 
UNCDEF Deallocate 
UNCDEF AllocMem 
UNCDEF AllocAbs 
UNCDEF FreeMem 
UNCDEF AvailMem 
UNCDEF AllocEntry 
UNCDEF FreeEntry 
UNCDEF Insert 
'UNCDEF AddHead 
UNCDEF AddTail 
UNCDEF Remove 
UNCDEF RemHead 
UNCDEF RemTail 
FUNCDEF Enqueue 
FUNCDEF FindName 
FUNCDEF AddTask 
FUNCDEF RemTask 
FUNCDEF FindTask 
FUNCDEF SetTaskPri 
FUNCDEF SetSignal 
FUNCDEF SetExcept 
FUNCDEF Wait 

FUNCDEF Signal 
FUNCDEF AllocSignal 
FUNCDEF FreeSignal 
FUNCDEF AllocTrap 
FUNCDEF FreeTrap 
FUNCDEF AddPort 
FUNCDEF RemPort 
FUNCDEF PutMsg 


BIR] GG) Ge 
x 





ny a Hy Ag A ep ay yy 
Zz 
a 


fy ey ey ey 














fey rey pe yey ep 














115 





FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEFP 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEP 
FUNCDEF 
FUNCDEP 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEP 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEP 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 
FUNCDEF 


ENDC 


Sep 28 17:12 1988 exec/exec_lib.i Page 2 


GetMsg 

ReplyMsg 
WaitPort. 
FindPort 
AddLibrary 
RemLibrary 
OldOpenLibrary 
CloseLibrary 
SetFunction 
SumLibrary 
AddDevice 
RemDevice 
OpenDevice 
CloseDevice 
DoIO 

SendiIo 

Check1O 

WaitIo 

AbortIO 
AddResource 
RemResource 
OpenResource 
RawlOInit 
RawMayGetChar 
RawPutChar 
RawDoFmt 

Getcc 

TypeofMem 
Procure 

Vacate 
OpenLibrary 
InitSemaphore 
ObtainSemaphore 
ReleaseSemaphore 
Attempt Semaphore 
ObtainSemaphoreList 
ReleaseSemaphoreList 
FindSemaphore 
AddSemaphore 
RemSemaphore 
SumKickData 
AddMemList 
CopyMem 
CopyMemQuick 


; BXEC_EXEC_LIB_I 














Sep 


WOOANNAUMNF WHE 


28 17:12 1988 exec/execbase.i Page 1 


IFND EXEC_EXECBASE_I 


EXEC_EXECBASE_I SET 1 

Kk 

ae $Pilename: exec/execbase.i $ 

** $Release: 1.3 $ 

ak 

xk 

** 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 


Kk 


IFND EXEC_TYPES_T 
INCLUDE "exec/types.i'' 
ENDC ; EXEC: TYPES _I 


IFND EXEC_LISTS_I 
INCLUDE "exec/lists.i" 
ENDC ; EXEC_LISTS_I 


IFND EXEC_INTERRUPTS_I 
INCLUDE "exec/interrupts.i" 
ENDC ; EXEC_INTERRUPTS_I 


IFND EXEC_LIBRARIES I 
INCLUDE "exec/libraries.i" 
ENDC ; EXEC_LIBRARIES_I 





HREHKEX Static System Variables **## xm RIK H RAR IKI IR HHRRR ER ERIKK EERE ERIE 


STRUCTURE ExecBase,LIB_SIZE i 


UWORD SsoftVer i 
WORD LowMemChkSum i 
ULONG ChkBase } 
APTR ColdcCapture ; 
APTR CoolCapture ; 
APTR WarmCapture i 
APTR SysStkUpper ; 
APTR SysStkLower ; 
ULONG MaxLocMem i 
APTR DebugEntry ; 
APTR DebugData ; 
APTR AlertData i 
APTR MaxExtMem i 
WORD chkSum i 


Standard library node 


kickstart release number 
checksum of 68000 trap vectors 


; system base pointer complement 
; cold soft capture vector 
; cool soft capture vector 


warm soft capture vector 

system stack base (upper bound) 
top of system stack (lower bound) 
last calculated local memory max 
global debugger entry point 

global debugger data segment 

alert data segment 

top of extended mem, or null if none 


for all of the above 


xxxexex Interrupt Related FOR II RO IO IOI IK IR FOR SOI IO IORI OR IRI IO IK IO 


LABEL IntVects 

STRUCT IVTBE , IV_SI2ZE 
STRUCT IVDSKBLK, IV_SIZE 
STRUCT IVSOFTINT,IV_SIZE 
STRUCT IVPORTS , IV_SIZE 
STRUCT IVCOPER , [V_SIZE 
STRUCT IVVERTB,IV_SIZE 
STRUCT IVBLIT,IV_SIZE 
STRUCT IVAUDO, IV_S1ZE 
STRUCT IVAUDL , IV_SIZE 
STRUCT IVAUD2 , I1V_SIZE 
STRUCT IVAUD3 , IV_SIZE 
STRUCT IVRBF ,IV_SIZE 
STRUCT IVDSKSYNC , IV_SIZE 
STRUCT IVEXTER,IV_SIZE 
STRUCT IVINTEN , IV_SIZE 
STRUCT IVNMI ,IV_SIZE 











| 





8¢ - a 

















Sep 28 17:12 1988 exec/execbase.i Page 2 Sep 28 17:12 1988 exec/execbase.i Page 3 


70 139 * Processors and Co-processors: 

7k 140 BITDEF AF,68010,0 ; also set for 68020 

72 KKKKKKK Dynamic System Variables 27k III III IIIT IORI I IK IOK 141 BITDEF AF,68020,1 

73 142 BITDEF AF,68881,4 

74 APTR ThisTask pointer to current task 143 

75 ULONG Tdlecount idle counter 144 ; These two bits used to be AFB PAL and AFB_50HZ. After some soul 

76 ULONG DispCount. dispatch counter 145 ; searching we realized that they were misnomers, and the information 


77 UWORD Quantum ; time slice quantum 146 ; is now kept in VBlankFrequency and PowerSupplyFrequency above. 





78 UWORD Elapsed current quantum ticks 147 ; To find out what sort of video conversion is done, look in the 
79 UWORD SysFlags ; mise system flags 148 ; graphics subsytem. 
80 BYTE IDNestCnt ; interrupt disable nesting count 149 BITDEF AF,RESERVED8,8 
81 BYTE TDNestcCnt ; task disable nesting count 2° BITDEF AF,RESERVEDS ,9 
82 151 
83 UWORD AttnFlags ; Special attention flags 152 ENDC ; EXEC_EXECBASE_I 
84 UWORD AttnResched ; rescheduling attention 
85 APTR ResModules ; pointer to resident module array 
86 
87 APTR TaskTrapCode ; default task trap routine 
88 APTR TaskExceptCode ; default task exception code 
89 APTR TaskExitCode ; default task exit code 
90 ULONG TaskSigAlloc ; preallocated signal mask 
91 UWORD TaskTrapAlloc ; preallocated trap mask 
92 
93 
94 *eeRHRR System List Headers * eR AIK IRR RAK IR ARIK II RRR RIK ITOK RIC IORI OR IK 
95 
96 STRUCT Membist ,LH_ SIZE 
97 STRUCT ResourceList,LH_SIZE 
98 STRUCT DeviceList,LH_ST2E 
99 STRUCT IntrLlist,LH_SIZE 
100 STRUCT LibList,LH_SIZE 
101 STRUCT PortList,LH_SIZE 
102 STRUCT TaskReady,LH_SIZE 
tea STRUCT TaskWait ,LH_SIZE 
04 
Ie STRUCT SoftInts,SH_SIZE*5 
06 
107 STRUCT LastAlert ,4*4 
108 
109 
110 jc these next. two variables are provided to allow 
ili joc system developers to have a rough idea of the 
112 coc. period of two externally controlled signals -~~- 
113 ccc the time between vertical blank interrupts and the 
114 jcc external line rate (which is counted by CIA A's 
115 ccc "time of day" clock). In general these values 
116 jo77~-- «will be 50 or.60, and may or may not track each 
117 j-———-- other. These values replace the obsolete AFB_PAL 
118 joc and AFB_50HZ flags. 
119 UBYTE VBlankFrequency 
3 UBYTE PowerSupplyFrequency 
133 STRUCT SemaphoreList ,LH_SIZE 
124 ja77to-- «these next two are to be able to kickstart into user ram. 
125 co KickMemPtr holds a singly linked list of MemLists which 
126 jc-77--- will be removed from the memory list via AllocAbs. If 
127 jcc all the AllocAbs's succeeded, then the KickTagPtr will 
128 ccc be added to the rom tag list. 
129 APTR KickMemPtr ; ptr to queue of mem lists 
130 APTR KickTagPtr ; ptr to rom tag queue 
131 APTR KickCheckSum ; checksum for mem and tags 
132 
133 STRUCT ExecBaseReserved , 10 
Ie STRUCT ExecBaseNewReserved , 20 
3 
136 LABEL SYSBASESIZE 


137 | LL 
138 ******* AttnFlags 





6@ - a 








28 17:12 1988 exec/execname.i Page 1 Sep 28 17:12 1988 exec/initializers.i Page 1 








1 IFND EXEC_EXECNAME_T 1 IFND EXEC_INITIALIZERS_T 
2 EXEC_EXECNAME I SET 1 2 EXEC_INITIALIZERS_T SET 1 
3 ak 3 xk 
4 ** $Filename: exec/execname.i $ 4 ** $Filename: exec/initializers.i $ 
5 ** $Release: 1.3 $ 5 ** $Release: 1.3 $ 
6 Kk 6 xk 
7 ** 7 ** 
BQ xx Q ** 
Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. Q xx (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 
ll nk 11 ak 
12 12 
13 EXECNAME macro 13 INITBYTE MACRO * goffset,&value 
14 dc.b ‘exec. library',0 14 DC.B $e0 
15 ds .w 0 15 DC.B 0 
16 endm 16 DC.W \L 
17 17 DC.B \2 
18 ENDC j; EXEC_EXECNAME_ I 18 DC.B 0 
19 ENDM 
20 
21 INITWORD MACRO * goffset, &value 
22 DC.B $ao 
23 DC.B 0 
24 DC.W \L 
25 DC .W \2 
26 ENDM 
27 
28 INITLONG MACRO * goffset, &value 
29 DC.B $c0 
30 DC.B 0 
31 DC.W \l 
32 DC.L \2 
33 ENDM 
34 
35 INITSTRUCT MACRO * gsize,&offset, &value, &count 
36 DS .W 0 
37 IFC \4! yi! 
38 COUNT\@ SET 0 
39 ENDC 
40 IFNC \4t,' 
Al COUNT\G SET \4 
42 ENDC 
43 CMD\G SET (CAL) <4) !COUNTYG) 
44 IPLE (\2)-255 
45 DC.B (CMD\@) 1 $80 
46 DC.B \2 
47 MEXIT 
48 ENDC 
49 DC.B CMD\(@! $OCO 
50 DC.B (((\2)>>16) &SOFF) 
51 DC.W ( (\2)&SOFFFF) 
52 ENDM 
53 
54 ENDC ; EBXEC_INITIALIZERS_ I 














oc - a 





Sep 


WOMAN US WDHE 


28 17:13 1988 exec/interrupts.i Page 1 Sep 28 17:13 1988 exec/interrupts.i Page 2 


IFND EXEC_INTERRUPTS_I 70 ENDC ; EXEC_INTERRUPTS_I 
EXEC_INTERRUPTS_I SET 1 
aK 
x $Filename: exec/interrupts.i $ 
id $Release: 1.3 $ 
KK 
aK 
xk 
ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
eK All Rights Reserved 


Kk 


IFND EXEC_NODES I 
INCLUDE “exec/nodes.i'" 
ENDC ; EXEC_NODES_T 


IFND EXEC_LISTS_I 
INCLUDE "exec/lists.i" 
ENDC ; EXEC_LISTS_ TI 


STRUCTURE IS,LN_SIZE 
APTR IS_DATA 
APTR IS_CODE 
LABEL IS_SIZE 


STRUCTURE IV,0 
APTR IV_DATA 
APTR IV_CODE 
APTR IV_NODE 
LABEL IV_SIZE 


Bo System Flag bits (in SysBase.SysFlags ) 
BITDEF S,SAR,15 * scheduling attention required 


BITDEF S,TOQE,14 * time quantum expended ~~ time to resched 
BITDEF $,SINT,13 





STRUCTURE SH,LH_SIZE 
UWORD  SH_PAD 
LABEL  SH_SIZE 


SIH_PRIMASK EQU $OFO 
SIH_QUEUES EQU 


xx this is a fake INT definition, used only for AddIntServer and the like 
BITDEF INT,NMI,15 








T€ ~ a 





Sep 


WOWNHANS WHE 





28 17:13 1988 


EXEC_IO_I 
kk 


xk 
xx 
Kk 
ak 


exec/io.i Page 1 


IFND EXEC_IO_I 


SET 1 


$Filename: exec/io.i $ 
$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


IFND EXEC_PORTS_I 
INCLUDE "exec/ports.i" 
ENDC ; EXEC_PORTS_T 


IFND EXEC_LIBRARIES_I 
INCLUDE "exec/libraries.i" 
ENDC 7; EXEC_LIBRARIES_I 


STRUCTURE I0O,MN_SIZE 
APTR IO_DEVICE 
APTR IO_UNIT 
UWORD IO_COMMAND 
UBYTE IO_FLAGS 
BYTE TO_ERROR 
LABEL IO_SIZE 


—--- Standard IO request extension: 


ULONG IO_ACTUAL 
ULONG IO_LENGTH 
APTR IO_DATA 

ULONG TO_OFFSET 
LABEL IOSTD_SIZE 


—-—— IO_FLAGS bit definitions: 


BITDEF I0,QUICK,0 


LIBINIT 


LIBDEF . DEV_BEGINIO 
LIBDEF DEV_ABORTIO 


Required portion of IO request: 


device node pointer 
unit (driver private) 
device command 
special flags 

error or warning code 


OF 


actual # of bytes transfered 
requested # of bytes transfered 
pointer to data area 

offset for seeking devices 


eee 


* complete IO quickly 


* process IO request 
* abort IO request 





117 
118 
119 
120 
121 








invalid command 

reset as if just inited 
standard read 

standard write 

write out all buffers 
clear all buffers 

hold current and queued 
restart after. stop 
abort entire queue 


value: 


28 17:13 1988 exec/io.i Page 2 
BEGINIO MACRO 
LINKLIB DEV_BEGINIO, IO_DEVICE(A1) 
ENDM 
ABORTIO MACRO 
LINKLIB DEV_ABORTIO, 10_DEVICE(A1) 
ENDM 
a 
*x 
* Standard Device Command Definitions 
* 
dE 
Boo Command definition macro: 
DEVINIT MACRO * [baseoffset] 
IFC 1! , ot 
CMD_COUNT SET CMD_NONSTD 
ENDC 
IENC Natt 
CMD_COUNT SET \L 
ENDC 
ENDM 
DEVCMD MACRO * omdname 
\1 EQU CMD_COUNT 
CMD_COUNT SET CMD_COUNT+1 
ENDM 
a Standard device commands: 
DEVINIT 0 
DEVCMD CMD_INVALID * 
DEVCMD CMD_RESET * 
DEVCMD CMD_READ * 
DEVCMD CMD_WRITE * 
DEVCMD CMD_UPDATE * 
DEVCMD CMD_CLEAR * 
DEVCMD CMD_STOP * 
DEVCMD CMD START * 
DEVCMD CMD_FLUSH * 
*—-— First non-standard device command 
DEVCMD CMD_NONSTD 
ENDC ; EXEC_IO_1I 











ce - a 











Sep 


rt 
DYONDU PUNE 


28 17:13 1988 exec/libraries.i Page 1 


IFND EXEC_LIBRARIES_I 


EXEC_LIBRARIES_I SET 1 


xk 
xk 
kk 
xk 
xk 
xk 
Kk 
KK 
kk 


$Filename: exec/libraries.i $ 
$SRelease: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND EXEC_NODES_I 
INCLUDE “exec/nodes.i" 
ENDC ; EXEC_NODES I 


——~—— Special CONStants mmr 


LIB_VECTSIZE EQU 6 
LIB_RESERVED EQU 4 


LIB_BASE EQU 
LIB_USERDEF EQU 
LIB_NONSTD EQU 


*—— 


LIBINIT 


COUNT _LIB SET 


$SFFFFFFFA * (-LIB_VECTSIZE) 
LIB _BASE-(LIB_RESERVED*LIB_VECTSIZE) 
LIB_USERDEF 


---- LIBINIT sets base offset for library function definitions: 


MACRO x [baseoffset] 
IFC NT, t! 
LIB_USERDEF 


AL! 


ENDC 
IFNC 


COUNT LIB SET \L 


LIBDEF 


\l 


COUNT_LIB SET 


ENDC 
ENDM 





---— LIBDEF is used to define each library function entry: 


MACRO * libraryFunctionSymbol 
EQU COUNT_LIB 
COUNT_LIB-LIB_VECTSIZE 
ENDM 


LIBINIT LIB _BASE 


LIBDEFP 
LIBDEF 
LIBDEF 
LIBDEF 


LIB_OPEN 
LIB_CLOSE 
LIB_EXPUNGE 


LIB_EXTFUNC * reserved * 


Standard Library Data Structure 





Sep 28 17:13 1988 exec/libraries.i Page 2 





TQ Rn 
71 

72 STRUCTURE LIB,LN_SIZE 

73 UBYTE LIB FLAGS 

74 UBYTE LIB_pad 

75 UWORD  LIB_NEGSIZE * number of bytes before LIB 
76 UWORD LIB _POSSIZE * number of bytes after LIB 
77 UWORD LIB VERSION * major 

78 UWORD = LIB_REVISION * minor 

79 APTR LIB _IDSTRING * identification 

80 ULONG LIB _SUM * the checksum itself 

81 UWORD LIB_OPENCNT * number of current opens 
82 LABEL LIB_SIZE 

83 

84 

B5 kee LIB_FLAGS bit definitions: 

86 

87 BITDEF LIB,SUMMING,0 * we are currently checksumming 
88 BITDEF LIB,CHANGED, 1 * we have just changed the lib 
89 BITDEF LIB,SUMUSED,2 * set if we should bother to sum 
90 BITDEF LIB,DELEXP, 3 * delayed expunge 

91 

92 

93 x -——- 5 
94 * 

95 * Function Invocation Macros 

96 * 

Q] *-------- ne 
98 

99 *#—— CALLLIB for calling functions where A6 is already correct: 
100 

101 CALLLIB MACRO * functionOffset 

102 IFGT NARG-1 . 

103 FAIL !!4 CALLLIB MACRO ~ too many arguments !!! 

104 ENDC 

105 JSR \1(A6) 

106 ENDM 

107 

108 

109 *----—— LINKLIB for calling functions where A6 is incorrect: 

110 

111 LINKLIB MACRO * functionOffset,libraryBase 

112 IFGT NARG-2 

113 FAIL !!! LINKLIB MACRO - too many arguments !!! 

114 ENDC 

115 MOVE.L A6,~-(SP) 

116 MOVE.L \2,A6 

117 CALLLIB \1 

118 MOVE.L (SP)+,A6 

119 ENDM 

120 

121 ENDC ; EXEC_LIBRARIES_I 











€€ -~ a 








Sep 28 17:13 1988 exec/lists.i Page 1 |Sep 28 17:13 1988 exec/lists.i Page 2 








1 IFND EXEC_LISTS_I IFNOTEMPTY MACRO * list,label 
2 EXEC_LISTS_I SET 1 CMP. LH_TAIL+LN_PRED(\1) 1 
3 kK BNE \2 
4 xk $Filename: exec/lists.i $ ENDM 
5 ** SRelease: 1.3 $ 
6 ** TSTNODE MACRO * node,next 
7 ** MOVE.L (\1),\2 
Q xx TST.L (\2) 
9 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. ENDM 
10 ** All Rights. Reserved 
ll ** NEXTNODE MACRO * next,current,exit_label (DX,AX,DISP16) 
12 MOVE.L \1,\2 
13 IFND EXEC_NODES_I MOVE.L (\2),\1 
14 INCLUDE "“exec/nodes.i" TFC "\o','! 
15 ENDC ; EXEC_NODES_I BEQ \3 
16 ENDC 
17 IFNC ‘\o',t! 
jQ *-----—---------~--— ~~~ BEQ.S \3 
19 * ENDC 
20 * List Structures ENDM 
21 * 
Dm I ADDHEAD MACRO 
23 MOVE.L (AQ) ,;DO 
24 ; normal, full featured list MOVE.L Al1,(A0) 
25 STRUCTURE 1LH,0 MOVEM.L DO/AO, (AL) 
26 APTR LH_HEAD MOVE.L DO,AO 
27 APTR LH TAIL MOVE.L AlL,LN_PRED(AQ) 
28 APTR LH_TATLPRED ENDM 
29 UBYTE LH_TYPE 
30 UBYTE LH_pad ADDTAIL MACRO 
31 LABEL LH_SIZE LEA LH_TAIL( AQ) ,A0 
32 MOVE.L LN _PRED(AOQ) ,DO 
33 ; minimal list, no type checking possible MOVE.L Al1,LN_PRED(A0) 
34 STRUCTURE MLH,0 MOVE.L AO,(A1) 
35 APTR MLH_HEAD MOVE.L DO,LN_PRED(A1) 
36 APTR MLH_TAIL MOVE.L DO0,A0 
37 APTR MLH TATLPRED MOVE.L Al1,(AQO) 
38 LABEL MLH_ SIZE ENDM 
39 
40 REMOVE MACRO 
41 NEWLIST MACRO * list MOVE.L (A1L),A0 
42 MOVE.L \1,(\1) MOVE.L IN _PRED(A1),AlL 
43 ADDO.L = #LH_ TAIL, (\1) MOVE.L AO, (Al) 
44 CLR.L  LH_TAIL(\1) MOVE.L Al,LN_PRED(AO) 
45 MOVE.L \1,(LH_TAIL+LN_PRED)(\1) ENDM 
46 ENDM 
47 REMHEAD MACRO 
48 TSTLIST MACRO * [list] MOVE.L (AQ),AL 
49 IFC Nt MOVE.L (AL) ,DO 
50 CMP.L LH TAIL+LN_PRED(AO),AO BEQ.S REMHEAD\G@ 
51 ENDC MOVE.L DO,{AQ) 
52 IFNC Natt! EXG.L DO,Al 
53 CMP.L LH 'TAIL+LN_PRED(\1),\1 MOVE.L AO,LN_PRED(A1) 
54 ENDC REMHEAD\(@ 
55 ENDM. ENDM 
56 
57 SUCC MACRO * node,suce Pe 
58 MOVE.L (\1),\2 : 
59 ENDM * REMHEADQ —— remove-head quickly 
60 x 
61 PRED MACRO * node,pred * Useful when a scratch register is available, and 
62 MOVE.L LN_PRED(\1),\2 * list is known to contain at least one node. 
63 ENDM * 
64 Yo 
65 IFEMPTY MACRO * list, label 
66 CMP.L LH TAIL+LN_PRED(\1),\1 REMHEADQ MACRO * head,node,scratchReg 
67 BEQ \2 MOVE.L (\1),\2 
68 ENDM MOVE.L (\2),\3 
69 MOVE.L \3,(\1) 














pe - a 














Sep 28 17:13 1988 exec/lists.i Page 3 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 





MOVE.L \1,LN_PRED(\3) 
ENDM 
REMTAIL MACRO 
MOVE.L LH_TAIL+LN_PRED(AO) ,Al 
MOVE.L LN_PRED(A1) ,DO 
BEQ.S REMTAIL\@ 
MOVE.L DO,LH_TAIL+LN_PRED(AO) 
EXG.L  DO,Al 
MOVE.L AO, (AL) 
ADDO.L #4, (AL) 
REMTAIL\@ 
ENDM 
ENDC ; EXEC_LISTS_I 


Sep 


WOnNDUEPWDHNE 


28 17:13 1988 exec/memory.i Page 1 


IFND EXEC_MEMORY_I 


EXEC_MEMORY_T SET 1 


kk 
Kk 
xk 
xk 
Kk 
Kk 
wk 
xk 
kk 


ee 


ee HH HH HH 


$Filename: exec/memory.i $ 
SRelease: 1.3 $ 


definitions for use with the memory allocator 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


TFND EXEC_NODES_I 
INCLUDE “exec/nodes.i" 
ENDC ; EXEC_NODES T 


A memory list appears in two forms: One is a requirements list* 
the other is a list of already allocated memory. The format is 
the same, with the reqirements/address field occupying the same 
position. 


The format is a linked list of ML structures each of which has 
an array of ME entries. 


STRUCTURE Ml, LN_SIZE 


UWORD ML NUMENTRIES * The number of ME structures that follow 
LABEL ML ME * where the ME structures begin 
LABEL ML_SIZE 


STRUCTURE ME,0 


LABEL ME _REQS 
APTR ME_ADDR 


the AllocMem requirements 

the address of this block (an alias 
for the same location as ME_REQS) 

the length of this region 


+ + FO 


ULONG  ME_LENGTH 
LABEL ME _SIZE 


*—---——— memory options: 


BITDEF MEM,PUBLIC,0 
BITDEF MEM,CHIP,1 
BITDEF MEM,FAST,2 
BITDEF MEM,CLEAR, 16 
BITDEF MEM, LARGEST ,17 


*——---- alignment rules for a memory block: 


MEM_BLOCKSIZE EQU 8 
MEM _ BLOCKMASK EQU (MEM _BLOCKSIZE-1) 


STRUCTURE MH,LN_SIZE 





se - a 


Sep 28 17:13 1988 exec/memory.i Page 2 


UWORD -MH_ATTRIBUTES 
APTR MH FIRST 

APTR MH LOWER 

APTR §_MH_UPPER 
ULONG MH_FREE 

LABEL MH SIZE 


STRUCTURE MC,0 
APTR = MC_NEXT 
ULONG MC_BYTES 
LABEL MC SIZE 


ENDC ; EXEC_MEMORY_I 





characteristics of this region 
first free region 

lower memory bound 

upper memory bound+1 

number of free bytes 


* + 4 OM 


* ptr to next chunk 
* chunk byte size 





Sep 


WON NKDUSWNE 


28 17:13 1988 exec/nodes.i Page 1 


IFND  _EXEC_NODES_I 


EXEC_NODES_I SET 1 

Ks 

ak $Filename: exec/nodes.i $ 

*e $Release: 1.3 $ 

kk 

xk 

xk 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 


ak 


STRUCTURE 1N,0 
APTR LN_SUCC 
APTR LN_PRED 
UBYTE LN_TYPE 
BYTE LN_PRI 
APTR LN_NAME 
LABEL LN_SIZE 


; min node —- only has minimum necessary, no type checking possible 
STRUCTURE MLN,0 
APTR MLN_SUCC 
APTR MLN_PRED 
LABEL MLN_SIZE 


x-~-—-— Node Types: 
NT_UNKNOWN EQU 0 
NT_TASK EQU 1 
NT_INTERRUPT EQU 2 ; also for software interrupt node 
NT_DEVICE EQU 3 
NT_MSGPORT EQU 4 
NT_MESSAGE EQU 5 
NT_FREEMSG EQU 6 
NT_REPLYMSG EQU 7 
NT_RESOURCE EQU 8 
NT_LIBRARY EQU 9 
NT_MEMORY EQU 10 
NT_SOFTINT EQU 11 ; exec private 
NE_FONT EQU 12 
NT_PROCESS EQU 13 
NT_SEMAPHORE EQU 14 
NT_SIGNALSEM EQU 15 ; signal semaphores 
NT_BOOTNODE EQU 16 
ENDC ; EXEC_NODES_I 














9€ - a 











Sep 28 17:13 1988 exec/ports.i Page 1 Sep 28 17:13 1988 exec/resident.i Page 1 











1 IFND EXEC_PORTS_I 1 IFND EXEC_RESIDENT_I 

2 EXEC_PORTS_I SET 1 2 EXEC_RESIDENT_I SET L 

3 ak 3 kk 

4 ** $Filename: exec/ports.i $ 4 ** SPilename: exec/resident.i $ 

5 ** $Release: 1.3 $ 5 ** SRelease: 1.3 $ 

6 ** 6 kk 

7 ** 7 owe 

B xx QB xx 

Q *x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. Q xx (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 

Li o** ll ** 

12 12 

13 IFND EXEC_NODES_I LQ Rm 
14 INCLUDE "“exec/nodes.i" 14 * 

15 ENDC ; EXEC_NODES_I 15 * Resident Module Tag 

16 16 * 

17 IFND EXEC_LISTS_I TR 
18 INCLUDE "exec/lists.i" 18 

19 ENDC ; EXEC_LISTS_I 19 STRUCTURE RT,0O 

20 20 UWORD RT_MATCHWORD * word to match 

21 21 APTR RT_MATCHTAG * pointer to structure base 
DQ 22 APTR  RT_ENDSKIP * address to continue scan 
23 * 23 UBYTE RT_FLAGS * various tag flags 

24 * Message Port Structure 24 UBYTE RT_VERSION * release version number 
25 * 25 UBYTE RT_TYPE * type of module 

DER 26 BYTE RT_PRI * initialization priority 
27 27 APTR RT_NAME * pointer to node name 
28 STRUCTURE MP,LN SIZE 28 APTR RT_IDSTRING * pointer to id string 
29 UBYTE MP_FLAGS 29 APTR RT_INIT * pointer to init code 
30 UBYTE MP_SIGBIT * signal bit number 30 LABEL RT_SIZE 

31 APTR MP_SIGTASK * task to be signalled 31 

32 STRUCT MP_MSGLIST,LH_SIZE x message linked list 32 

33 LABEL MP_SIZE 330 *#----—— Match word definition: 

34 34 

35 35 RTC_MATCHWORD EQU S4AFC * (ILLEGAL instruction) 
36% unions: 36 

37 37 

38 MP_SOFTINT EQU MP_SIGTASK 38 Bom RT_FLAGS bit and field definitions: 

39 9 

40 40 BITDEF RT,COLDSTART, 0 

4] *------ flags fields: ‘o BITDEF RT,AUTOINIT,7 * RT_INIT points to data 
42 

43 PF_ACTION EQU 3 43 * Compatibility: 

44 44 RTM_WHEN EQU 1 * field position in RT_FLAGS 
45 45 RTW_NEVER EQU 0 * never ever init 

46 *----—— PutMsg. actions: io RTW_COLDSTART EQU L * init at coldstart time 
47 

48 PA_SIGNAL EQU 0 48 ENDC ; EXEC_RESIDENT_I 

49 PA_SOFTINT FQU 1 

50 PA_IGNORE EQU 2 

51 

52 

53 *------- oe 

54 * 

55 * Message Structure 

56 

57 k-------- 

58 

59 STRUCTURE MN,LN- SIZE 
60 APTR MN_REPLYPORT * message reply port 
61 UWORD = MN_LENGTH * message len in bytes 
62 LABEL MN_SIZE 
63 


64 ENDC 7; EXEC_PORTS_TI 

















4€-4@ 


Sep 28 17:13 1988 exec/semaphores.i Page 1 Sep 28 17:13 1988 exec/strings.i Page 1 








1 IFND EXEC_SEMAPHORES_I 1 IFND EXEC_STRINGS_T 
2 EXEC_SEMAPHORES_I SET 1 2 EXEC_STRINGS_I SET 1 
3 xx 3 °** 
4 ** $Filename: exec/semaphores.i $ 4 xk $Filename: exec/strings.i $ 
5 ** $Release: 1.3 $ 5 ** $SRelease: 1.3 $ 
6 kk 6 xx 
7 ** 7 nk 
8 kk 8 kk 
9. ee (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. Q9 ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 
ll ** ll ** 
12 12 
13 IFND EXEC_NODES_I 130 %--- Terminal Control: 
14 INCLUDE "exec/nodes.i" 14 
15 ENDC ; EXEC_NODES_I 15 EOS EQU 0 
16 16 BELL EQU 7 
L7 IFND EXEC_LISTS_I 17 LF : EQU 10 
18 INCLUDE "“exec/lists.i" 18 CR EQU 13 
19 ENDC 3; EXEC_LISTS_I 19 BS EQU 8 
20 . 20 DEL EQU S7F 
21 IFND EXEC _PORTS_I 21 NL EQU LF 
22 INCLUDE "exec/ports.i" 22 
23 ENDC ; EXEC_PORTS_I 23 
24 QI Rn 
25 25 * 
DR OE 26 * String Support Macros 
27 * 27 
28 * Semaphore. Structure DBR I 
29 * 29 
30 *-------------- rr ct aI 30 STRING MACRO 
31 31 DC.B \l 
32 32 DC.B 0 
33 STRUCTURE SM,MP_SIZE 33 CNOP 0,2 
34 WORD SM_BIDS * number of bids for lock 34 ENDM 
35 LABEL SM_SIZE 35 
36 36 
37 37 STRINGL MACRO 
38 *-----— unions: 38 DC.B 13,10 
39 39 DC.B Al 
40 SM_LOCKMSG EQU MP_SIGTASK 40 DC.B 0 
41 41 CNOP 0,2 
42 42 ENDM 
I 43 
44 * 44 
45 * Signal Semaphore Structure 45 STRINGR MACRO 
46 * 46 DC.B \1 
IT Ri a 47 DC.B 13,10,0 
48 48 CNOP 0,2 
49 * this is the structure used to request a signal semaphore —— allocated 49 ENDM 
50 * on the fly by ObtainSemaphore( ) 50 
51 STRUCTURE SSR,MLN_SIZE 51 
52 APTR SSR_WAITER 52 STRINGLR MACRO 
53 LABEL SSR_SIZE , 53 DC.B 13,10 
54 54 DC.B AL 
55 55 DC.B 13,10,0 
56 * this is the actual semaphore itself -—- allocated statically 56 CNOP 0,2 
57 STRUCTURE SS,LN_SIZE 57 ENDM 
58 SHORT SS_NESTCOUNT 58 
59 STRUCT SS_WAITQUEUE,MLH SIZE 59 ENDC ;} EXEC_STRINGS T 
60 STRUCT . SS_MULTIPLELINK,SSR_SIZE 
61 APTR SS_OWNER 
62 SHORT SS_QUEUECOUNT 
63 LABEL SS_SIZE 
64 


65 ENDC 7; EXEC_SEMAPHORES_T 








ge - a 


Sep 


be 
HOUDNAUEBWNE 


12 


28 17:13 1988 exec/tasks.i Page 1 








IFND EXEC_TASKS_ I 


EXEC_TASKS_I SET 1 
Kk 


xk 
xx 
xk 
kk 
xk 
kk 
kk 
xk 


$Filename: exec/tasks.i $ 


S$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 


All Rights Reserved 


IFND EXEC_NODES_I 
INCLUDE “exec/nodes.. i" 
ENDC ; EXEC_NODES I 


IFND EXEC_LISTS I 
INCLUDE "exec/lists.i" 
ENDC ; EXEC_LISTS_T 


STRUCTURE TC,LN_SIZE 


UBYTE TC_FLAGS 
UBYTE TC_STATE 
BYTE TC_IDNESTCNT 
BYTE TC_TDNESTCNT 


ULONG TC_SIGALLOC 
ULONG TC_SIGWAIT 
ULONG TC_SIGRECVD 
ULONG TC_SIGEXCEPT 
UWORD TC_TRAPALLOC 
UWORD TC_TRAPABLE 


APTR TC_EXCEPTDATA 
APTR TC_EXCEPTCODE 
APTR TC_TRAPDATA 
APTR TC_TRAPCODE 
APTR TC_SPREG 

APTR TC_SPLOWER 
APTR TC_SPUPPER 
APTR TC_SWITCH 
APTR TC_LAUNCH 
STRUCT TC_MEMENTRY,LH_SIZE 
APTR TC_Userdata 
LABEL TC_SIZE 


—-—— Flag Bits: 


BITDEF T,PROCTIME,0 
BITDEF T,STACKCHK,4 
BITDEF T,EXCEPT,5 
BITDEF T,SWITCH,6 
BITDEF T,LAUNCH,7 


——-~ Task States: 
0 


TS_INVALID EQU 


TS ADDED EQU TS_INVALID+1 
TS_RUN EQU TS_ADDED+1 
TS_READY EQU TS_RUN+1 
TS_WAIT EQU TS_READY+1 
TS_EXCEPT EQU TS_WAIT+1 


TS REMOVED EQU 


TS_EXCEPT+1 


+. Oe HH HF HH HF HH HH HH HH 


intr disabled nesting 
task disabled nesting 
sigs allocated 

sigs we are waiting for 
sigs we have received 
sigs we take as exceptions 
traps allocated 

traps enabled 

data for except proc 
exception procedure 
data for proc trap proc 
proc trap procedure 
stack pointer 

stack lower bound 

stack upper bound + 2 
task losing CPU 

task getting CPU 
allocated memory 





28 17:13 1988 exec/tasks.i Page 2 


x System Task Signals: 
SIGF_ABORT EQU $0001 
SIGF_CHILD EQU $0002 
SIGF_BLIT EQU $0010 
SIGF_SINGLE EQU $0010 
SIGF_DOS EQU $0100 
SIGB_ ABORT EQU 0 
SIGB_ CHILD EQU 1 
SIGB_BLIT EQU 4 
SIGB_SINGLE EQU 4 
SIGB_DOS EQU 8 
SYS_SIGALLOC EQU SOFFFF 
SYS_TRAPALLOC EQU $08000 


ENDC 


; EXEC_TASKS I 





; pre-allocated signals 
; pre-allocated traps 

















Sep 28 17:13 1988 exec/types.i Page 1 Sep 28 17:13 1988 exec/types.i Page 2 






























































1 IFND EXEC_TYPES I 70 ENDM 
2 EXEC_TYPES I SET 1 71 
3 ** 72 APTR MACRO 
4 ** $Filename: exec/types.i $ 73\1 EQU SOFFSET 
5 ** $Release: 1.3 $ 74 SOFFSET SET SOFFSET+4 
6 ** 75 ENDM 
7 kk 7 6 
B xx 77 CPTR MACRO 
Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 \1 EQU SOFFSET 
10 ** All Rights Reserved 79 SOFFSET SET SOFFSET+4 
1l ** 80 ENDM 
12 81 
13 EXTERN_LIB MACRO 82 RPTR MACRO 
14 XREF = _LVO\1 83 \l EQU SOFFSET 
15 ENDM . 84 SOFFSET SET SOFFSET+2 
16 85 ENDM 
17 STRUCTURE MACRO 86 
18 \1 EQU 0 * for assembler's sake 87 STRUCT MACRO 
19 SOFFSET SET \2 88 \l EQU SOFFSET 
20 ENDM 89 SOFFSET SET SOFFSET+\2 
21 90 ENDM 
22 BOOL MACRO 91 
23 \1 EQU SOFFSET 92 LABEL MACRO 
24 SOFFSET SET SOFFSET+2 93 \1 EQU SOFFSET 
25 ENDM 94 ENDM 
26 95 
27 BYTE MACRO 96 te bit definition macro ~——-—o oo rr 
28 \1 EQU SOFFSET 97 * 
29 SOFPSET SET SOFFSET+1 98 * Given: 
30 ENDM 99 * 
31 100 * BITDEF MEM,CLEAR,16 
32 UBYTE MACRO 101 * 
FI) 33 \1 EQU SOFFSET 102 * Yields: 
t] 34 SOFFSET SET SOFFSET+1 103 * 
w| 35 ENDM 104 * MEMB CLEAR EQU 16 
©] 36 105 * MEMF CLEAR EQU (1.SL.MEMB_ CLEAR) 
37 WORD MACRO 106 * 
38 \L EQU SOFFSET 107 
39 SOFFSET SET SOFFSET+2 108 BITDEF MACRO * prefix, &name, &bitnum 
40 ENDM 109 BITDEFO \1,\2,B_,\3 
41 110 \@BITDEF SET 1<<\3 
42 UWORD MACRO lll BITDEFO \1,\2,F_,\@BITDEF 
43 \1 EQU SOFFSET 112 ENDM 
44 SOFFSET SET SOFFSET+2 113 
45 ENDM 114 BITDEFO MACRO * prefix, &name, &type, &value 
46 115 \I\3\2 EQU \4 
47 SHORT MACRO 116 ENDM 
48 \1 EQU SOFFSET 117 
49 SOFFSET SET SOFFSET+2 118 LIBRARY_VERSION EQU 34 
50 ENDM 119 
51 120 ENDC 7 EXEC_TYPES_T 
52 USHORT MACRO 
53 \L EQU SOFFSET 
54 SOFFSET SET SOFFSET+2 
55 ENDM 
56 
57 LONG MACRO 
58 \l EQU SOFFSET 
59 SOFFSET SET SOPFSET+4 
60 ENDM 
62 ULONG MACRO 
63 \l EQU SOFFSET 
64 SOFFSET SET SOFFSET+4 
ENDM 
FLOAT MACRO 
Al EQU SOFFSET 
SOFFSET SET SOFFSET+4 





OvV-a 


Sep 


WOnNINAUPWNE 





28 17:20 1988 graphics/clip.i Page 1 
LFND GRAPHICS CLIP_I 
GRAPHICS_CLIP_I SET 
xk 
ak $Filename: graphics/clip.i $ 
*k $Release: 1.3 $ 
ak 
Kk 
nk 
** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 
wk 
IFND GRAPHICS GFX_I 
include "graphics/gfx.i" 
ENDC 
IFND EXEC_SEMAPHORES_I 
include "exec/semaphores.i" 
ENDC 
NEWLOCKS equ. L 
STRUCTURE Layer,0 
LONG lr_front 
LONG lr_back 
LONG lr ClipRect. 
LONG lr_rp 
WORD lr Minx 
WORD lr Miny 
WORD lyr Maxx 
WORD lr _MaxyY 
STRUCT lr_reserved,4 
WORD lr_ priority 
WORD lr_Flags 
LONG lr_SuperBitMap 
LONG lr _SuperClipRect 
APTR lr_Window 
WORD lr_Scroll_X 
WORD lr Scroll_Y- 
APTR lr_cr 
APTR lr_cr2 
APTR lr_crnew 
APTR lr _ SuperSaverClipRects 
APTR lr__cliprects 
APTR lr_LayerInfo 
* just by lucky coincidence 
* this is not confused with simplesprites 
STRUCT Ilr _Lock,SS_SIZE 
STRUCT Ilr _reserved3,8 
APTR lr_ClipRegion 
APTR lr_saveClipRects 
STRUCT lr_reserved2 ,22 
APTR lr DamageList 
LABEL lr SIZEOF 
STRUCTURE ClipRect,0 
LONG cr_Next 
LONG er_prev 
LONG cr_lobs 
LONG cr_BitMap 
WORD cr Minx 
WORD cer MinYy 
WORD cr_MaxXx 
WORD exr_MaxY 
APTR cr_ pl 
APTR cr p2 
LONG cr_reserved 
LONG er_Flags 
LABEL cr_SIZEOF 





28 17:20°1988 graphics/clip.i Page 2 


* internal cliprect flags 
CR_NEEDS_NO_CONCEALED_RASTERS equ 


x defines for clipping 
ISLESSX equ 1 
ISLESSY equ 2 
ISGRTRX equ 4 
ISGRTRY equ 8 


* for ancient history reasons 
IFND ir_Front 


lr_Front equ lr_front 
lr_Back equ lr_back 
lr _RastPort equ ir 
cr_Prev equ cr_prev 
cr_LObs equ cr_lobs 
ENDC 
ENDC ; GRAPHICS CLIP_I 


Tv - a 


Sep 


WAN NUP WHE 





28 17:21 1988 graphics/copper.i Page 1 
IFND GRAPHICS COPPER_I 

GRAPHICS _COPPER_I SET 1 

kk 


we 
xk 
* 
xk 
xk 
xk 
Kk 
Kk 


COPPER_MOVE equ 0 
COPPER_WAIT equ 1 


CPRNXTBUF equ 2 /7* continue processing with next buffer */ 
CPR_NT_LOF equ $8000 /* copper instruction only for short frames */ 
CPR_NT_SHT equ $4000 /* copper instruction only for long frames */ 
STRUCTURE CopIns ,0 

WORD ci_OpCode * 0 = move, 1 = wait */ 

STRUCT cl_nxtlist,0 * UNION 

STRUCT cl VWaitPos ,0 

STRUCT  ci_DestAddr,2 

STRUCT  ci_HWaitPos,0 

STRUCT ci_DestData,2 


* structure of cprlist that points to list that hardware actually executes */ 


$Filename: graphics/copper.i $ 
$Release: 1.3 $ 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


/* pseude opcode for move #XXXX,dir */ 
/* pseudo opcode for wait y,x */ 


LABEL ci_SIZEOF 


STRUCTURE 
APTR crl_Next 
APTR crl_start 
WORD crl_MaxCount 

LABEL crl_SIZEOF 


eprlist,0 


STRUCTURE Cophist ,0 
APTR cl_Next /* next block for this copper list */ 
APTR cl_Cophist /* system use */ 
APTR cl_ ViewPort /* system use */ 
APTR cl _CopiIns /* start of this block */ 
APTR cl_CopPtr /* intermediate ptr */ 
APTR cl_CopLStart /* mrgcop fills this in for Long Frame*/ 
APTR cl_CopsStart /* mrgcop fills this in for Short Frame*/ 
WORD cl_Count /* intermediate counter */ 
WORD ci_MaxCount /* max # of copins for this block */ 
WORD cl_DyOffset /* offset this copper list vertical waits */ 
LABEL cl_SIZEOF 
STRUCTURE UCophist ,0 
APTR ucl_Next 
APTR ucl_ FirstCopList /* head node of this copper list */ 
APTR ucl_CopList /* node in use */ 


LABEL ucl_SIZEOF 


private graphics data structure 


STRUCTURE copinit,0 
STRUCT  copinit_diagstrt,8 
STRUCT copinit _sprstrtup,2*( (2*8*2)+2+(2*2)+2) 
STRUCT  copinit_sprstop,4 


LABEL copinit_SIZEOF 


ENDC ; GRAPHICS _COPPER_I 








Sep 


bet be 
FPOWUONAUSFWNE 


28 17:21 1988 graphics/display.i Page 1 
IFND GRAPHICS_DISPLAY_I 
GRAPHICS_DISPLAY_I SET 1 
Kk 
*e $Filename: graphics/display.i $ 
ae $Release: 1.3 $ 
KK 
xx include define file for display control registers 
Kk 
xe (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
x All Rights Reserved 
Kk 
* bplcon0 defines 
MODE_640 equ $8000 
PLNCNIMSK equ $7 * how many bit planes? 
* * 0 = none, 1->6 = 1-6, 7 = reserved 
PLNCNTSHF® equ 12 * bits to shift for bplcon0 
PF2PRI equ $40 * bplcon2 bit 
COLORON equ $0200 * disable color burst 
DBLPF equ $400 
HOLDNMODIFY equ $800 
INTERLACE equ 4 * interlace mode for 400 


* bplconl defines 
PFA_FINE_SCROLL equ $F 
PFB_FINE_SCROLL_SHIFT equ 4 


PF_FINE_SCROLL_MASK 


equ SF 


* display window start and stop defines 


DIW_HORIZ POS equ $7F * horizontal start/stop 
DIW_VRTCL_POS equ $lFF * vertical start/stop 
DIW_VRECL_POS SHIFT equ 7 , 


* Data. fetch start/stop horizontal position 


DFTCH_MASK equ $FF 

* vposr bits 

VPOSRLOF equ $8000 
ENDC ; GRAPHICS_DISPLAY_T 











ce - a 











28 17:21 1988 graphics/gels.i Page 1 














28 17:21 1988 graphics/gels.i Page 2 


1 IFND GRAPHICS_GELS_I 70 APTR vs_DrawPath ; struct *vSprite: pointer of overlay drawing 
2 GRAPHICS_GELS_I SET 1 71 APTR vs_ClearPath ; struct *vSprite: pointer for overlay clearing 
3 kK 72 * the vSprite positions are defined in (y,x) order to make sorting 
4 ** $Pilename: graphics/gels.i $ 73 * sorting easier, since (y,x) as a long integer 
5 ** $SRelease: 1.3 $ 74 WORD vs_Oldy ; previous position 
6 ** 75 WORD vs_Oldx i 
7 ** include file for AMIGA GELS (Graphics Elements) 76 * —- COMMON VARIABLES ~- 
8 ** 77 WORD vs_VSFlags ; vSprite flags 
Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 78 *  -~ USER VARIABLES —— 
10 ** All Rights Reserved 79 * the vSprite positions are defined in (y,x) order to make sorting 
Ll ** go * easier, since (y,x) as a long integer 
12 81 WORD vs_Y ; screen position 
13 *-—----- VS_vSflags -——------~-~--- 82 WORD vs_X 
14 83 WORD vs_Height 
15 * j77 user~set vSprite flags -- 84 WORD vs_Width ; number of words per row of image data 
16 SUSERFLAGS EQU SOOFF ; mask of all user-settable vSprite-flags 85 WORD vs_Depth ; number of planes of data 
17 BITDEF VS,VSPRITE,0 ; set if vSprite, clear if bob 86 WORD vs_MeMask ; which types can collide with this vSprite 
18 BITDEF VS,SAVEBACK, 1 ; set if background is to be saved/restored 87 WORD vs_HitMask ; which types this vSprite can collide with 
19 BITDEF VS,OVERLAY,2 ; set to mask image of bob onto background 88 APTR vs_ImageData ; *WORD pointer to vSprite image 
20 BITDEF VS,MUSTDRAW, 3 ; set if vSprite absolutely must be drawn 89 * borderLine is the one-dimensional logical OR of all 
21 * j-- system-set vSprite flags —- 90 * the vSprite bits, used for fast collision detection of edge 
22 BITDEF VS,BACKSAVED,8 ; this bob's background has been saved 91 APTR vs_BorderLine. ; *WORD: logical OR of all vSprite bits 
23 BITDEF VS,BOBUPDATE ,9 ; temporary flag, useless to outside world 92 APTR vs_CollMask ; *WORD: similar to above except this is a 
24 BITDEF VS,GELGONE,10 ; set if gel is completely clipped (offscreen) 93 * matrix pointer to this vSprite's color definitions (not used by bobs) 
25 BITDEF VS,VSOVERFLOW,11 ; vSprite overflow (if MUSTDRAW set we draw!) 94 APTR vs_SprColors ; *WORD 
26 95 APTR vs_VSBob ; struct *bob: points home if this vSprite is 
27 96 7; part of a bob 
28 %#---—— = B_ flags ----~------——— i 97 * planePick flag: set bit selects a plane from image, clear bit selects 
29 * ;-- these are the user flag bits — 98 * use of shadow mask for that plane 
30 BUSERFLAGS EQU SOOFF ; Mask of all user-settable bob-flags 99 * onoff flag: if using shadow mask to fill plane, this bit (corresponding 
31 BITDEF B,SAVEBOB,0 ; set to not erase bob 100 * to bit in planePick) describes whether to fill with 0's or l's 
32 BITDEF B,BOBISCOMP,] ; set to identify bob as animComp 101 * There are two uses for these flags: 
33 * ;-— these are the system flag bits —— 102 * ~ if this is the vSprite of a bob, these flags describe how 
34 BITDEF B,BWAITING,8 ; set while bob is waiting on ‘after' 103 * the bob is to be drawn into memory 
35 BITDEF B,BDRAWN,9 ; set when bob is drawn this DrawG pass 104 * — if this-is a simple vSprite and the user intends on setting 
36 BITDEF B,BOBSAWAY,10 ; set to initiate removal of bob 105 * the MUSTDRAW flag of the vSprite, these flags must be set 
37 BITDEF B,BOBNIX,11 ; set when bob is completely removed 106 * too to describe which color registers the user wants for 
38 BITDEF B,SAVEPRESERVE,12 ; for back-restore during double-buffer 107 * the image 
39 BITDEF B,OUTSTEP,13 ; for double-clearing if double-buffer 108 BYTE vs_PlanePick 
40 109 BYTE vs_Planeonoff 
4l 110 LABEL vs_SUserExt ; user definable 
42 *----—- defines for the animation procedures -----——-—3 iD LABEL  vs_SIZEOF 
43 
44 ANFRACSIZE EQU 6 113 
45 ANIMHALF EQU $0020 114 *-—--— BOB DO rr i eS 
46 RINGTRIGGER EQU $0001 115 
47 116 STRUCTURE BOB,0 i bob: blitter object 
48 *-———-- macros —~--------< <n nnn 117 *  -- COMMON VARIABLES —- 
49 * these are GEL functions that are currently simple enough to exist as a 118 WORD bob_BobFlags ; general purpose flags (see definitions below) 
50 * definition. It should not be assumed that this will always be the case 119 * —- USER VARIABLES —~- 
51 120 APTR bob_SaveBuffer ; *WORD pointer to the buffer for background 
52 InitAnimate MACRO * ganimKey 121 * save used by bobs for "cookie-cutting" and multi-plane masking 
53 CLR.L AL 122 APTR bob_ImageShadow 7 *WORD 
54 ENDM 123 * pointer to BOBs for sequenced drawing of bobs 
55 124 * for correct overlaying of multiple component animations 
56 125 APTR bob Before ; struct *bob: draw this bob before bob pointed 
57 RemBob MACRO * &b 126 ; to by before 
58 OR.W #BF_BOBSAWAY ,b_BobFlags+\1 127 APTR bob_After ; struct *bob: draw this bob after bob pointed 
59 ENDM 128 ; to by after 
60 129 APTR bob_BobvSprite ; struct *vSprite: this bob's vSprite definition 
6] *-——-—- VS : vSprite ae a 130 APTR bob_BobComp ; struct *animComp: pointer to this bob's 
62 STRUCTURE vsS,0 ; vSprite 131 ; animComp def 
63 * —— SYSTEM VARIABLES -~ 132 APTR bob_bBuffer ; struct dBufPacket: pointer to this bob's 
64 * GEL linked list forward/backward pointers sorted by y,x value 133 ; dBuf packet 
65 APTR vs_NextVSprite ; struct *vSprite 134 LABEL bob_BUserExt ; bob user extension 
66 APTR vs_PrevVSprite ; struct *vSprite 135 LABEL bob_SIZEOF 
67 * GEL draw list constructed in the order the bobs are actually drawn, then 136 
68 * list is copied to clear list 137% BC 5 ALM COMI or 
69 * must be here in vSprite for system boundary detection 138 








ev -da 











Sep 28 17:21 1988 graphics/gels.i Page 3 Sep 28 17:21 1988 graphics/gfx.i Page l 





139 STRUCTURE AC,0 ; animComp 1 IFND GRAPHICS_GFX_I 
140 * —- COMMON VARIABLES —— 2 GRAPHICS_GFX_I SET 

141 WORD ac_CompFlags ; animComp flags for system & user 3 ** 

142 * timer defines how long to keep this component active: 4 xx $Filename: graphics/gfx.i $ 
143 * if set non-zero, timer decrements to zero then switches to nextSeq 5 ** SRelease: 1.3 $ 

144 * if set to zero, animComp never switches 6 ** 

145 WORD ac_Timer 7 ** 

146 * -- USER VARIABLES —— 8 xx 

147 * initial value for timer when the animComp is activated by the system . Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
148 WORD ac_TimeSet 10 ** All Rights Reserved 
149 * pointer to next and previous components of animation object 1l ** 

150 APTR ac_NextComp 7; struct *animComp 12 

151 APTR ac_PrevComp ; struct *animComp 13 BITSET equ $8000 

152 * pointer to component component definition of next image in sequence 14 BITCLR equ 0 

153 APTR ac_NextSeq ; struct *animComp 15 AGNUS equ 1 

154 APTR ac_PrevSeq ; struct *animComp 16 DENISE equ 1 

155 APTR ac_AnimCRoutine ; address of special animation procedure 17 

156 WORD ac_YTrans ; initial y translation (if this is a component) 18 STRUCTURE BitMap,0 

157 WORD ac_XTrans ; initial x translation (if this is a component) 19 WORD bm_BytesPerRow 
158 APTR ac_Headob ; struct *animOb 20 WORD bm_Rows 

159 APTR ac_AnimBob ; struct *bob 21 BYTE bm_Flags 

160 LABEL ac SIZE 22 BYTE bm_ Depth 

161 23 WORD bm_Pad 

VO BRO RLM 24 STRUCT bm_Planes,8*4 

163 25 LABEL bm_SIZEOF 

164 STRUCTURE AO,0 ; animOb 26 

165 * —~ SYSTEM VARIABLES ~~ 27 STRUCTURE Rectangle,0 

166 APTR ao_NextOb i struct *animOb 28 WORD ra_MinX 

167 APTR aco_PrevOb struct *animOb 29 WORD ra_MinY 

168 * number of calls to Animate this animOb has endured 30 WORD ra_MaxX 

169 LONG ao_Clock 31 WORD ra_MaxY 

170 WORD ao_Anoldy ; old y,x coordinates 32 LABEL ra_SIZEOF 

171 WORD ao_Anol1dx i 33 

172 * -— COMMON VARIABLES —— 34 ENDC ; GRAPHICS_GFX_I 
173 WORD ao_AnY ; ¥,x coordinates of the animob 

174 WORD ao_AnX i 

175 * ~~ USER VARIABLES -~— 

176 WORD ao_YVel ; velocities of this object 

177 WORD ao_xXvel ; 

178 WORD ao_XAccel ; accelerations of this object 

179 WORD ao_YAccel i tt! backwards !!! 

180 WORD ao_RingYTrans ; Ying translation values 

181 WORD ao_RingXTrans i 

182 APTR ao_AnimORoutine ; address of special animation procedure 

183 APTR ao_HeadComp ; struct *animComp: pointer to first component 

184 LABEL ao_AUserExt ; animOb user extension 

185 LABEL ao_SIZEOF 

186 

187 

188 *---—-—- DBP : GBULP ACK Ct mmr ri 


189 * dBufPacket defines the values needed to be saved across buffer to buffer 
190 * when in double-buffer mode 


191 

192 STRUCTURE DBP,0 ; dBufPacket 

193 WORD dbp_Bufy 7; save the other buffers screen coordinates 
194 WORD dbp_BufXx ; 

195 APTR dbp BufPath i struct *vSprite: carry the draw path over 
196 the gap 


197 * these pointers must be filled in by the user 
198 * pointer to other buffer's background save buffer 


199 APTR dbp BufBuffer 7 *WORD 

200 * pointer to other buffer's background plane pointers 
201 APTR dbp_BufPlanes 7 **WORD 

202 LABEL dbp_SIZEOF 

203 


204 ENDC ; GRAPHICS GELS_I 


vt - a 











28 17:21 1988 graphics/gfxbase.i Page 1 Sep 28 17:21 1988 graphics/gfxbase.i Page 2 


1 IFND GRAPHICS_GFXBASE_I re LABEL gb_SIZE 
2 GRAPHTCS_GEXBASE_T SEP 1 : 72 * bits for dalestuff, which may go away when blitter becomes a resource 
** i : i wi 73 OWNBLITTERn equ 0 * blitter owned bit 
5 ak Braden eee! | Iyaghics/atxbase is 74 QBOWNERn equ l * blitter owned by blit queuer 
ak 75 

§ ** 76 QBOWNER equ 1<<QBOWNERn 

8 «x 77 

Q x (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 78 ENDC ; GRAPHICS GFXBASE_ I 

10 ** All Rights Reserved 
ll ** 
12 
13 TFND EXEC_LISTS_I 
14 include "“exec/lists.i" 

15 ENDC 

16 IFND EXEC_BLIBRARIES_I 

17 include "exec/libraries.i" 

18 ENDC 

19 IFND EXEC _INTERRUPTS_I 
20 include "exec/interrupts.i" 
21 ENDC 
22 
23 STRUCTURE GfxBase,LIB_SIZE 

24 APTR gb_ActiView ; struct *View 

25 APTR gb_copinit ; struct *copinit; ptr to copper start up list 
26 APTR gb_cia ;- for 6526 resource use 
27 APTR gb_blitter ; for blitter resource use 


28 APTR gb_LOFlist ; current copper list being run 
29 APTR gb_SHPlist ; Current copper list being run 
30 APTR gb_blthd ; struct *bltnode 

31 APTR gb_blttl i 

32 APTR gb_bsblthd i 

33 APTR gb_bsblttl i 

34 STRUCT gb _vbsrv,IS_SIZE 

35 STRUCT gb_timsrv,IS_ SIZE 

36 STRUCT gb _bltsrv,IS_SIZE 

37 STRUCT gb_TextFonts,LH_SIZE 

38 APTR gb_DefaultFont 

39 UWORD  gb_Modes 3; copy of bltcond 

40 BYTE gb_VBlank 

41 BYTE gb_Debug 

42 UWORD  gb_BeamSync 

43 WORD gb_system_bplcond 

44 BYTE gb_SpriteReserved 

45 BYTE gb_bytereserved 


47 WORD gb_Flags 

48 WORD gb_BlitLock 

49 WORD gb_BlitNest 

50 STRUCT gb _BlitWaitQ,LH_ SIZE 
51 APTR gb_BlitOwner 

52 STRUCT gb_TOF WaitQ,LH_SIZE 


54 WORD gb_DisplayFlags 

55 APTR gb_SimpleSprites 

56 WORD gb_MaxDisplayRow 

57 WORD gb_MaxDisplayColumn 

58 WORD gb_NormalDisplayRows 

59 WORD gb_NormalDisplayColumns 
60 WORD gb_Norma1DPMX 

61 WORD gb_Norma1DPMY 


63 APTR gb_LastChanceMemory 
64 APTR gb_LCMptr 


66 WORD gb_MicrosPerLine j; usecs per line times 256 
67 WORD gb_MinDisplayColumn 





69 STRUCT gb_reserved , 92 ; bytes reserved for future use 














Sep 


WONHDTFPWNE 








28 17:21 1988 graphics/rastport.i Page 1 


IFND GRAPHICS_RASTPORT_I 
GRAPHICS _RASTPORT_I SET 1 
xk 
xk $Filename: graphics/rastport.i $ 
xe $Release: 1.3 $ 
Kk 
ak 
kk 
x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 


Kk 


IFND GRAPHICS_GFX_I 
include "graphics/gfx.i" 

ENDC 
RTI TMRAS 
STRUCTURE TmpRas,0 

APTR tr_RasPptr 7; *WORD 

LONG tr_Size 

LABEL tr_SIZEOF 
ko GelsInfo 

STRUCTURE GelsInfo,0 

BYTE gi_sprRsrvd x flag of which sprites to reserve from 
* * vsprite system 

BYTE gi_Flags x reserved for system use 

APTR gi_gelHead 

APTR gi_gelTail * dummy vSprites for list management 


* pointer to array of @ WORDS for sprite available lines 





28 17:21 1988 graphics/layers.i Page 1 Sep 
IFND GRAPHICS _LAYERS_I 1 
GRAPHICS LAYERS_T SET 1 2 
uk 3 
ae $Filename: graphics/layers.i $ 4 
ae S$Release: 1.3 $ 5 
kk 6 
xk 7 
ak 8 
ee (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 9 
ae All Rights Reserved 10 
x ll 
12 

IFND EXEC_SEMAPHORES_T 13 
include "exec/semaphores.i" 14 

ENDC 415 

16 

IFND EXEC_LISTS I 17 
include “exec/lists.i" 18 

ENDC 19 

20 

* these should be clip.i/h but you know backwards compatibility etc. 21 
LAYERSIMPLE equ 1 22 
LAYERSMART equ 2 23 
LAYERSUPER equ 4 24 
LAYERUPDATING equ $10 25 
LAYERBACKDROP equ $40 26 
LAYERREFRESH equ $80 27 
LAYER_CLIPRECTS LOST equ $100 28 
29 

LMN_REGION equ —1l 30 
31 

STRUCTURE Layer_Info,0 32 
APTR li_top_layer 33 
APTR li_check_lp 34 
APTR li_obs 35 
STRUCT li_FreeClipRects ,MLH_SIZE 36 
STRUCT 1li_Lock,SS_SIZE 37 
STRUCT li_gs_Head,LH_SIZE 38 

LONG li_long_reserved 39 

WORD 1i_Flags 40 

BYTE 1li_fatten_count 41 
BYTE li_LockLayersCount 42 

WORD li_LayerInfo_extra_size 43 
APTR li_blitbuff 44 

APTR 1i_LayerInfo_extra 45 
LABEL 1i_SIZEOF 46 

47 

NEWLAYERINFO_CALLED equ 1 48 
ALERTLAYERSNOMEM equ $83010000 49 
50 

ENDC ; GRAPHICS_LAYERS_ I 51 

52 

53 

54 

55 

56 

57 

58 

59 

60 

61 

62 

63 

64 

65 

66 

67 

68 





APTR gi_nextLine 
* pointer to array of 8 pointers for color~-last~assigned to vSprites 
APTR gi_lastColor 
APTR gi_collHandler * addresses of collision routines 
SHORT gi_leftmost 
SHORT gi_rightmost 
SHORT gi_topmost 
SHORT gi_bottommost 
APTR gi_firstBlissObj 
APTR gi_lastBlissOb} * system use only 
LABEL gi_SIZEOF 
No RP_Flags ~—-—~~ 
BITDEF RP, FRST_DOT,0 ; draw the first dot of this line ? 
BITDEF RP ,ONE_DOT,1 ; use one dot mode for drawing lines 
BITDEF RP ,DBUFFER , 2 ; flag set when RastPorts are double-buffered 
* ; (only used for bobs) 
BITDEF RP,AREAOUTLINE,3 ; used by areafiller 
BITDEF RP,NOCROSSFILL,5 ; used by areafiller 
koe — RP_DrawMode --——~~- 
RP_JAM1 EQU 0 
RP_JAM2 EQU 1 
RP_COMPLEMENT §&QU 2 . 
RP_INVERSVID QU 4 ; inverse video for drawing modes 
+ RP_TxFlags —-~~—— 
BITDEF RP,TXSCALE,0 
STRUCTURE RastPort,0 
LONG rp_Layer 
LONG rp _BitMap 
LONG rp_AreaPtrn 
LONG rp_TmpRas 
LONG rp_AreaInfo 
LONG rp _GelsInfo 
BYTE rp Mask 

















9% - aA 


Sep 28 17:21 1988 graphics/rastport.i Page 2 28 17:21 1988 graphics/regions.i Page 1 


70 BYTE rp_FgPen 1 IFND GRAPHICS REGIONS _I 
71 BYTE rp_BgPen 2 GRAPHICS REGIONS _I SET 1 
72 BYTE rp_AOLPen 3 ** 
73 BYTE rp_DrawMode 4 *k $Filename: graphics/regions.i $ 
74 BYTE rp AreaPtSz 5 ** $Release: 1.3 $ 
75 BYTE rp_Dummny 6 ** 
76 BYTE rp_linpatent 7 ** 
77 WORD rp_Flags 8 ** 
78 WORD rp_LinePtrn Q ** (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
79 WORD rp_cp x ak All Rights Reserved 
80 WORD rp_cp_y ak 
81 STRUCT ) minterms , 8 
82 WORD rp_PenWidth IFND GRAPHICS GFX I 
83 WORD rp_PenHeight include "“graphics/gfx.i" 
84 LONG ) Font ENDC 
85 BYTE rp_AlgoStyle 
86 BYTE rp_TxFlags STRUCTURE Region,0 
87 WORD rp_TxHeight STRUCT  rg_bounds,ra_SIZEOF 
88 WORD xrp_TxWidth APTR rg_RegionRectangle 
89 WORD rp TxBaseline LABEL rg_SIZEOF 
90 WORD rp_TxSpacing 
91 APTR rp_RP_User STRUCTURE RegionRectangle,0 
92 STRUCT rp_longreserved , 8 APTR rr_Next 
93 ifnd GFX_RASTPORT_1_2 APTR rr Prev 
94 STRUCT rp_wordreserved , 14 : STRUCT rr_bounds, ra_SIZEOF 
95 STRUCT rp _reserved,8 LABEL rxr_SIZEOF 
96 ende 
97 LABEL rp_SIZEOF ENDC ; GRAPHICS REGIONS I 
98 
99 STRUCTURE AreaInfo,0 
100 LONG ai_VetrTbl 
101 LONG ai_VetrPtr 
102 LONG ai_FlagTbl 
103 LONG ai_FlagPtr 
104 WORD ai_Count 
105 WORD ai_MaxCount 
106 WORD ai_Firstx 
107 WORD ai_Firsty 
108 LABEL ai_SIZEOF 
109 
110 ONE_DOTn equ 1 
111 ONE_DOT equ $2 * 1<<ONE_DOTn 
112 FRST_DOTn equ 0 
113 FRST_DOT equ i * .1<<FRST_DOTn 
114 


115 ENDC 7; GRAPHICS_RASTPORT_I 








Ly - da 








sep 


WONDHDUF WHE 


28 17:21 1988 graphics/sprite.i Page 1 


IFND GRAPHICS_SPRITE_I 


GRAPHICS _SPRITE_I SET 1 

KK 

xe $Filename: graphics/sprite.i $ 
ae $Release: 1.3 $ 


xk 
KK 
xk 
Ke 
KK 
xk 


(Cc) 


STRUCTURE 
APTR 
WORD 
WORD 
WORD 
WORD 
LABEL 


ENDC 


Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


SimpleSprite,0 
ss_posctldata 
ss_height 

ss_X 

ss_y 

ss_num 
ss_SIZEOF 


; GRAPHICS _SPRITE_I 





Sep 


we 
BOODAANHNUSWNE 


a 
we 





(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


;normal text (no style attributes set) 
jextended face (must be designed) 

jitalic (slanted 1:2 right) 

;bold face text (ORed w/ shifted right 1) 
junderlined (under baseline) 


;font is from diskfont. library 
;designed path is reversed (e.g. left) 
;designed for hires non-interlaced 
;designed for lores interlaced 
;character sizes can vary from nominal 
jsize is "designed", not constructed 
the font has been removed 


KR KIKI KK IKKE KKK KEK ERE KK EKER KERR RK KEKE 


jname of the desired font 
;size of the desired font 
;desired font style 

;font preferences 


28 17:21 1988 graphics/text.i Page 1 
IFND GRAPHICS _TEXT_I 
GRAPHICS_TEXT_I SET 1 
ak 
we $Filename: graphics/text.i $ 
** $Release: 1.3 $ 
Kk 
xx graphics library text structures 
xk 
KK 
ae All Rights Reserved 
Kk 
IFND EXEC_PORTS_T 
INCLUDE "exec/ports.i" 
ENDC 
to Font Styles ——~~~~-~—— 
FS NORMAL  EQU 0 
BITDEF FS , EXTENDED , 3 
BITDEF FS, ITALIC,2 
BITDEF FS, BOLD, 1 
BITDEF FS , UNDERLINED, 0 
*-—--~- Font Flags —~~~7~77777—— 
BITDEF FP , ROMFONT , 0 jfont is in rom 
BITDEF FP ,DISKFONT,1 
BITDEF FP ,REVPATH,2 
BITDEF FP , TALLDOT , 3 
BITDEF FP ,WIDEDOT, 4 
BITDEF FP, PROPORTIONAL, 5 
BITDEP FP,DESIGNED,6 
BITDEF FP ,REMOVED , 7 i 
KEKKKKK TextAttr node KKKKKKK 
STRUCTURE TextAttr,0 
APTR ta_Name 
UWORD ta_YSize 
UBYTE ta_Style 
UBYTE ta_Flags 
LABEL ta_SIZEOF 


KORO TEX EFOnt node 10 III IC IORI TOR FOCI RR TOK TOR IK AIK ICTR RIK ZR IK IKK 
STRUCTURE 


* 


UWORD 
UBYTE 
UBYTE 
UWORD 
UWORD 
UWORD 


UWORD 


UBYTE 
UBYTE 
APTR 


UWORD 
APTR 


APTR 
APTR 
LABEL 


ENDC 


TextFont ,MN_SIZE 


tf_YSize 
tf_Style 

tf Flags 
tf_xsize 

tf{_ Baseline 
tf_Boldsmear 


tf_Accessors 
tf_Lochar 
tf_Hichar 
tf_CharData 


tf£_Modulo 
tf _CharLoc 


;font name in LN \ used in this 
jfont height order to best 
;font style match a font 
j;preference attributes / request. 
jnominal font width 

;distance from the top of char to baseline 
jsmear to affect a bold enhancement 


jaccess count 

;the first character described here 
;the last character described here 
jthe bit character data 


;the row modulo for the strike font data 
;ptr to location data for the strike font 


; 2 words: bit offset then size 


tf£_CharSpace 
tf_CharKern 
tf SIZEOF 


;ptr to words of proportional spacing data 
j;ptr to words of kerning data 


; GRAPHICS _TEXT_I 











8y - a 


28 17:21 1988 graphics/view.i Page 1 | Sep 28 17:21 1988 graphics/view.i Page 2 














1 IFND GRAPHICS VIEW I 70 STRUCTURE RasInfo,0 
2 GRAPHICS VIEW I SET T ~ . 71 APTR vi_Next 
3 ex ~ ~ 72 LONG ri_BitMap 
4 xe Filename: graphics/view.i 73 WORD ri_RxOffset 
5 ee Selene B 7 , 74 WORD ri_RyOffset 
6 xk 75 LABEL r1_SIZEOF 
7 «x 76 
B xx T7 ENDC 7 GRAPHICS VIEW_I 
Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 

10. ** All Rights Reserved 

ll ** 

12 

13 IFND GRAPHICS_GFX_I 

14 include "graphics/gfx.i" 

15 ENDC 

16 

17 IFND GRAPHICS _COPPER_I 

18 include "graphics/copper.i" 

19 ENDC 

20 

21 V_PFBA EQU $40 

22 V_DUALPF EQU $400 

23 V_HIRES EQU $8000 

24 V_LACE EQU 4 

25 V_HAM EQU $800 

26 V_SPRITES EQU $4000 

27 GENLOCK VIDEO EQU 2 

28 

29 STRUCTURE ColorMap ,0 

30 BYTE cm_Flags 

31 BYTE cm_Type 

32 WORD = cm_Count 

33 APTR cm_ColorTable 

34 LABEL cm_SIZEOP 

35 

36 

37 STRUCTURE ViewPort ,0 

38 LONG vp_Next 

39 LONG vp_ColorMap 

40 LONG vp_DspIns 

41 LONG vp_SprIns 

42 LONG vp_Clrins 

43 LONG vp_UCopIns 

44 WORD vp_DWidth 

45 WORD vp_DHeight 

46 WORD vp_DxOffset 

47 WORD vp_DyOffset 

48 WORD vp_Modes 

49 BYTE vp_SpritePriorities 

50 BYTE vp_reserved 

51 APTR vp_RasInfo 

52 LABEL vp SIZEOP 

53 

54 


55 STRUCTURE View,0 

56 LONG v_ViewPort 
57 LONG v_LOFCprList 
58 LONG v._SHFCprList 
59 WORD v_DyOffset 
60 WORD v_Dxoffset 
61 WORD v_Modes 

62 LABEL v_SI2ZEOF 


65 STRUCTURE collTable,0 
66 LONG cp_collPtrs,16 
67 LABEL — cp SIZEOF 





6% - a 








sep 


OONAUS WHE 


28 17:21 1988 hardware/adkbits.i Page 1 


IFND HARDWARE_ADKBITS_T 


HARDWARE_ADKBITS_I SET L 


kk 
xk 
Kk 
aK 
ak 
Kx 
Ke 
kk 
ak 


$Filename: hardware/adkbits.i $ 
$Release: 1.3 $ 


bit definitions for adkcon register 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


ADKB_SETCLR RQU 15 ; standard set/clear bit 
ADKB_PRECOMPL EQU 14 ; two bits of precompensation 
ADKB PRECOMPO EQU 13 


ADKB_MFMPREC EQU 12 
ADKB_UARTBRK EQU 11 
ADKB_WORDSYNC EQU 10 
ADKB_MSBSYNC QU 
ADKB_FAST EQU 
ADKB_USE3PN ——- EQU 
ADKB_USE2P3 EQU 
ADKB USE1P2 EQU 
ADKB_USEOP1 EQU 
ADKB_USE3VN —- EQU 
ADKB_USE2V3 EQU 
ADKB USE1V2 EQU 
ADKB_USEOV1 EQU 


ADKF_SETCLR  EQU 
ADKF_PRECOMP1 EQU 
ADKF PRECOMPO EQU 
ADKF_MFMPREC  EQU 
ADKF_UARTBRK  EQU 
ADKF WORDSYNC EQU 
ADKF MSBSYNC  EQU 
ADKF_FAST EQU 
ADKF_USE3PN  ——- EQU 
ADKF _USE2P3 EQU 
ADKF_USE1P2 EQU 
ADKP_USEOP1 § EQU 
ADKF_USE3VN —- EQU 
ADKF USE2V3 EQU 
ADKF_USE1V2  EQU 
ADKF_USEOV1  EQU 


ADKF_PREOOONS FQU 0 
ADKF_PREL40NS EQU 
ADKF PRE280NS EQU 
ADKF_PRES60NS EQU 


; use mfm style precompensation 

; force uart output to zero 

; enable DSKSYNC register matching 
; (Apple GCR Only) syne on MSB for reading 
; 1 -> 2 us/bit (mim), 2 —> 4 us/bit (ger) 
; use aud chan 3 to modulate period of ?? 
to modulate period of 
to modulate period of 
to modulate period of 
to modulate volume of 
to modulate volume of 
to modulate volume of 
to modulate volume of 


; use aud chan 
; use aud chan 
; use aud chan 
; use aud chan 
; use aud chan 


i 
i 
i 
i 
i 
j 
; use aud chan 
i 
i 
i 
i 
i 
; use aud chan 


OPN WAUIN~IMLO 


OrRNWOrRN 


; 000 ns of precomp 
(ADKF_PRECOMP0O) ; 140 ns of precomp 
(ADKF_PRECOMP]1 ) ; 280 ns of precomp 
(ADKF_PRECOMPO!ADKF_PRECOMP1) ; 560 ns of precomp 


ENDC ; HARDWARE_ADKBITS_T 











| 
oe 


WON AUPWNE 





28 17:21 1988 hardware/blit.i Page 1 


IEND HARDWARE_BLIT_I 

HARDWARE_BLIT_I SET 1 
Kk 
xk $Filename: hardware/blit.i $ 
xk SRelease: 1.3 $ 
xx 
kk 
Kk 
** (C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 
*e All Rights Reserved 
ak 

STRUCTURE bltnode,0 


LONG bn n 

LONG bn_function 
BYTE bn_stat 
BYTE bn_dummy 
WORD bn_blitsize 
WORD bn_beamsync 
LONG bn_cleanup 
LABEL bn_SIZEOF 


* bit defines used by blit queuer 
CLEANMEn equ 6 


CLEANME equ 1<<CLEANMEn 
* include file for blitter */ 
HSI ZEBITS equ 


6 
VSIZEBITS equ 16-HSIZEBITS 


HSIZEMASK equ $3f /* 276 —— 1 */ 
VSIZEMASK equ $3FF /* 2°10 - 1 */ 
MAXBYTESPERROW EQU 128 

* definitions for blitter control register 0 */ 
ABC equ $80 

ABNC equ. $40 

ANBC equ $20 

ANBNC equ $10 

NABC equ $8 

NABNC equ $4 

NANBC equ $2 

NANBNC equ $1 

BCOB_DEST equ 8 

BCOB_SRCC equ 9 

BCOB_SRCB equ 10 

BCOB SRCA equ 11 


BCOF DEST equ $100 
BCOF_SRCC equ $200 


BCOF_SRCB equ $400 

BCOF_SRCA equ $800 

BCIF_DESC equ 2 

DEST equ $100 

SRCC equ $200 

SRCB equ $400 

SRCA equ $800 

ASHIFTSHIFT equ 12 /* bits to right align ashift value */ 


BSHIFTSHIFT equ. 12 /* bits to right align bshift value */ 
* definations for blitter control register 1 */ 

LINEMODE equ $1 

PILL_OR equ $8 

FILL_XOR equ $10 


FILL CARRYIN equ $4 





oS -d 





28 17:21 1988 hardware/blit.i Page 2 Sep 28 17:21 1988 hardware/cia.i Page 1 














ONEDOT equ $2 1 IFND HARDWARE_CIA_I 
OVFLAG equ $20 2 HARDWARE CIA I SET 1 
SIGNFLAG equ $40 3 ** 
BLITREVERSE equ $2 4 ke $Filename: hardware/cia.i $ 
5 ** $Release: 1.3 $ 
SUD equ $10 6 ** 
SUL equ $8 7 ** registers and bits in the Complex Interface Adapter (CIA) chip 
AUL equ $4 8 ** 
Q *K (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
OCTANTS equ 24 1O ** All Rights Reserved 
OCTANT7 equ 4 ll ** 
OCTANT6 equ 12 12 
OCTANT5 equ 28 13 * 
OCTANT4 equ 20 14 * _ciaa is on an ODD address (e.g. the low byte) —- $bfe001 
OCTANT3 equ 8 15 * _ciab is on an EVEN address (e.g. the high byte) —— $bfd000 
OCTANT2 equ 0 16 * 
86 OCTANT1 equ 16 17 * do this to get the definitions: 
87 18 * XREF _ciaa 
88 ENDC ; HARDWARE BLIT_I 19 * XREF _ciab 
20 * 
21 
22 
23 * cla register offsets 
24 ciapra EQU  =$0000 
25 claprb EQU = $0100 
26 ciaddra EQU $0200 
27 ciaddrb EQU = $0300 
28 ciatalo EQU $0400 
29 ciatahi EQU = =$0500 
30 ciatblo EQU = $0600 
31 ciatbhi EQU $0700 
32 ciatodlow EQU = $0800 
33 ciatodmid EQU $0900 
34 ciatodhi EQU $OA00 
35 ciasdr EQU = $0C00 
36 ciaicr - EQU  $0D00 
37 ciacra EQU SOE0O 
38 ciacrb EQU SOFO00 
39 
40 * interrupt control register bit numbers 
41 CIAICRB_TA EQU 0 
42 CIAICRB_TB EQU 1 
43 CIAICRB_ALRM EQU 2 
44 CIAICRB_SP EQU 3 
45 CIAICRB_FLG EQU 4 
46 CIAICRB_IR EQU 7 
47 CIAICRB_SETCLR EQU 7 
48 
49 * control register A bit numbers 
50 CIACRAB_START EQU 0 
51 CIACRAB_PBON EQU 1 
52 CIACRAB_OUTMODE EQU 2 
53 CIACRAB_RUNMODE EQU 3 
54 CIACRAB LOAD EQU 4 
55 CIACRAB_INMODE EQU 5 
56 CIACRAB_SPMODE EQU 6 
57 CIACRAB_TODIN EQU 7 
58 
59 * control register B bit numbers 
60 CIACRBB_START EQU 0 
61 CIACRBB_PBON EQU 1 
62 CIACRBB_ OUTMODE EQU 2 
63 CIACRBB_RUNMODE EQU 3 
64 CIACRBB_LOAD EQU 4 
65 CIACRBB_INMODEO EQU 5 
66 CIACRBB_INMODEL EQU 6 
67 CIACRBB_ ALARM EQU 7 
68 


69 * interrupt control register bit masks 





118 
119 





28 17:21 1988 hardware/cia.i Page 2 
CIAICRF_TA EQU  (1<<0) 
CIAICRF_TB FQU (1<<1) 
CIAICRF_ALRM EQU  (1<<2) 
CIAICRF_SP EQU  (1«<3) 
CIAICRF_FLG EQU (1<<4) 
CIAICRF_IR EQU (1<<7) 
CIAICRF_SETCLR EQU (1<<7) 


* control register A bit masks 
CIACRAF_START EQU (1<<0) 
CIACRAF_PBON EQU (1<<1) 
CIACRAF OUTMODE EQU = (1<<2) 
CIACRAF_RUNMODE EQU = (1<<3) 
CIACRAF_LOAD EQU. (1<<4) 
CIACRAF INMODE EQU  (1<<5) 
CIACRAF_SPMODE EQU (1<<6) 
CIACRAF TODIN EQU = (1<<7) 


* control register B bit masks 


CIACRBF_START FOU = (1<<0) 
CIACRBF_PBON EQU = (1<<1) 
CIACRBF OUTMODE EQU (1<<2) 
CIACRBF_RUNMODE EQU = (1<<3) 
CIACRBF_LOAD FQU (1<<4) 
CIACRBF_INMODEO -EQU = (1<<5) 
CIACRBF_INMODEL EQU (1<<6) 
CIACRBF_ALARM EQU (1<<7) 





* control register B INMODE masks 

CIACRBF_IN PHI2 EQU 0 

CIACRBF_IN_CNT EQU  (CIACRBF_INMODEO) 

CIACRBF_IN_TA EQU (CIACRBF_INMODE] ) 

CIACRBF_IN_CNT_TA EQU (CLIACRBF_INMODEO!CIACRBF_INMODE1 ) 

* 

* Port definitions -- what each bit in a cia peripheral register is tied to 
x 

* ciaa port A (Oxbfe001) 


CIAB_GAMEPORT1 EQU (7) * 
CIAB_GAMEPORTO EQU (6) * 
CIAB_DSKRDY EQU (5) * disk 
CIAB_DSKTRACKO EQU (4) * disk 
CIAB_DSKPROT EQU (3) * disk 
CIAB_DSKCHANGE EQU (2) * disk 
CIAB_LED BQU (1) * 
CIAB_OVERLAY EQU (0) * 


* ciaa port B (0xbfel01) -~ parallel 


* clab port 

CIAB_COMDTR EQU (7) * 
CIAB_COMRTS EQU (6) * 
CIAB_COMCD EQU (5) * 
CIAB_COMCTS EQU (4) * 
CIAB_COMDSR EQU (3) * 
CIAB_PRTRSEL EQU (2) * 
CIAB_PRTRPOUT EQU (1) * 
CIAB_PRTRBUSY EQU (0) * 


gameport 1, pin 6 (fire button*) 
gameport 0, pin 6 (fire button*) 


ready* 

on track 00* 
write protect* 
change* 


led light control (0==>bright) 
memory overlay bit 


port 


A (O0xbfd000) —- serial and printer control 
serial Data Terminal Ready* 
serial Request to Send* 
serial Carrier Detect* 
serial Clear to Send* 
serial Data Set Ready* 
printer SELECT 

printer paper out 

printer busy 


motorr* 

select unit 3* 
select unit 2* 
select unit 1* 
select unit 0* 
side select* 


* ciab port B (Oxbfd100) —- disk control 
CIAB_DSKMOTOR EQU (7) * disk 
CIAB_DSKSEL3 EQU (6) * disk 
CIAB_DSKSEL2 EQoU (5) * disk 
CIAB_DSKSELL EQU (4) ™* disk 
CIAB_DSKSELO EQU (3) * disk 
CIAB_DSKSIDE EQU (2) * disk 
CIAB_DSKDIREC EQU (1) * disk 


direction of seek* 





Sep 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 


28 17:21 1988 hardware/cia.i Page 3 


CIAB_DSKSTEP EQU (0) 


* ciaa port A (Oxbfe001) 


CIAF_GAMEPORTL EQU = (1<<7) 
CIAF_GAMEPORTO EQU (1<<6) 
CIAF_DSKRDY BQU (1<<5) 
CIAF_DSKTRACKO EQU (1<<4) 
CIAF_DSKPROT EQU (1<<3) 
CIAF_DSKCHANGE EQU (1<<2) 
CIAF_LED EQU (1<<1) 
CIAF_OVERLAY BOU  (1<<0) 


* ciaa port B (Oxbfel01) -- parallel port 


* ciab port 

CIAF_COMDTR EQU | (1<<7) 
CIAF_COMRTS EQU (1<<6) 
CIAF_COMCD EQU  (1¢<5) 
CIAF_COMCTS EQU (1<<4) 
CIAF COMDSR BRQU (1<<3) 
CIAF_PRTRSEL EQU (1¢<2) 
CIAF_PRTRPOUT EQU (1<¢1) 
CIAF_PRTRBUSY EQU  (1<<0) 


* clab port B (Oxbfdl00) -- disk control 


CIAF .DSKMOTOR EQU (1<<7) 
CIAP_DSKSEL3 EQU (1¢<6) 
CIAF_DSKSEL2 EQU  (1<<5) 
CIAF DSKSEL1 EQU  (1<<4) 
CIAF_DSKSELO EQU (1<<3) 
CIAF_DSKSIDE EQU  (1<<2) 
CIAF _DSKDIREC EQU  (1<<1) 
CIAF_DSKSTEP EQU  (1<<0) 


ENDC ; HARDWARE_CIA_ TI 








* disk step heads* 


A (Oxbfd000) -- serial and printer control 








eg - a4 








Sep 


CONDO PWNH 


28 17:21 1988 hardware/custom.i Page ] 


IFND HARDWARE_CUSTOM_I 


HARDWARE_CUSTOM_I SET 1 

Kk 

aK $Filename: hardware/custom.i $ 

ae $Release: 1.3 $ 

xk 

aK 

xk 

ae (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
ae All Rights Reserved 


ak 


* 


x do this to get base of custom registers: 


* XREF custom; 
* 


bltddat EQU $000 
dmaconr EQU $002 
vposr EQU $004 
vhposr EQU $006 
dskdatr EQU $008 
joy0dat EQU - SO0A 
joyldat EQU $sooc 
clxdat EQU $00E 
adkconr EQU $010 
potddat EQU $012 
potidat EQU $014 
potinp EBQU $016 
serdatr EQU $018 
dskbytr EQU SO1A 
intenar EQU $0lc 
intreqr EQU SOLE 
dskpt. EQU $020 
dsklen EQU $024 
dskdat EQU $026 
refptr EQU $028 
vposw EQU $020 
vhposw EQU $02c 
copcon EQU $02E 
serdat EQU $030 
serper EQU $032 
potgo EQU $034 
joytest EQU $036 
strequ EQU $038 
strvbl EQU $O3A 
strhor EQU = $03C 
strlong EQU $03E 
bltcond EQU > $040 
bltconl EQU $042 
bltafwm EQU $044 
bltalwn EQU $046 
bltcpt EQU $048 
bltbpt EQU -$04C 
bltapt EQU $050 
bltdpt EQU $054 
bltsize EQU $058 
bltcmod EQU $060 
bltbmod EQU $062 
bltamod EQU $064 
bltdmod EQU $066 
bltcdat EQU = $070 
bltbdat EQU $072 


bltadat EQU $074 


Sep 28 17:21 1988 hardware/custom.i Page 2 
70 
71 dsksyne EQU  SO7E 
72 
73 coplic EQU = $080 
74 cop2ic EQU $084 
75 copjmpl EQU $088 
76 copjmp2 EQU SOBA 
77 copins FOU = $08C 
78 diwstrt EQU $O8E 
79 diwstop EQU  =$090 
80 ddfstrt EQU $092 
81 ddfstop EQU $094 
82 dmacon EQU $096 
83 clxcon EQU $098 
84 intena EQU SO9A 
85 intreg EQU = $09C 
86 adkcon EQU SO9E 
87 
88 aud EQU SOAO 
89 audd EQU  $0A0 
90 audl EQU  =$0B0 
91 aud2 EQU $0C0 
92 aud3 EQU = $O0D0 
93 
94 * STRUCTURE AudChannel,0 
95 ac_ptr EQU $00 7 ptr to start of waveform data 
96 ac_len EQU $04 i? Length of waveform in words 
97 ac_per EQU $06 7 sample period 
98 ac_vol EQU = $08 ; volume 
99 ac_dat EQU SOA ; Sample pair 
100 ac_SIZEOF EQU $10 
101 
102 bplpt EQU  $0EO 
103 
104 bplcon0d EQU = $100 
105 bplconl EQU $102 
106 bpicon2 EQU $104 
107 bpllmod EQU $108 
108 bp1l2mod EQU $10A 
109 
110 bpldat EQU $110 
111 
112 sprpt EQU $120 
113 
114 spr EQU $140 
115 * STRUCTURE SpriteDef 
116 sd_pos EQU = $00 
117 sd_ctl EQU $02 
118 sd_dataa EQU $04 
119 sd_datab EQU $08 
120 
121 color EQU $180 
122 
123 ENDC 7 HARDWARE _CUSTOM_T 


€s - a 








Sep 


WONNnUEWNE 


a 
HO 


28 17:22 1988 hardware/dmabits.i Page 1 
IFND HARDWARE_DMABITS_TI 

HARDWARE_DMABITS_I SET 1 

xk 

** $Filename: hardware/dmabits.i $ 

xe $Release: 1.3 $ 

kk 

xk include file for defining dma control stuff 

Ke 

xk (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 

xx All Rights Reserved 

n* 

* write definitions for dmaconw 

DMAF_SETCLR EQU $8000 

DMAF_AUDIO EQU SOOOF * 4 bit mask 

DMAF_AUDO EQU. = $0001 

DMAF_AUD] EQU $0002 

DMAF_AUD2 EQU $0004 

DMAF_AUD3 EQU $0008 

DMAF_DISK EQU $0010 

DMAF_SPRITE EQU $0020 


DMAF_BLITTER EQU $0040 
DMAF_COPPER EQU $0080 
DMAF_RASTER EQU $0100 


DMAF_MASTER EQU $0200 

DMAF_BLITHOG EQU $0400 

DMAF_ALL EQU SO1IFF * all dma channels 
* read definitions for dmaconr 


* bits 0-8 correspnd to dmaconw definitions 
DMAF_BLTDONE EQU $4000 
DMAF_ BLTNZERO EQU $2000 


DMAB_SETCLR EQU 15 


DMAB_AUDO EQU 0 
DMAB_AUD1L EQU) 1 
DMAB_AUD2 EQU 2 
DMAB_AUD3 EQU 3 
DMAB_DISK EQU 4 
DMAB_ SPRITE EQU 5 
DMAB_BLITTER EQU 6 
DMAB_COPPER EQU 7 
DMAB_RASTER EQU 8 
DMAB_ MASTER EOU 9 
DMAB_BLITHOG EQU 10 
DMAB_BLTDONE EQU 14 
DMAB_BLINZERO EQU 13 


ENDC ; HARDWARE_DMABITS I 





Sep 


WOANAUPWHE 


28 17:22 1988 hardware/intbits.i Page 1 





IFND HARDWARE_INTBITS_I 

HARDWARE_INTBITS_I SET 1 

kk 

** $Filename: hardware/intbits.i $ 

ae $Release: 1.3 $ 

Kk 

** bits in the interrupt enable (and interrupt request) register 

kk 

ad (C) Copyright 1985,1986 ,1987,1988 Commodore-Amiga, Inc. 

** All Rights Reserved 

Kk 

INTB_SETCLR EQU (15) ;Set/Clear control bit. Determines if bits 
;written with a 1 get set or cleared. Bits 
jwritten with a zero are allways unchanged. 

INTB_INTEN EQU (14) ;Master interrupt (enable only ) 

INTB_EXTER EQU (13) ;External interrupt 

INTB_DSKSYNC = EQU (12) ;Disk re-SYNChronized 

INTB_RBF EQU (11) ;serial port Receive Buffer Full 

INTB_AUD3 EQU (10) ;Audio channel 3 block finished 

INTB_AUD2 EQU (9) ;Audio channel 2 block finished 

INTB_AUD1 EQU (8) ;Audio channel 1 block finished 

INTB_AUDO EQU (7) ;Audio channel 0 block finished 

INTB_BLIT EQU (6) ;Blitter finished 

INTB_VERTB EQU (5) j;start of Vertical Blank 

INTB_COPER EQU (4) ; Coprocessor 

INTB_PORTS EQU (3) 71/0 Ports and timers 

INTB_SOFTINT EQU (2) ;software interrupt request 

INTB_DSKBLK EQU (1) ;Disk Block done 

INTB_TBE EQU (0) ;serial port Transmit Buffer Empty 

INTF_SETCLR EQU  (1¢<15) 

INTP_INTEN ROU (1<<14) 

INTF_EXTER EQU {1<<13) 

INTF DSKSYNC EQU  (1<<12) 

INTF_RBF FQU (1<<11) 

INTF_AUD3 EQU (1<<10) 

INTF_AUD2 FOU (1<<9) 

INTF_AUDL EQU  (1<¢8) 

INTF_AUDO BQU (1¢<7) 

INTF_BLIT EQU  (1<<6) 

INTF_VERTB EQU  (1<<5) 

INTF_COPER FQU (1<<4) 

INTF_PORTS EQU (1<<3) 

INTF_SOPTINT EQU  (1<<2) 

INTF_DSKBLK FQU (1<<1) 

INTF_TBE EQU (1<<0) 

ENDC ; HARDWARE_INTBITS_I 











iS - a 


Sep 


WO AU WN 


28 17:22 1988 intuition/intuition.i Page 1 


IFND 


INTUITION_INTUITION_I 


INTUITION_INTUITION_I SET 1 
Kk 


ak 
xk 
xk 
bd 
kk 
Kk. 
xk 
ak 


$Filename: intuition/intuition.i $ 
$Release: 1.3 $ 


main intuition include 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 


All 


Rights Reserved 


IFND EXEC_TYPES_I 


INCLUDE 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


"exec/types.i" 


GRAPHICS GFX_I 
"graphics/gfx.i" 


GRAPHICS CLIP_I 
“graphics/clip.i" 


GRAPHICS_VIEW_I 
“graphics/view.i" 


GRAPHICS RASTPORT_I 
"graphics/rastport.i" 


GRAPHICS LAYERS _I 
“graphics/layers.i" 


GRAPHICS TEXT I 
"“graphics/text.i" 


IFND EXEC_PORTS_I 


include 
ENDC 


IFND 
include 
ENDC 


IFND 
include 
ENDC 


“exec/ports.i" 


DEVICES_TIMER_I 
“devices/timer.i" 


DEVICES INPUTEVENT_I 
"devices/inputevent. i" 














APTR mu_NextMenu 
WORD mu_LeftEdge 
WORD mu_TopEdge 


WORD mu_Height 
WORD mu_Flags 

APTR mu_MenuName 
APTR mu_FirstItem 


; these mysteriously~named variables are for internal use only 





j Menu pointer, same level 
; position of the select box 
a ; position of the select box 
WORD mu_Width ; dimensions of the select box 


dimensions of the select box 
see flag definitions below 

; text for this Menu Header 

; pointer to first in chain 


WORD mu_Jaz2X 


Sep 28 17:22 1988 





106 


108 
109 
110 
lil 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 


135 
136 
137 
138 


intuition/intuition.i Page 2 


WORD mu_JazzY 

WORD mu_BeatX 

WORD mu_BeatY 

LABEL mu_SI2ZEOF 
i;*** FLAGS SET BY BOTH THE APPLIPROG AND INTUITION *** 
MENUENABLED EQU $0001 ; whether or not this menu is enabled 
7*** FLAGS SET BY INTUITION *** 
MIDRAWN EQU $0100 ; this menu's items are currently drawn 


APTR mi_NextItem i 
WORD mi_LeftEdge i 
WORD mi_TopEdge ; position of the select box 


WORD mi_Width 
WORD mi_Height 
WORD mi_Flags 


























pointer to next in chained list 
position of the select box 


dimensions of the select box 
dimensions of the select box 
; see the defines below 


LONG mi_MutualExclude ; set bits mean this item excludes that item 


APTR mi_ItemPFill ; points to Image, IntuiText, or NULL 


i when this item is pointed to by the cursor and the items highlight 
i Mode HIGHIMAGE is selected, this alternate image will be displayed 
APTR mi_SelectFill ; points to Image, IntuiText, or NULL 


BYTE mi_Command ; Only if appliprog sets the COMMSEQ flag 


BYTE mi_KludgeFill00 ; This is strictly for word-alignment 


APTR mi_SubItem i if non-zero, DrawMenu shows "'->" 


; The NextSelect field represents the menu number of next selected 
; item (when user has drag-selected several items) 
WORD mi_NextSelect 


LABEL mi_SIZEOF 





; ~-— FLAGS SET BY THE APPLIPROG ~---------------~------------_-----______-- 


CHECKIT 
ITEMTEXT 
COMMSEQ 
MENUTOGGLE 
ITEMENABLED 


; these are 
HIGHFLAGS 
HIGHIMAGE 
HIGHCOMP 
HIGHBOX 
HIGHNONE 


7 777 FLAGS 
CHECKED 


j; ~~ FLAGS 
ISDRAWN 
HIGHITEM 
MENUTOGGLED 


the 


SET 


SET 


EQU $0001 ; whether to check this item if selected 

EQu $0002 7; set if textual, clear if graphical item 
EQU $0004 ; set if there's an command sequence 

EQU $0008 7 set to toggle the check of a menu item 

EQU $0010 7 set if this item is enabled 


SPECIAL HIGHLIGHT FLAG state meanings 

EQU $00c0 ; see definitions below for these bits 

EQU $0000 7 use the user's "select image" 

EQU $0040 i highlight by complementing the select box 
EQu $0080 ; highlight by drawing a box around the image 
EQU $00CO ; don't highlight 


BY BOTH APPLIPROG AND INTUITION ~----~~----—---------------~—~ 
EQU $0100 ; if CHECKIT, then set this when selected 





BY INTUITION ——-~-----~—---~-—---~~—-----—-~-------------_-—- 
EQU $1000 ; this item's subs are currently drawn 

EQU $2000 ; this item is currently highlighted 

EQU $4000 ; this item was already toggled 





ss - 4a 
































Sep 28 17:22 1988 intuition/intuition.i Page 3 Sep 28 17:22 1988 intuition/intuition.i Page 4 
139 208 
140 209 WORD gg_Flags ; see below for list of defines 
141 210 
142 ; 211 WORD gg_Activation ; see below for list of defines 
143 ; 212 
144 ; = 213 WORD gg_GadgetType ; see below for defines 
145 STRUCTURE Requester ,0 214 
146 215 ; appliprog can specify that the Gadget be rendered as either as Border 
147 ; the ClipRect and BitMap and used for rendering the requester © 216 ; or an Image. This variable points to which (or equals NULL if there's 
148 APTR rq OlderRequest 217 ; nothing to be rendered about this Gadget.) 
149 WORD rgq_LeftEdge ; dimensions of the entire box 218 APTR gg_GadgetRender 
150 WORD rgq_TopEdge ; dimensions of the entire box 219 
151 WORD rq Width ; dimensions of the entire box 220 ; appliprog can specify "highlighted" imagery rather than algorithmic 
152 WORD rq Height ; dimensions of the entire box 221 ; this can point to either Border or Image data 
153 222 APTR gg_SelectRender 
154 WORD rq _RelLeft ; get POINTREL Pointer relativity offsets 223 
122 WORD rq_RelTop ; get POINTREL Pointer relativity offsets 224 APTR gg_GadgetText ; text for this gadget; 
156 225 
157 APTR rq_ReqGadget ; pointer to the first of a list of gadgets 226 ; by using the MutualExclude word, the appliprog can describe 
158 APTR rq_ReqBorder ; the box's border 227 ; which gadgets mutually-exclude which other ones. The bits in 
159 APTR rq ReqText ; the box's text ‘ 228 ; MutualExclude correspond to the gadgets in object containing 
160 229 ; the gadget list. If this gadget is selected and a bit is set 
161 WORD rq_Flags ; see definitions below 230 ; in this gadget's MutualExclude and the gadget corresponding to 
162 231 ; that bit is currently selected (e.g. bit 2 set and gadget 2 
163 UBYTE rq_BackFill ; pen number for back-plane fill before draws 232 ; is currently selected) that gadget must be unselected. Intuition 
164 233 ; does the visual unselecting (with checkmarks) and leaves it up 
165 BYTE rq_KludgeFi1l100 ; This is strictly for word-alignment 234 ; to the program to unselect internally 
166 235 LONG gg_MutualExclude ; set bits mean this gadget excludes that 
167 APTR rq_ReqLayer ; layer in which requester rendered 236 . 
168 STRUCT rgq_ReqPad1, 32 ; for backwards compatibility (reserved) 237 ; pointer to a structure of special data required by Proportional, String 
169 238 ; and Integer Gadgets 
170 ; If the BitMap plane pointers are non-zero, this. tells the system 239 APTR gg_Specialinfo 
171 ; that the image comes pre-drawn (if the appliprog wants to define 240 
172 ; it's own box, in any shape or size it wants!); this is OK by 241 WORD gg_GadgetID ; user-definable ID field 
173 ; Intuition as long as there's a good correspondence between the image 242 APTR gg_UserData ; ptr to general purpose User data (ignored by Intuit) 
174 ; and the specified Gadgets 243 
i? APTR rq_ImageBMap ; points to the BitMap of PREDRAWN imagery oe LABEL gg_SIZEOF 
76 24 
177 APTR xrg_RWindow ; points back to requester's window 246 ; —-— FLAGS SET BY THE APPLIPROG ~trrr rr rt rn 
178 STRUCT rq_ReqPad2, 36 ; for backwards compatibility (reserved) 247 ; combinations in these bits describe the highlight technique to be used 
179 248 GADGHIGHBITS EQU $0003 
180 LABEL rq_SIZEOF 249 GADGHCOMP EQU $0000 ; Complement the select box 
181 250 GADGHBOX EQU $0001 ; Draw a box around the image 
182 ; FLAGS SET BY THE APPLIPROG 251 GADGHIMAGE FQU $0002 ; Blast in this alternate image 
183 POINTREL EQU $0001 ; if POINTREL set, TopLeft is relative to pointer 252 GADGHNONE EQU $0003 ; don't highlight 
184 -PREDRAWN EQU $0002 ; if ReqBMap points to predrawn Requester imagery 253 
185 NOISYREQ EQU $0004 ; iff you don't want requester to filter input. 254 ; set this flag if the GadgetRender and SelectRender point to Image imagery, 
186 255 ; clear if it's a Border 
187 ; FLAGS SET BY INTUITION; 256 GADGIMAGE BQU $0004 
188 REQOFFWINDOW EQU $1000 ; part of one of the Gadgets was offwindow 257 
189 REQACTIVE EQu $2000 ; this requester is active 258 ; combinations in these next two bits specify to which corner the gadget's 
190 SYSREQUEST EQU $4000 ; this requester caused by system 259 ; Left & Top coordinates are relative. If relative to Top/Left, 
191 DEFERREFRESH EQU $8000 ; this Requester stops a Refresh broadcast 260 ; these are "normal" coordinates (everything is relative to something in 
192 261 ; this universe) 
193 262 GRELBOTTOM EQU $0008 ; set if rel to bottom, clear if rel top 
194 263 GRELRIGHT EQU $0010 ; set if rel to right, clear if to left 
195 264 ; set the RELWIDTH bit to spec that Width is relative to width of screen 
196 265 GRELWIDTH EQU $0020 
197 ; 266 ; set the RELHEIGHT bit to spec that Height is rel to height of screen 
198 267 GRELHEIGHT EQU $0040 
199 268 
200 269 ; the SELECTED flag is initialized by you and set by Intuition. It 
201 270 ; specifies whether or not this Gadget is currently selected/highlighted 
202 APTR gg_NextGadget. ; next gadget in the list 271 SELECTED FOU $0080 
203 272 
204 WORD gg_LeftEdge ; “hit box" of gadget 273 
205 WORD gg_TopEdge ; “hit box" of gadget 274 ; the GADGDISABLED flag is initialized by you and later set by Intuition 
206 WORD gg_Width ; "hit box" of gadget 275 ; according to your calls to On/OffGadget(). It specifies whether or not 
207 WORD gg_Height ; “hit box" of gadget 276 ; this Gadget is currently disabled from being selected 











9g - 4 






























Sep 28 17:22 1988 intuition/intuition.i Page 5 Sep 28 17:22 1988 intuition/intuition.i Page 6 

277 GADGDISABLED EQU $0100 346 STRGADGET EQU $0004 

278 . 347 

279 348 

280 ; —— These are the Activation flag bits ---~~----------------_-_-__-_-_---- 349 

281 ; RELVERIFY is set if you want to verify that the pointer was still over 350 ; 

282 ; the gadget when the select button was released 351 ; 

283 RELVERIFY EQU $0001 352 ; 

284 353 ; This is the special data needed by an Extended Boolean Gadget 

285 ; the flag GADGIMMEDIATE, when set, informs the caller that the gadget 354 ; Typically this structure will be pointed to by the Gadget Field SpecialInfo 
286 ; was activated when it was activated. this flag works in conjunction with 355 

287 ; the RELVERIFY flag 356 STRUCTURE Boolinfo,0 

288 GADGIMMEDIATE QU $0002 357 

289 358 WORD bi_Flags ; defined below 

290 ; the flag ENDGADGET, when set, tells the system that this gadget, when 359 APTR bi_Mask ; bit mask for highlighting and selecting 

291 ; selected, causes the Requester or AbsMessage to be ended. Requesters or 360 i Mask must follow the same rules as an Image 

292 ; AbsMessages that are ended are erased and unlinked from the system 361 ; plane. It's width and height are determined 
293 ENDGADGET EQU $0004 362 ; by the width and height of the gadget's 

294 363 ; select box. (i.e. Gadget.Width and .Height). 
295 ; the FOLLOWMOUSE flag, when set, specifies that you want to receive 364 LONG bi_Reserved ; set to 0 

296 ; reports on mouse movements (ie, you want the REPORTMOUSE function for 365 

297 ; your Window). When the Gadget is deselected (immediately if you have 366 LABEL  bi_SIZEOF 

298 ; no RELVERIFY) the previous state of the REPORTMOUSE flag is restored 367 

293 ; You probably want to set the GADGIMMEDIATE flag when using FOLLOWMOUSE, 368 ; set BoolInfo.Flags to this flag bit. 

300 ; since that's the only reasonable way you have of learning why Intuition 369 ; in the future, additional bits might mean more stuff hanging 

301 ; is suddenly sending you a stream of mouse movement events. If you don't 370 ; off of BoollInfo.Reserved. 

302 ; set RELVERIFY, you'll.get at least one Mouse Position event. 371 

303 FOLLOWMOUSE EQU $0008 372 BOOLMASK EQU $0001 ; extension is for masked gadget 

304 373 

305 ; if any of the BORDER flags are set in a Gadget that"s included in the 374 ; 

306 ; Gadget list when a Window is opened, the corresponding Border will 375 ; 

307 ; be adjusted to make room for the Gadget 376 ; = 

308 RIGHTBORDER EQU $0010 377 ; this is the special data required by the proportional Gadget 

309 LEFTBORDER EQU $0020 378 ; typically, this data will be pointed to by the Gadget variable Specialinfo 
310 TOPBORDER EQU $0040 379 STRUCTURE PropInfo,0 

311 BOTTOMBORDER EoU $0080 380 

312 381 WORD pi_Flags ; general purpose flag bits (see defines below) 
313 TOGGLESELECT EQU $0100 ; this bit for toggle-select mode 382 

314 383 ; You initialize the Pot variables before the Gadget is added to 

315 STRINGCENTER EQU $0200 ; center the String 384 ; the system. Then you can look here for the current settings 

316 STRINGRIGHT EQU $0400 ; vight—justify the String 385 ; any time, even while User is playing with this Gadget. To 

317 386 ; adjust these after the Gadget is added to the System, use 

318 LONGINT EQU $0800 ; This String Gadget is a Long Integer 387 ; ModifyProp(); The Pots are the actual proportional settings, 

319 388 ; where a value of zero means zero and a value of MAXPOT means 

320 ALTKEYMAP EQU $1000 ; This String has an alternate keymapping 389 ; that the Gadget is set to its maximum setting. 

321 390 WORD pi_HorizPot ; 16-bit FixedPoint horizontal quantity percentage; 
322 BOOLEXTEND EQU $2000 ; This Boolean Gadget has a BoolInfo 391 WORD pi_VertPot ; 16-bit FixedPoint vertical quantity percentage; 
323 392 

324 ; —-— GADGET TYPES —--—~~~---------—--— a a a a 393 ; the 16-bit FixedPoint Body variables describe what percentage 

325 ; These are the Gaget Type definitions for the variable GadgetType. 394 ; of the entire body of stuff referred to by this Gadget is 

326 ; Gadget number type MUST start from one. NO TYPES OF 2ERO ALLOWED. 395 ; actually shown at one time. This is used with the AUTOKNOB 

327 ; first comes the mask for Gadget flags reserved for Gadget typing 396 ; routines, to adjust the size of the AUTOKNOB according to how 

328 GADGETTYPE EQU $FCOO ; all Gadget Global Type flags (padded) 397 ; much of the data can be seen. This is also used to decide how 

329 SYSGADGET EQU $8000 ; 1 = SysGadget, 0 = AppliGadget 398 ; far to advance the Pots when User hits the Container of the Gadget. 
330 SCRGADGET EQU $4000 ; 1 = ScreenGadget, 0 = WindowGadget 399 ; For instance, if you were controlling the display of a 5-line 

331 G2Z2GADGET EQU $2000 ; 1 = Gadget for GIMMEZEROZERO borders 400 ; Window of text with this Gadget, and there was a total of 15 

332 REQGADGET EQU $1000 ; 1 = this is a Requester Gadget 401 ; lines that could be displayed, you would set the VertBody value to 
333 ; system gadgets 402 ; (MAXBODY / (TotalLines / DisplayLines)) = MAXBODY / 3. 

334 SIZING EQU $0010 403 ; Therefore, the AUTOKNOB would fill 1/3 of the container, and if 
335 WDRAGGING EQU $0020 404 ; User hits the Cotainer outside of the knob, the pot would advance 
336 SDRAGGING EQU $0030 405 ; 1/3 (plus or minus) If there's no body to show, or the total 

337 WUPFRONT EQU $0040 406 ; amount of displayable info is less than the display area, set the 
338 SUPFRONT EQU $0050 407 ; Body variables to the MAX. To adjust these after the Gadget is 
339 WDOWNBACK EQU $0060 408 ; added to the System, use ModifyProp(). 

340 SDOWNBACK EQU $0070 409 WORD pi_HorizBody ; horizontal Body 

341 CLOSE EQU $0080 410 WORD pi_VertBody ; vertical Body 

342 ; application gadgets 411 

343 BOOLGADGET EQU $0001 412 ; these are the variables that Intuition sets and maintains 

344 GADGETO002 EQU $0002 413 WORD pi_CWidth ; Container width (with any relativity absoluted) 
345 PROPGADGET EQU $0003 414 WORD pi. CHeight ; Container height (with any relativity absoluted) 











ig - 4a 






































Sep 28 17:22 1988 intuition/intuition.i Page 7 Sep 28 17:22 1988 intuition/intuition.i Page 8 
415 WORD pi_HPotRes ; pot increments 484 
416 WORD pi_VPotRes ; pot increments 485 BYTE it_DrawMode ; the mode for rendering the text 
417 WORD pi_LeftBorder ; Container borders 486 
418 WORD pi_TopBorder ; Container borders 487 BYTE it _KludgeFi1100 ; This is strictly for word-alignment 
419 LABEL pi_SIZEOF 488 
420 489 WORD it _LeftEdge ; relative start location for the text 
QL mm BLING BITS TT 490 WORD it_TopEdge ; relative start location for the text 
422 AUTOKNOB EQU $0001 ; this flag sez: gimme that old auto-knob 491 
423 FREEHORIZ EQU $0002 ; if set, the knob can move horizontally 492 APTR it_ITextFont ; if NULL, you accept the defaults 
424 PREEVERT EQU $0004 ; if set, the knob can move vertically 493 
425 PROPBORDERLESS EQU $0008 ; if set, no border will be rendered 494 APTR it_IText ; pointer to null-terminated text 
426 KNOBHIT EQU $0100 ; set when this Knob is hit 495 
427 496 APTR it _NextText ; continuation to TxWrite another text 
428 497 
429 KNOBHMIN EQU 6 ; Minimum horizontal size of the knob 498 LABEL it_SIZEOF 
430 KNOBVMIN EQU 4 ; minimum vertical size of the knob 499 
431 MAXBODY EQU $FFFF ; Maximum body value 500 
432 MAXPOT EQU $FFFF ; Maximum pot value 501 
433 502 
434 503 
435 ; 504 ; 
436 ; StringInfo 505 ; 
437 5 == 506 ; = 
438 ; this is the special data required by the string Gadget 507 ; er, used for drawing a series of lines which is intended 
439 ; typically, this data will be pointed to by the Gadget variable SpecialInfo 508 ; use as a border drawing, but which may, in fact, be used to render any 
440 STRUCTURE StringInfo,0 509 ; arbitrary vector shape. 
44] 510 ; The routine DrawBorder sets up the RastPort with the appropriate 
442 ; you initialize these variables, and then Intuition maintains them 511 ; variables, then does a Move to the. first coordinate, then does Draws 
443 APTR si_Buffer ; the buffer containing the start and final string 512 ; to the subsequent coordinates. 
444 APTR si _UndoBuffer ; optional buffer for undoing current entry 513 ; After all the Draws are done, if NextBorder is non-zero we call DrawBorder 
445 WORD si_BufferPos ; character position in Buffer 514 ; recursively 
446 WORD si_MaxChars ; max number of chars in Buffer (including NULL) 515 STRUCTURE Border ,0 
447 WORD si_DispPos ; Buffer position of first displayed character 516 
448 517 WORD bd _LeftEdge ; initial offsets from the origin 
449 ; Intuition initializes and maintains these variables for you 518 WORD bd_TopEdge ; initial offsets from the origin 
450 WORD: si_UndoPos ; character position in the undo buffer 519 BYTE bd_FrontPen ; pen number for rendering 
451 WORD si_NumChars ; number of characters currently in Buffer 520 BYTE bd_BackPen ; pen number for rendering 
452 WORD si_DispCount ; number of whole characters visible in Container 521 BYTE bd_DrawMode ; mode for rendering 
453 WORD si CLeft ; topleft offset of the container 522 BYTE bd_Count ; number of XY pairs 
454 WORD si_CTop ; topleft offset of the container 523 APTR bd_XY ; vector coordinate pairs rel to LeftTop 
455 APTR si_LayerPtr ; the RastPort containing this Gadget 524 APTR bd NextBorder ; pointer to any other Border too 
456 525 
457 ; you can initialize this variable before the gadget is submitted to 526 LABEL bd_SIZEOF 
458 ; Intuition, and then examine it later to discover what integer 527 
459 ; the user has entered (if the user never plays with the gadget, 528 
460 ; the value will be unchanged from your initial setting) 529 ; 
hes LONG si_LongInt ; the LONG return value of a LONGINT String Gadget 530 ; 
62 531; 
463 ; If you want this Gadget to use your own Console keymapping, you 532 ; This is a brief image structure 
464 ; set the ALTKEYMAP bit in the Activation flags of the Gadget, and then 533 ; image data to a RastPort 
465 ; set this variable to point to your keymap. If you don't set the 534 STRUCTURE Image,0 
466 ; ALTKEYMAP, you'll get the standard ASCII keymapping. 535 
467 APTR si_AltKeyMap 536 WORD ig LeftEdge ; starting offset relative to something 
468 537 WORD ig_TopEdge ; starting offset relative to. something 
469 LABEL si_SIZEOF 538 WORD ig Width ; pixel size (though data is word~aligned) 
470 539 WORD ig Height ; pixel size 
471. 540 WORD ig_Depth ; pixel size 
472 541 APTR ig_ImageData ; pointer to the actual image bits 
473 542 
474 ; 543 ; the PlanePick and PlaneonOff variables work much the same way as the 
475 ; IntuiText 544 ; equivalent GELS Bob variables. It's a space-saving 
476 ; ame 545 ; mechanism for image data. Rather than defining the image data 
477 ; IntuiText is a series of strings that start with a screen location 546 ; for every plane of the RastPort, you need define data only for planes 
478 ; (always relative to the upper-left corner of something) and then the 547 ; that are not entirely zero or one. As you define your Imagery, you will 
479 ; text of the string. The text is null-terminated. 548 ; often find that most of the planes ARE just as color selectors. For 
480 STRUCTURE IntuiText,0 549 ; instance, if you're designing a two-color Gadget to use colors two and 
481 550 ; three, and the Gadget will reside in a five-plane display, plane zero 
482 BYTE it_FrontPen ; the pens for rendering the text 551 ; of your imagery would be all ones, bit plane one would have data that 
483 BYTE it_BackPen ; the pens for rendering the text 552 ; describes the imagery, and bit planes two through four would be 











gs -d 








[621 





Sep 28 17:22 1988 intuition/intuition.i Page 9 
553 ; all zeroes. Using these flags allows you to avoid wasting all that 
554 ; Memory in this way: 
555 i; first, you specify which planes you want your data to appear 
556 7; in using the PlanePick variable. For each bit set in the variable, the 
557 ; next "plane" of your image data is blitted to the display. For each bit 
558 ; clear in this variable, the corresponding bit in PlaneoOnOff is examined. 
559 ; If that bit is clear, a "plane" of zeroes will be used. If the bit is 
560 ; set, ones will: go out instead. So, for our example: 
561 ; Gadget..PlanePick = 0x02; 
562 i Gadget.Planeonoff = 0x01; 
563 ; Note that this also allows for generic Gadgets, like the System Gadgets, 
564 7; which will work in any number of bit planes 
565 ; Note also that if you want an Image that is only a filled rectangle, 
566 ; you can get this by setting PlanePick to zero (pick no planes of data) 
567 and set Planeonoff to describe the pen color of the rectangle. 
568 BYTE ig PlanePick 
20? BYTE ig_Planeonoff 
70 
571 ; if the NextImage variable is not NULL, Intuition presumes that 
572 ; it points to another Image structure with another Image to be 
573 7; rendered 
574 APTR ig_NextImage 
575 
576 
577 LABEL ig_SIZEOF 
578 
579 
580 
581 
582 
583 
584 
zee ’ STRUCTURE IntuiMessage,0 
86 
587 STRUCT im_ExecMessage,MN_SIZE 
588 
589 ; the Class bits correspond directly with the IDCMP Flags, except for the 
590 ; special bit LONELYMESSAGE (defined below) 
591 LONG im_ Class 
592 
593 ; the Code field is for special values like MENU number 
594 WORD im_Code 
595 
596 ; the Qualifier field is a copy of the current InputEvent's Qualifier 
597 WORD im Qualifier 
598 : . 
599 ; IAddress contains particular addresses for Intuition functions, like 
600 ; the pointer to the Gadget or the Screen 
601 APTR im_IAddress 
602 
603 ; when getting mouse movement reports, any event you get will have the 
604 ; the mouse coordinates in these variables. the coordinates are relative 
605 ; to the upper-left corner of your Window (GIMMEZEROZERO notwithstanding) 
606 WORD im MouseX 
607 WORD im Mousey 
608 . 
609 ; the time values are copies of the current system clock time. Micros 
610 ; are in units of microseconds, Seconds in seconds. 
611 LONG im_Seconds 
et2 LONG im_Micros 
3 
614 ; the IDCMPWindow variable will always have the address of the Window of 
615 ; this IDCMP 
616 APTR im_IDCMPWindow 
617 
618 ; system-use variable 
638 APTR im_SpecialLink 
20 


LABEL im_SIZ2EOF 














28 17:22 1988 intuition/intuition.i Page 10 
73. 777 IDCMP Classes -—-—-—-— 77 rn 
SIZEVERIFY BQU $00000001 ; See the Programmer's Guide 
NEWSIZE EQU $00000002 i; See the Programmer's Guide 
REFRESHWINDOW | EQU $00000004 ; See the Programmer's Guide 
MOUSEBUTTONS EQU $00000008 ; See the Programmer's Guide 
MOUSEMOVE EQU $00000010 ; See the Programmer's Guide 
GADGETDOWN EQU $00000020 ; See the Programmer's Guide 
GADGETUP EQU $00000040 ; See the Programmer's Guide 
REQSET EQU $00000080 ; See the Programmer's Guide 
MENUPICK EQU $00000100 ; See the Programmer's Guide 
CLOSEWINDOW EQU $00000200 ; See the Programmer's Guide 
RAWKEY EQU $00000400 ; See the Programmer's Guide 
REQVERIFY EQU $00000800 ; See the Programmer's Guide 
REQCLEAR EQU $00001000 7? See the Programmer's Guide 
MENUVERIFY EQU $00002000 ; See the Programmer's Guide 
NEWPREFS EQU $00004000 ; See the Programmer's Guide 
DISKINSERTED EQU $00008000 ; See the Programmer's Guide 
DISKREMOVED EQU $00010000 ; See the Programmer's Guide 
WBENCHMESSAGE EQU $00020000 ; See the Programmer's Guide 
ACTIVEWINDOW EQU $00040000 ; See the Programrer's Guide 
INACTIVEWINDOW EQU $00080000 ; See the Programmer's Guide 
DELTAMOVE EQU $00100000 ; See the Programmer's Guide 
VANILLAKBY EQU $00200000 j See the Programmer's Guide 
INTUITICKS EQU $00400000 See the Programmer's Guide 
; NOTEZ-BIEN: $80000000 is reserved for internal use by IDCMP 
; the IDCMP Flags do not use this special bit, which is cleared when 
; Intuition sends its special message to the Task, and set when Intuition 
7 gets its Message back from the Task. Therefore, I can check here -to 
find out fast whether or not this Message is available for me to send 

LONELYMESSAGE EQU $80000000 
i 777 IDCMP Codes qr nn 
; This group of codes is for the MENUVERIFY function 
MENUHOT EQU $0001 ; IntuiWants verification or MENUCANCEL 
MENUCANCEL EQU $0002 ; HOT Reply of this cancels Menu operation 
MENUWAITING EQU $0003 ; Intuition simply wants a ReplyMsg() ASAP 
; These are internal tokens to represent state of verification attempts 
; Shown here as a clue. 
OKOK EQU MENUHOT i; guy didn't care 
OKABORT EQU $0004 ; window rendered question moot 
OKCANCEL EQU MENUCANCEL ; window sent cancel reply 
; This group of codes is for the WBENCHMESSAGE messages 
WBENCHOPEN EQU $0001 
WBENCHCLOSE EQU $0002 
’ STRUCTURE Window, 0 

APTR wd_NextWindow ; for the linked list of a Screen 

WORD wd_LeftEdge 7; Screen dimensions 

WORD wd_TopEdge 7; sereen dimensions 

WORD wd_Width 7 screen dimensions 

WORD wd_Height ; screen dimensions 

WORD wd_MouseY ? relative top top-left corner 














6S - a 





Sep 28 17:22 1988 intuition/intuition.i Page il Sep 28 17:22 1988 intuition/intuition.i Page 12 





691 WORD wd_MouseX ; relative top top-left corner 760 ; These variables have the mouse coordinates relative to the 

692 761 ; inner-Window of GIMMEZEROZERO Windows. This is compared with the 
693 WORD wd_MinWidth ; Minimum sizes 762 ; MouseX and MouseY variables, which contain the mouse coordinates 
694 WORD wd_MinHeight ; Minimum sizes 763 ; relative to the upper-left corner of the Window, GIMMEZEROZERO 

695 WORD wd_MaxWidth ; Maximum sizes 764 ; notwithstanding 

696 WORD wd_MaxHeight ; maximum sizes 765 WORD wd_GZZMouseX 

697 766 WORD wd_GZZMouseY 

698 LONG wd_Flags ; see below for definitions 767 ; these variables contain the width and height of the inner—Window of 
699 768 ; GIMMEZEROZERO Windows 

700 APTR wd_MenuStrip ; first in a list of menu headers 769 WORD wd_GZZWidth 

701 770 WORD wd_G2ZHeight 

702 APTR wd_Title ; title text for the Window 771 

703 772 APTR wd_ExtData 

704 APTR wd_FirstRequest ; first in linked list of active Requesters 773 

705 APTR wd_DMRequest ; the double-menu Requester 774 ; general-purpose pointer to User data extension 

706 WORD wd_ReqCount ; number of Requesters blocking this Window 775 APTR wd_UserData 

707 APTR wd_WScreen ; this Window's Screen 776 APTR wd_WLayer ; stash of Window. RPort~>Layer 

708 APTR wd_RPort ; this Window's very own RastPort 777 

709 778 ; NEW 1.2: need to keep track of the font that OpenWindow opened, 

710 ; the border variables describe the window border. If you specify 779 ; in case user SetFont's into RastPort 

711 ; GIMMEZEROZERO when you open the window, then the upper-left of the 780 APTR IFont 

712 ; ClipRect for this window will be upper-left of the BitMap (with correct 781 

713 ; offsets when in SuperBitMap mode; you MUST select GIMMEZEROZERO when 782 LABEL wd_Size 

714 ; using SuperBitMap). If you don't specify ZeroZero, then you save 783 

715 ; Memory {no allocation of RastPort, Layer, ClipRect and associated 784 ; --- FLAGS REQUESTED (NOT DIRECTLY SET THOUGH) BY THE APPLIPROG ~-~~~~~~~~~—— 
716 ; Bitmaps), but you also must offset all your writes by BorderTop, 785 WINDOWSI ZING EQU $0001 ; include sizing system-gadget? 

717 ; BorderLeft and do your own mini-clipping to prevent writing over the 786 WINDOWDRAG EQU $0002 ; include. dragging system-gadget? 

718 ; system gadgets 787 WINDOWDEPTH EQU $0004 ; include depth arrangement gadget? 

719 BYTE wd_BorderLeft 788 WINDOWCLOSE EQU $0008 ; include close-box system-gadget? 

720 BYTE wd_BorderTop 789 

721 BYTE wd_BorderRight 790 SIZEBRIGHT EQU $0010 ; size gadget uses right border 

722 BYTE wd_BorderBottom 791 SIZEBBOTTOM EQU $0020 ; Size gadget uses bottom border 

723 APTR wd_BorderRPort 792 

724 793g —— LEFLESH MODES Mr a 
725 ; You supply a linked-list of gadget that you want for your Window. 794 ; combinations of the REFRESHBITS select the refresh type 

726 ; This list DOES NOT include system Gadgets. You get the standard 795 REFRESHBITS EQU $00CO 

727 ; window system Gadgets by setting flag~bits in the variable Flags (see 796 SMART REFRESH EQU $0000 

728 ; the bit definitions below) 797 SIMPLE REFRESH EQU $0040 

729 APTR wd_FirstGadget 798 SUPER_BITMAP EQU $0080 

730 799 OTHER_REFRESH EQU $00CO0 

731 ; these are for opening/closing the windows 800 

732 APTR wd_Parent 801 BACKDROP EQU $0100 ; this is an ever-popular BACKDROP window 
733 APTR wd_Descendant 802 

734 803 REPORTMOUSE EQU $0200 ; set this to hear about every mouse move 
735 ; sprite data information for your own Pointer 804 

736 ; set these AFTER you Open the Window by calling SetPointer() 805 GIMMEZEROZERO EQU $0400 . 7 Make extra border stuff 

737 APTR wd_Pointer 806 

738 BYTE wd_PtrHeight 807 BORDERLESS EQU $0800 ; set this to get a Window sans border 
739 BYTE wd_PtrWidth 808 

740 BYTE wd_xOffset 809 ACTIVATE EQU $1000 ; when Window opens, it's the Active one 
741 BYTE wd_YOffset 810 

742 811 ; FLAGS SET BY INTUITION 

743 ; the IDCMP Flags and User's and Intuition's Message Ports 812 WINDOWACTIVE EQU $2000 ; this window is the active one 

744 ULONG wd_IDCMPFlags 813 INREQUEST EQU $4000 ; this window is in request mode 

745 APTR wd_UserPort 814 MENUSTATE EQU $8000 ; this Window is active with its Menus on 
746 APTR wd. WindowPort 815 

747 APTR wd_MessageKey BLE fp mm OCHS USEL PLAgs marr 
748 817 RMBTRAP EQU $00010000 ; Catch RMB events for your own 

749 BYTE wd_DetailPen 818 NOCAREREFRESH EQU $00020000 ; not to be bothered with REFRESH 

750 BYTE wd_BlockPen 819 

751 B20 5 ——— Other Tmtuit Lom PLags om 
752 ; the CheckMark is a pointer to the imagery that will be used when 821 WINDOWREFRESH EQU $01000000 ; Window is currently refreshing 

753 ; rendering MenuItems of this Window that want to be checkmarked 822 WBENCHWINDOW EQU $02000000 7; WorkBench Window 

754 ; if this is equal to NULL, you'll get the default imagery 823 WINDOWTICKED EQU $04000000 ; only one timer tick at a time 

795 APTR wd_CheckMark 824 

756 825 SUPER_UNUSED EQU $FCFC0000 ;bits of Flag unused yet 

757 ; if non-null, Screen title when Window is active 826 

7598 APTR wd_ScreenTitle 827 

759 828 ; ~-- see struct IntuiMessage for the IDCMP Flag definitions ~-----~———""-~~ 





—t 





09 -—da 
































Sep 28 17:22 1988 intuition/intuition.i Page 13 Sep 28 17:22 1988 intuition/intuition.i Page 14 

829 898 INCLUDE “intuition/screens. i" 

830 899 ENDC 

831 ; 900 

832 ; 901 IFND INTUITION_PREFERENCES_I 

833 902 INCLUDE "intuition/preferences. i" 

834 903 ENDC 

835 904 

836 WORD nw_LeftEdge ; initial Window dimensions 905 ; 

837 WORD nw_TopEdge ; initial Window dimensions 906 ; 

838 WORD nw_Width ; initial Window dimensions 907 ; =Ss> 

839 WORD nw_Height ; initial Window dimensions 908 ; this structure is used for remembering what memory has been allocated to 
840 909 ; date by a given routine, so that a premature abort or systematic exit 
841 BYTE nw_DetailPen ; for rendering the detail bits of the Window 910 ; can deallocate memory cleanly, easily, and completely 

842 BYTE nw_BlockPen ; for rendering the block~fill bits 911 STRUCTURE Remember, 0 

843 912 

844 LONG nw_IDCMPFlags ; initial IDCMP state 913 APTR xm _NextRemember 

845 914 LONG rm_RememberSize 

846 LONG nw_Flags ; see the Flag definition under Window 915 APTR xm_Memory 

847 916 

848 ; You supply a linked-list of Gadgets for your Window. 917 LABEL rm_SIZEOP 

849 i; This list DOES NOT include system Gadgets. You get the standard 918 

850 ; System Window Gadgets by setting flag-bits in the variable Flags (see 919 

851 ; the bit definitions under the Window structure definition) 920 

852 “APTR nw_FirstGadget 921 ; 

853 922 ; 

854 ; the CheckMark is a pointer to the imagery. that will be used when 923 ; 

855 ; rendering Menultems of this Window that want to be checkmarked 924 

856 ; if this is equal to NULL, you'll get the default imagery 925 ; 

857 APTR nw_CheckMark 926 ;#define MENUNUM(n) (n & Ox1F) 

858 / 927 ;#define ITEMNUM(n) ((n >> 5) & Ox003F) 

859 APTR nw_Title ; title text for the Window 928 ;#define SUBNUM(n) ((n >> 11) & Ox001F) 

860 929 ; 

861 ; the Screen pointer is used only if you've defined a CUSTOMSCREEN and 930 ;#define SHIFTMENU(n) (n & OxLF) 

862 ; want this Window to open in it. If so, you pass the address of the 931 ;#define SHIFTITEM(n) ((n & Ox3F) << 5) 

863 ; Custom Screen structure in this variable. Otherwise, this variable 932 ;#define SHIFTSUB(n) ((n & OxlF) << 11) 

864 ; is ignored and doesn't have to be initialized. 933 ; 

865 APTR nw_Screen 934 ;#define SRBNUM(n) (0x08 - (n >> 4)) /* SerRWBits -> read bits per char. */ 
866 935 ;#define SWBNUM(n) (0x08 - (n & Ox0F))/* SerRWBits -> write bits per chr */ 
867 i; SUPER_BITMAP Window? If so, put the address of your BitMap structure 936 ;#define SSBNUM(n) (0x01 + (n >> 4)) /* SerStopBuf -> stop bits per chr */ 
868 ; in this variable. If not, this variable is ignored and doesn't have 937 ;#define SPARNUM(n) (n >> 4) /* SerParShk -> parity setting */ 
869 ; to be initialized 938 ;#define SHAKNUM(n) (n & Ox0F) /7* SerParShk —> handshake mode */ 
870 APTR nw_BitMap 939 ; 

871 940 ; = MENU STUFF =====s=8essssseseeessesssee ses sess SS SS 
872 ; the values describe the minimum and maximum sizes of your Windows. 94] NOMENU FQU $OO1LF 

873 ; these matter only if you've chosen the WINDOWSIZING Gadget option, 942 NOITEM EQU $003F 

874 ; which means that you want to let the User to change the size of 943 NOSUB. EQU SOO1LF 

875 ; this Window. You describe the minimum and maximum sizes that the 944 MENUNULL EQU SFFFF 

876 ; Window can grow by setting these variables. You can initialize 945 

877 ; any one these to zero, which will mean that you want to duplicate 946 

878 ; the setting for that dimension (if MinWidth == 0, MinWidth will be 947 ; = =RJ='s peculiarities =-=s===«===<=ss0s<sssssseesssoSSSSSSS55555558S8= 
8793 i; set to the opening Width of the Window). 948 ;#define FOREVER for(;;) 

880 ; You can change these settings later using SetWindowLimits(). 949 ;#define SIGN(x) ( ((x) > 0) - ((x) ¢ 0) ) 

881 ; If you haven't asked for a SIZING Gadget, you don't have to 950 

882 ; initialize any of these variables. 951 

883 WORD nw_MinWidth 952 ; these defines are for the COMMSEQ and CHECKIT menu stuff. If CHECKIT, 
884 WORD nw_MinHeight 953 ; I'll use a generic Width (for all resolutions) for the CheckMark. 

885 WORD nw_MaxWidth 954 ; If COMMSEQ, likewise I'll use this generic stuff 

886 WORD nw_MaxHeight 955 CHECKWIDTH EQU 19 

887 956 COMMWIDTH EQU 27 

888 ; the type variable describes the Screen in which you want this Window to 957 LOWCHECKWIDTH EQU 13 

889 ; Open. The type value can either be CUSTOMSCREEN or one of the 958 LOWCOMMWIDTH EQU 16 

890 ; system standard Screen Types such as WBENCHSCREEN. See the 959 

891 ; type definitions under the Screen structure 960 

892 WORD nw_Type 961 ; these are the AlertNumber defines. if you are calling DisplayAlert() 
893 962 ; the AlertNumber you supply must have the ALERT_TYPE bits set to one 

894 LABEL nw_SIZE 963 ; of these patterns 

895 964 ALERT_TYPE EQU $80000000 

896 965 RECOVERY_ALERT EQU $00000000 ; the system can recover from this 
897 IFND INTUITION _SCREENS_I 966 DEADEND_ALERT —EQU $80000000 j no recovery possible, this is it 

















28 17:22 1988 intuition/intuition.i Page 15 Sep 28 17:22 1988 intuition/intuitionbase.i Page 1 























1 IFND INTUITION _INTUITIONBASE_I 
2 INTUITION_INTUITIONBASE_TI SET 1 
; When you're defining IntuiText for the Positive and Negative Gadgets 3 ** 
; created by a call to AutoRequest(), these defines will get you 4 ** $Filename: intuition/intuitionbase.i $ 
j reasonable-looking text. The only field without a define is the IText 5 ** $SRelease: 1.3 $ 
field; you decide what text goes with the Gadget 6 ** 
AVTOFRONTPEN EQU 0 7 ** the IntuitionBase structure and supporting structures 
AUTOBACKPEN EQU 1 8 *x* 
AUTODRAWMODE EQU RP_JAM2 Q xx (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
AUTOLEFTEDGE EQU 6 10 ** All Rights Reserved 
AUTOTOPEDGE EQU 3 1] ** 
AUTOITEXTFONT EQU 0 12 
AUTONEXTTEXT EQU 0 13 IFND EXEC_TYPES_I 
14 INCLUDE "exec/types.i" 
15 ENDC 
16 
;* -~~ RAWMOUSE Codes and Qualifiers (Console OR IDCMP) -77Tow77WWTTOOOor 17 IFND. EXEC_LIBRARIES_T 
SELECTUP EQU (IECODE_LBUTTON+IECODE_UP_PREFIX) 18 INCLUDE “exec/libraries.i" 
SELECTDOWN EQU (IECODE_LBUTTON) 19 ENDC 
MENUUP EQU (IECODE_RBUTTON+IECODE_UP_PREFIX) 20 
MENUDOWN EQU ( IECODE_RBUTTON) al IFND GRAPHICS_VIEW_I 
ALTLEFT EQU (IEQUALIFIER_LALT) 22 INCLUDE "graphics/view. i" 
ALTRIGHT EQU ( LEQUALIPIER_RALT) 23 ENDC 
AMIGALEFT EQU (IEQUALIFIER_LCOMMAND) 24 
AMIGARIGHT EQU (ITEQUALIFIER_RCOMMAND) 25 * Be sure to protect yourself against someone modifying these data as 
AMIGAKEYS EQU (AMIGALEFT+AMIGARIGHT) 26 * you look at them. This is done by calling: 
27 * 
CURSORUP EQU $4c 28 * lock = LockIBase(0), which returns a ULONG. When done call 
CURSORLEFT EQU S4F 29 * pod dO 
CURSORRIGHT EQU $4E . 30 * UnlockIBase(lock) where lock is what LockIBase() returned. 
CURSORDOWN EQU $4D 31 * AO 
KEYCODE_Q EQU $10 32 * NOTE: these library functions are simply stubs now, but should be called 
KEYCODE_X EQU $32 33 * to be compatible with future releases. 
KEYCODE_N EQU $36 34 
KEYCODE_M EQU $37 35 * 
KEYCODE_V EQU $34 36 * 
KEYCODE_B EQU $35 37 * 
38 STRUCTURE IntuitionBase,0 
IFND INTUITION _INTUITIONBASE_I 39 
include “intuition/intuitionbase. i" 40 STRUCT ib _LibNode,LIB_SIZE 
ENDC 41 STRUCT ib ViewLord, v_SIZEOF 
42 APTR iblActiveWindow 
ENDC 7 INTUITION_INTUITION_I 43 APTR ib_ActiveScreen 
44 
45 * the FirstScreen variable points to the frontmost Screen. Screens are 
46 * then maintained in a front to back order using Screen.NextScreen 
47 
48 APTR ib FirstScreen 
49 
50 * there is not size here because... 
51 * 
52 * 
53 


54 ENDC ; INTUITION_INTUITIONBASE_I 











c9 - a 


n 
Q 
o 


WCONNMNSWNHE 


He 
ro 


12 








28 17:22 1988 intuition/preferences.i Page 1 


IFND INTUITION _PREFERENCES_1I 
INTUITION_PREFERENCES I SET i 
xk 
xe $Filename: intuition/preferences.i $ 
aK $Release: 1.3 $ 
xk 
ed 
kk 
ax (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 


xk 


IFND EXEC_TYPES_I 
INCLUDE “exec/types. i" 
ENDC 


ITFND DEVICES _TIMER_I 


include "devices/timer.i" 
ENDC 





; these are the definitions for the printer configurations 
FILENAME SIZE EQU 30 ; Filename size 
Size of Pointer data buffer 


POINTERSIZE EQU (14+164+1)*2 ; 


; These defines are for the default font size. These actually describe the 
; height of the defaults fonts. The default font type is the topaz 

i font, which is a fixed width font that can be used in either 

i eighty—column or sixty-column mode. The Preferences structure reflects 

i which is currently selected by the value found in the variable FontSize, 
; which may have either of the values defined below. These values actually 
; are used to select the height of the default font. By changing the 

; height, the resolution of the font changes as well. 


TOPAZ EIGHTY EQU 8 

TOPAZ SIXTY EQU 9 

’ STRUCTURE Preferences ,0 
; the default font height 
BYTE pf_FontHeight ; height for system default font 
; constant describing what's hooked up to the port 
BYTE pf_PrinterPort ; printer port connection 
; the baud rate of the port 
WORD pf_BaudRate ; baud rate for the serial port 
; various timing rates 
STRUCT pf£_KeyRptSpeed,TV_SIZE ; repeat speed for keyboard 
STRUCT pf KeyRptDelay,TV_SIZE ; Delay before keys repeat. 
STRUCT pf DoubleClick,TV_SIZE ; Interval allowed between clicks 
; Intuition Pointer data 
STRUCT pf_PointerMatrix,POINTERSIZE*2 ; Definition of pointer sprite 
BYTE pf_xoffset i X-Offset for active 'bit' 
BYTE pf_yoffset 3; Y-Offset for active 'bit' 
WORD pf. colorl7 PRR AR KR KK KKK RE KKEKEKREKEKREEE 
WORD pf_color18 ; Colours for sprite pointer 
WORD pf_colorl9 PRRRKKRRAKKK KR REK EKER RKEKEERKK EEE 
WORD pf_PointerTicks ; Sensitivity of the pointer 
3; Workbench Screen colors 
WORD pf_colord PRR RRA KKK IKKE KEIR IR IK IRE 
WORD pf_colorl 7; Standard default colours 


Sep -28 17:22 1988 





ll 


intuition/preferences.i Page 2 


70 WORD pf_color2 i Used in the Workbench 

qi WORD pf_color3 PRRR ARK R KRHA KK KKK KAKA K KER KKK KEKE 

72 

73 ; positioning data for the Intuition View 

74 BYTE pf_ViewXxoffset ; Offset for top lefthand corner 

75 BYTE pf_Viewyoffset ; X and Y dimensions 

76 WORD pf_ViewInitx ; View initial offsets at startup 

77 WORD pf _ViewInity ; View initial offsets at startup 

78 

79 BOOL EnablecLt ; CLI availability switch 

80 

81 ; printer configurations 

82 WORD pf_PrinterType ; printer type 

83 STRUCT pf_PrinterFilename, FILENAME SIZE ; file for printer 

84 

85 ; print format and quality configurations 

86 WORD pf_PrintPitch ; print pitch 

87 WORD pf_PrintQuality i; print quality 

88 WORD pf_PrintSpacing ; number of lines per inch 

89 WORD pf_PrintLeftMargin ; left margin in characters 

30 WORD pf_PrintRightMargin ; right margin in characters 

91 WORD pf_PrintImage ; positive or negative 

92 WORD pf_PrintAspect ; horizontal or vertical 

93 WORD pf_PrintShade ; b&w, half-tone, or color 

94 WORD pf_PrintThreshold ; darkness ctrl for b/w dumps 

95 

96 

97 ; print paper description 

98 WORD pf _PaperSize j; Paper size 

99 WORD pf_PaperLength } paper length in lines 

100 WORD pf_PaperType ; continuous or single sheet 

101 . 

102 ; Serial device settings: These are six nibble-fields in three bytes 
103 (these look a little strange so the defaults will map out to zero) 
104 BYTE pf_SerRWBits ; upper nibble = (8-number of read bits) 
105 ; lower nibble = (8-number of write bits) 
106 BYTE pf_SerStopBuf ; upper nibble = (number of stop bits - 1) 
107 ; lower nibble = (table value for BufSize) 
108 BYTE pf_SerParShk 7; upper nibble = (value for Parity setting) 
109 7; lower nibble = (value for Handshake mode) 
110 

111 BYTE pf_LacewB ; if workbench is to be interlaced 

112 

113 STRUCT pf_WorkName,FILENAME SIZE ; temp file for printer 

114 : 

115 BYTE pf_RowSizeChange i 

116 BYTE pf_ColumnSizeChange ; 

117 

118 UWORD  pf_PrintFlags j; user preference flags 

119 WORD pf_PrintMaxWidth 7 max width of printed picture in l0ths/inch 
120 UWORD = pf_ PrintMaxHeight ; max height of printed picture in 10ths/inch 
121 UBYTE pf _PrintDensity ; print density 

122 UBYTE pf_Printxoffset ; offset of printed picture in 10ths/inch 
123 

124 UWORD = pf_wb_ Width ; override default workbench width 

125 UWORD = pf_wb Height ; override default workbench height 

126 UBYTE pf_wb Depth ; override default workbench depth 

127 

128 UBYTE pf_ext size 7; extension information -- do not touch! 
129 ; extension size in blocks of 64 bytes 
130 LABEL pf SIZEOF 

131 

132 

133 ; === Preferences definitions =="====s=ss=ssss=ssssess=sssSSsSSSSSSSSSSs=m 
134 

135 ; Workbench Interlace (use one bit) 

136 LACEWB EQU $01 

137 

138 ; PrinterPort 











€9 - a 











Sep 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
1793 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 
193 
194 
195 
196 
197 
198 
199 
200 
201 
202 
203 
204 
205 
206 
207 


28 17:22 1988 


PARALLEL_PRINTER EQU 
SERIAL PRINTER EQU $01 


; BaudRate 

BAUD_110 EQU 
BAUD _300 EQU 
BAUD_1200 QU 
BAUD_2400 QU 
BAUD 4800 EQU 
BAUD_9600 EQU 


BAUD 19200 EQU 
BAUD_MIDI EQU 
; PaperType 
FANFOLD EQU 
SINGLE EQU 
; PrintPitch 
PICA EQU 
ELITE EQU 
FINE EQU 
; PrintQuality 
DRAFT EQU 
LETTER EQU 
; PrintSpacing 
SIX_LPI EQU 


EIGHT_LPI EQU 


; Print Image 
IMAGE POSITIVE 
IMAGE_NEGATIVE 


; PrintAspect 
ASPECT_HORIZ 
ASPECT_VERT EQU 


; PrintShade 

SHADE_BW EQU 
SHADE_GREYSCALE 
SHADE COLOR EQU 


; PaperSize 
US_LETTER EQU 


US_LEGAL EQU 
N_TRACTOR — EQU 
W_TRACTOR QU 
CUSTOM EQU 
; PrinterType 


CUSTOM NAME EQU 
ALPHA_P_101 EQU 
BROTHER_15XL 

CBM MPS1000 EQU 
DIAB_630 EQU 
DIAB_ADV_D25 

DIAB_C 150 EQU 
EPSON EQU 
EPSON_JX_80 EQU 
OKIMATE 20 EQU 
QUME_LP_20 EQU 


HP_LASERJET EQU 


HP_LASERJET_PLUS EQU 


$00 
$ol 
$02 
$03 
$04 
$05 
$06 
$07 


$00 
$80 


$000 
$400 
$800 


$000 
$100 


$000 
$200 


EQU 
EQU 


EQU 
$01 


$00 
EQU 
$02 


$00 
$10 
$20 
$30 
$40 


$00 
$0l 
EQU 
$03 
$04 
EQU 
$06 
$07 
$08 
$09 
SOA 


SOB 


intuition/preferences.i Page 3 


$00 


$00 
$01 


$00 


Sol 


$02 


$05 


new printer entries, 3 October 1985 


$oc 


; Serial Input Buffer Sizes 


SBUF_512 


EQU 


$00 








Sep 


208 
209 
210 
211 
212 
213 
214 
215 
216 
217 
218 
219 
220 
221 
222 
223 
224 
225 
226 
227 
228 
229 
230 
231 
232 
233 
234 
235 
236 
237 
238 
239 
240 
241 
242 
243 
244 
245 
246 
247 
248 
249 
250 
251 
252 
253 
254 
255 
256 
257 
258 
259 
260 


28 17:22 1988 intuition/preferences.i Page 4 


SBUF_1024 EQU 
SBUF_2048 EQU 
SBUF_4096 EQU 
SBUF_8000 EQU 
SBUF 16000 EQU 
; Serial Bit Masks 

SREAD BITS EQU $FO 


SWRITE_BITS EQU SOF 


SSTOP_BITS EQU $FO 


SBUFSIZE_BITS EQU SOF 


SPARITY_BITS EQU 


SHSHAKE_ BITS EQU SOF 


i 


$01 
$02 
$03 
$04 
$05 


(BOUNDED_|  DIMENSIONS+ABSOLUTE_DIMENSIONS+PIXEL_DIMENSIONS 


SPARITY_NONE EQU $00 
SPARITY_EVEN EQU $ol 
SPARITY_ODD EQU $02 
SHSHAKE_XON EQU 
SHSHAKE_RTS EQU $ol 
SHSHAKE_NONE EQU $02 

; new defines for PrintFlags 
CORRECT_RED EQU $0001 
CORRECT_GREEN EQU $0002 
CORRECT_BLUE FOU $0004 
CENTER_IMAGE EQU $0008 
IGNORE_DIMENSIONS EQU $0000 
BOUNDED DIMENSIONS EQU $0010 
ABSOLUTE_DIMENSIONS EQU $0020 
PIXEL DIMENSIONS EQU $0040 
MULTIPLY DIMENSIONS. EQU $0080 
INTEGER_SCALING EBQU $0100 
ORDERED_DITHERING EQU $0000 
HALPTONE DITHERING EQU $0200 
FLOYD_DITHERING EQU $0400 
ANTI_ALIAS EQU $0800 
GREY_SCALE2 EQU $1000 
CORRECT_RGB_MASK EQU (CORRECT _] 
DIMENSIONS_MASK EQU 
DITHERING_MASK EQU 


ENDC 


i 


; pf_SerRWBits 


; pf_SerStopBuf 


SFO ; pf_SerParShk 


Serial Handshake Mode (low nibble, mask by SHSHAKE_BIT'S) 


Serial Parity (high nibble, but here shifted right, as by C-macro SPARNUM) 


; color correct red shades 
; color correct green shades 
; color correct blue shades 


; center image on paper 


ignore max width/height 
use max width/height as 
use max width/height as 
use max width/height as 
use max width/height as 


; force integer scaling 


; ordered dithering 
; halftone dithering 


settings 
boundaries 
absolutes 
prt pixels 
multipliers 


; floyd-steinberg dithering 


; anti-alias image 


i 


RED+CORRECT_GREEN+CORRECT. 


for use with hi-res monitor 


' BLUE) 


(HALFTONE_DITHERING+FLOYD_DITHERING) 


INTUITION_PREFERENCES_I 














79 - @ 








Sep 


CONDON 


28 17:22 1988 intuition/screens.i Page 1 


IFND INTUITION_SCREENS_I 


INTUITION _SCREENS_I SET 1 


ae 
kk 
Kk 
ak 
x* 
*k 
xk 
* 
xk 


$Filename: intuition/screens.i $ 
SRelease: 1.3 $ 


(C) Copyright 1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


IFND EXEC_TYPES_I 
INCLUDE "exec/types.i" 
ENDC 


IFND GRAPHICS GFX_I 
INCLUDE "graphics/gf{x.i" 
ENDC 


IFND GRAPHICS CLIP_I 
INCLUDE "graphics/clip.i" 
ENDC 


IFND GRAPHICS VIEW_I 
INCLUDE "graphics/view. i" 
ENDC 


IFND GRAPHICS _RASTPORT_I 
INCLUDE "graphics/rastport. i" 
ENDC 


IFND GRAPHICS | LAYERS _T 
INCLUDE "graphics/layers. i" 
ENDC 























’ STRUCTURE Screen, 0 


APTR 
APTR 


WORD sc_LeftEdge 
WORD sc_TopEdge 


WORD sc_Width 


WORD sc_Height ; for Windows without ScreenTitle 
WORD sc_MouseY ; position relative to upper-left © 
WORD sc_MouseX ; position relative to upper-left 
WORD sc_Flags ; see definitions below 

APTR sc_Title 

APTR sc_DefaultTitle 


3; Ba 
BYTE 
BYTE 
BYTE 
BYTE 


BYTE 
BYTE 
BYTE 
BYTE 
BYTE 


sc_NextScreen ; linked list of screens 
sce_FirstWindow i; linked list Screen's Windows 


x sizes for this Screen and all Window's in this Screen 


sec_BarHeight 
sc_BarVBorder 
sc_BarHBorder 
sc_MenuVBorder 
sc_MenuHBorder 
sc_WBorTop 
sc_WBorLeft 
sc_WBorRight 
sc_WBorBottom 


parameters of the screen 
parameters of the screen 


null-terminated Title text 





Sep 28 17:22 1988 intuition/screens.i Page 2 

















BYTE sc_KludgeFil100 ; This is strictly for word-alignment 
; the display data structures for this Screen 
APTR sc_Font ; this screen's default font 
STRUCT sc_ViewPort ,vp_SIZEOF ; describing the Screen's display 
STRUCT sc_RastPort,rp_SIZEOF ; describing Screen rendering 
STRUCT se BitMap bm | SIZEOF ; auxiliary graphexcess baggage 
STRUCT sc_LayerInfo,li_SIZEOF ; each screen gets a LayerInfo 
; You supply a linked-list of Gadgets for your Screen. 
; This list DOES NOT include system Gadgets. You get the standard 
; system Screen Gadgets by default 
APTR sc_FirstGadget 
BYTE sc_DetailPen ; for bar/border/gadget rendering 
BYTE sc_BlockPen ; for bar/border/gadget rendering 
; the following variable(s) are maintained by Intuition to support. the 
; DisplayBeep() color flashing technique 
WORD sc_SaveColor0 
; This layer is for the Screen and Menu bars 
APTR sc_BarLayer ; was "BarLayer" 
APTR sc_ExtData 
APTR sc_UserData ; general-purpose pointer to User data 
LABEL sc_SIZEOF 
7 ~~~ FLAGS SET BY INTUITION mr 
; The SCREENTYPE bits are reserved for describing various Screen types 
; available under Intuition. 
SCREENTYPE EQU $O00F ; all the screens types available 
j 77 the definitions for the Screen Type —------~----—--~~-----~~~~-~-------— 
WBENCHSCREEN EQU $0001 i; Ta Da! The Workbench 
CUSTOMSCREEN EQU SOOO0F ; for that special look 
SHOWIITLE EQU $0010 i this gets set by a call to ShowTitle() 
BEEPING EQU $0020 ; set when Screen is beeping 
CUSTOMBITMAP EQU $0040 ; if you are supplying your own BitMap 
SCREENBEHIND EQU $0080 ; if you want your screen to open behind 
; already open screens 
SCREENQUIET EQU $0100 ; if you do not want Intuition to render 
; into your screen (gadgets, title) 
STDSCREENHEIGHT EQU -1 7 supply in NewScreen.Height 
i 
i NewScreen = 
STRUCTURE NewScreen, 0 
WORD ns_LeftEdge ; initial Screen dimensions 
WORD ns_TopEdge ; initial Screen dimensions 
WORD ns_Width ; initial Screen dimensions 
WORD ns_Height 7 initial Screen dimensions 
WORD ns_Depth ; initial Screen dimensions 
BYTE ns_DetailPen ; default rendering pens (for Windows too) 
BYTE ns_BlockPen ; default rendering pens (for Windows too) 
WORD ns_ViewModes ; @isplay "modes" for this Screen 








69 -a 





pe 28 17:22 1988 intuition/screens.i Page 3 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 





WORD ns_Type ; Intuition Screen Type specifier 
APTR ns_Font ; default font for Screen and Windows 
APTR ns_DefaultTitle ; Title when Window doesn't care 
APTR ns_ Gadgets ; Your own initial Screen Gadgets 


; if you are opening a CUSTOMSCREEN and already have a BitMap 

; that you want used for your Screen, you set the flags CUSTOMBITMAP in 
; the Types variable and you set this variable to point to your BitMap 

# structure. The structure will be copied into your Screen structure, 

; after which you may discard your own BitMap if you want 

APTR ns_CustomBitMap 


LABEL ns_SIZEOF 


ENDC 7; INTUITION_SCREENS_I 








() 


99 - a 


Sep 28 17:22 1988 libraries/configregs.i Page 1 


1 IFND LIBRARIES_CONFIGREGS_T 
2 LIBRARIES_CONFIGREGS_I SET 1 
3 xe 
4 *x $Filename: libraries/configregs.i $ 
5 ** SRelease: 1.3 $ 
6 *x 
7 ** register and bit definitions for expansion boards 
8 xk 
Q ** {C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
LL x 
12 


13 ** Expansion boards are actually organized such that only one nibble per 
14 ** word (16 bits) are valid information. This table is structured 

15 ** as LOGICAL information. This means that it never corresponds 

16 ** exactly with a physical implementation. 

17 ** 

18 ** The expansion space is logically split into two regions: 

19 ** a rom portion and a control portion. The rom portion is 

20 ** actually stored in one's complement form (except for the 

21 ** er type field). 


22 

23 

24 STRUCTURE ExpansionRom, 0 

25 UBYTE er_Type 

26 UBYTE er_Product 

27 UBYTE er_Flags 

28 UBYTE er Reserved03 
29 UWORD er_ Manufacturer 
30 ULONG er SerialNumber 
31 UWORD er_InitDiagVec 
32 UBYTE er Reserved0c 
33 UBYTE er_Reserved0d 
34 UBYTE er_Reserved0e 
35 UBYTE er Reserved0f 
36 LABEL ExpansionRom_SIZEOF 
37 


38 STRUCTURE ExpansionControl ,0 


39 UBYT ec_Interrupt ; interrupt control register 
40 UBYTE ec_Reservedll 

41 UBYTE ec_BaseAddress ; set new config address 

42 UBYTE ec_Shutup ; @on't respond, pass config out 
43 UBYTE ec_Reserved14 

44 UBYTE ec_Reserved15 

45 UBYTE ec_Reserved16 

46 UBYTE ec_Reservedl7 

47 UBYTE ec_Reserved18 

48 UBYTE ec_Reservedl9 

49 UBYTE ec_Reservedla 

50 UBYTE ec_Reservedlb 

51 UBYTE ec_Reservedic 

52 UBYTE ec_Reservedid 

53 UBYTE ec_Reservedie 

54 UBYTE ec_Reservedif 

55 LABEL ExpansionControl_SIZEOF 

56 

57 xk 


58 ** many of the constants below consist of a triplet of equivalent 
59 ** definitions: xxMASK is a bit mask of those bits that matter. 

60 ** xxBIT is the starting bit number of the field. xxSIZE is the 
61 ** number of bits that make up the definition. This method is 

62 ** used when the field is larger than one bit. 


64 ** If the field is only one bit wide then the xxB_xx and xxF_xx convention 
65 ** is used (xxB_xx is the bit number, and xxF_xx is mask of the bit). 


68 ** manifest constants */ 


69 E SLOTSIZE EQU $10000 


28 17:22 1988 libraries/configregs.i Page 2 


E_SLOTMASK 
E_SLOTSHIFT 


EQU Sffff 
EQU 16 


** these define the two free regions of Zorro memory space. 
** THESE MAY WELL CHANGE FOR FUTURE PRODUCTS! 


E_EXPANSIONBASE EQU $e80000 
E_EXPANSIONSIZE EQU $080000 
E_EXPANSIONSLOTS EQU 8 
E_MEMORYBASE EQU $200000 
E_MEMORYSIZE EQU $800000 
E_MEMORYSLOTS EQU 128 


xxkxxx* ec Type definitions */ 


** board type -- ignore "old style" boards */ 
ERT_TYPEMASK EQU $c0 


ERT_TYPEBIT EOU 6 
ERT_TYPESIZE EQU 2 
ERT_NEWBOARD EQU $c0 


*x* type field memory size */ 


ERT_MEMMASK EQU $07 
ERT _MEMBIT EQU 0 
ERT_MEMSIZE EQU 3 


*x other bits defined in type field */ 
BITDEF ERT, CHAINEDCONFIG, 3 
BITDEF ERT,DIAGVALID,4 
BITDEF ERT,MEMLIST,5 


** er Flags byte -- for those things that didn't fit into the type byte */ 
BITDEF ERF,MEMSPACE,7 ; wants to be in 8 meg space. Also 

i implies that board is moveable 

i; board can't be shut up. Must not 

; be a board. Must be a box that 

; does not pass on the bus. 


BITDEF ERF,NOSHUTUP,6 


** interrupt control register */ 
BITDEF ECI,INTENA,1 
BITDEF ECI,RESET,3 
BITDEF ECI,INT2PEND,4 
BITDEF ECI,INT6PEND,5 
BITDEF ECI,INT7PEND,6 
BITDEF ECI, INTERRUPTING,7 


RHR KKK KKK EERE IKKE KR ER KERR KHER KKK KEK KAA KEKE KEKE RRA ERK 

xk 

** these are the specifications for the diagnostic area. If the Diagnostic 
*x* Address Valid bit is set in the Board Type byte (the first byte in 

** expansion space) then the Diag Init vector contains a valid offset. 

kk 

** The Diag Init vector is actually a word offset from the base of the 

** board. The resulting address points to the base of the DiagArea 

** structure. The structure may be physically implemented either four, 

** eight, or sixteen bits wide. The code will be copied out into 

*x ram first before being called. 

kk 

** The da_Size field, and both code offsets (da_DiagPoint and da_BootPoint) 
** are offsets from the diag area AFTER it has been copied into ram, and 

*x "de-nibbleized" (if needed). Inotherwords, the size is the size of 

** the actual information, not how much address space is required to 








49 -a 








Sep 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 
169 
170 
171 
172 
173 
174 
175 
176 
177 
178 
179 
180 
181 
182 
183 
184 
185 
186 
187 
188 
189 
190 
191 
192 


28 


ak 
ask 
xk 
** 
kk 
kk 
Kk 
uk 
xk 
xk 


17:22 1988 libraries/configregs.i Page 3 


store it. 


All bits are encoded with uninverted logic (e.g. 5 volts on the bus 
is a logic one). 


If your board is to make use of the boot facility then it must leave 
its config area available even after it has been configured. Your 
boot vector will be called APTER your board's final address has been 
set. 


HH K RRR HRI KI KICK RK IKI KR IKK RIK IKK KIKI IIR RIK KK II IK IIR IR IKARIA ERIK 


STRUCTURE DiagArea,0 


UBYTE da_Config 
UBYTE da_Flags 


i; See below for definitions 

; see below for definitions 
UWORD da_Size ; the size (in bytes) of the total diag area 
UWORD da_DiagPoint ; where to start for diagnostics, or zero 
UWORD da_BootPoint ; where to start for booting 
UWORD da_Name ; offset in diag area where a string 

} identifier can be found (or zero if no 

i identifier is present). 


UWORD da_Reserved01 ; two words of reserved data. must be zero. 
UWORD da_Reserved02 
LABEL DiagArea_SIZEOF 

; da_Config definitions 

DAC_BUSWIDTH EQU sco ; two bits for bus width 

DAC_NIBBLEWIDE EQU $00 

DAC_BYTEWIDE EQU $40 

DAC_WORDWIDE EQU $80 

DAC_BOOTTIME EQU $30 ; two bits for when to boot 

DAC_NEVER EQU $00 7; obvious 

DAC_CONFIGTIME EQU $10 7; Call da_BootPoint when first configing the 

} the device 
DAC_BINDTIME EQU - $20 ; run when binding drivers to boards 


eK 
xk 
xk 
Kk 
ak 
xk 
wk 
Kk 
“* 
kk 
xk 
kk 
Kk 
kk 


These are the calling conventions for Diag or Boot area 


A7 ~~ points to at least 2K of stack 


A6é —- ExecBase 

AS -- ExpansionBase 

A3 -—- your board's ConfigDev structure 

A2 — Base of diag/init area that was copied 


AO —- Base of your board 
Your board should return a value in DO. If this value is NULL, then 


the diag/init area that was copied in will be returned to the free 
memory pool. 


ENDC ; LIBRARIES_CONFIGREGS_I 





Sep 


WOnnuPWNeE 





28 17:22 1988 libraries/configvars.i Page 1 


LIBRARIES_CONFIGVARS_I SET 
aK 


wk 
ak 
Kk 
xx 
ae 
nk 
ak 
xk 


IFND LIBRARIES_CONFIGVARS_I 


1 


$SFilename: libraries/configvars.i $ 


$SRelease: 1.3 $ 


software structures for configuration subsystem 


(C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


IEND EXEC_NODES_I 
INCLUDE “exec/nodes. i" 
ENDC ; EXEC_NODES I 


IFND LIBRARIES_CONFIGREGS_I 
INCLUDE "libraries/configregs.i" 
ENDC ; LIBRARIES _ CONFIGREGS_T 


STRUCTURE ConfigDev,0 


STRUCT cd_Node,LN_SIZE 
UBYTE cd_Flags 
UBYTE cd_Pad 
STRUCT cd_Rom,ExpansionRom_SIZEOF ; copy of boards config rom 
APTR cd_BoardAddr 7; where in memory the board is 
APTR cd_BoardSize ; size in bytes 
UWORD ed_SlotAddr ; which slot number 
UWORD ced_SlotSize 7 number of slots the board takes 
APTR cd_Driver ; pointer to node of driver 
APTR ced_NextcD ; linked list of drivers to config 
STRUCT ced_Unused, 4*4 ; for whatever the driver whats 
LABEL ConfigDev_SIZEOF 

; cd_Flags 


BITDEF CD,SHUTUP,0 
BITDEF CD,CONFIGME,L  ; 


; this board has been shut up 


this board needs a driver to claim it 


; this structure is used by GetCurrentBinding() and SetCurrentBinding() 
STRUCTURE CurrentBinding,0 





APTR ch_ConfigDev 

APTR cb FileName 

APTR eb ProductString 

APTR cb_ToolTypes 

LABEL CurrentBinding_SIZEOF 
ENDC ; LIBRARIES CONFIGVARS_I 








g9 - 4 





wn 
oO 
© 


ODN AUP WHE 


28 17:22 1988 libraries/diskfont.i Page 1 


IFND 
LIBRARIES_DISKFONT_I 
*K 


LIBRARIES _DISKFONT_TI 
SET 1 


kk 
KK 
Kk 
xk 
ak 
xk 
a* 
x* 


SFilename: libraries/diskfont.i $ 
$Release: 1.3 $ 


diskfont library definitions 


Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 


All Rights Reserved 


(Cc) 


IFND EXEC_NODES_I 
INCLUDE "exec/nodes. i" 
ENDC 
IFND EXEC_LISTS_T 
INCLUDE "exec/lists.i" 
ENDC 
IFND GRAPHICS _TEXT_I 
INCLUDE "“graphics/text. i" 
ENDC 
MAXFONTPATH EQU 256 ; including null terminator 
STRUCTURE FC,0 
STRUCT fo_FileName ,MAXFONTPATH 


UWORD fc_YSize 
UBYTE fc Style 
UBYTE fc_Flags 
LABEL fc_SIZEOF 
FCH_ID EQU $0£00 
STRUCTURE FCH,0 
UWORD fch_FileID 
UWORD fch_NumEntries 
LABEL fch_FC i 


; FCH_ID 
; the number of FontContents elements 
the FontContents elements 


DFH_ID EQU 
MAXFONTNAME EQU 


$0£80 
32 ; font name including ".font\0" 


STRUCTURE DiskFontHeader ,0 
; the following 8 bytes are. not actually considered a part of the 
; DiskFontHeader, but immediately preceed it. The NextSegment is supplied 
; by the linker/loader, and the ReturnCode is the code at the beginning 
; of the font in case someone runs it. 
ULONG dfh_NextSegment 7; actually a “BPTR 
ULONG dfh ReturnCode ; MOVEQ #0,D0 : RTS 
here then is the official start of the DiskFontHeader... 
stRucT dfh_DF,LN_SIZE ; node to link disk fonts 
UWORD dfh_FileID ; DFH_ID 
UWORD dfh_Revision i the font revision in this version 
LONG dfh_ Segment. the segment. address when loaded 
STRUCT dfh_Name, MAXFONTNAME ; the font name (null terminated) 
STRUCT dfh_‘ TF, tf: SIZEOF ; loaded TextFont structure 
LABEL dfh_: STZEOF 


BITDEF AF , MEMORY , 0 
BITDEF AF,DISK,1 
STRUCTURE AF,0 
UWORD af_Type ; MEMORY or DISK 
STRUCT “af Attr,ta_SIZEOF ; text attributes for font 


LABEL af_SIZEOF 


STRUCTURE AFH,0 


UWORD afh_NumEntries ; number of AvailFonts elements 


hk 





Sep 28 17:22 1988 libraries/diskfont.i Page 2 


70 LABEL afh_AF ; the AvailFonts elements 
71 
72 ENDC ; LIBRARIES _DISKFONT_I 








69 -~ a 





Sep 28 20:25 1988 libraries/dos.i Page 1 


ODN DAUE WDNR 


IFND LIBRARIES _DOS_I 
LIBRARIES_DOS_I SET 1 
ak 
ae $Filename: libraries/dos.i $ 
x S$Release: 1.3 $ 
nk 
xe Standard assembler header for AmigaDOS 
KK 
** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 
x* 
* IFND EXEC_TYPES I 
* INCLUDE "exec/types.i" 
* ENDC 
DOSNAME MACRO 
pC.B ‘dos.library' ,0 
ENDM 

* Predefined Amiga DOS global constants 
DOSTRUE EQU -1 
DOSFALSE EQU 0 
* Mode parameter to Open() 
MODE_OLDFILE EQU. = 1005 * Open existing file read/write 
* * positioned at beginning of file. 
MODE_NEWFILE EQU. 1006 * Open freshly created file (delete 
* * old file) read/write 
MODE_READWRITE EQU 1004 * Open old file w/exclusive lock 
* Relative position to Seek() 
OFFSET_BEGINNING EQU) -i * relative to Beginning Of File 
OFFSET CURRENT EQU 0 * relative to Current file position 
OFFSET_END EQU 1 * relative to End Of File 
OFFSET_BEGINING EQU OFFSET_BEGINNING * Ancient compatibility 
BITSPERBYTE FQU 8 
BYTESPERLONG EQU 4 
BITSPERLONG EQU 32 
MAXINT EQU S$7FFFFFFF 
MININT EQU $80000000 
* Passed as type to Lock() 
SHARED _LOCK EQU -2 ; File is readable by others 
ACCESS _READ EOU = -2 ; Synonym 
EXCLUSIVE_LOCK EQU) 1 ; No other access allowed 
ACCESS WRITE EQU -1l  ; Synonym 
STRUCTURE DateStamp, 0 

LONG ds _ Days ; Number of days since Jan. 1, 1978 

LONG ds Minute ; Number of minutes past midnight 

LONG ds_Tick ; Number of ticks past minute 

LABEL ds_SIZEOF 7; DateStamp 
TICKS_PER_SECOND EQU 50 ; Number of ticks in one second 


* Returned by Examine() and ExInfo() 
STRUCTURE FileInfoBlock,0 


LONG 
LONG 


STRUCT fib_FileName,108 


LONG 
LONG 
LONG 
LONG 


fib_DiskKey 
fib_DirEntryType 
If > 0 a directory 

Null terminated. Max 30 chars used for now 
bit mask of protection, rwxd are 3-0. 


fib Protection 
fib_EntryType 
fib_Size ; Number of bytes in file 
fib_NumBlocks Number of blocks in file 


Type of Directory. If < 0, then a plain file. 


Sep 


117 
118 


120 
121 
122 
123 
124 
125 
126 
127 
128 
129 
130 
131 
132 
133 
134 
135 
136 
137 
138 


28 20:25 1988 - libraries/dos.i Page 2 


STRUCT fib DateStamp,ds_SIZEOF ; Date file last changed. 


STRUCT fib_Comment, 80 ; Null terminated. Comment associated with file 
STRUCT fib Reserved, 36 
LABEL fib SIZEOF ; FileInfoBlock 


* FIB stands for FileInfoBlock 
* FIBB are bit definitions, FIBF are field definitions 
BITDEF FIB,SCRIPT,6 ; program is an execute script 
BITDEF FIB,PURE,5 ; program is reentrant and reexecutable 
BITDEF FIB, ARCHIVE, 4 ; Cleared whenever file is changed 
BITDEF FIB,READ,3 ; ignored by the system 
BITDEF FIB,WRITE,2 ; ignored by the system 
BITDEF FIB, EXECUTE ,1 ; ignored by the system 
BITDEF FIB, DELETE , 0 ; prevent file from being deleted 


* All BCPL data must be long word aligned. BCPL pointers are the long word 
* address (i.e byte address divided by 4 (>>2)) 


* Macro to indicate BCPL pointers 
BPTR MACRO * Long word pointer 
LONG AL 
ENDM. 
BSTR MACRO * Long word pointer to BCPL string. 
LONG \L 
ENDM 


* #define BADDR( bptr ) (bptr << 2) * Convert BPTR to byte addressed pointer 


* BCPL strings have a length in the first byte and then the characters. 
* For example: s[0]=3 s[1]=S s[2]=Y s[3]=s 


* returned by Info() 

STRUCTURE InfoData,0 
LONG id_NumSoftErrors 
LONG id_UnitNumber 
LONG id_DiskState 
LONG id_NumBlocks 
LONG id_NumBlocksUsed 
LONG id_BytesPerBlock 


number of soft errors on disk 
Which unit disk is (was) mounted on 
See defines below 

Number of blocks on disk 

Number of block in use 


ee ee 


LONG id_DiskType * Disk Type code 
BPTR id_VolumeNode * BCPL pointer to volume node 
LONG id_InUse * Flag, zero if not in use 
LABEL id_SIZEOF * InfoData 
* ID stands for InfoData 
* Disk states 
ID_WRITE_PROTECTED EQU 80 * Disk is write protected 
ID_VALIDATING EQU 81 * Disk is currently being validated 
ID_VALIDATED EQU 82 * Disk is consistent and writeable 
* Disk types 
ID_NO_DISK_PRESENT EQU -1 
ID_UNREADABLE_DISK EQU ('B'<<24)!('A'K16)!('D' <<8B) 
ID_NOT_ REALLY Dos FQU ('N'<K24)!('DICK16) 1 C'O' KKB) ICTS") 
ID_DOS_DISK EQU ('D'<<24)!1('O'<<16) 1 ('S'<K<B) 
ID_KICKSTART DISK EFQU ('K'<<24) F(T I'<K16) 1 ('C' KKB) IC IK') 
* Errors from IoErr(), etc. 
ERROR_NO_FREE STORE EQU 103 
ERROR_TASK_TABLE_FULL EOQU 105 
ERROR_LINE_TOO_LONG EQU) 120 
ERROR_FILE_NOT_OBJECT EQU) 121 
ERROR_INVALID_RESIDENT_LIBRARY EQU 122 
ERROR_OBJECT_IN_USE EQU) 202 
ERROR_OBJECT_EXISTS EQU 203 
ERROR_OBJECT_NOT_FOUND EQU 205 
ERROR_ACTION_NOT KNOWN EQU 209 
ERROR_INVALID_COMPONENT_NAME EQU 210 
ERROR_INVALID LOCK FQU 211 





OL-~ da 








Sep 


139 
140 
141 
142 
143 
144 
145 
146 
147 
148 
149 
150 
151 
152 
153 
154 
155 
156 
157 
158 
159 
160 
161 
162 
163 
164 
165 
166 
167 
168 


28 20:25 1988 libraries/dos.i Page 3 


ERROR_OBJECT_WRONG_TYPE 
ERROR_DISK_NOT_VALIDATED 
ERROR_DISK WRITE PROTECTED 
ERROR_RENAME ACROSS DEVICES 
ERROR_DIRECTORY_NOT EMPTY 
ERROR_DEVICE_NOT MOUNTED 
ERROR_SEEK_ ERROR 
ERROR_COMMENT_TOO_ BIG 
ERROR_DISK_FULL 

ERROR DELETE PROTECTED 
ERROR_WRITE_ PROTECTED 
ERROR_READ PROTECTED 
ERROR_NOT_A DOS DISK 
ERROR_NO_ DISK 
ERROR_NO MORE ENTRIES 


EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 
EQU 


212 
213 
214 
215 
216 
218 
219 
220 
221 
222 
223 
224 
225 
226 
232 





* These are the return codes used by convention by AmigaDOS commands 
files 


* See FAILAT and IF for relvance to EXECUTE 
RETURN_OK EQU 0 
RETURN_WARN EQU 5 
RETURN_ERROR EQU 10 
RETURN FAIL EQU 20 


* 


* 
* 
* 


* Bit numbers that signal you that a user has 


BITDEF 
BITDEF 
BITDEF 
BITDEF 


ENDC 


SIGBREAK,CTRL_C,12 
SIGBREAK ,CTRL_D, 13 
SIGBREAK,CTRL_E, 14 
SIGBREAK,CTRL_F,15 


; LIBRARIES _DOS_I 


No problems, success 

A warning only 

Something wrong 

Complete or severe failure 


issued a break 


Sep 28 20:25 1988 libraries/dos.i Page 4 








TL -a@ 

















Sep 


OODMNIAO PWN 


28 17:22 1988 libraries/dos_lib.i Page 1 


IFND LIBRARIES DOS LIB I 
LIBRARIES DOS _LIB_I SET 1 
kk 
ae $Filename: libraries/dos_lib.i $ 
ae $Release: 1.3 $ 
x 
RK Library interface offsets for DOS library 
“* 

*e (C) Copyright 1985,1986,1987,1988 Commodore~Amiga, Inc. 
*x All Rights Reserved 

Kk 

reserve EQU 4 

vsize EQU 6 

count SET —-vsize*(reservet+1) 

LIBENT MACRO 

_LVO\1 = EQU count 

count SET count~vsize 

ENDM 

* 

* 

* 
LIBENT Open 
LIBENT Close 
LIBENT Read 
LIBENT Write 
LIBENT Input 
LIBENT Output 
LIBENT Seek 
LIBENT = DeleteFile 
LIBENT Rename 
LIBENT Lock 
LIBENT UnLock 
LIBENT  DupLock 
LIBENT Examine 
LIBENT. ExNext 
LIBENT Info 
LIBENT CreateDir 
LIBENT CurrentDir 
LIBENT ToErr 
LIBENT CreateProc 
LIBENT Exit 
LIBENT LoadSeg 
LIBENT UnLoadSeg 
LIBENT GetPacket 
LIBENT QueuePacket 
LIBENT DeviceProc 
LIBENT SetComment 
LIBENT SetProtection 
LIBENT DateStamp 
LIBENT Delay 
LIBENT WaitForChar 
LIBENT ParentDir 
LIBENT IsInteractive 
LIBENT Execute 

ENDC ; LIBRARIES DOS LIB_I 


Sep 


WOnNIDUP WHE 





28 17:23 1988 libraries/dosextens.i Page 1 


IFND LIBRARTES_DOSEXTENS_I 


LIBRARIES_DOSEXTENS_I SET 1 

Kk 

** $Pilename: libraries/dosextens.i $ 

aK $Release: 1.3 $ 

x* 

ak DOS structures not needed for the casual AmigaDOS user 
a* 

** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 


IFND EXEC_TYPES_I 
INCLUDE “exec/types.i" 
ENDC 

IFND EXEC_TASKS_I 
INCLUDE "exec/tasks.i" 
ENDC 

JFND EXEC_PORTS_I 
INCLUDE "“exec/ports.i" 
ENDC 

IFND EXEC LIBRARIES I 
INCLUDE "“exec/libraries.i" 
ENDC 


IFND LIBRARIES _DOS_I 
INCLUDE "libraries/dos.i" 
ENDC 


* All DOS processes have this STRUCTure 
*x Create and DeviceProc returns pointer to the MsgPort in this STRUCTure 
* Process_addr = DeviceProc(..) -— TC_SIZE 


STRUCTURE Process,0 
STRUCT pr_Task,TC_SI2ZE 
STRUCT pr_MsgPort,MP_ SIZE 
WORD pr_Pad 
BPTR pr_SegList 
LONG pr_StackSize 
APTR pr_GlobVec 
LONG pr_TaskNum 
BPTR pr_StackBase 


* This is BPTR address from DOS functions 
* Remaining variables on 4 byte boundaries 
* Array of seg lists used by this process 
* Size of process stack in bytes 
* Global vector for this process (BCPL) 
* CLI task number of zero if not a CLI 
* Ptr to high memory end of process stack 
LONG pr_Result2 * Value of secondary result from last call 
BPTR pr_CurrentDir * Lock associated with current directory 
BPTR pr_cis * Current CLI Input Stream 
BPTR pr_cos * Current CLI Output Stream 
APTR pr_ConsoleTask * Console handler process for current window 
APTR pr_FileSystemTask * File handler process for current drive 
BPTR pr_CLI * pointer to ConsoleLineInterpreter 
APTR pr_ReturnAddr * pointer to previous stack frame 
APTR pr_Pktwait * Function to be called when awaiting msg 
APTR pr_WindowPtr * Window pointer for errors 
LABEL pr_SIZEOF * Process 


* The long word address (BPTR) of this STRUCTure is returned by 

* Open() and other routines that return a file. You need only worry 
* about this STRUCT to do async io's via PutMsg() instead of 

* standard file system calls 


STRUCTURE FileHandle,0 


APTR fh_Link * pointer to EXEC message 
APTR fh_Interactive * Boolean; TRUE if interactive handle 
APTR fh_Type * Port to do PutMsg() to 


LONG fh_Buf 

LONG fh_Pos 

LONG fh_End 

LONG fh_Funcs 
fh_Funcl EQU fh_Funcs 








CL +4 




















Sep 28 17:23 1988 libraries/dosextens.i Page 2 Sep 28 17:23 1988 libraries/dosextens.i Page 3 
70 LONG fh_Func2 139 ACTION_PARENT EQU 29 
71 LONG fh_Func3 140 ACTION_TIMER EQU 30 
72 LONG fh_Args 141 ACTION_INHIBIT EQU 31 
73 fh_Argl EQU fh Args 142 ACTION DISK TYPE EQU 32 
74 LONG fh _Arg2 143 ACTION _DISK_CHANGE EQU 33 
75 LABEL fh_SIZEOF * FileHandle 144 ACTION_SET_DATE EQU 34 
76 145 
77 * This is the extension to EXEC Messages used by DOS 146 ACTION _SCREEN_MODE EQU 994 
78 STRUCTURE DosPacket ,0 147 
79 APTR dp_Link * pointer to EXEC message 148 ACTION READ_RETURN EQU LOOL 
80 APTR dp Port * pointer to Reply port for the packet 149 ACTION_WRITE_RETURN EQU 1002 
81 * * Must be filled in each send. 150 ACTION_SEEK EQU 1008 
82 LONG dp Type * See ACTION_... below and 151 ACTION FINDUPDATE EQU 1004 
83 * x 'R' means Read, 'W' means Write to the file system |152 ACTION_FINDINPUT EQU 1005 
84 LONG dp_Resl * For file system calls this is the result 153 ACTION_FINDOUTPUT EQU 1006 
85 * * that would have been returned by the 154 ACTION_END EQU 1007 
86 * * function, e.g. Write ('W') returns actual 155 ACTION_TRUNCATE EQU 1022 /* fast file system only */ 
87 * * length written 156 ACTION _WRITE PROTECT EQU 1023 /* fast file system only */ 
88 LONG dp Res2 * For file system calls this is what would 157 
89 * x have been returned by IoErr() 158 * DOS library node structure. 
90 LONG dp Argl 159 * This is the data at positive offsets from the library node. 
91 * Device packets common equivalents 160 * Negative offsets from the node is the jump table to DOS functions 
92 dp_Action EQU dp Type 161 * node = (STRUCT DosLibrary *) OpenLibrary( "dos.library" .. ) 
93 dp Status EQU dp Resl 162 
94 dp Status2 EQU dp Res2 163 STRUCTURE DosLibrary,0 
95 dp BufAddr EQU dp _Argl 164 STRUCT. dl lib,LIB_SI2E 
96 LONG dp_Arg2 165 APTR dl_Root * Pointer to RootNode, described below 
97 LONG dp_Arg3 166 APTR dl_Gv * Pointer to BCPL global vector 
98 LONG dp_Arg4 167 LONG dl_A2 * Private register dump of Dos 
99 LONG dp_Arg5 168 LONG dl_A5 
100 LONG dp Arg6 169 LONG dl_a6é 
101 LONG  dp_Arg7 170 LABEL dl _SIZEOF * DosLibrary 
102 LABEL dp SIZEOF * DosPacket 171 
103 172 * 
104 * A Packet does not require the Message to before it in memory, but 173 
105 * for convenience it is useful to associate the two. 174 STRUCTURE RootNode,0 
106 * Also see the function init_std_pkt for initializing this STRUCTure 175 BPTR rn_TaskArray * [0] is max number of CLI's 
107 176 * * [1] is APTR to process id of CLI 1 
108 STRUCTURE StandardPacket,0 177 * * [n] is APTR to process id of CLI.n 
109 STRUCT sp_Msg,MN_SIZE 178 BPTR rm_ConsoleSegment * SegList for the CLI 
110 STRUCT sp_Pkt,dp_SIZEOF 179 STRUCT rn_Time,ds_SIZEOF * Current time 
ill LABEL sp SIZEOF * StandardPacket 180 LONG rn_RestartSeg * SegList for the disk validator process 
112 181 BPTR rn_Info * Pointer ot the Info structure 
113 182 BPTR rn_FileHandlerSegment * code for file handler 
114 * Packet types 183 LABEL rn_SIZEOF * RootNode 
115 ACTION _NIL EQU 0 184 
116 ACTION_GET_BLOCK EQU 2 ; OBSOLETE 185 STRUCTURE DosInfo,0 
117 ACTION_SET MAP EQU 4 186 BPTR di_McName x Network name of this machine currently 0 
118 ACTION_DIE EQU 5 187 BPTR di_Devinfo * Device List 
119 ACTION_EVENT EQU 6 188 BPTR di_Devices * Currently zero 
120 ACTION_CURRENT_VOLUME EQU 7 189 BPTR di_Handlers * Currently zero 
121 ACTION _LOCATE_ OBJECT EQU 8 190 APTR di_NetHand * Network handler processid currently zero 
122 ACTION RENAME DISK EQU 9 191 LABEL di_SIZEOF * DosInfo 
123 ACTION_WRITE EQU ‘Ww! 192 
124 ACTION _READ EQU 'R! 193 * DOS Processes started from the CLI via RUN or NEWCLI have this additional 
125 ACTION _FREE_LOCK EQU 15 194 * set to data associated with them 
126 ACTION DELETE OBJECT EQU 16 195 
127 ACTION_RENAME OBJECT EQU 17 196 STRUCTURE CommandLineInterface,0 
128 ACTION MORE CACHE EQU 18 197 LONG cli_Result2 * Value of IoErr from last command 
129 ACTION_COPY_DIR EQU 19 198 BSTR  cli_SetName * Name of current directory 
130 ACTION_WAIT_CHAR EQU 20 199 BPTR cli_CommandDir * Lock associated with command directory 
131 ACTION_SET PROTECT EQU 21 200 TONG = cli_ReturnCode * Return code from last command 
132 ACTION_CREATE_DIR EQU 22 201 BSTR cli_CommandName * Name of current command 
133 ACTION EXAMINE OBJECT  EQU 23 202 LONG cli _FailLevel * Fail level (set by FAILAT) 
134 ACTION_EXAMINE_ NEXT EQU 24 203 BSTR cli_Prompt * Current prompt (set by PROMPT) 
135 ACTION_DISK_INFO FOU 25 204 BPTR  cli_StandardInput * Default (terminal) CLI input 
136 ACTION_INFO EQU 26 205 BPTR cli_CurrentInput * Current. CLI input 
137 ACTION_FLUSH EQU 27 206 BSTR = cli_CommandFile * Name of EXECUTE command file 
138 ACTION _SET_COMMENT EQU 28 207 LONG cli Interactive * Boolean True if prompts required 








€lL~-da 











Sep 28 17:23 1988 libraries/dosextens.i Page 4 

208 - LONG = cli_Background * Boolean True if CLI created by RUN 

209 BPTR cli_CurrentOutput * Current CLI output 

210 LONG cli_DefaultStack * Stack size to be obtained in long words 
211 BPTR cli_StandardoOutput * Default (terminal) CLI output 

212 BPTR cli Module * SegList of currently loaded command 

213 LABEL cli_SIZEOF * CommandLinelInterface 

214 

215 * This structure can take on different values depending on whether it is 
216 * a device, an assigned directory, or a volume. Below is the structure 
217 * reflecting volumes only. Following that is the structure representing 
218 * only devices. Following that is the unioned structure representing all 
219 * the values 

220 

221 * structure representing a volume 

222 

223 STRUCTURE DevList,0 

224 BPTR dl_Next ; bptr to next device list 

225 LONG dl_Type 7; see DLT below 

226 APTR dl_Task ; ptr to handler task 

227 BPTR dl_Lock ; not for volumes 

228 STRUCT dl_VolumeDate,ds_SIZEOF ; creation date 

229 BPTR di_hockbList ; cutstanding locks 

230 LONG dl_DiskType ; 'DOS', ete 

231 LONG dil_unused 

232 BSTR di_Name ; bptr to bepl name 

233 LABEL DevList_SIZEOF 

234 

235 * device structure (same as the DeviceNode structure in filehandler.i 
236 : 

237 STRUCTURE Devinfo,0 

238 BPTR avi_Next 

239 LONG dvi_Type 

240 APTR dvi_Task 

241 BPTR davi_Lock 

242 BSTR dvi_Handler 

243 LONG dvi_Stacksize 

244 LONG dvi_Priority 

245 LONG avi_Startup 

246 BPTR avi_SegList 

247 BPTR dvi_GlobVec 

248 BSTR davi_Name 

249 LABEL dvi_SIZEOP 

250 oe 

251 * combined structure for devices, assigned directories, volumes 

252 

253 STRUCTURE DosList,0 

254 BPTR dol_Next. ; bptr to next device on lis 

255 LONG dol_Type ; see DLT below 

256 APTR dol_Task ; ptr to handler task 

257 BPTR dol_Lock 

258 

259 STRUCT dol_VolumeDate, 0 7; Creation date (UNION) 

260 BSTR dol_Handler ; file name to load if seglist is null 
261 LONG dol_StackSize ; stacksize to use when starting process 
262 LONG dol_Priority ; task priority when starting process 
263 

264 STRUCT dol_LockList ,0 ; outstanding locks (UNION) 

265 ULONG dol_Startup ; startup msg: FileSysStartupMsg 
266 ; for disks 

267 

268 STRUCT dol_Diskype,0 ; 'DOS', ete (UNION) 

269 BPTR dol_SegList ; already loaded code for new task 
270 

271 BPTR dol_GlobVec ; BCPL global vector 

272 

273 BSTR dol_Name ; bptr to bepl name 

274 LABEL DosList_SIZEOF 

275 


276 





Sep 


277 
278 
279 
280 
281 
282 
283 
284 
285 
286 
287 
288 
289 
290 
291 
292 
293 





28 17:23 1988 libraries/dosextens.i Page 

* definitions for dl_Type 

DLT_DEVICE EQU 0 

DLT_DIRECTORY EQU i 

DLT_VOLUME EQU 2 

* a lock structure, as returned by Lock() 

STRUCTURE FileLock,0 
BPTR fl Link ; 
LONG fl_Key ; 
LONG f1_Access i 
APTR f1_Task ; 
BPTR f1_ Volume ; 
LABEL f£1_SIZEOF 
ENDC ; LIBRARIES DOSEXTENS IT 


or DupLock() 


bepl pointer to next lock 
disk block number 
exclusive or shared 
handler task's port 

bptr to a DeviceList 











Sep 28 17:23 1988 libraries/expansion.i Page 1 


Kk 
** 
xk 
*k 
wk 
xk 
10 ** 
ll ** 


WONDUS WE 


IFND LIBRARIES_EXPANSION_I 


LIBRARIES_EXPANSION_I SET L 
** 


$Filename: libraries/expansion.i $ 
SRelease: 1.3 $ 


external definitions for expansion. library 


(C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


13 EXPANSIONNAME MACRO 


de.b ‘expansion. library' ,0 
ENDM 


18 ;* flags for the AddDosNode() call */ 


tL -a 





BITDEF ADN,STARTPROC,0 


ENDC 7 LIBRARIES_EXPANSION_I 


-F 


WON DU PWNE 





28 17:23 1988 libraries/expansionbase.i Page 1 


IFND LIBRARIES _EXPANSIONBASE_ I 


LIBRARIES _EXPANSIONBASE_ I SET 1 

Kk 

xk $Filename: libraries/expansionbase.i $ 

xk $Release: 1.3 $ 

ak 

xx library structure for expansion library 

Kk 

ek (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
** All Rights Reserved 


x* 


IFND  - EXEC_TYPES_I 
INCLUDE. "exec/types.i" 
ENDC 7; EXEC_TYPES_T 


IFND EXEC_LIBRARIES I 
INCLUDE "exec/libraries.i" 
ENDC ; EXEC_LIBRARIES_ I 


IFND EXEC_INTERRUPTS_I 
INCLUDE "exec/interrupts.i" 
ENDC 7 EXEC_INTERRUPTS_I 


IFND EXEC_SEMAPHORES_TI 
INCLUDE "“exec/semaphores. i" 
ENDC ; EXEC_SEMAPHORES_I 


IFND LIBRARIES _CONFIGVARS TI 
INCLUDE "libraries/configvars.i" 
ENDC ; LIBRARIES CONFIGVARS I 


TOTALSLOTS EQU 256 

STRUCTURE ExpansionInt,0 
UWORD ei_IntMask ; mask for this list 
UWORD ei_ArrayMax ; Current max valid index 
UWORD ei_ArraySize ; allocated size 
LABEL ei_Array ; actual data is after this 
LABEL ExpansionInt_SIZEOF 

STRUCTURE ExpansionBase, LIB_SIZE 
UBYTE . eb Flags 
UBYTE eb_pad 
ULONG eb_ExecBase 
ULONG eb SegList 
STRUCT eb_CurrentBinding,CurrentBinding_SI2ZEOF 
STRUCT eb_BoardList,LH SIZE 
STRUCT eb_MountList ,LH_SIZE 
STRUCT eb_AllocTable, TOTALSLOTS 
STRUCT eb_BindSemaphore,SS_SIZE 
STRUCT eb_Int2List,IS_SIZE 
STRUCT eb_Int6List,IS_ SIZE 
STRUCT eb_Int7List,IS SIZE 
LABEL ExpansionBase_SIZEOF 


7; error codes 


EE_LASTBOARD FOU 40 ; could not shut him up 
EE_NOEXPANSION EQU 41 7 not enough expansion mem; board shut up 
EE_NOBOARD EQU 42 ; no board at that address 
EE_NOMEMORY EQU 42 7 not enough normal memory 
i flags 
BITDEF EB,CLOGGED,0 7 someone could not be shutup 
BITDEF EB,SHORTMEM, 1 ; ran out of expansion mem 


ENDC ; LIBRARIES EXPANSIONBASE IT 





GiL-da 





Sep 28 17:23 1988 libraries/expansionbase.i Page 2 





Sep 


WOMNAU PWN 


28 17:23 1988 libraries/filehandler.i Page 1 


IFND LIBRARIES_FILEHANDLER_I 
LIBRARIES _FILEHANDLER_I SET 1 
x* 
*e $Filename: libraries/filehandler.i $ 
eK $Release: 1.3 $ 
“* 
xe device and file handler specific code for AmigaDos 
xk 
we (C) Copyright 1986,1987,1988 Commodore-Amiga, Inc. 


All Rights Reserved 


IFND EXEC_TYPES_I 
INCLUDE "exec/types.i"' 
ENDC ; EXEC_TYPES_I 
IFND EXEC_PORTS_I 
INCLUDE "exec/ports.i" 
ENDC ; EXEC_PORTS_I 
IFND LIBRARIES _Dos_I 
INCLUDE "libraries/dos.i" 
ENDC ; LIBRARIES Dos_I 


* The disk “environment" is a longword array that describes the 


* disk geometry. 


It is variable sized, with the length at the beginning. 


x Here are the constants for a standard geometry. 


STRUCTURE DosEnvec ,0 


ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
ULONG 
LONG 

ULONG 


LABEL 


de_TableSize 
de_SizeBlock 
de_Secorg 

de_ Surfaces 
de_SectorPerBlock 
de_BlocksPerTrack 
de_Reserved 
de_PreAlloc 
de_Interleave 
de_LowCyl 
de_HighCyl 
de_NumBuffers 
de_BufMemType 
de_MaxTransfer 
de Mask 
de_BootPri 


de_DosType 


DosEnvec_SIZEOF 


DE_TABLESIZE EQU 0 
DE_SIZEBLOCK  EQU 1 
DE_SECORG EQU 2 
DE_NUMHEADS EQU 3 
DE_SECSPERBLK  EQU 4 
DE_BLKSPERTRACK EQU 5 
DE_RESERVEDBLKS EQU 6 
DE PREPAC EQU 7 
DE_INTERLEAVE EQU 8 
DE_LOWCYL EQU 9 
DE_UPPERCYL EQU 10 
DE_NUMBUFFERS  EQU il 
DE _MEMBUFTYPE  EQU 12 
DE_BUFMEMTYPE — EQU 12 


eS Se SS 


; Size of Environment vector 
; in longwords: standard value is 128 
; not used; must be 0 


# of heads (surfaces). drive specific 


; not used; must be 1 
; blocks per track. drive specific 


DOS reserved blocks at start of partition. 
DOS reserved blocks at end of partition 


; usually 0 
; starting cylinder. typically 0 


max cylinder. drive specific 


; Initial # DOS of buffers. 
; type of mem to allocate for buffers 


Max number of bytes to transfer at a time 


; Address Mask to block out certain memory 


Boot priority for autoboot 

ASCII (HEX) string showing filesystem type; 
0xX444F5300 is old filesystem, 

0X444F5301 is fast file system 


the array 


standard value is 11 
in longwords: standard value is 128 
not used; must be 0 

# of heads (surfaces). drive specific 
not used; must be 1 

blocks per track. drive specific 
unavailable blocks at start. usually 2 
not used; must be 0 

usually 0 

starting cylinder. typically 0 

max cylinder. drive specific 

starting # of buffers. typically 5 
type of mem to allocate for buffers. 
same as above, better name 


Ne SS Se Se Ne ee 














100 
101 
"102 
11103 
3] 104 
1105 
106 
107 
108 
109 
110 
lll 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 











28 17:23 1988 libraries/filehandler.i Page 2 


1 is public, 3 is chip, 5 is fast 


DE_MAXTRANSFER EQU 13 ; Maximum number of bytes to transfer at a time 
DE_MASK EQU 14 ; Address Mask to block out certain memory 
DE_BOOTPRI EQu 15 ; Boot priority for autoboot 
DE_DOSTYPE EQU 16 ; ASCII (HEX) string showing filesystem type 
; 0X444P5300 is old filesystem, 
; 0X444F5301 is fast file system 
* 
x The file system startup message is linked into a device node's startup 
* field. It contains a pointer to the above environment, plus the 
* information needed to do an exec OpenDevice(). 
* 


STRUCTURE FileSysStartupMsg,0 


ULONG fssm_Unit j; exec unit number for this device 
BSTR fssm_Device ; null terminated bstring to the device name 
BPTR fssm_Environ ; ptr to environment table (see above) 
ULONG fssm_Flags ; flags for OpenDevice() 
LABEL FileSysStartupMsg_SIZEOF 
* The include file "libraries/dosextens.h" has a DeviceList structure. 
* The "device list" can have one of three different things linked onto 
x it. Dosextens defines the structure for a volume. DLT_DIRECTORY 
* is for an assigned directory. The following structure is for 
* a dos "device" (DLT_DEVICE). 


STRUCTURE DeviceNode,0 


BPTR dn_Next. ; 
ULONG dn_Type i 
CPTR dn_Task i 
i 

i 

BPTR dn_Lock ; 
BSTR dn_Handler ; 
ULONG dn_StackSize ; 
LONG dn_Priority i 
BPTR dn_ Startup ; 
BPTR dn_SegList i 
i 

BPTR dn_GlobalVec i 
i 

i 

i 

i 

; 

BSTR dn_Name i 
LABEL DeviceNode_SIZEOF 
ENDC ; LIBRARIES_FILEH 


; singly linked list 
; always 0 for dos "devices" 
; standard dos 


"task" field. If this is 
null when the node is accesses, a task 
will be started up 


; not used for devices ~~ leave null 
; filename to loadseg (if seglist is null) 


stacksize to use when starting task 


; task priority when starting task 
; startup msg: FileSysStartupMsg for disks 


code to run to start new task (if necessary) . 
if null then dn_Handler will be loaded. 


; BCPL global vector to use when starting 


a task. -l means that dn_SegList is not 
for a bepl program, so the dos won't 

try and construct one. 0 tell the 

dos that you obey BCPL linkage rules, 
and that it should construct a global 
vector for you. 


the node name, e.g. '\3','D','F','3' 


ANDLER_I 


Sep 


WOOMADUOB WHE 





28 17:23 1988 libraries/mathlibrary.i Page 1 


IFND LIBRARIES MATHLIBRARY_I 


LIBRARIES MATHLIBRARY_I SET 1 


Kk 
xk 
wk 
kk 
kk 
xk 
Kk 
x* 
K* 


$Filename: 
SRelease: 


libraries/mathlibrary.i $ 
1.3 $ 


(C) Copyright 1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


ifnd EXEC_TYPES I 
include "exec/types.i" 
endc 

ifna EXEC_LIBRARIES_I 


include “exec/libraries.i" 
endc 


STRUCTURE MathIEEEBase ,0 
STRUCT MathIEEEBase_LibNode,LIB_SIZ& 


UBYTE . MathIEEEBase_Flags 

UBYTE MathIEEEBase_reservedl 

APTR MathIEEEBase_68881 ; ptr to base of 68881 io 
APTR MathIEEEBase_SysLib 

APTR MathIEREBase Seghist 

APTR MathIEEEBase_Resource ; ptr to math resource found 
APTR MathIEEEBase_TaskOpenLib 7; hook 

APTR MathIEEEBase_TaskCloseLib i; hook 


This structure may be extended in the future */ 
LABEL MathIEEEBase_SIZE 


Math resources may need to know when a program opens or closes this 
library. The functions TaskOpenLib and TaskCloseLib are called when 

a task opens or closes this library. The yare initialized to point 
local initialization pertaining to 68881 stuff if 68881 resources 

are found. To override the default the vendor must provide appropriate 
hooks in the MathIEEEResource. If specified, these will be called 

when the library initializes. 


BNDC ; LIBRARIES _MATHLIBRARY_I 











tL-a 











Sep 


WODAIDUPWN FE 


28 17:23 1988 libraries/romboot_base.i Page 1 


IFND LIBRARIES ROMBOOT_BASE_I 


LIBRARIES ROMBOOT_BASE_T SET 1 

ak 

ae $Filename: libraries/romboot_base.i $ 

** $Release: 1.3 $ 

wk 

ak 

“x 

** (C) Copyright 1987,1988 Commodore-Amiga, Inc. 
x All Rights Reserved 


K* 


IFND EXEC TYPES I 
include "exec/types.i" 
ENDC 

TEND EXEC_NODES_I 
include "exec/nodes.i" 
ENDC 

IFND EXEC_LISTS_I 
include "exec/lists.i" 
ENDC 

IFND EXEC_LIBRARIES_I 
include "exec/libraries.i" 
ENDC 

IFND EXEC_EXECBASE_I 
include "exec/execbase.i" 
ENDC 

IFND EXEC_EXECNAME_I 
include "exec/execname. i" 
ENDC 


STRUCTURE RomBootBase,LIB_SIZE 
APTR rbb_ExecBase 
STRUCT rbb BootList,LH_SIZE 
STRUCT rbb_Reserved,16 
LABEL rbb_SIZEOF 


; for future expansion 


STRUCTURE BootNode,LN_SIZE 
UWORD- bn _ Flags 
CPTR bn_DeviceNode 


LABEL BootNode_SIZEOF 
ROMBOOT_NAME: MACRO 

DC.B 'romboot.. library',0 

DS .W 0 

ENDM 

BNDC ; LIBRARIES_ROMBOOT_BASE_I 





Ki 
Q 
o 


WMAINUN FS WHE 


28 17:23 1988 libraries/translator.i Page 1 


IFND LIBRARIES_TRANSLATOR_I 


LIBRARIES_TRANSLATOR_I SET 
ae 


xk 
xk 
x* 
Kk 
“* 
xk 
KK 
“* 


SFilename: libraries/translator.i $ 
$Release: 1.3 $ 


Translator error codes 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


TR_NotUsed EQU -1 ;This is an often used system re 
TR_NoMem EQU ~2 ;Can't allocate memory 
TR_MakeBad EQU -4 ;Error in MakeLibrary call 

ENDC ; LIBRARIES_TRANSLATOR_I 


8L- 4 





28 17:23 1988 resources/cia.i Page 1 28 17:23 1988 resources/disk.i Page 1 








1 IFND RESOURCES CIA _I 1 IFND RESOURCES _DISK_I 
2 RESOURCES CIA I SET 1 2 RESOURCES DISK_I SET l 
Kk 3 xk 
4 ** $Filename: resources/cia.i $ 4 ** S$Filename: resources/disk.i $ 
5 ** SRelease: 1.3 $ 5 ** $Release: 1.3 $ 
6 ** 6 x 
7 ** 7 ** external declarations for disc resources 
B xx 8 xx . 
Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xe All Rights Reserved 10 ** All Rights Reserved 
xk lL xk 
12 
CIAANAME MACRO 13 IFND EXEC_TYPES_I 
DC.B ‘ciaa.resource' ,0 14 INCLUDE “exec/types.i" 
ENDM 15 ENDC ; EXEC_TYPES I 
16 4 
CIABNAME MACRO 17 IFND —- EXEC_LISTS_I 
DC.B ‘'ciab.resource',0 18 INCLUDE "exec/lists.i" 
ENDM 19 ENDC ; EXEC_LISTS_I 
20 
ENDC ; RESOURCES_CIA_T al IFND EXEC_PORTS_I 
22 INCLUDE "exec/ports.i" 
23 ENDC ; EXEC_PORTS_I 
24 
25 IEND EXEC_INTERRUPTS_I 
26 INCLUDE "exec/interrupts.i" 
27 ENDC 7; EXEC_INTERRUPTS_ TI 
28 
29 IFND EXEC_LIBRARIES I 
30 INCLUDE "exec/libraries.i" 
31 ENDC ; EXEC_LIBRARIES I 
32 
33 
34 RRM IKKE KEK KEKE II KIRKE KEK KRU E KEKE KEK KEKE KEKE KER REE KEK KK KEKE KRKEKEKKEREK 
35 * 
36 * Resource structures 
37 * 
38 KIKI RIKKI KKK IKK KKK EI KEKE KEE KKK EEK KEK EERE KREKEREKE EE KEKKKKKEKKKEK 
39 
40 STRUCTURE DISCRESOURCEUNIT,MN_ SIZE 
41 STRUCT DRU_DISCBLOCK,IS_SIZE 
42 STRUCT DRU_DISCSYNC,IS_SIZE 
43 STRUCT DRU_INDEX,IS SIZE 
44 LABEL DRU_SIZE 
45 
46 
47 
48 STRUCTURE DISCRESOURCE,LIB SIZE 
49 APTR DR_CURRENT ; pointer to current unit structure 
50 UBYTE DR_FLAGS 
51 UBYTE DR_pad 
52 APTR DR_SYSLIB 
53 APTR DR_CIARESOURCE 
54 STRUCT DR_UNITID,4*4 
55 STRUCT DR_WAITING,LH_SIZE 
56 STRUCT DR_DISCBLOCK,IS_SIZE 
57 STRUCT DR_DISCSYNC,IS SIZE 
58 STRUCT DR_INDEX,IS_SIZE 
59 LABEL DR_SIZE 
60 
61 BITDEF DR,ALLOCO,0 ; unit zero is allocated 
62 BITDEF DR,ALLOC1,1 ; unit one is allocated 
63 BITDEF DR,ALLOC2,2 ; unit two is allocated 
64 BITDEF DR,ALLOC3,3 ; unit three is allocated 
65 BITDEF DR,ACTIVE,7 ; is the disc currently busy? 
66 
67 


BQ ARKH RE KIKI KKK KEK KKH KIER KERR IHRE ERK RK KKH KEK EK KKK RRR RE KEK KEKRKKEE 


69 * 








64 -a4 





28 17:23 1988 resources/disk.i Page 2 


* Hardware Magic 
* 


HK KK IK KK KIRK KK IKK KIKI AIK KEI I KK KIRKE IK IKI KERR KEKE ERK EKER KEKE 


DSKDMAOFF EQU $4000 ; idle command for dsklen register 


HK KIRK KIRK RK IK KKK III KIKI RK IK KI KIKI IK IK IK KEI KEKE RIKER KEIR EKER KE KEK 
* 

* Resource specific commands 

* 

KKK IKKE RIK IKI KAA KERIKERI KK KKK KKK ERK KEKR EKER EERE KKK ER KKEKEKKEKER 
*—- DR_NAME is a generic macro to get the name of the resource. This 
x—— way if the name is ever changed you will pick up the change 

*-~ automatically. 

+ 

*-- Normal usage would be: 

+ 


*-- internalName: 
+ 


DISKNAME 


DISKNAME : MACRO 
DC.B ‘disk. resource’ ,0 
DS.W 0 


ENDM 


LIBINIT LIB_BASE 
LIBDEF DR_ALLOCUNIT 
LIBDEF DR_FREEUNIT 
LIBDEF DR_GETUNIT 
LIBDEF DR_GIVEUNIT 
LIBDEF DR_GETUNITID 
EQU 


DR_LASTCOMM DR_GIVEUNIT 


HIRI KI KKK KR IK KR K TKI KIRK KI KKK IKKE KE RK IKKE REE EK EKER KEKE EK 
* 

* drive types 

x 

KKK IKK IK KK IK IKK KR RIKI III IER KIKI IK KIRK IK II KR IK IKK KI KER EKA EKER EKER KEKE EK 


DRT_AMIGA EQU $00000000 
DRT_37422D2S EQU $55555555 
DRT_EMPTY EQU SFFFFFFFF 

ENDC ; RESOURCES_DISK_I 


Sep 


WMA US WD he 





28 17:23 1988 resources/filesysres.i Page 1 


RESOURCES_FILESYSRES_TI 


ak 
kk 
wk 
wk 
ak 
xk 
xk 
kk 
kk 
Kk 


IFND RESOURCES_FILESYSRES_I 


SET 1 
$Filename: resources/filesysres.i $ 
$Revision: 1.0 $ 

$Date: 88/07/11 15:32:39 $ 
FileSystem.resource description 


(C) Copyright 1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND EXEC_NODES_I 
INCLUDE "exec/nodes.i" 
ENDC 

IFND EXEC_LISTS_T 
INCLUDE “exec/lists.i" 
ENDC 

IFND LIBRARIES _DOS_T 


INCLUDE "Llibraries/dos.i" 
ENDC 


FSRNAME MACRO 


dec.b 'FileSystem. resource! ,0 
ENDM 
STRUCTURE FileSysResource,LN_SIZE j; on resource list 
CPTR fsr_Creator 7; name of creator of this resource 
STRUCT fsr FileSysEntries,LH_SIZE ; list of FileSysEntry structs 


LABE: 


LL  FileSysResource_SIZEOF 


STRUCTURE FileSysEntry,LN_ SIZE ; on fsr FileSysEntries list 
; LN_NAME is of creator of this entry 
ULONG fse_DosType DosType of this PileSys 


ULON 


Version of this FileSys 


IG fse_ Version 
; bits set for those of the following that need 


ULONG fse_PatchFlags 


i to be substituted into a standard device 
i node for this file system: e.g. $180 
i for substitute SegList & Globalvec 
ULONG fse_Type ; device node type: zero 
CPTR fse_Task ; standard dos "task" field 
BPTR fse_Lock ; not used for devices: zero 
BSTR fse_Handler ; filename to loadseg (if SegList is null) 
ULONG fse_StackSize ; stacksize to use when starting task 
LONG fse_Priority ; task priority when starting task 
BPTR fse_Startup ; startup msg: FileSysStartupMsg for disks 
BPTR fse_SegList ; code to run to start new task 
BPTR fse_Globalvec ; BCPL global vector when starting task 
; no more entries need exist than those implied by fse_PatchFlags 


ENDC ; RESOURCES_FILESYSRES_I 


08 - a 














Sep 28 17:23 1988 resources/mathresource.i Page 1 Sep 28 17:23 1988 resources/misc.i Page. 1 
1 IFND RESOURCES _MATHRESOURCE_I 1 IFND RESOURCES _MISC_I 
2 RESOURCES MATHRESOURCE_I SET 1 2 RESOURCES_MISC_I SET 1 
3 ** 3 oe 
4 ** $filename: resources/mathresource.i $ 4 ** SFilename: resources/misec.i $ 
5 ** $Release: 1.3 $ 5 ** SRelease: 1.3 $ 
6 Kk 6 Kk 
7 ** 7 ** external declarations for misc system resources 
8 xk 8 ** 
Q *x (C) Copyright 1987,1988 Commodore-Amiga, Inc. Q ** {C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 10 ** All Rights Reserved 
1] ** ll ** 
12 12 
13 IFND EXEC TYPES _I 13 IFND EXEC_TYPES_I 
14 include "exec/types.i" 14 INCLUDE "exec/types.i" 
15 ENDC 15 ENDC ; EXEC_TYPES_I 
16 16 
17 LEND EXEC_NODES_I 17 IFND EXEC_LIBRARIES_I 
18 include “exec/nodes.i" 18 INCLUDE "exec/libraries.i" 
19 ENDC 19 ENDC ; EX&C_LIBRARIES_T 
20 20 
21 * 21 HRA IRI RHR I KKK KIRKE RR RK RRR IK IKE KEKE EE KEE RRR RR ERER EKER EK KEKE 
22 * The 'Init' entries are only used if the corresponding 22 * 
23 * bit is set in the Flags field. 23 * Resource structures 
24 * * 
as *x So if you are just a 68881, you ao not need the Tnit stuff 24 KKK KKK KEK IKKE KKK KKK KEE EERE KE RK KEKE KERR RK KER KEKE RE KK EKER KER KKKEKKKK 
26 * just make sure you have cleared the Flags field. 26 
27 * 27 MR_SERIALPORT EQU 0 
28 * This should allow us to add Extended Precision later. 28 MR_SERIALBITS EQU 1 
29 * 29 MR_PARALLELPORT EQU 2 
30 * For Init users, if you need to be called whenever a task 30 MR_PARALLELBITS EQU 3 
31 * opens this library for use, you need to change the appropriate 31 
32 * entries in MathIEEELibrary. 32 NUMMRTYPES EQU 4 
33 * 33 
34 34 STRUCTURE MiscResource,LIB_ SIZE 
35 STRUCTURE MathIEEEResourceResource , 0 35 STRUCT mr_AllocArray ,4*NUMMRTYPES 
36 STRUCT MathIEEEResource_Node,LN_SIZE 36 LABEL mr_Sizeof 
37 USHORT MathIEEEResource_Flags 37 
38 APTR MathIEEEResource_BaseAddr * ptr to 881 if exists *| 38 LIBINIT LIB_BASE 
39 APTR MathIEEEResource_Db1BasInit 39 LIBDEF MR_ALLOCMISCRESOURCE 
40 APTR MathIEEEResource_Dbl1TransInit 40 LIBDEF MR_FREEMISCRESOURCE 
41 APTR MathIEEEResource_SglBasInit 41 
42 APTR MathIEEEResource_SglTransInit 42 
43 APTR MathIBEEResource_ExtBasInit 43 MISCNAME MACRO 
44 APTR MathIEEEResource_ExtTransInit 44 DC.B 'misc.resource',0 
i? LABEL MathIEEEResourceResource_SIZE 45 ENDM 
4 46 
47 * definations for MathIEEERESOURCE_FLAGS * 47 ENDC 7; RESOURCES_MISC_I 
48 BITDEF MATHIEEERESOURCE , DBLBAS , 0 
49 BITDEF MATHIEEERESOURCE , DBLTRANS,1 
50 BITDEF MATHIEEERESOURCE , SGLBAS , 2 
51 BITDEF MATHIEEERESOURCE , SGLTRANS, 3 
52 BITDEF MATHIEEERESOURCE ,EXTBAS , 4 
23 BITDEF MATHIEEERESOURCE ,EXTTRANS,5 
4 
55 ENDC ; RESOURCES_MATHRESOURCE_I 











WODMATNUE WN PH 











28 17:23 1988 resources/potgo.i. Page 1 


IFND RESOURCES_POTGO_I 

RESOURCES _POTGO_I SET 1 
xk 
aK $Filename: resources/potgo.i $ 
x $Release: 1.3 $ 
xk 
aK 
Kk 
x (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
xR All Rights Reserved 
wk 
POTGONAME MACRO 

IC.B 'potgo.resource' 

De.B O 

DS.W 0 

ENDM 


ENDC ; RESOURCES. POTGO_I 








I 


kk 
xk 
x 
xk 
kk 
Kk 
10 ** 
LL x 


DOOnNDUOSP WNP 


14 * 


cg8 - a 





20 ICONNAME 


28 17:24 1988 workbench/icon.i Page 1 


TFND WORKBENCH_TCON_T 


WORKBENCH_ICON_I SET 1 
kK 


$Filename: workbench/icon.i $ 
SRelease: 1.3 $ 


external declarations for workbench support library 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


13 KIRKE EKER ERK IKKE ERK KK EKER EKER REE KERR RK EK ERE KER KERERKKEKREKEEREKEKKK 


15 * Library structures 
* 


17 KKK RE KKK IKEA KIKI KEKE KKH KEKE KEK KI KK KKK KKK KKK KKK KIRKE REE KEKE KIRKE KEK 


MACRO 
DC.B ‘icon. library' ,0 
ENDM 

ENDC ; WORKBENCH _ICON_I 








Sep 


WOON NDUE WN 


28 17:24 1988 workbench/startup.i Page 1 


IFND WORKBENCH_STARTUP_I 


WORKBENCH _STARTUP_I SET Ll 
** 


kk 
KK 
Kk 
Kk 
kk 
xk 
ak 
xk 


$Filename: workbench/startup.i $ 
$Release: 1.3 $ 


Workbench startup definitions 


(C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
All Rights Reserved 


IFND EXEC TYPES I 
INCLUDE "exec/types. i" 
ENDC ; EXEC_TYPES_I 


IFND EXEC_PORTS_I 
INCLUDE "exec/ports.i” 
ENDC ; EXEC_PORTS_I 


IFND LIBRARIES _DOS_T 
INCLUDE "libraries/dos.i" 
ENDC ; LIBRARIES DOS I 


STRUCTURE WBStartup,0 


STRUCT sm_Message,MN_SIZE ; a standard message structure 
APTR sm_Process ; the process descriptor for you 
BPTR sm_Segment. ; a descriptor for your code 
LONG sm_NumArgs ; the number of elements in ArgList 
APTR sm_ToolWindow ; description of window 
APTR sm_ArgList ; the arguments themselves 
LABEL sm_SIZEOF 

STRUCTURE WBArg,0 
BPTR wa_Lock ; a lock descriptor 
APTR wa_Name ; a string relative to that lock 
LABEL wa_SIZEOF 


ENDC 7 WORKBENCH_STARTUP_I 











€8 —a 





Sep 28 17:24 1988 workbench/workbench.i Page 1 


1 IFND WORKBENCH_WORKBENCH_ I 
2 WORKBENCH_WORKBENCH_I SET 1 

3 Kk 

4 *x $Filename: workbench/workbench.i $ 
5 ke $Release: 1.3 $ 

6 Kk 

7 Kk 

8 Kk 

Q ** (C) Copyright 1985,1986,1987,1988 Commodore-Amiga, Inc. 
10 ** All Rights Reserved 
11 xx 
12 
13 IFND EXEC_TYPES I 
14 INCLUDE "exec/types.i" 
15 ENDC ; EXEC_TYPES_T 
16 
17 IFND EXEC_NODES_I 
18 INCLUDE "exec/nodes.i" 
19 ENDC ; EXEC_NODES IT 
20 
21. IFND EXEC_LISTS I 
22 INCLUDE "exec/lists.i" 

23 ENDC ; EXEC_LISTS I 
24 

25 IFND —_ EXEC_TASKS_I 

26 INCLUDE "exec/tasks.i" 
27 ENDC ; EXEC_TASKS I 
28 

29 IFND INTUITION _INTUITION_I 
30 INCLUDE "intuition/intuition.i" 
31 ENDC 3 INTUITION_INTUITION_I 
32 

33 

34 ; the Workbench object types 

35 WBDISK EQU 1 

36 WBDRAWER EQU 2 

37 WBTOOL EQU 3 

38 WBPROJECT EQU 4 

39 WBGARBAGE EQU 5 

40 WBDEVICE EQU 6 

41 WBKICK EQU 7 

42 

43 


44 ; the main workbench object structure 
45 STRUCTURE DrawerData,0 


46 STRUCT dd_NewWindow,nw_SIZE ; args to open window 

47 LONG dd_CurrentX% ; current x coordinate of origin 
48 LONG dd_CurrentY ; current y coordinate of origin 
4 9 LABEL dd_SIZEOF 

0 

51 ; the amount of DrawerData actually written to disk 

52 DRAWERDATAFILESI ZE EQU (dd_SIZEOF) 

53 

54 

55 STRUCTURE DiskObject ,0 

56 UWORD do_Magic 7 a magic num at the start of the file 
57 UWORD do_Version ; a version number, so we can change it 
58 STRUCT do_Gadget ,gg_SIZEOF ; a copy of in core gadget 

59 UWORD do_Type 

60 APTR do_DefaultTool 

61 APTR do_ToolTypes 

62 LONG do_Currentx 

63 LONG do_CurrentYy 

64 APTR do_DrawerData 

65 APTR do_ToolWindow ; only applies to tools 

66 LONG do_StackSize ; only applies to tools 

67 LABEL do_SI2ZEOF 

68 


69 WB_DISKMAGIC 


EQU $e310 ; a magic number, not easily impersonated 





28 17:24 1988 workbench/workbench.i Page 2 


WB_DISKVERSION EQU 


STRUCTURE FreeList,0 
£1_NumFree 
f1_MemList,LH_SIZE 


WORD 
STRUCT 


i 


; Our current version number 


; weird name to avoid conflicts with FileLocks 


LABEL 


FreeList_SIZEOF 


* each message that comes into the WorkBenchPort must have a type field 
* in the preceeding short. These are the defines for this type 
* 


MTYPE_PSTD 
MTYPE_TOOLEXIT 
MTYPE DISKCHANGE 
MTYPE_TIMER 
MTYPE_CLOSEDOWN 
MTYPE_IOPROC 


EQU 
EQU 
EQU 
EQU 
EQU 
EQU 


; a "standard Potion" message 

; exit message from our tools 

; dos telling us of a disk change 
; we got a timer tick 


<unimplemented> 
<unimplemented> 


workbench does different complement modes for its gadgets. 
It supports separate images, complement mode, and backfill mode. 
The first two are identical to intuitions GADGIMAGE and GADGHCOMP. 


image (which normally would be color three when complemented) 


is flood-filled to color zero. 


* 
* 
* 
* backfill is similar to GADGHCOMP, but the region outside of the 
* 
* 
* 


GADGBACKFILL 


EQU 


* if an icon does not really live anywhere, set its current position 


* to here 
* 


NO_ICON_POSI'TION 


ENDC 


EQU 


; WORKBENCH WORKBENCH_I 





($80000000) 


Section F 


Linker Libraries 


This section contains autodoc summaries for the ‘‘amiga.lib” and “debug.lib” linker 
libraries, and reference source code listings for exec support functions in amiga.lib. 
Unlike the libraries described in Section A, these are not shared run-time libraries. 
Instead, they are concatenated Amiga format object modules which are linked with your 
code as library files. The linker scans specified library files and inserts a copy of each 
referenced library function into your program code. 


The libraries described here are: 


debug.lib 
Contains “stdio”-like functions for communicating with a serial terminal con- 
nected to the Amiga via its built-in serial port. Typically this terminal will be a 
9600 baud, 8 data bits, one stop bit connection to an external terminal or an 
Amiga running a terminal package. The debug.lib functions allow you to out- 
put messages and prompt for input, even from within low level task or interrupt 
code, without disturbing the Amiga’s display and or current state (other than 


Demonstrates assembler use of the compiled C exec support 

routines (CreatePort, etc.) in Amiga.lib, and also the use of 
Amiga.lib csupport functions such as _printf for simple formatted 
output and debugging. Creates port, outputs address, deletes port. 


LINK INSTRUCTIONS: Alink with Astartup.obj ... LIBRARY Amiga.lib 
Astartup sets up DOSBase and the stdout needed for Amiga.lib’ printf. 

If you do not link with Astartup.obj, you must add the following 
variables, XDEF them, and initialize them as commented: 

DC.L _DOSBase O j;needs base returned from OpenLibrary of dos.library 
DC.L _stdout O ;needs an AmigaDOS file handle from a dos Open call 
DC.L _SysBase OQ ;needs the address stored at location 4 


Ht Ok OO OOF 


INCLUDE "exec/types.i" 
INCLUDE "exec/io.i" 
INCLUDE "libraries/dos.i" 


k--- Imported labels: C interface Amiga.lib routines 
XREF _CreatePort 
XREF _DeletePort 
XREF _printf 
k--———— Exported labels: Where Astartup.obj JSR's to our code 
XDEF _main 
CODE 
;use startup code (_main + link with Astartup.obj) 
main: 
~ movem. 1 d2-d7/a2-a6,-(sp) ;Save registers 
*-- Exec Support function: msgPort = CreatePort(name, pri) 
move.1 #0,-(Sp) ipush priority 0 on stack as long 
pea portname ¢push addr of null-termed portname 
jsr _CreatePort iCall CreatePort 
addq.1 #8,Sp jadd 4 to stack for each long pushed 
jsr mydebug0 jrtn to print dO (preserves dQ) 
tst.1 do jtest result 
beq.s failure ;if zero, CreatePort failed 
k-———— Exec Support function: DeletePort(port) 
move.1 d0,-(sp) ;else push dO (now our msgPort) 
jsr DeletePort ;call DeletePort 
addq.1 #4,sp jada 4 to stack for pushed long 
move. 1 #RETURN_OK,d0 jset up success return code 
bra.s endcode jand skip to exit code 
ka Failure to CreatePort branches here 
failure: 
move.1 #RETURN FAIL, dO ;set up failure return code 
endcode: 
movem. 1 (sp)+,d2-d7/a2-a6 ;Restore registers 
rts ;rts with dO = return code 
ka mydebugO — Subroutine uses Amiga.lib printf to print the contents 
* of dO. Preserves all registers. 
mydebug0: 
movem,. 1 d0-d7/a0-a6,-(sp) jsave registers 
*---—— C Support function printf(): here printf("$%lx\n",contents of dQ) 


* Note that the fstrl DC.B below specifies '\n' and null as 10,0 


portname 
fstrl 


move.1 do,-(sp) 


pea fstri 
jsr rintf 
addq.1 ¥8,sp 


movem.1 (sp) i, d0-d7 /a0-a6 
rts 


DATA 


DC.B ‘sample msgport',0 
DC.B '$%1x',10,0 
END 


jpush dO on the stack 

;push addr of format string 
;call printf 

jadd 4 to stack for each long 
jrestore saved registers 

jrts 


Example C Callable function that adds two numbers. From C, the 
call would look like this: 
result=AddThemUp( first, second) ; 


_AddThemUp 


XDEF _AddThemUp 


move.l 4(sp),D0O 
move.1 B (SP), D1 
add.1 D1,D 

rts 


;Make an External Definition 


;Get FIRST number 
;Get SECOND number 
;Add them 

;Return result 


the state of the serial hardware itself). No matter how badly the system may 
have crashed, these functions can usually get a message out. A similar debug- 
ging library currently called ddebug.lib is available for sending debugging output 
to the parallel port. This is useful for debugging serial applications. Ddebug.lib 
is not documented here. It contains functions similar to debug.lib but with 
names starting with ‘d’ instead ‘k’. 


amiga.lib 
This is the main Amiga scanned linker library, generally linked with every 
program for the Amiga. The major components of amiga.lib are: 


stubs - Individual interface stubs for each Amiga ROM routine 
that enable stack based C compilers to call register based 
Amiga ROM routines. 


offsets - The negative Library Vector Offset (_LVO) for each Amiga 
function. 
exec_support - C functions which simplify many exec procedures such as 


the creation and deletion of tasks, ports, and IO request 
structures. Source code is provided for these functions. 
clib - C support functions including pseudo-random number 
generation and a limited set of file and stdio functions 
designed to work directly with AmigaDOS file handles. 
other - Miscellaneous handy functions, callable from any language. 











TABLE 


amiga. 
amiga. 
amiga. 
amiga. 
amiga. 
amiga. 
amiga 
amiga. 
amiga. 
amiga. 
amiga. 
amiga. 
amiga 
amiga. 
amiga. 
amiga. 
amiga. 
amiga. 
amiga. 
amiga. 


OF CONTENTS 


lib/Add@TOF 
lib/BeginIO 
lib/CreateExtIo 
lib/CreatePort 
lib/CreateTask 
lib/DeleteExtIo 


.lib/DeletePort 


lib/DeleteTask 
lib/FastRand 
lib/nath/afp 
lib/math/arnd 
lib/math/dbf 


.lib/math/fpa 


lib/math/fpbed 
lib/NewList 
lib/printf£ 
lib/RangeRand 
Lib/RemTOF 
lib/sprintf 
lib/stdio 








amiga. lib/AddTOF amiga. lib/AddTOF 


NAME 
Ad@TOF — add a task to the TopOfFrame Interrupt server chain. 


SYNOPSIS 
AGATOF(i,p,a); 
void AddTOF(struct Isrvstr *, APTR, APTR); 


FUNCTION 
Adds a task to the vertical-blanking interval interrupt server 
chain. This prevents C programmers from needing to write an 
assembly language stub to do this function. 


INPUTS 
i - pointer to structure Isrvstr. 
p - pointer to the C-code routine that this server is to call each 
time TOF happens. 
a — pointer to the first longword in an array of longwords that 
is to be used as the arguments passed to your routine 
pointed to by p. 


SEE ALSO 
RemTOF, graphics/graphint .h 











amiga. lib/BeginIO 


NAME 
BeginIO -- initiate asynchronous 1/0 


SYNOPSIS 
BeginI0O(i0ORequest ) 
void BeginIO(struct IORequest *); 


FUNCTION 
This function takes an IORequest, and passes it directly to the 
BEGINIO vector of the proper device. This works exactly like 
SendIo, but does not clear the io_Flags field first. 


This function does not wait for the I/O to complete. 


INPUTS 
iORequest - Pointer to an initialized, open IORequest structure 
with the io Flags field set to a reasonable value 
(use zero if you do not require io_Flags). 


SEE ALSO 
exec/DoIO, exec/SendIO, exec/WaitIo 








amiga. lib/BeginIo amiga. lib/CreateExtIO 





amiga. lib/CreateExtIOo 


NAME 
CreateExtIO() —- create an IORequest structure 


SYNOPSIS 
ioReq = CreateExtIO( ioReplyPort, size ); 
struct IORequest *CreateExtIO(struct MsgPort *,. ULONG); 


FUNCTION 
Allocates memory for and initializes a new IO request block 
of a user-specified number of bytes. The number of bytes 
MUST be the size of a legal IORequest (or extended IORequest) 
or very nasty things will happen. 


INPUTS 
ioReplyPort ~ a pointer to an already initialized 
message port to be used for this IO request's reply port. 
(usually created by CreatePort()). 
size — the size of the IO request to be created. 


RESULT 
Returns a pointer to the new IO Request block, or NULL if 
the request failed. 


SEE ALSO 
CreatePort, DeleteExtIo 
CreatelIORequest 








amiga. lib/CreatePort 





amiga.lib/CreatePort 


NAME 
CreatePort - Allocate and initialize a new message port 
SYNOPSIS 
CreatePort (name, pri) 
struct MsgPort *CreatePort(char *,LONG); 
FUNCTION 
Allocates and initializes a new message port. The message list 
of the new port will be prepared for use (via NewList). The port 
will be set to signal your task when a message arrives (PA_SIGNAL). 
INPUTS 
name — NULL if other tasks will not search for this port 
via the FindPort() call. If non-null, this must be 
a null-terminated string; the port will be added to 
the system public port list. The name is not copied. 
pri - Priority used for insertion into the public port list. 
RESULT 
A new MsgPort structure ready for use. 
SEE ALSO 


DeletePort, exec/FindPort, exec/ports.h 


amiga. lib/CreateTask 


amiga. lib/CreateTask 


NAME 
CreateTask -- Create task with given name, priority, stacksize 


SYNOPSIS 
CreateTask( name, pri, initPC, stackSize) 
task=(struct Task *)CreateTask(char *, LONG, funcEntry, ULONG); 


FUNCTION 
This function simplifies program creation of subtasks by 
dynamically allocating and initializing required structures 
and stack space, and adding the task to Exec's task list 
with the given name and priority. A tc_MemEntry list is provided 
so that all stack and structure memory allocated by CreateTask 
is automatically deallocated when the task is removed. 


An Exec task may not call dos.library functions or any function 
which might cause the loading of a disk-resident library, device, 
or file (since such functions are indirectly calls to dos.library). 
Only AmigaDOS Processes may call AmigaDOS; see the DOS CreateProc({) 
call for more information. 


If other tasks or processes will need to find this task by name, 
provide a complex and unique name to avoid conflicts. 


If your compiler provides automatic insertion of stack-checking 
code, you may need to disable this feature when compiling subtask 
code since the stack for the subtask is at a dynamically allocated 
location. If your compiler requires 68000 registers to contain 
particular values for base relative addressing, you may need to 
save these registers from your main process, and restore them 

in your initial subtask code. 


The function entry initPC is generally provided as follows: 


In C: 
extern void functionName( ) ; 
char *tname = "unique name"; 


task = CreateTask(tname, OL, functionName, 4000L); 


In assembler: 
PEA startLabel 


INPUTS 


name — a null terminated string. 
pri - an Exec task priority between -128 and 127 (commonly 0) 
funcEntry ~- the address of the first executable instruction 
of the subtask code. 
stackSize —- size in bytes of stack for the subtask. Don't cut it 
too close - system function stack usage may change. 


SEE ALSO 
DeleteTask, exec/FindTask 








NAME 
DeleteExtIo() - return memory allocated for extended IO request 


SYNOPSIS 
DeleteExtIo( ioReq ); 
void DeleteExtIO(struct IORequest *); 


FUNCTION 
Frees up an IO request as allocated by CreateExtIO(). By 
looking at the mm_Length field, it knows how much memory 
to deallocate. 


INPUTS 
ioReq ~- A pointer to the IORequest block to be freed. 


SEE ALSO 
CreateExtiIO 








amiga. lib/DeleteExtIo amiga. lib/DeleteExtIo amiga. lib/DeletePort 
NAME 








amiga. lib/DeletePort 


DeletePort -— Free a message port created by CreatePort 


SYNOPSIS 
DeletePort (msgPort ) 
void DeletePort(struct MsgPort *); 


FUNCTION 
Frees a message port created by CreatePort. All messages that 
may have been attached to this port must have already been 
replied to. 


INPUTS 
msgPort — A message port 


SEE ALSO 
CreatePort 











amiga. lib/DeleteTask 





amiga. lib/DeleteTask 


NAME 
DeleteTask —- Delete a task created with CreateTask 


SYNOPSIS 
DeleteTask( task ) 
void DeleteTask(struct Task *); 


FUNCTION 
This function simply calls exec/RemTask, deleting a task from the 
Exec task lists and automatically freeing any stack and 
structure memory allocated for it by CreateTask. 


Before deleting a task, you must first make sure that the task is 
not currently executing any system code which might try to signal 
the task after it is gone. 


This can be accomplished by stopping all sources that might reference 
the doomed task, then causing the subtask execute a Wait(0L). Another 
option is to have have the task DeleteTask()/RemTask( ) itself. 


INPUTS 
task — pointer to a Task 


SEE ALSO 
CreateTask, exec/RemTask 


amiga. lib/FastRand 





amiga. lib/FastRand 


NAME 
FastRand — quickly generate a somewhat random integer 


SYNOPSIS 
number = FastRand(seed) ; 
ULONG PastRand(ULONG) ; 


FUNCTION 
c-implementation only. Seed value is taken from stack, shifted 
left one position, exclusive-or'ed with hex value $1D872B41 and 
returned (D0). 


INPUTS 
seed ~ a 32-bit integer 


RESULT 
number ~ new random seed, a 32-bit value 


SEE ALSO 
RangeRand 








amiga. lib/math/afp amiga.lib/math/afp 


NAME 
afp — Convert ASCII string variable into fast floating point 


USAGE 
ffp_value = afp(string); 


FUNCTION 
Accepts the address of the ASCII string in C format that is 
converted into an FFP floating point number. 


The string is expected in this Format: 
{S}{digits}{'.'}{digits}['E'}{S}{digits} 
KKK IKK AMANTI SGAK RR KKK KD OX KHEXPONENT® * > 


Syntax rules: 

Both signs are optional and are '+' or '-‘. The mantissa must be 
present. The exponent need not be present. The mantissa may lead 
with a decimal point. The mantissa need not have a decimal point. 
Examples: All of these values represent the number fourty~two. 


42 - 04263 

42. +.042e+03 

+42, 0.000042e6 
0000042.00 420000e-4 


420000. 00e—-0004 


Floating point range: 
Fast floating point supports the value zero and non-zero values 
within the following bounds — 

18 20 


9.22337177 x 10 > +mumber > 5.42101070 x 10 
1 —20 


8 
~9.22337177 x 10 > -number > —2.71050535 x 10 


| Precision: 
ov This conversion results in a 24 bit precision with guaranteed 
error less than or equal to one~half least significant bit. 


INPUTS 
string - Pointer to the ASCII string to be converted. 


OUTPUTS 
string — points to the character which terminated the scan 


equ — fast floating point equivalent 





amiga. lib/math/arnd amiga. 1lib/math/arnd 


NAME 
arnd ~ ASCII round of the provided floating point string 


USAGE 
arnd(place, exp, &string[0]); 


FUNCTION 
Accepts an ASCII string representing an FFP floating point 
number, the binary representation of the exponent of said 
floating point number and the number of places to round to. 
A rounding process is initiated, either to the left or right 
of the decimal place and the result placed back at the 
input address defined by &string[0]. 


INPUTS 
place ~ integer representing number of decimal places to round to 
exp — integer representing exponent value of the ASCII string 
&string[{0] - address where rounded ASCII string is to be placed 
(16 bytes) 


RESULT 
&string[0] ~ rounded ASCII string 


BUGS 
None 











amiga. lib/math/dbf : amiga. lib/math/dbf amiga. lib/math/fpa amiga.lib/math/fpa 


NAME NAME 
dbf ~ convert FFP dual-binary number to FFP format fpa - convert fast floating point into ASCII string equivalent 
USAGE USAGE 
fnum = dbf(exp, mant); exp = fpa(fnum, 4string[0]); 
FUNCTION FUNCTION 
Accepts a dual-binary format (described below) floating point Accepts an FFP number and the address of the ASCII string where it's 
number and converts it to an FFP format floating point number. onverted output is to be stored. The number is converted to a NULL 
The dual~binary format is defined as: terminated ASCII string in and stored at the address provided. 
Additionally, the base ten (10) exponent in binary form is returned. 
exp bit 16 = sign (0=>positive, 1=>negative) 
exp bits 15-0 = binary integer representing the base INPUTS : 
ten (10) exponent fnum — Motorola Fast Floating Point number 
man binary integer mantissa &string[0] ~ address for output of converted ASCII character string 
(16 bytes) 
INPUTS 
exp ~ binary integer representing sign and exponent RESULT . 
mant — binary integer representing the mantissa &string[0] - converted ASCII character string 
exp - integer exponent value in binary form 


RESULT 

fnum — converted FFP floating point format number BUGS 
None 
BUGS 


None 











amiga. lib/math/fpbed amiga. Lib/math/fpbed 
NAME 
fpbed -— convert FFP floating point number to BCD format 


USAGE 
fpbed(fnum, &string[0]); 


FUNCTION 
Accepts a floating point. number and the address where the 
converted BCD data is to be stored. The FFP number is 
converted and stored at the specified address in an ASCII 
form in accordance with the following format: 


MMMM SES B 


Where: M = Four bytes of BCD, each with two (2) digits of 
the mantissa (8 digits) 
S = Sign. of mantissa (0x00 = positive, OxFF = negative) 
E = BCD byte for two (2) digit exponent 
S = Sign of exponent (0x00 = positive, OxFF = negative) 
B = One (1) byte binary two's compliment representation 
of the exponent 
INPUTS 
fnum — floating point number 
a&string[0] - address where converted BCD data is to be placed 
RESULT 


&string[0] - converted BCD data 








amiga. lib/NewList amiga. lib/NewList 


NAME 


NewList —- prepare a list structure for use 





SYNOPSIS 
NewList(list*) 
void NewList(struct List *); 


FUNCTION 
Prepare a List structure for use; the list will be empty and 


ready to use. 


This function prepares the lh_Head, lh_Tail and lh_TailPred fields. 
You are responsible for initializing lh_Type. Assembly programmers 
will want to use the NEWLIST macro instead. 


INPUTS 
list - Pointer to a List 


SEE ALSO 
exec/lists.h 








amiga. lib/printf 


NAME 
printf — print a formatted output line to the standard output. 


SYNOPSIS . 
printf( formatstring. [,value [,values] ] ); 


FUNCTION 
Format the output in accordance with specifications in the format 
string: 


INPUTS 
formatstring ~ a pointer to a null-terminated string describing the 
output data, and locations for parameter substitutions. 
value(s) ~ numeric variables or addresses of null-terminated strings 
to be added to the format information. 


The function printf can handle the following format conversions, in 
common with the normal C language call to printf: 





%c — the next long word in the array is to be fonmatted 
as a character (8-bit) value 

sad — the next long word in the array is to be formatted 
as a decimal number 

%x —- the next long word in the array is to be formatted 
as a hexadecimal number 

%s — the next long word is the starting address of a 
null-terminated string of characters 


And "1" (small-L) character. must be added between the % and. the letter 
if the value is a long (32 bits) or if the compiler in use forces 
passed paramters to 32 bits. 

Floating point output is not supported. 


I Following the %, you may also specify: 


° an optional minus (-) sign that tells the formatter 
to left-—justify the formatted item within the field 
width 

° an optional field-width specifier... that is, how 


many spaces to allot for the full width of this 
item. If the field width specifier begins with 

a zero (0), it means that leading spaces, ahead of 
the formatted item (usually a number) are to be 
zero-filled instead of blank~filled 








° an optional period (.) that separates the width 
specifier from a maximum number of characters 
specifier 

° an optional digit string (for %ls specifications 


only) that specifies the maximum number of characters 
to print from a string. 


See other books on C language programming for examples of the use 
of these formatting options (see "printf" in other books). 





NOTE 
The global "_stdout" must be defined, and contain a pointer to 
a legal AmigaDos file handle. Using the standard Amiga startup 
module sets this up. In other cases you will need to define 
stdout, and assign it to some reasonable value (like what the 
AmigaDOS Output() call returns). This code would set it up: 





ULONG stdout; 
stdout=Output(); 





amiga. lib/printf amiga. lib/RangeRand 











amiga. 1lib/RangeRand 
NAME 


RangeRand - To obtain a random number within a specific integer range 
of 0 to value. 


SYNOPSIS 
number = RangeRand(value) ; 


FUNCTION 
RangeRand accepts a value from 1 to 65535, and returns a value : 
within that range. (16-bit integer). Note: C-language implementation. 


Value is passed on stack as a 32-bit integer but used as though 
it is only a 16-bit integer. Variable named RangeSeed is available 
beginning with V1.2 that contains the global seed value passed from 
call to call and thus can be changed by a program by declaring:: 


extern ULONG RangeSeed; 


INPUTS 
value - integer in the range of 1 to 65535. 


RESULT 
number - pseudo random integer in the range of 1 to <value>. 


SEE ALSO 
FastRand 








ot - 4 











amiga. lib/RemTOF amiga. lib/RemTOF 


NAME 
RemfOF ~ Remove a task from the TopOfFrame interrupt server chain. 


SYNOPSIS 
RemTOF (i); 
void RemIOF(struct Isrvstr *); 


FUNCTION 
To remove a task from the vertical-blanking interval interrupt server 
chain. 


INPUTS 
i - pointer to structure Isrvstr. 


SEE ALSO 
AddTOF , graphics/graphinit.h 





amiga.lib/sprintf amiga.lib/sprintf 
NAME 
sprintf — format a C-like string into a string buffer 


SYNOPSIS 
sprintf( destination, formatstring [{,value [, values] ] ); 


FUNCTION 
perform string formatting identical to printf, but direct the output 
into a specific destination in memory. This uses the ROM version 
ef printf, so it is very small. 


Assembly programmers can call this by placing values on the 
stack, followed by a pointer to the formatstring, followed 
by a pointer to the destination string. 


INPUTS 
destination - the address of an area in memory into which the 
formatted output is to be placed. 
formatstring - pointer to a null terminated string describing the 
desired output formatting. 
value(s) — numeric information to be formatted into the output 
stream. 


SEE ALSO 
printf, exec/RawDoFmt 











Tl - 4 








amiga. lib/stdio amiga. lib/stdio 


NAMES 


fclose - close file 

fgetc  - get a character from a file 

fprintf - format data to file (see exec. library/RawDoFmt) 
fputc - put character to file 

fputs - write string to file 


getchar —- get a character from stdin 

printf - put format data to stdout (see exec. Library/RawDoFint ) 
putchar ~ put character to stdout : 

puts — put string to stdout, followed by newline 

sprintf - format data into string (see exec. library/RawDoFmt) 


FUNCTION 


FROM 


FROM 


These functions work much like the standard C functions of the same 
names. The file I/O functions all use non-buffered AmigaDOS 
filehandles, and must not be mixed with the file I/O of any C 
compiler. The names of these function match those found in many 
standard C libraries, when a name conflict occurs, the function is 
generally taken from the FIRST library that was specified on the 
linker's command line. Thus to use these functions, specify 

the amiga.lib library first. 


To get a suitable AmigaDos filehandle, the AmigabOS Open() 
function must be used. 


All of the functions that write to stdout expect an appropriate 
filehandle to have been set up ahead of time. Depending on 
your C compiler and options, this may have been done by the 
startup code. Or it can be done manually: 


Cc: 

extern ULONG stdout; 

/* Remove the extern if startup code did not define stdout */ 
stdout=Output(); 


ASSEMBLY: 
XDEF _ stdout 
DC.L _stdout ;<~ Place result of dos.library Output() here. 





||) 


fl - a 





TABLE 


debug. 
debug. 
debug. 
debug. 
debug. 
debug. 
debug. 


OF CONTENTS 


Lib/KcmpStr 
lib/KGetChar 
lib/KGetNum 
lib/KMayGetChar 
lib/KPrintF 
lib/KPutChar 
libskPutstr 





debug. Lib/KCmpstr debug. 1ib/KCmpstr 


NAME 

KCmpStr ~- compare two null terminated strings 
SYNOPSIS ; 

mismatch = KCmpStr(stringl, string2) 

DO AQ Al 
FUNCTION 


stringl is compared to string2 using the ASCII coalating 
sequence. 0 indicates the strings are identical. 














eT -da 














debug. 1lib/KGetChar debug. lib/KGetChar 


NAME 
KGetChar — get a character from the console 
(defaults to the serial port at 9600 baud) 
SYNOPSIS 
char = KGetChar() 
DO 
FUNCTION 


busy wait until a character arrives from the console. 
KGetChar is the assembly interface, _KGetChar and _kgetc 
are the C interfaces. 





debug. lib/KGetNum 


NAME 

kKGetNum — get a number from the console 
SYNOPSIS 

number = KGetNum() 

DO 
FUNCTION 


get a signed decimal integer from the console. 
wait until the number arrives. 


debug. lib/KGetNum 


This will busy 














debug. lib/KMayGetChar debug. lib/KMayGetChar 
NAME : 
KMayGetChar ~ return a character if present, but don't wait 
(defaults to the serial port at 9600 baud) 


SYNOPSIS 
flagChar = KMayGetChar() 
DO 


FUNCTION 
return either a -l1, saying that there is no character present, or 
whatever character was waiting. KMayGetChar is the assembly 
interface, _KMayGetChar is the C interface. 


4 


tT 





debug. Lib/KPrintF debug. lib/kKPrintF 





NAMB 
KPrintF - print formatted data to the console 
(defaults to the serial port at 9600 baud) 
SYNOPSIS 
KPrintF("format string", values) 
AO AL 
FUNCTION 
print a formatted C-type string to the console. See the 
exec RawDoFmt() call for the supported % formatting commands. 
INPUTS 
"format string" - AC style string with % commands to indicate 
where paramters are to be inserted. 
values — A pointer to an array of paramters, to be inserted into 
specified places in the string. 
KPrintf is the assembly interface that wants the two pointers 
in registers. _KPrintF and _kprintf are the C interfaces that 
expect the format string on the stack, and the paramters on 
the stack above that. 
SEE ALSO 


exec. library/RawDoFmt, any C compiler's "printf" call. 


| 




















sT~- da 





debug. lib/KPutChar 


NAME 
KPutChar — put a character to the console 
(defaults to the serial port at 9600 baud) 
SYNOPSIS 
char = KPutChar(char) 
DO DO 
FUNCTION 
put a character to the console. This function will not return 
until the character has been completely transmitted. 
INPUTS 


kPutChar is the assembly interface, the character must be in DO. 
_KPutchar and _kputc are the C interfaces, the character must be 
a longword on the stack. 


debug. 1ib/KPutChar 


debug. lib/kPutStr debug. lib/KPutStr 





NAME 

KPutStr —- put a string to the console 

(defaults to the serial port at 9600 baud) 

SYNOPSIS 

KPutStr(string) 

AQ 

FUNCTION 

put a null terminated string to the console. This function will 

not return until the string has been completely transmitted. 
INPUTS 


kKPutStr is the assembly interface, a string pointer must be in AO. 
_kputStr and _kputs are the C interfaces, the string pointer must 
be on the stack. 

















Oct 1 19:45 1988. CreateExtIO.c Page 1 



















JReRKEHE aMiga..LAD/CLEAteEXt IO RII IRI IIR RRR IOC IR IRI K RK / 


#include “exec/types.h" 
#include "exec/memory.h" 
#include "exec/io.h" 


#include "proto/exec.h" 
#include "functions.h" 


struct IORequest *CreateExtIO( ioReplyPort, size ) 
struct MsgPort *ioReplyPort; 
ULONG size; 


( 
struct IORequest *ioReq; 


if(! ioReplyPort ) 
return(NULL) ; 


ioReq = 
(struct I0Request *)AllocMem( size, (ULONG)MEMF_CLEAR |MEMF_PUBLIC i 


if( !ioReq) 
return (NULL) ; 


ioReq->io_Message.mn_Node.ln Type = NT_MESSAGE; 
ioReq->io Message .mn_Length = size; /* save for later */ 
ioReg->io_Message.mn_ReplyPort = joReplyPort; 


return( ioReqg ); 


renews amiga. Lib/DeleteBxt TO AIR IIIIC IIO IR RIK RR IR IKI RIK RARE / 


9T - 4 


void DeleteExtIO( iokxt ) 
struct IORequest *ioExt; 
/* try to make it hard to reuse the request by accident */ 
LoExt—>io_Message.mn_Node.ln_ Type = —1; 
ioExt—>io_Message.mn_ReplyPort 
ioExt—>io_Device 


(struct MsgPort *)-1; 
(struct Device *) -l; 


FreeMem( ioExt, (ULONG)ioExt-—>io_Message.mn_Length ); 


Joct 1 19:45 1988 CreatePort.c Page 1 


[RRRKKK amiga. lib/createPort FOO II IIR RR III TOR RR ITO I KI I ICOK 7 


#include "exec/types .h" 
#include "exec/ports.h" 
#include "exec/memory.h" 
* 

#include "proto/exec.h" 
#include “functions.h" 


*/ 


/* Example only, please use the amiga.lib version where possible */ 


struct MsgPort *CreatePort(name, pri) 
char *name; 

LONG pri; 

{ 
int sigBit; 

struct MsgPort *port; 


if ((sigBit = AllocSignal(-1L)) == —1) 
return (NULL) ; 


port = (struct MsgPort *) 
AllocMem( (ULONG) sizeof (struct MsgPort) , (ULONG)MEMF_CLEAR |MEMF_PUBLIC) ; 


if (!port) 
{ 


FreeSignal(sigBit) ; 
return (NULL) ; 
} 





port—> mp_Node.1n_ Name = name; 
port-> mp-Node.In_ Pri = pri; 





port—> mp_Node.1n_ Type = NT_MSGPORT; 
port-> mp_Flags = PA_SIGNAL; 
port—> mp_SigBit = sigBit; 


port-> mp_SigTask (struct Task *)FindTask(0L); /* find THIS task */ 
if (name) 

AddPort( port) ; 
else 

NewList(&(port—> mp_MsgList)); /* init message list */ 


return(port) ; 


/xxeeee amiga. lib/DeletePort FOI III III III IAT IOI IG RAI | 


void DeletePort (port) 
struct MsgPort *port; 
{ 
if ( port-> mp_Node.1n_Name ) /* if it was public... */ 
RemPort (port); 


/* Make it difficult to re-use the port */ 


port-—> mp_SigTask = (struct Task *) ~1; 
port-> mp _MsgList.lh_Head = (struct Node *) —l; 


FreeSignal( port-> mp_SigBit ); 
FreeMem( port, (ULONG)sizeof(struct MsgPort) ); 




















Oct 1 19:45 1988 CreateTask.c Page 1 


[RRREER amiga. lib/CreateTask WRK ERE KERRIER RAEI RRR EKER | 


#include "exec/types.h" 
#include "exec/tasks.h" 
#include "exec/memory.h" 


#include "proto/exec.h" 
* 


#Hinclude "functions.h" 


*/ 


7* the template for the mementries. Unfortunately, this is hard to 


x do from C; mementries have unions, and they cannot be statically 
* initialized... 

* 

* In the interest of simplicity I recreate the mem entry structures 
* here with appropriate sizes. We will copy this to a local 

* variable and set the stack size to what the user specified, 

* then. attempt to actually allocate the memory. 

* 
#define ME_TASK 0 
#define ME_STACK 1 
#define NUMENTRIES 2 


‘|struct FakeMemEntry { 


L£T.- 4 


ULONG fme_Reqs; 
ULONG fme_Length; 
I; 


struct FakeMemList { 
struct Node fml_Node; 
UWORD fml_NumEnt ries; 
struct FakeMemEntry fmil_ME[NUMENTRIES] ; 
} TaskMemTemplate = [ 
{ 0 } 7* Node */ 


f 
NUMENTRIES, /7* num entries */ 
( /* actual entries: */ 
{ MEMF_PUBLIC | MEMF CLEAR, sizeof( struct Task ) }, /* task */ 
{ MEMF_CLEAR, 0 } /* stack */ 


struct Task * CreateTask( name, pri, initPC, stackSize ) 
char *name; 

ULONG pri; 

APTR initPCc; 

ULONG stackSize; 


{ 

struct Task *newTask; 

struct FakeMemList fakememlist; 
struct MemList *ml; 


7* vound the stack up to longwords... */ 
stackSize = (stackSize +3) & “3; 


* 


* This will allocate two chunks of memory: task of PUBLIC 
* and stack of PRIVATE 

* 

fakememlist = TaskMemTemplate; 
fakememlist.fml_ME[ME_ STACK] .fme_Length = stackSize; 


ml = (struct MemList *)AllocEntry( (struct MemList *)&fakememlist ); 


if(! ml ) 
return( NULL ); 


Oct 1 19:45 1988 CreateTask.c Page 2 


7* set the stack accounting stuff */ 
newTask = (struct Task *) ml—>ml_ME[ME_TASK] .me_Addr; 


ml->ml_ME[ME_STACK] .me_Addr; 
(APTR) ( (ULONG) (newTask~>te_SPLower) + stackSize); 
newTask~>tc_SPUpper ; 


newTask—>tc_SPLower 
newfask—>tc_SPUpper 
newTask—>tc_SPReg 


to owe 


/* mise task data structures */ 


newTask—->tc_Node.1ln_Type = NT_TASK; 
newlask—>tc_Node.1n Pri = pri; 
newTask—>tc_Node.1n_ Name = name; 


/* add it to the tasks memory list */ 
NewList( &newTask—>tc_MemEntry ); 
AddHead( &newTask->tc_MemEntry, (struct Node *)ml ); 


/* add the task to the system -~ use the default final PC */ 
AddTask( newTask, initPC, OL ); 
return( newTask ); 


JReeeee amiga. Lib/DeleteTask * II III III IIIA II IR IR RI IR RRR IIR / 


void DeleteTask( tc ) 
struct Task *tc; 


{ 
/* because we added a MemList structure to the tasks's TC_MEMENTRY 


* structure, all the memory will be freed up for us! */ 
RemTask( tc ); 





8T - 4 


Mn 


Oct 1 19:45 1988 Misc.asm Page 1 


wR amiga. LID/BeEgi NO * ARR III I IK IIR IKI 





INCLUDE "exec/types.i" 
INCLUDE "“exec/lists.i" 
INCLUDE "exec/io.i" 


;Call the BeginIO vector of a device directly. Much like exec/SendIO, but 
;does not touch IO FLAGS. 
SECTION _BeginIO 


XDEF _BeginIo 
__BeginIo: move.l 4(sp),al ;Get IORequest pointer 
po 
move.] a6,—(a7) 
move.1 IO DEVICE(al),a6 ;Pointer to device 
jsr DEV_BEGINIO(a6) ;Jump to device's BEGINIO vector 
move.1 (a7)+,a6 
rts 
END 


aKeEKKK amiga. LID/NEWLISE RRR RRA RIK KIKI KIRK RIK ERK 


INCLUDE "exec/types.i" 
INCLUDE "exec/lists.i" 





SECTION _NewList 


XDEP _NewList 
| NewList: move.l1 4(sp),a0 ;Get pointer from C's stack 
move.] a0Q,d0 :pass the list back in DO 


;This next code is equavalent to the NEWLIST macro 


clr.1  LH_TAIL(a0) 

move.1 a0,LH_TAILPRED(a0) 

addq.1 #LH_TAIL,a0 ;pointer plus 4... 
move.l1 a0,-(a0) ;-..back down to LH_HEAD 
rts 


END 











Section G 


Sample Device, Sample Library 


This section contains source code for a sample hbrary and sample device. These exam- 
ples can provide an excellent starting point in the creation of a custom device or library. 


The library has two functions: one that adds two numbers together and one that dou- 
bles a number. Supporting interface code source is provided. The device is a complete 4 
unit, static-sized RAM disk that works under the old (standard) filing system, the new 
V1.3 FastFileSystem, and has optional code to bind it to an AutoConfig device. 


The examples have been assembled under the Metacomco assembler, V11.0 and under 
the CAPE assembler, V2.0. 


Dec 9 04:21 1988 SampleDevice/asmsupp.i Page 1 





XLIB 


; Put a message to the serial port at 9600 baud. 


MeN NN SS 


PUTMSG: 


msg\@ 


end\@ 


LINKSYS MACRO 


CALLSYS MACRO 





MOVE.L A6,~(SP) 
MOVE.L \2,A6 


JSR _LVO\1(A6) 
MOVE.L (SP)+,A6 
ENDM 
; call a library via A6 without having to see _IwWOo 
JSR _EVO\1(A6) 
ENDM 
MACRO ; define a library reference without the _LVO 
XREF =—_LVO\1 
ENDM 


PUTMSG 30,<'%s/Init: called'> 


XREF KPutFmt 
MACRO * level,msg 


IFGE INFO_LEVEL-\1 


PEA subSysName (PC) 
MOVEM.L AQ/A1/D0/D1,-(SP) 
LEA ——msg\@(pc) , A0 

LEA 4*4(SP),Al 

JSR KPutFmt 


MOVEM.L (SP)+,D0/D1/A0/A1 
ADDQ.L #4,SP 
BRA.S  end\@ 


DC.B 2 
DC.B 10 
DC.B 0 
DS.W 0 
ENDC 


ENDM 


RIKKI KEKE KEKE KKK RIK KR REE ERE KEE KEKE EE RRR ERE KEKE EKER KREKEERERK ERE 


All rights reserved. 


* 
* Copyright (C) 1985, Commodore Amiga Inc. 
* Permission granted for non-commercial use 
* 
* asmsupp.i ~- random low level assembly support routines 
* used by the Commodore sample Library & Device 
* 
KKK KHKKK KKK HK KEK KEK IHRE KEK KKK EKA KEE RK KIRKE I KEK KEKE KE RIKER RREREKAKE 
CLEAR MACRO iquick way to clear a D register on 68000 
MOVEQ = #0,\1 
ENDM 
;BHS MACRO 
; BCC.\O \i ;\0 is the extension used on the macro (such as ".s") 
i ENDM 
;BLO MACRO 
i BCS.\O \l 
; ENDM 
EVEN MACRO ; word align code stream 
DS.W 0 
ENDM 


; link to a library without having to see a _LVO 


Used as so: 


Parameters can be printed out by pushing them on the stack and 
adding the appropriate C printf-style % formatting commands. 


;Point to static format string 
;Point to args 











Dec 9 04:21 1988 SampleDevice/ramdev-mountlist Page 1 


f* 
* Mountlist for manually mounting the sample ramdisk driver. 
* 
* FO: and Fl: are set up for the V1.3 fast file system (FFS). 
* $2: and $3: are setup for the old file system (OFS). 
* 
* 
* After mounting, the drives must be formatted. Be sure to 
* use the FFS flag when formatting the Fast File System 
* ramdrives: 
* 
* j;make sure "ramdev.device" is in DEVS: 
x 
* mount f0: from mydev-mountlist 
* format drive £0: name "Zippy" FFS 
* 
*/ 
FO: Device = ramdev.device 
Unit = 0 
LowCyl = 0 ; HighCyl = 14 
Surfaces = 1 
Buffers = 1 
BlocksPerTrack = 10 
Flags = 0 
Reserved = 2 
GlobVec = -1 
BufMemType = 0 
DosType = 0x444F5301 
StackSize = 4000 
FileSystem = 1:fastfilesystem 
# 
Fl: Device = ramdev.device 
Unit =1 
LowCyl = 0 ; HighCyl = 14 
Surfaces = 1 
Buffers = 1 
BlocksPerTrack = 10 
Flags = 0 
Reserved = 2 
GlobVec = -1 
BufMemType = 0 
DosType = 0x444F5301 
StackSize = 4000 
FileSystem = 1:fastfilesystem 
# 
S2: Device = ramdev.device 
Unit = 2 
Flags = 0 
Surfaces = ] 
BlocksPerTrack = 10 
Reserved = 1 
Interleave = 0 
LowCyl = 0 ; HighCyl = 14 
Buffers = 1 
BufMemType = 0 
# 
S3: Device = ramdev.device 
Unit =3 
Flags = 0 
Surfaces = 1 


BlocksPerTrack = 10 
Reserved = 1 

Interleave = 0 

LowCyl = 0 ; HighCyl = 14 
Buffers = 1 

BufMemType = 0 








Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 1 


KKK KER REE ERE REEEKK KERR RRR ERE EKER KKK EKER KEKE EKKKK KEKE KK EKKKERRKEEK 
x 
* Copyright (C) 1986,1988 Commodore Amiga Inc. All rights reserved. 


* Permission granted for non-commercial use. 
* 


REE RIKI KEKE KKK RII KKK IKK EK KEK IKKE EEK REE RHE KERRIER KRENEK REKEEK 
* 


ramdev.asm -- Skeleton device code. 


A sample 4 unit ramdisk that can be bound to an expansion slot device, 
or used without. Works with the Fast File System. 

This code is required reading for device driver writers. It contains 
information not found elsewhere. 


This example includes a task, though a task is not actually needed for 
a simple ram disk. Unlike a single set of hardware registers that 
May need to be shared by multiple tasks, ram can be freely shared. 
This example does not show arbitration of hardware resources. 


Tested with CAPE and Metacomco 


Based on mydev.asm 

10/07/86 Modified by Lee Erickson to be a simple disk device 
using RAM to simulate a disk. 

02/02/88 Modified by C. Scheppner, renamed ramdev 

09/28/88 Repaired by Bryce Nesbitt for new release 


11/01/88 More clarifications 
HREKKKEIKE KEKE IKKE KKKKKKEREKK KEK KKK KER ERE KKK KKK KEKE EER K EKER EKER REE EEKEKK 


4 t+ HH HO HH HH HH HO OH HH HH OH 


SECTION firstsection 


NOLIST 

include "exec/types.i" 

include “exec/devices.i" 

include “exec/initializers.i" 
include “exec/memory. i" 

include "exec/resident.i" 
include "exec/io.i" 

include "exec/ables.i" 

include "exec/errors.i" 

include "exec/tasks.i" 

include "hardware/intbits.i" 
IFNE AUTOMOUNT 

include "libraries/expansion.i" 
include "libraries/configvars.i" 
include "libraries/configregs.i" 
ENDC 


include "asmsupp.i" ;standard asmsupp.i, same as used for library 
LIST . 
include “ramdev.i" 


ABSEXECBASE equ 4 Absolute location of the pointer to exec.library base 


i777 These don't have to be external, but it helps some 
377-——— debuggers to have them globally visible 

XDEF Init 

XDEFP Open 

XDEF Close 

XDEF Expunge 

XDEF Null 

XDEP myName 

XDEF  BeginIo 

XDEF AbortIoO 


7Pull these _LVOs in from amiga.lib 
XLIB AddIntServer 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 2 


XLIB RemiIntServer 

XLIB Debug 

XLIB Initstruct 

XLIB  OpenLibrary 

XLIB CloseLibrary 

XLIB Alert 

XLIB FreeMem 

XLIB Remove 

XLIB AddPort 

XLIB AllocMem 

XLIB AddTask 

XLIB PutMsg 

XLIB RemTask 

XLIB- ReplyMsg 

XLIB Signal 

XLIB GetMsg 

XLIB Wait 

XLIB WaitPort 

XLIB  AllocSignal 

XLIB  SetTaskPri 

XLIB GetCurrentBinding 
XLIB MakeDosNode 

XLIB AddDosNode . 
XLIB CopyMemQuick ;Highly optimized copy function from exec. library 


;Use to get list of boards for this driver 


INT. ABLES ;Macro from exec/ables.i 


The first executable location. This should return an error 
in case someone tried to run you as a program (instead of 
loading you as a device). 


i 
i 
i 
i 


FirstAddress: 
moveg #-1,d0 
rts 


; A romtag structure. You load module will be scanned for 
; this structure to discover magic constants about you 
(such as where to start running you from...). 


; Most people will not need a priority and should leave it at zero. 
; the RT_PRI field is used for configuring the roms. Use "mods" from 
; wack to look at the other romtags in the system 

MYPRI EQU 0 


initDDescrip: 

; STRUCTURE RT,0 
RTC_MATCHWORD RT_MATCHWORD (Magic cookie) 
initDDescrip ; RT_MATCHTAG (Back pointer) 
EndCode ; RT_ENDSKIP (To end of this hunk) 
RTF_AUTOINIT ; RT_FLAGS (magic~see "Init:") 
VERSION ; RT_VERSION 
NT_DEVICE ; RT_TYPE 
MYPRI ; RT PRI 
myName ; RT_NAME 
idString ; RT_IDSTRING 
Init ; RT_INIT 

; LABEL RT_SIZE 


8 
= 


RRRSSHREE 


;This name for debugging use 

IFNE INFO_LEVEL ;If any debugging enabled at all 
subSysName: 

dc.b “ramdev" ,0 

ENDC 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm. Page 3 


; this is the name that the device will have 
myName : MYDEVNAME 


IFNE AUTOMOUNT 
ExLibName de.b ‘expansion. library',0 ; Expansion Library Name 
ENDC 


; a Major version number. 
VERSION: EQU 1 


; A particular revision. This should uniquely identify the bits in the 
; device. I use a script that advances the revision number each time 
I recompile. That way there is never a question of which device 
; that really is. 
REVISION: EQU 30 


; this is an identifier tag to help in supporting the device 
; format is 'name version.revision (dd MON yyyy)',<cr>,<lf>,<null> 
idstring: dec.b 'ramdev 1.30 (1 Nov 1988)',13,10,0 


; force word alignment 
ds.w 


; The romtag specified that we were "RTF_AUTOINIT". This means 
; that the RT_INIT structure member points to one of these 

; tables below. If the AUTOINIT bit was not set then RT_INIT 

; would point to a routine to run. 


MyDev_Sizeof ; data space size 

funcTable ; pointer to function initializers 
dataTable ; pointer to data initializers 
initRoutine ; routine to run 


Init: 
De. 
we. 
we. 
pe. 


L 
L 
L 
L 


funcTable: 


jovccc> «standard system routines 
dc.1 Open 
de.l Close 
dce.l Expunge 
de.1 Null ;Reserved for future 
joc «my device definitions 

dc.1 BeginIo 

de.1 AbortIo 


custom extended functions 
FunctionA 
FunctionB 


j77——_ function table end marker 
de.) -1 


;The data table initializes static data structures. The format is 
;specified in exec/InitStruct routine's manual pages. The 


; INITBYTE/INITWORD/INITLONG macros are in the file "exec/initializers.i". 


;The first argument is the offset from the device base for this 
jbyte/word/long. The second argument is the value to put in that cell. 
;The table is null terminated 


dataTable: 
INITBYTE LN_TYPE,NT_DEVICE 
INITLONG LN_NAME,myName 
INITBYTE LIB_FLAGS , LIBF_SUMUSED! LIBF_CHANGED 
INITWORD LIB_VERSION , VERSION 


;Must be LN_TYPE! 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 4 


INITWORD LIB_REVISION, REVISION 
INITLONG LIB_IDSTRING, idString 
De.L 0 


; FOR RTF_AUTOINIT: 

; This routine gets called after the device has been allocated. 
The device pointer is in DO. The AmigaDOS segment list is in a0. 
If it returns it's device pointer, then the device will be linked 
into the device list. If it returns NULL, then the device 
will be unloaded. 


; IMPORTANT: 
If you don't use the "RTF_AUTOINIT" feature, there is an additional 
caveat. If you allocate memory in your Open function, remember that 
allocating memory can cause an Expunge... including an expunge of your 
device. This must not be fatal. The easy solution is don't add your 
device to the list until after it is ready for action. 


; This call is single-threaded; please read the description for 
"Open" below. 


; a3 —- Points to temporary RAM 
-—— Expansion library base 
—- device pointer 
—-— Exec base 


get the device pointer into a convenient A register 
5,<'Ss/Init: called'> 
movem.1 d1-d7/a0-a5,-(sp) ; Preserve ALL modified registers 
move.1 d0,a5 


save a pointer to exec 
a6,md_SysLib(a5) 


i save a pointer to our loaded code 
move.l a0,md_SegList(a5) 


HRA KKKKE KE KKK KKK EK IKK RK KKH EE KERR K KEE REE IKE KK EERE KEE REE KEK KEKE KEEKEKKKREEEK 


Here starts the AutoConfig stuff. Normally you would put this driver 
in the expansion drawer, and be called when binddrivers finds a board 
that matches your driver (the "PRODUCT=" in TOOLTYPES) . 
GetCurrentBinding() would return your board. 


e+ + 4 4 HO 


IFNE AUTOMOUNT 


lea.1 ExLibName , Al 
moveg.1 #0,D0 
CALLSYS OpenLibrary 
tst.1 DO 
Init_Error 


; Get expansion lib. name 


; Open the expansion library 


init_OpSuccess: 
DO,A4 ;[expansionbase to A4] 
#0,D3 
md_Base(A5),A0 ; Get the Current Bindings 
#4 ,DO j; Just get address (length = 4 bytes) 
_LVOGetCurrentBinding , A4 
md_Base(A5),D0 ; Get start of list 
DO 3; If controller not found 
Init_End@ ; Exit and unload driver 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 5 


PUTMSG 10,<'%s/Init: GetCurrentBinding returned non-zero'> 

move.1 DO,A0 ; Get config structure address 

move.1 cd_BoardAddr(A0) ,md_Base(A5); Save board base address 
#CDB_CONFIGME,,cd_Flags(A0); Mark board as configured 


; Here we build a packet describing the characteristics of our disk to 

; pass to AmigaDOS. This serves the same purpose as a "mount" command 

; of this device would. For disks, it might be useful to actually 

; get this information right from the disk itself. Just as mount, 

; it could be for multiple partitions on the single physical device. 

; For this example, we will simply hard code the appropriate parameters. 


; The AddDosNode call adds things to dos's list without needing to 


; use mount. We'll mount all 4 of our units whenever we are 
; started. 








it!!! If your card was successfully configured, you can mount the 
;'!! units as DOS nodes 


Allocate temporary RAM to build MakeDosNode parameter packet 
#MEMF_CLEAR!MEMF_PUBLIC,d1 

#mdn_Sizeof ,d0 ; Enough room for our parameter packet 
AllocMem 

a0 ,a3 


#-——— Use InitStruct to initialize the constant portion of packet 
move.1 a0,a2 ; Point to memory to initialize 

moveq.1 #0,da0 ; Don't need to re-zero it 

lea.1 mdn_Init(pc),AlL 

CALLSYS InitStruct 


lea mdn_dName(a3),a0 ; Get addr of Device name 
move.1 a0,mdn_dosName(a3) ; and save in environment 


#0 ,d6 i; Now tell AmigaboS about all units UNITNUM 


d6,do ; Get unit number 

#$30,a0 ; Make ASCII, minus 1 

dO ,mdn_dName+2 (a3) i and store in name 

d6 ,mdn_unit(a3) ; Store unit # in environment 


;! Before adding to the dos list, you should really check if you 
;! are about to cause a name collision. This example does not. 


move.l a3,a0 

LINKLIB _LVOMakeDosNode,a4 ; Build AmigaDOS structures 
;This can fail, but so what? 

move.1 d0,a0 i; Get deviceNode address 
moveg.1  #0,d0 ; Set device priority to 0 
moveq.1 #0,d1 

moveg.1 #ADNF_STARTPROC,d1 i See note below 

;it's ok to pass a zero in here 

LINKLIB _LVOAd@DosNode,a4 


; ADNF_STARTPROC will work, but only if dn_Seglist is filled in 


; in the SegPtr of the handler task. 


addq #1,d6 ; Bump unit number 
cmp.b #MD_NUMUNITS ,d6 
bls.s Uloop 7 Loop until all units installed 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 6 


move.1 a3,al ; Return RAM to system 
move.1 #mdn_Sizeof,d0 
CALLSYS FreeMen 


Init_End: 


move.1l a4,al ; Now close expansion library 
CALLSYS CloseLibrary 


; You would normally set dO to a NULL if your initialization failed, 
; but I'm not doing that for this demo, since it is unlikely 

; you actually have a board with any particular manufacturer ID 

; installed when running this demo. 


i 
KKKEKKKKEKKEKEKEKKKEKKEREKEK KKK EK KEKE KK KE KEE KERRIER KEKREEREEREEERKEEKKEKEK 


ENDC 


move.1 a5,d0 
Init_Error: 
movem.1 (sp)+,dl-d7/a0-a5 


; Here begins the system interface commands. When the user calls 

; OpenDevice/CloseDevice/RemDevice, this eventually gets translated 
; into a call to the following routines (Open/Close/Expunge) . 

; Exec has already put our device pointer in a6 for us. 


; IMPORTANT: 
; These calls are guaranteed to be single-threaded; only one task 
will execute your Open/Close/Expunge at a time. 


For Kickstart V33/34, the single-threading method involves "Forbid". 
There is a good chance this will change. Anything inside your 
Open/Close/Expunge that causes a direct or indirect Wait() will break 
the Forbid(). If the Forbid() is broken, some other task might 
manage to enter your Open/Close/Expunge code at the same time. 

Take care! 


; Since exec has turned off task switching while in these routines 
(via Forbid/Permit), we should not take too long in them. 


; Open sets the IO_ERROR field on an error. If it was successfull, 
; we should also set up the IO_UNIT field. 


i ( device:a6, iob:al, unitnum:d0, flags:dl ) 
20,<'%s/Open: called'> 
movem.1 d2/a2/a3/a4,—(sp) 


move.1 al,a2 ; Save the iob 


see if the unit number is in range *!* UNIT 0 to 3 *!* 
#1,d0 ; Unit ZERO IS allowed! 

#MD_NUMUNITS , dO 

Open_Range_Error ; unit number out of range (BHS) 


see if the unit is already initialized 
d0,d2 ; save unit number 

#2,d0 

md_Units(a6,d0.1),a4 

(a4) ,d0 

Open_UnitOK 


try and conjure up a unit 
InitUnit ;seratch:a3 unitnum:d2 devpoint:a6 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 7 


see if it initialized OK 
(a4),d0 
Open_Error 


move.1 d0,a3 ; unit pointer in a3 
move.1  d0,IO_UNIT(a2) 


joc--~7> «mark us as having another opener 
addq.w  #1,LIB_OPENCNT(a6) 

addq.w  #1,UNIT_OPENCNT(a3) ;Internal bookkeeping 
j-—-7-- ~prevent delayed expunges 

belr #LIBB_DELEXP ,md_Flags(a6) 


movegq.1 #0,d0 
elr.b IO_ERROR (a2) 


Open_End: 


movem.1 (sp)+,d2/a2/a3/a4 
rts 


Open_Range_Error: 


#IOERR_OPENFAIL,d0O 

d0,IO_ERROR(a2) 
PUIMSG 2,<'%s/Open: failed'> 
bra.s Open_End 


; There are two different things that might be returned from the Close 
; routine. If the device wishes to be unloaded, then Close should return 
; the segment list (as given to Init). Otherwise close MUST return NULL. 


Close: i; ( device:a6, iob:al ) 
movem.1 dl/a2-a3,-(sp) 
PUTMSG 20,<'%s/Close: called'> 


move. 1 al,a2 
move.] IO_UNIT(a2) ,a3 


j777-77> «make sure the iob is not used again 
jo77c> «with a -1 in IO_DEVICE, any BeginIO() attempt will 

jo7777- «immediatly crash (which is better than a subtle corruption 
ju777 «Cthat will lead to hard-to-trace crashes. 

moveq.1 #-1,d0 

move.l  d0,IO_UNIT(a2) 
move.1 d0,1IO_DEVICE(a2) 


jWe're closed... 
;customers not welcome at this IORequest! ! 


joc > «see if the unit is still in use 
subq.w #1, UNIT_OPENCNT(a3) 


Since this example is a RAM disk (and we don't want the contents to 
disappear between opens, ExpungeUnit will be skipped here. It would 
be used for drivers of "real" devices 
bne.s Close Device 
ExpungeUnit 


Close_Device: 
i mark us.as having one fewer openers 
moveg.1 #0,d0 
subgq.w  #1,LIB_OPENCNT(a6) 


j——-77- see if there is anyone left with us open 
bne.s Close_End 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 8 


jo «see if we have a delayed expunge pending 
btst #LIBB_DELEXP ,md_Flags (a6) 
Close_End 


do the expunge 
Expunge 


Close_End: 


“Tovem. 1 (sp)+,d1/a2-a3 
rts ;MUST return either zero or the SegList!!! 


; There are two different things that might be returned from the Expunge 
; routine. If the device is no longer open then Expunge should return the 
; segment list (as given to Init). Otherwise Expunge should set the 

; delayed expunge flag and return NULL. 


One other important note: because Expunge is called from the memory 
allocator, it may NEVER Wait() or otherwise take long time to complete. 


Expunge: °; ( device: a6 


) 
PUIMSG 10,<'%s/Expunge: called'> 


movem.1 4d1/d2/a5/a6,-(sp) ; Save ALL modified registers 
move. 1 a6,a5 
move.l1 md_SysLib(a5),a6 


j77-- «see if anyone has us open 
tst.w LIB_OPENCNT(a5) 
1!tt! The following line is commented out for this RAM disk demo, since 
we don't want the RAM to be freed after FORMAT, for example. 


1$ 


it is still open. set the delayed expunge flag 
#LIBB_DBLEXP ,md_Flags(a5) 

ao 

Expunge_End 


i 


i go ahead and get rid of us. Store our seglist in d2 
move.] md_SegList(a5),d2 


unlink from device list 
a5,al 
CALLSYS Remove ;Remove first (before FreeMem) 


i 


; device specific closings here... 


1 
LIB_NEGSIZE(a5) ,d1 
dl,al ;Calculate base of functions 
LIB_POSSIZE(a5) ,d0 
a1,do ;Calculate size of functions + data area 


CALLSYS FreeMem 


joc-7- «set up our return value 
move.1 d2,d0 


" (sp)+,dl/d2/a5/a6 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 9 Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 10 


Null: NEWLIST a0 ;“- IMPORTANT! Lists MUST! have NEWLIST 
PUIMSG 1,<'%s/Null: called'> ;work magic on them before use. (AddPort() 
CLEAR dO jean do this for you) 
rts 7The Null function MUST return NULL. 

IFD INTRRUPT 

move.1 a3,mdu_is+IS_DATA(a3) ; Pass unit addr to interrupt server 

ENDC 


; 
iTwo "do nothing" device-specific functions 


ai,dQ —; Add 


FunctionB: 


add.l d0,da0 ;Double 
rts 


InitUnit: 7; ( d2:unit number, a3:scratch, a6:devptr ) 


PUTMSG 30,<'%s/InitUnit: called'> 
movem.1 d2-d4/a2,—(sp) 


y----—- allocate unit memory 
move.l1 #MyDevUnit_Sizeof,d0 
move.1  #MEMF PUBLIC!MEMF CLEAR,d1 
LINKSYS AllocMem,md_SysLib(a6) 
tst.1 dao 

beq InitUnit_End 

move.1 d0,a3 


moveq.] #0,da0 ; Don't need to re-zero it 

move.1 a3,a2 ; InitStruct is initializing the UNIT 
lea.1 mdu_Init(pc),Al 

LINKSYS InitStruct,md_SysLib(a6) 


7!! IMPORTANT !} 
move. 1 #42414400 ,mdu_RAM(a3) ;Mark offset zero as ASCII "BAD " 
;!! IMPORTANT !! 


jinitialize unit number 


move.b d2,mdu_UnitNum(a3) 
j;initialize device pointer 


move.l1 a6,mdu_Device(a3) 


Start up the unit task. We do a trick here — 
we set his message port to PA_IGNORE until the 
new task has a change to set it up. 
j-—--—- We cannot go to sleep here: it would be very nasty 
j——-~-~ if someone else tried to open the unit 
(exec's OpenDevice has done a Forbid() for us — 
we depend on this to become single threaded). 


Initialize the stack information 
mdu_stack(a3),a0 ; Low end of stack 
a0,mdu_tcbt+TC_SPLOWER(a3) 
MYPROCSTACKSIZE(a0) ,a0 ; High end of stack 
a0,mdu_tcb+TC_SPUPPER(a3) 
a3,-(A0) ; argument -- unit ptr (send on stack) 
a0,mdu_tcb+TC_SPREG(a3) 
mdu_tcb(a3),a0 

move. a0,MP_SIGTASK(a3) 


IFGE INFO_LEVEL-30 
move.1 a0,~(SP) 
move.1 a3,-(SP) 
PUTMSG 30,<'%s/InitUnit, unit= tlx, task=%1x'> 
addq.1 #8,sp 


initialize the unit's message port's list 
MP_MSGLIST(a3),a0 


Startup the task 

lea mdu_tcb(a3),al 

lea Task_Begin(PC) ,a2 
move.1 a3,~-(Sp) ; Preserve UNIT pointer 
lea -1,a3 ; generate address error 

; if task ever "returns" (we RemTask() it 

; to get rid of it...) 
CLEAR ao 

PUIMSG 30,<'%s/About to add task'> 

LINKSYS AddTask,md_SysLib(a6) 
move.1 (sp)+,a3 ; restore UNIT pointer 


mark us as ready to go 
a2,da0 7; unit number 
#2,da0 
a3,md_Units(a6,d0.1) ; set unit table 
PUTMSG 30,<'Ss/InitUnit: ok!'> 


InitUnit_End: 


movem. 1 (sp)+,d2-d4/a2 


; ( a3:unitptr, a6:deviceptr ) 
a3,al . 
#MyDevUnit_Sizeof ,d0 

LINKSYS FreeMem,md_SysLib(a6) 

rts 


ExpungeUnit: 7; ( a3:unitptr, a6é:deviceptr ) 


PUIMSG 10,<'%s/ExpungeUnit: called'> 
move.1 d2,-(sp) 


; If you can expunge you unit, and each unit has it's own interrupts, 
; you must remember to remove its interrupt server 


IFD INTRRUPT 

lea.l  mdu_is(a3),al ; Point to interrupt structure 
moveg #INTB_PORTS , dO ; Portia interrupt bit 3 

LINKSYS RemIntServer,md_SysLib(a6) ;Now remove the interrupt server 
ENDC 


jv777- «get rid of the unit's task. We know this is safe 
j7——--~ ~because the unit has an open count of zero, so it 
is 'guaranteed' not in use. 
mdu_tcb(a3),al 
LINKSYS RemTask,md_SysLib(a6) 


j777- «~save the unit number 
CLEAR d2 
move.b mdu_UnitNum(a3) ,d2 


free the unit structure. 
FreeUnit 


j77tt «clear out the unit vector in the device 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 11 Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 12 




















isl.1 #2 ,da2 ; Read, Write, Format 
clr.1 md_Units(a6,d2.1) NEVERIMMED EQU  $0000080C 
ENDC 
move.1 (sp)+,d2 
rts 
; BeginIO starts all incoming io. The IO is either queued up for the 
; unit task or processed immediately. 
; here begins the device specific functions ; BeginIo often is given the responsibility of making devices single 
; ; threaded... so two tasks sending commands at the same time don't cause 
POT er —— a ja problem. Once this has been done, the command is dispatched via 
; emdtable is used to look up the address of a routine e that will ; Performio. 
; implement the device command. 
; ; There are many ways to do the threading. This example uses the 
; NOTE: the "extended" commands (ETD_READ/ETD_WRITE) have bit 15 set! ; UNITB_ACTIVE bit. Be sure this is good enough for your device before 
; We deliberately refuse to operate on such commands. However a driver ; using! Any method is ok. If immediate access can not be obtained, the 
; that supports removable media may want to implement this. One ; request is queued for later processing. 
; open issue is the handling of the "seclabel" area. It is probably ; 
; best to reject any command with a non-null "seclabel" pointer. ; Some IO. requests do not need single threading, these can be performed 
i ; immediatley. 
cmdtable: ; 
oe.bL Invalid 7$00000001 ;0 CMD_INVALID ; IMPORTANT: 
DC.L MyReset 7$00000002 ;1 CMD_RESET ; The exec WaitIO() function uses the IORequest node type (LN_TYPE) 
bo.L RdWrt 7$00000004 ;2 CMD_READ (\/common ) ; as a flag. If set to NT_MESSAGE, it assumes the request. is 
DC.L  RdaWrt 7800000008 ;3 CMD WRITE (/\common)  ETD_ ; still pending and will wait. If set to NT_REPLYMSG, it assumes the 
pc.L Update 3$00000010 ;4 CMD_UPDATE (NO-OP ) ETD_ ; request is finished. It's the responsibility of the device driver 
pe.L Clear 7$00000020 ;5 CMD_CLEAR (NO-OP ) ETD_ ; to set the node type to NT_MESSAGE before returning to the user. 
DC.L MyStop ;$00000040 ;6 CMD STOP ETD_ ; 
pe.L = Start 3800000080 ;7 CMD_START j : ; ( iob: al, device:a6 ) 
pc.L Flush 7$00000100 ;8 CMD_FLUSH 
De.L Motor 3$00000200 ;9 TD_MOTOR (NO-OP ) ETD_ IFGE INFO_LEVEL-1 
pe.L Seek 3$00000400 ;A TD_SEEK (NO-OP) ETD_ behg.b #1,$bfe001 ;Blink the power LED 
De.L RdwWrt 7$00000800 ;B TD_FORMAT (Same as write) ENDC 
be.L MyRemove ;$00001000 ;C TD_REMOVE (NO-OP) IFGE INFO_LEVEL-3 
DC.L ChangeNum 7$00002000 ;D TD_CHANGENUM (returns 0) elr.1 —(sp) 
pe. = ChangeState ;$00004000 ;E TD _CHANGESTATE (returns 0) move.w IO COMMAND(al),2(sp) ;Get entire word 
pe.L ProtStatus 7$00008000 ;F TD_PROTSTATUS (returns 0) PUTMSG 3,<'%s/BeginIO -- %ld'> 
De.L RawRead ;$00010000 ;10 TD _RAWREAD (INVALID) : #4,sp 
DC.L RawWrite ;$00020000 ;11 TD_RAWWRITE (INVALID) 
DC.L GetDriveType ;$00040000 ;12 TD_GETDRIVETYPE (Returns 1) 
pC.L  GetNumTracks ;$00080000 ;13 TD_GETNUMTRACKS (Returns NUMTRKS) movem.l1 dl/a0/a3,-(sp) 
pe.L Ada@ChangeInt ;$00100000 ;14 TD _ADDCHANGEINT {NO-OP) 
DC.L RemChangeInt ;$00200000 ;15 TD_REMCHANGEINT (NO-OP) move.b #NT_MESSAGE,LN_TYPE(al) ;So WaitIO() is guaranteed to work 
ondtable. end: move.1 IO_UNIT(al),a3 jbookkeeping —> what unit to play with 
move.w IO _COMMAND(al),d0 
; this define is used to tell which commands should be handled 
; immediately (on the caller's schedule). 7Do a range check & make sure ETD_XXX type requests are rejected 
7 cmp.w #MYDEV_END,d0O ;Compare all 16 bits 
; The immediate commands are Invalid, Reset, Stop, Start, Flush bee BeginIO_NoCmd jyno, reject it. (bec=bhs — unsigned) 
; Note that this method limits you to just 32 device specific commands, jcc «process all immediate commands no matter what 
; which may not be enough. move.1 #IMMEDIATES,d1 
;IMMEDIATES EQU %00000000000000000000000111000011 DESABLE ad <-> Ick, nasty stuff, but needed here. 
ai ae LSE ES ES nl tst.1 dd,dl 
a FEDCBA987654 321 0FEDCBA9876543210 bne BeginIO_Immediate 
;;An alternate version. All commands that are trivially short INTRRUPT ; if using interrupts, 
;;and %100 reentrant are included. This way you won't get the queue all NEVERIMMED commands no matter what 
j;;task switch overhead for these commands. move. w  #NEVERIMMED,d1 
ii btst ao,dl 
IMMEDIATES: EQU %11111111111111211111011111110011 bne.s BeginIO_QueueMsg 
; wooo sess ——-~— Soe ENDC 
i FEDCBA987 654321 0FEDCBA9876543210 
IFD INTRRUPT ; if using interrupts, -----— see if the unit is STOPPED. If so, queue the msg. 
; These commands can NEVER be done "immediately" if using interrupts, btst #MDUB_STOPPED, UNIT_FLAGS (a3) 





; since they would "wait" for the interrupt forever! bne BeginIO QueueMsg 











Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 13 


wo This is not an immediate command. See if the device is 
i777 busy. If the device is not, do the command on the 
j77~~-— user schedule. Else fire up the task. 

j—-—-- This type of arbitration is not really needed for a ram 
i777 disk, but is essential for a device to reliably work 
j;7--—— with shared hardware 

ean When the lines below are ";" commented out, the task gets 
ij77——— a better workout. When the lines are active, the calling 
jo77--~ process is usually used for the operation. 


pods REMEMBER:::: Never Wait() on the user's schedule in BeginIO()! 
;ccc The only exception is when the user has indicated it is ok 
i777 by setting the "quick" bit. Since this device copies from 
;77~——— ram that never needs to be waited for, this subtlely may not 
jocc--= be clear. 

bset #UNITB_ACTIVE,UNIT FLAGS (a3) ;<--—— comment out these 

beq.s  BeginIO_ Immediate <---> lines to test task. 
ccc we need to queue the device. mark us as needing 


jcc task attention. Clear the quick flag 
BeginIo | QueueMsg: 
bset #UNITB_INTASK, UNIT_FLAGS (a3) 
belr #1IOB_QUICK,1O_FLAGS(al) ;We did NOT complete this quickly 
ENABLE a0 


IFGE INFO_LEVEL-250 

move.1 al,—(sp) 

move.1. a3,-(sp) 

PUTMSG 250,<'%s/PutMsg: Port=%lx Message=31x'> 
addq.1 #8,sp 
ENDC 


move.l a3,a0 

LINKSYS PutMsg,md_SysLib(a6) ;Port=a0, Message=al 
bra.s  BeginIO_End 

;-———— return to caller before completing 


cc Do it on the schedule of the calling process 
BeginIO_ Immediate: 

ENABLE a0 

bsr.s  PerformIo 


BeginI0o | End: 
PUTMSG 200,<'%s/BeginIO_End'> 
movem. 1 (sp)+, dl/a0/a3 
rts 


BeginIO_NocCmd: 
move.b #IOERR_NOCMD, IO_ERROR(al) 
bra.s  BeginIO_End 


; PerformIO actually dispatches an io request. It might be called from 
the task, or directly from BeginIO (thus on the callers's schedule) 


It expects a3 to already 

have the unit pointer in it. a6 has the device pointer (as always). 
al has the io request. Bounds checking has already been done on 
the I/O Request. 


Nee Me Se See See 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 14 


Performl0o: ; ( iob:al, unitptr:a3, devptr:a6 ) 
IFGE INFO_LEVEL-150 
elr.1 —(sp) 
Move.w IO _COMMAND( al.) 2(sp) ;Get entire word 
PUTMSG 150,<'%s/PerformIO ~~ ald! > 
addg.1 #4,sp 
ENDC 


moveg #0,d0 

move.b d0,IO_ERROR(A1) ; No error so far 

move.b IO_COMMAND+]1(al),d0 ;Look only at low byte 

lsl.w  #2,d0 ; Multiply. by 4 to get table offset 
lea.1 cmdtable(pc),a0 

move.1 0(a0,d0.w),a0 


jmp (a0) jlob:al unit:a3 devprt:a6 


; TermIO sends the IO request back to the user. It knows not to mark 
; the device as inactive if this was an immediate request or if the 
; request was started from the server task. 


; ( iob:al, unitptr:a3, devptr:a6 ) 
160,<'%s/TermlIo ' > 
IO_COMMAND(al) ,d0 


#IMMEDIATES , dl. 
do,dl 
TermIO_ Immediate 710 was immediate, don't do task stuff... 


—--——— we may need to turn the active bit off. 
btst #UNITB_INTASK,UNIT_FLAGS(a3) 


TermIO_Immediate 710 was came from task, don't clear ACTIVE... 


the task does not have more work to do 
#UNITB_ACTIVE, UNIT_FLAGS (a3) 


TermIO_Immediate: 
if the quick bit is still set then we don't need to reply 
i msg ~~ just return to the user. 
btst #1IOB_QUICK,1O_FLAGS (al) 
bne.s  TermIO_End 
LINKSYS ReplyMsg,md_SysLib(a6) ;al-message 
;(ReplyMsg sets the LN_TYPE to NT_REPLYMSG) 


TermIO_End: 
rts 


; Here begins the functions that implement the device commands 
; all functions are called with: 

al —- a pointer to the io request block 

a3 ~~ a pointer to the unit 

a6 —- a pointer to the device 


; Commands that conflict with 68000 instructions have a "My" prepended 


;We can’t AbortIO anything, so don't touch the JORequest! 
AbortIo: ; ( lob: al, device:a6 ) 

moveq #IOERR_NOCMD,d0O 

rts 








Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 15 Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 16 











RawRead: ; 10 Not supported (INVALID) ; [D0=offset] 
RawWrite: ; 11 Not supported (INVALID) 
Invalid: move.1 IO_OFFSET(a2),d0 
move.b #IOERR_NOCMD, TO_BRROR(al) move.1 d0,dl 
bra.s TermIO and.1 #SECTOR-1,d1 ;Bad sector boundary or alignment? 
bne.s Io_LenErr jbad... 
; ; [D0O=of fset J 
; Update and Clear are internal buffering commands. Update forces all / 
; io out to its final resting spot, and does not return until this is * check for IO within disc range 
; totally done. Since this is automatic in a ramdisk, we simply return "Ok". ; [D0=of fset] 
i add.1 IO_LENGTH(a2) ,d0 ;Add length to offset 
; Clear invalidates all internal buffers. Since this device bes.s IO_LenErr ;overflow... (important test) 
; has no internal buffers, these commands do not apply. cmp.1 #RAMSIZE ,d0 ;Last byte is highest acceptable total 
i / bhi.s JO_LenErr ;bad... (unsigned compare) 
Update: and.1 #SECTOR-1 , dO ;Even sector boundary? 
Clear: bne.s IO_LenErr jbad... 
MyReset: ;Do nothing (nothing reasonable to do) 
AddChangelInt : ;Do nothing : * We've gotten this far, it must be a valid request. 
RemChangelInt: ;Do nothing 
MyRemove: ;Do nothing IFD  INTRRUPT 
Seek: ;Do nothing move.1  mdu_SigMask(a3),d0 ; Get signals to wait for 
Motor: ;Do nothing LINKSYS Wait,md_SysLib(a6) ; Wait for interrupt before proceeding 
ChangeNum: ;Zero ok ENDC 
ChangeState: ;Zero indicates disk inserted 
ProtStatus: ;Zero indicates unprotected 
eclr.1l  IO_ACTUAL(al) lea.1  mdu_RAM(a3),a0 ; Point to RAMDISK "sector" for I/O 
bra.s TermIO add.1 IO_OFFSET (a2) ,a0 ; Add offset to ram base 
move.1 IO_LENGTH(a2),d0 
move.] d0,IO_ACTUAL(a2) ; Indicate we've moved all bytes 
GetDriveType: jmake it look like 3.5" (90mm) drive beq.s  RdWrt_end j—-—-deal with zero length 1/0 
moveq  #DRIVE3_5,d0 move.l JIO_DATA(a2),al ; Point to data buffer 
move.1 d0,IO_ACTUAL(al) i 
bra.s  TermIoO ;AO=ramdisk index 
;Al=user buffer 
;D0=Length 
GetNumTfracks: i 
move.] #RAMSIZE/BYTESPERTRACK,IO_ACTUAL(al) ;Number of tracks emp.b #CMD_READ,IO_COMMAND+1(a2) ; Decide on direction 
bra.s  TexmIO BEQ.S CopyTheBlock 
EXG AO, AL ; For Write and Format, swap source & dest 
i CopyTheBlock : 
; Foo and Bar are two device specific commands that are provided just LINKSYS CopyMemQuick ,md_SysLib(a6) ;AQ=source Al=dest D0=size 
; to show you how to add your own commands. They currently return that ;CopyMemQuick is very fast 
; no work was done. 
RdWrt_end: 
Foo: move.] a2,al 
Bar: movem.1 (sp)+,a2/a3 
elr.i I0_ACTUAL(al) bra TexmiIo ;END 
bra.s TermIo Io_LenErr: 
move.b #IOERR_BADLENGTH , IO_ERROR(a2) 
IO_End: 
; a elr.1 1O0_ACTUAL (a2) Initially, no data moved 
; This device is designed so that no combination of bad bra.s  RdWrt_end 
; inputs can ever cause the device driver to crash. 
c 
RdwWrt : 


IFGE INFO_LEVEL—200 ; the Stop command stop all future io requests from being 


move.] IO_LENGTH(al),—(sp) ; processed. until a Start command is received. The Stop 
PUIMSG 200,<'%s/RdWrt len %1d'> ; command is NOT stackable: e.g. no matter how many stops 
addg.1 #4,sp . ; have been issued, it only takes one Start to restart 
; processing. 

movem.] a2/a3,~(sp) ;Stop is rather silly for a ramdisk 

move.1 al,a2 ;Copy iob MyStop: 

move.1 IO_UNIT(a2),a3 ;Get unit pointer PUTMSG 30,<'%s/MyStop: called'> 

bset #MDUB_STOPPED,UNIT_FLAGS(a3) 
* check operation for legality bra  TermIo 


btst.b #0,IO_DATA(a2) ;check if user's pointer is ODD 
bne.s  I0_LenErr jbad... 





ot - 5d 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 17 


Start: 
PUTMSG 30,<'%s/Start: called'> 
bsr “InternalStart 
bra TermIO 


InternalStart: 
move.1 al,-—(sp) 
i777-— turn processing back on 
belr  #MDUB_STOPPED, UNIT _FLAGS(a3) 


777 kick the task to start it moving 
move.b MP_SIGBIT(a3),dl 

CLEAR dao 

bset di,do 

LINKSYS Signal,md_SysLib(a3) 

move.l (sp)t+,al 

rts 


; Flush pulls all I/O requests off the queue and sends them back. 
; We must be careful not to destroy work in progress, and also 
; that we do not let some io requests slip by. 


; Some funny magic goes on with the STOPPED bit in here. Stop is 
; defined as not being reentrant. We therefore save the old state 
; of the bit and then restore it later. This keeps us from 

; needing to DISABLE in flush. It also fails miserably if someone 


; does a start in the middle of a flush. (A semaphore might help...) 


30,<'ts/Flush: called'> 
d2/al/aé,—(sp) 


md_SysLib(a6),a6 


bset #MDUB_STOPPED, UNIT_FLAGS (a3) 
a2 


CALLSYS  GetMsg ;Steal messages from task's port 


tst.1 dao 
beq.s Flush _End 


move.1 d0,al 
move.b  #IOERR_ABORTED, IO_ERROR(al) 
CALLSYS ReplyMsg 
bra.s  Flush_Loop 
Flush _ End: 
move.1 d2,do 
movem, 1 (sp)+,d2/al/a6 


tst.b dod 
beq.s 1s 


bsr InternalStart 


bra TermIoO 


; Here begins the task related routines 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 18 


; A Task is provided so that queued requests may be processed at 
; a later time. This is not very justifiable for a ram disk, but 
; is very useful for "real" hardware devices. Take care with 

; your arbitration of shared hardware with all the multitasking 

; programs that might call you at once. 


; Register Usage 


; a3 —- unit pointer 

; a6 —— syslib pointer 

; a5 —- device pointer 

; a4 -- task (NOT process) pointer 
; a7 —— wait mask 


; some dos magic, useful for Processes (not us). A process is started at 

; the first executable address after a segment list. We hand craft a 

; segment list here. See the the DOS technical reference if you really 

; need to know more about this. 

; The next instruction after the segment list is the first executable address 


cnop 0,4 ; long word align 
pe. 16 ; segment length -~ any number will do (this is 4 
; bytes back from the segment pointer) 


myproc_seglist: 
pe.L 0 


; pointer to next segment 


Task_Begin: 
PUIMSG 35,<'%s/Task_Begin'> 
move.1 ABSEXECBASE , a6 


j7777 «Grab the argument passed down from our parent 
move.l1 4(sp),a3 ; Unit pointer 
move.1 mdu_Device(a3),a5 ; Point to device structure 


IFD INTRRUPT 

jo Allocate a signal for "I/O Complete" interrupts 
moveq  #-1,d0 ; -1 is any signal at all 
CALLSYS AllocSignal 

move .b d0 ,mdu_SigBit(A3) ; Save in unit structure 
moveq  #0,d7 ; Convert bit number signal mask 
bset d0,da7 

move.l  d7,mdu_SigMask(A3) ; Save in unit structure 
lea.1  mdu_is(a3),al ; Point to interrupt structure 
movegqg #INTB_PORTS,d0 ; Portia interrupt bit 3 
CALLSYS AddIntServer ' ; Now install the server 
move.l1 md_Base(a5),a0 ; Get board base address 
bset..b #INTENABLE , INTCTRL2 (a0) ; Enable interrupts 


Allocate a signal 
#-1,d0 ; ~l is any signal at all 
CALLSYS AllocSignal 
move.b d0,MP_SIGBIT(a3) 
move.b #PA_SIGNAL,MP_FLAGS(a3) ;Make message port "live" 
change the bit number into a mask, and save in d7 
#0,07 ;Clear D7 
bset a0,d7 


IFGE INFO_LEVEL—40 

move.1l $114(a6),-(sp) 

move.l1 a5,-(sp) 

move.l a3,-(sp) 

move.1 d0,-(sp) 

PUTMSG 40,<'%s/Signal=%ld, Unit=%lx Device=%lx Task=%1x'> 
add. #4*4,sp 

ENDC 





TT - 9 





Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 19 


bra.s  Task_StartHere 


OK, kids, we are done with initialization. We now can start the main loop 
of the driver. It goes like this. Because we had the port marked 
PA_IGNORE for a while (in InitUnit) we jump to the getmsg code on entry. 
(The first message will probably be posted BEFORE our task gets a chance 
to run) 

To wait for a message 

—T lock the device 

nal get a message. If no message, unlock device and loop 

——— dispatch the message 


sao loop back to get a message 


—_—~~ no more messages. back ourselves out. 


Task ‘unlock: 


and.b #$ff6(" (UNITE _ ACTIVE! UNITF_INTASK) ) , UNIT_FLAGS (a3) 
j;-7———- main loop: wait for a new message 


Task_MainLoop: 


PUTMSG 75,<'%s/4+4+Sleep'> 
move.1 d7,d0 
CALLSYS Wait 
IFGE INFO_LEVEL—5 
bchg.b #1,$bfe001 ;Blink the power LED 


Task_StartHere: 


PUTMSG 75,<'%s/++Wakeup'> 


TT see if we are stopped 
btst #MDUB_STOPPED, UNIT_FLAGS(a3) 
bne. s Task_MainLoop ; device is stopped, ignore messages 


~---—- lock the device 
bset #UNITB_ACTIVE, UNIT_FLAGS(a3) 
bne Task_MainLoop ; device in use (immediate command?) 


———--~ get the next request 


Task . NextMessage: 


7 


move.1 a3,a0 

CALLSYS GetMsg 

PUIMSG 1,<'%s/GotMsg'> 

tst.1 dd 

beq Task_Unlock ; no message? 


—--—- do this request 
move. 1 d0,al 


exg a5,a6 ; put device ptr in right place 
bsr PerformIO 
exg a5,a6 7; get syslib back in a6 


bra.s Task_NextMessage 


Here is a dummy interrupt handler, with some crucial components commented 
out. If the IFD INTRRUPT is enabled, this code will cause the device to 
wait for a level two interrupt before it will process each request 
(pressing a key on the keyboard will do it). This code is normally 
disabled, and must fake or omit certain operations since there isn't 
really any hardware for this driver. Similar code has been used 
successfully in other, "REAL" device drivers. 


IFD INTRRUPT 
Al should be pointing to the unit structure upon entry! 


myintr: move.l1 mdu_Device(al),a0 ; Get device pointer 

move.1 md_Base(a0) ,a0 ; point to board base address 
* btst.b #TAMPULLING , INTCTRL1(a0);See if I'm interrupting 
* beq.s myexnm ; if not set, exit, not mine 


* 


move .b #0, INTACK(a0) ; toggle controller's int2 bit 


Jan 12 13:48 1989 SampleDevice/ramdev.device.asm Page 20 


signal the task that an interrupt has occurred 


move.1 mdu_SigMask(al),d0 

lea mdu_tcb(al),al 

move.l md_SysLib(a0),a6 ; Get pointer to system 
CALLSYS Signal 


now clear the zero condition code so that 
the interrupt handler doesn't call the next 
interrupt server. 


moveg #1,d0 clear zero flag 
bra.s myexit now exit 


this exit point sets the zero condition code 
so the interrupt handler will try the next server 
in the interrupt chain 


moveg #0,d0 set zero condition code 


Initialize the device 


INITBYTE MP_FLAGS,PA_IGNORE ;Unit starts with a message port 
INITBYTE LN_TYPE,NP_MSGPORT ; 
INITLONG LN | NAME jmyName i 
INITLONG mdu_tcb+LN_NAME pmyName 
INITBYTE mdu_ teb+LN_! TYPE , NT_TASK 
INITBYTE mdu_’ tebtLN 1] PRI, 5 
IFD INTRRUPT 
INITBYTE mdu_ist+tLN_PRI,4 ; Int priority 4 
INITLONG mdu_ist+tIS_ CODE,myintr ; Interrupt routine addr 
INITLONG mdu_is+LN_NAME ,myName 
ENDC 
Dpe.L 0 


IFNE AUTOMOUNT 


Initialize packet for MakeDosNode 


INITLONG mdn_execName ,myName ; Address of driver name 
INITLONG mdn_tableSize,11 ; # long words in AmigaDOS env. 
INITLONG mdn_dName ,$524d0000 ; Store 'RM' in name 
INITLONG mdn_sizeBlock,SECTOR/4 ; # longwords in a block 
INITLONG mdn_numHeads,1 ; RAM disk has only one "head" 
INITLONG mdn_secsPerBlk,1 7; secs/logical block, must = "1" 
INITLONG mdn_blkTrack,SECTORSPER ; secs/track (must be reasonable) 
INITLONG mdn_resBlks,1 ; reserved blocks, MUST > 0! 
INITLONG mdn_upperCyl, (RAMSIZE/BYTESPERTRACK)-1 ; upper cylinder 
INITLONG mdn_numBuffers,1 ; # AmigabOS buffers to start 
bo.b 0 

ENDC 





; EndCode is a marker that shows the end of your code. Make sure it does not 
; span hunks, and is not before the rom tag! It is ok to put it right after 
; the rom tag -- that way you are always safe. I put it here because it 

; happens to be the "right" thing to do, and I know that it is safe in this 

; case (this program has only a single code hunk). 





et - 








Dec 9 04:21 1988 SampleDevice/ramdev.i Page 1 


KKK KKK KKK KKK KK EEK KKK EK KK RK KK EK KKK KKK KKK KKK ERIK KKK KKK RK KEKE KKKK 
* 
* 


* Copyright (C) 1986, Commodore Amiga Inc. All rights reserved. 


* Permission granted for non-commercial use 
* 


KEKE KEK IKK KER KEE KKK KEKE EERE KKK KEK KEK KER EKER KEKE KEKE KAEKKEKKEKEK 
* 

* ramdev.i -~ external declarations for skeleton ramdisk device 

* 

HREKEKK RE KEREKKRHEEK EK KRK EERE KKK KK KEKE EKER EKKEKR ERK EKEREEKKKK 


j777 Assemble-time options 
INFO_LEVEL EQU 0 ; Specify amount of debugging info desired 
; If > 0 you must link with debug.lib! 
; You will need to run a terminal program to 
7; set the baud rate. 
*INTRRUPT SET 1 ; 
AUTOMOUNT EOQU 0 i 


; Remove "*" to enable fake interrupt code 
Work with the "mount" command if 0 
Do it automatically if 1 


j77> stack size and priority for the process we will create 
MYPROCSTACKSIZE EQU $900 
MYPROCPRI EQU (0 ;Devices are often 5, NOT higher 

777— Base constants 

NUMBEROFTRACKS EQU 40 ;<<<< Change THIS to change size of ramdisk <<<< 


SECTOR EQU .512 ;# bytes per sector 

SECSHIFT EQU 9 ;Shift count to convert byte # to sector # 
SECTORSPER EoU 10 ;# Sectors per "track" 

RAMSIZE EQU SECTOR* NUMBEROFTRACKS* SECTORSPER 


; Use this much RAM per unit 
BYTESPERTRACK EQU SECTORSPER* SECTOR 
TAMPULLING EQU 7 ; "I am pulling the interrupt" bit of INTCRL1 
INTENABLE EQU 4 ; “Interrupt Enable" bit of INTCRL2 
INTCTRL1 EQU $40 ; Interrupt control register offset on board 
INTCTRL2 EQU $42 ; Interrupt control register offset on board 
INTACK EQU $50 ; My board's interrupt reset address 





BITDEF TD,EXTCOM,15 ; for “extended” commands !!! 
DEVINIT 
DEVCMD CMD MOTOR 7; control the disk's motor (NO-OP) 
DEVCMD CMD SEEK 7; explicit seek (NO-OP) 
DEVCMD CMD FORMAT ; format disk ~ equated to WRITE for RAMDISK 
DEVCMD CMD REMOVE ; notify when disk changes (NO-OP) 
DEVCMD CMD _CHANGENUM ; number of disk changes (always 0) 
DEVCMD CMD _CHANGESTATE ; is there a disk in the drive? (always TRUE) 
DEVCMD CMD _PROTSTATUS ; is the disk write protected? (always FALSE) 
DEVCMD CMD_RAWREAD ; Not supported 
DEVCMD CMD_RAWWRITE 7; Not supported 
DEVCMD CMD_GETDRIVETYPE ; Get drive type 
DEVCMD CMD_GETNUMTRACKS ; Get number of tracks 
DEVCMD CMD_ADDCHANGEINT ; Add disk change interrupt (NO-OP) 
DEVCMD CMD_REMCHANGEINT ; Remove disk change interrupt ( NO-OP) 
DEVCMD MYDEV_END ; place marker -~ first illegal command # 
DRIVE3_5 EQU 1 
DRIVES 25 FQU 2 





; Layout of parameter packet for MakeDosNode 





9 04:21 1988 SampleDevice/ramdev.i Page 2 


STRUCTURE MKDosNodePkt , 0 


APTR mdn_dosName ; Pointer to DOS file handler name 
APTR mdn_execName ; Pointer to device driver name 
ULONG mdn_unit ; Unit number 

ULONG mdn_flags ; OpenDevice flags 


ULONG mdn_tableSize ; Environment size 
ULONG mdn_sizeBlock ; # longwords in a block 


ULONG mdn_secOrg ; sector origin —- unused 

ULONG mdn_numHeads ; humber of surfaces 

ULONG mdn_secsPerBlk ; secs per logical block —- unused 
ULONG = mdn_blkTrack 7 secs per track 

ULONG mdn_resBlks ; reserved blocks —- MUST be at least 1! 
ULONG mdn_prefac ; unused 


ULONG mdn_ interleave ; interleave 
ULONG = mdn_lowCyl ; lower cylinder 
ULONG mdn_upperCyl ; upper cylinder 


ULONG mdn_numBuffers ; number of buffers 

ULONG = mdn_memBufType ; Type of memory for AmigaDOS buffers 
STRUCT mdn_dName,5 ; DOS file handler name "“RAMO" 

LABEL mdn_Sizeof ; Size of this structure 


; maximum number of units in this device 
MD_NUMUNITS EQU . 


STRUCTURE MyDev,LIB_SIZE 

UBYTE md_Flags 

UBYTE md_Padl 

j;now longword aligned 

ULONG md_SysLib 

ULONG = md_SegList 

ULONG md_Base ; Base address of this device's expansion board 
STRUCT md_Units,MD_NUMUNITS*4 

LABEL MyDev_Sizeof 


STRUCTURE MyDevUnit,UNIT_SIZE 
UBYTE mdu_UnitNum 
UBYTE mndu_SigBit 
i;Now longword aligned! 
APTR mdu_Device 
STRUCT mdu_stack ,MYPROCSTACKSIZE 

STRUCT mdu_tcb,TC_SIZE ; Task Control Block (TCB) for disk task 
ULONG mdu_SigMask Signal these bits on interrupt 

IFD INTRRUPT 


;Odd # longwords 


; Signal bit allocated for interrupts 


STRUCT mdu_is,IS_SIZE ; Interrupt structure 
UWORD mdu_padl ;Longword align 

ENDC 

STRUCT  mdu_RAM,RAMSIZE ; RAM used to simulate disk 


LABEL MyDevUnit_Sizeof 


j777-—- «state bit for unit stopped 
BITDEF MDU , STOPPED, 2 


MYDEVNAME MACRO 
be.B 'ramdev.device',0 
ENDM 




















€T - 9 














Oct 7 20:31 1988 SampleLibrary/include/samplebase.h Page 1 


/* 


samplebase.h ~~ C include file defining sample.library base 


4 tt 4 ot 


Copyright (C) 1985, 1988 Commodore Amiga Inc. All rights reserved. 
*/ 


#ifndef SAMPLE _BASE_H 
#define SAMPLE_BASE_H 


#ifndef EXEC_TYPES_H 
#include <exec/types.h> 
#tendif EXEC_TYPES_H 


#ifndef EXEC _LISTS_H 
#include <exec/lists.h> 
#endif | EXEC_LISTS_H 


#ifndef EXEC_LIBRARIES H 
#include <exec/libraries.h> 
tendif | EXEC_LIBRARIES_H 


/* library data structures 
* 


* Note that the library base begins with a library node 


*/ 


struct SampleBase [{ 
struct Library LibNode; 
UBYTE Flags; 
UBYTE pad; 
/* We are now longword aligned */ 
ULONG SysLib; 
ULONG DosLib; 
ULONG SegList; 
i 


#define SAMPLENAME "sample. library" 


tendif EXEC_SAMPLEBASE_H 





Oct. 7 20:31 1988 SampleLibrary/include/samplebase.i Page 1 


FRI III TR IO IORI IK IOI III IR TIKIT RIK KIRK IR ITI IRR IRI TIKIT ITOK TIRE IKE EK 


x *x 
* samplebase.i ~~ definition of sample.library base * 
* * 
* Copyright (C) 1985, 1988 Commodore Amiga Inc. All rights reserved. * 
* * 
* * 


FIR III III SIT IR IOI IR FIO TAT TI TI I III KIRK AIHA RIKI KKK KKK EIR ERIE NRE RE K 


IFND SAMPLE_BASE_I 
SAMPLE_BASE_I SET 1 


IFND EXEC_TYPES_I 
INCLUDE "exec/types.i" 
ENDC ; EXEC_TYPES_I 


IFND EXEC_LISTS_I 
INCLUDE “exec/lists.i" 
ENDC ; EXEC_LISTS_I 


IFND EXEC_LIBRARIES_1 
INCLUDE "exec/libraries.i" 
ENDC ; EXEC_LIBRARIES_I 


; Note that the library base begins with a library node 


STRUCTURE SampleBase,LIB_S1IZE 
UBYTE sb_Flags 

UBYTE  sb_pad 

;We are now longword aligned 
ULONG sb SysLib 

| ULONG = sb_DosLib 

ULONG ~— sb_SegList 

LABEL SampleBase_SIZEOP 


SAMPLENAME MACRO 
DC.B ‘sample. library' ,0 
ENDM 


ENDC ;EXEC_SAMPLEBASE I 














tT - 9 


Oct 7 20:31 1988 SampleLibrary/lib/samplelib_lvos.asm Page 1 


HFK II IK KIKI IK KIKI I IK IK IK IK IR RIK IK KKK I IKI IKI RIK KIRK IKI KIKI IKI TKK IKE 
* samplelib stubs.asm 
* 


* Copyright 1988 Commodore-Amiga, Inc. 
_LVO definitions that match this .fd file: 


##base _SampleBase 
##bias 30 

##public 

Double(nl) (D0) 
AddThese(n1,n2)(D0,D1) 
##end 


After assembling, . 
JOIN samplelib_stubs.o samplelib_lvos.o AS sample.lib 


LINK with LIBRARY sample.lib when calling sample.library functions 


+ He OO 


FRI KKKKIIKIIHK IKKKIIKIKIKIIKKKRKKRIK IIR IRI RIK ETHIE IIIT KIA KIKI 


INCLUDE ‘exec/types.i" 
INCLUDE "exec/libraries.i" 


SECTION _LVO 


DATA 
x-——~~ LIBINIT initializes an LVO value to -30 to skip the first four 
x 6-byte required library vectors (Open, Expunge, etc) 

LIBINIT 
eo LIBDEF assigns the current LVO value to a label, and then 
*x—--—— bumps the LVO value by -6 in preparation for next LVO label 
*— This assigns the value —30 to our first _LVO label 

LIBDEF _LVODouble 7730 

XDEF “LVODouble 
*————— The value —30-6 is asigned to our second _LVO label 

LIBDEF _LVOAddThese 3736 

XDEF _LVOAddThese 

END 





Oct 7 20:31 1988 SampleLibrary/lib/samplelib stubs.asm Page 1 





FHKE KEK KKK KEI KEK KKK KKH KEKE KKK IKK EKER IKE KEI KKK AKER K KEKE KKK EERE KKK 


* samplelib stubs.asm 
* 


* Copyright 1988 Commodore-Amiga, Inc. 
* 

* Stubs that match this .fd file: 

* 

* ##base _SampleBase 

* #ébias 30 

* ##public 

* Double(nl) (D0) 

* AddThese(nl,n2)(D0,D1) 

* ##end 

x 

* After assembling, 

x JOIN samplelib stubs.o samplelib_lvos.o AS sample.lib 
*x 


* LINK with LIBRARY sample.lib when calling sample.library functions 
* 


RRR KKK KR IK RIK KKK IKK KKK KKK KK KKK KKK KK III KIA KK KKK KI KKK KIRK KKK KEK EEK EAE K 
INCLUDE '"exec/types.i"' 
INCLUDE "exec/libraries.i" 


SECTION CSTUB 


CODE 
*-—— Caller declares and initializes SampleBase in their C code 
XREF _ SampleBase 
Be Must externally reference the _LVO labels defined in samplelib_lvos 
XREF _LVODouble 
XREF _LVOAddThese 
*----—- Make C function stubs available to caller 
XDEF _ Double 
XDEF _AddThese 
*x------~ These stubs move C args from stack to appropriate registers, 
e+ call the library function, and return result in dQ 
Double 
MOVE.L A6,~(SP) ;Save register(s) 
MOVE.L 8(SP),DO ;Copy param to register 
MOVE.L _SampleBase , A6 ;Library base to A6 
JSR _LVODouble(A6) 7Go to real routine 
MOVE.L (SP)+,A6 j;Restore register(s) 
RTS 
__AddThese: 
MOVE.L A6,~(SP) ;Save register(s) 
MOVEM.L 8(SP) ,DO/D1 jCopy params to registers 
38(SP) goes into DO 
712(SP) goes into Dl 
MOVE .L _SampleBase , A6 ;Library base to A6 
JSR _LVOAGdThese ( A6) ;Go to real routine 
MOVE .L (SP)+,A6 ;Restore register(s) 
RTS 


END 








St - 











Oct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 1 


KKK KKK KEE KEKE KEK KEKE IKE KICKER EH KERIKERI KEKE EKER EERE 


x * 
* sample.library.asm ~~ Example run~time library source code * 
*x * 
* Copyright (C) 1985, 1988 Commodore Amiga Inc. All rights reserved. * 
* * 
* Assemble and link, without startup code, to create Sample.library, * 
* a LIBS: drawer run-time shared library * 
* * 
* Linkage Info: * 
* FROM sample. library.o * 
* LIBRARY LIB:Amiga.lib * 
* TO sample. library * 
* * 
KKK KKK KKK IK KIKI KE KIRKE KKK KEKE KEE KIRKE KEKE REE KEKE EK RKKEKKKRERKEEEKEK 

SECTION section 

NOLIST 


INCLUDE "“exec/types.i" 
INCLUDE "exec/libraries.i" 
INCLUDE "exec/lists.i" 
INCLUDE "“exec/alerts.i" 
INCLUDE “exec/initializers.i" 
INCLUDE “exec/resident.i" 
INCLUDE "libraries/dos.i" 


INCLUDE “asmsupp.i” 
INCLUDE "samplebase. i" 


LIST 
TTT These don't have to be external, but it helps some 


jo7cco- debuggers to have them globally visible 
XDEFP Init 


XDEP Open 
XDEF Close 
XDEF Expunge 
XDEF Null 
XDEF sampleName 
XDEF Double 
XDEF AddThese 
XREF _AbsExecBase 
XLIB  OpenLibrary 
XLIB  CloseLibrary 
XLIB Alert 
XLIB FreeMem 
XLIB Remove 
; The first executable location. This should return an error 
; in case someone tried to run you as a program (instead of 
; loading you as a library). 
Start: 
MOVEQ #-1,d0 
rts 


A romtag structure. Both "exec" and "“ramlib" look for 
this structure to discover magic constants about you 
(such as where to start running you from...). 


; Most people will not need a priority and should leave it at zero. 
; the RT_PRI field is used for configuring the roms. Use "mods" from 
j; wack to look at the other romtags in the system 





Oct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 2 


MYPRI EQU 0 


initDDescrip: 
; STRUCTURE RT,0 

DC.W RTC_MATCHWORD ; UWORD RT_MATCHWORD 
me.L initDDescrip ; APTR  RT_MATCHTAG 
o.L EndCode ; APTR  RT_ENDSKIP 
DO.B RTF_AUTOINIT ; UBYTE RT_FLAGS 
Ic.B VERSION ; UBYTE RT_VERSION 
DC.B NT_LIBRARY ; UBYTE RT_TYPE 
DC.B MYPRI ; BYTE RT_PRI 
be.L sampleName ; APTR RT_NAME 
me.L idString ; APTR RT_IDSTRING 
p.L Init ; APTR) RT_INIT 


; this is the name that the library will have 
sampleName: SAMPLENAMB 


j; a major version number. 
VERSION: EQU 34 


; A particular revision. This should uniquely identify the bits in the 
; library. I use a script that advances the revision number each time 
; I recompile. That way there is never a question of which library 
; that really is. 
REVISION: EQU 1 
; this is an identifier tag to help in supporting the library 
format is ‘name version.revision (dd MON yyyy)',<cr>,<lf>,<null> 
‘samplelib 1.3 (03 Oct 1988)',13,10,0 


i 
idstring: de.b 
dosName : DOSNAME 


; force word allignment 
ds.w 


The romtag specified that we were "RTF_AUTOINIT". This means 
that the RT_INIT structure member points to one of these 
tables below. If the AUTOINIT bit was not set then RT_INIT 

; would point to a routine to run. 


, 
Z 
7 
; 








Init: 
DC.L  SampleBase_SIZEOF ; size of library base data space 
DC.L funcTable ; pointer to function initializers 
pe.L dataTable ; pointer to data initializers 
DC.L . initRoutine ; routine to run 

funcTable: 
jo-~-> standard system routines 
dc.1 Open 
dc.1 Close 
de.1 Expunge 
dec.1 Null 


jot my libraries definitions 
de.1 Double 
de. AddThese 


joc-+-- function table end marker 
de. -l 


The data table initializes static data structures. 
The format is specified in exec/InitStruct routine's 
The INITBYTE/INITWORD/INITLONG routines 


i 
Z 


; Manual pages. 





9I - 9 





foct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 3 


are in the file "“exec/initializers.i". The first argument 

is the offset from the library base for this byte/word/long. 
The second argument is the value to put in that cell. 

The table is null terminated 

NOTE ~ LN_TYPE below is a correction - old example had LH_TYPE 


dataTable: 
INITBYTE LN_TYPE,NT_LIBRARY 
INITLONG —LN_NAME, sampleName 
INITBYTE LIB_FLAGS, LIBF_SUMUSED! LIBF_ CHANGED 
INITWORD LIB_VERSION, VERSION 
INITWORD LIB_REVISION, REVISION 
INITLONG LIB_IDSTRING, idString 
bow.L 0 


; This routine gets called after the library has been allocated. 
; The library pointer is in DO. The segment list is in AO. 
i If it returns non-zero then the library will be linked into 
the library list. 
initRoutine: 


—-~~-- get the library pointer into a convenient A register 
move. 1 a5,-(sp) 
move. 1] ao,as 


Tl save a pointer to exec 
move .1 a6,sb_SysLib(a5) 


~"——77 Save a pointer to our loaded code 
move. a a0,sb_SegList (a5) 


pot open the dos library 
lea dosName(pc),al 
CLEAR dao 
CALLSYS  OpenLibrary 
move.1 d0,sb_DosLib(a5) 
bne.s 1s 
—~---- can't open the dos! what gives 
ALERT AG_OpenLib!AO_DOSLib 
1s: 


joc77--- now build the static data that we need 


i; put your initialization here... 
move.1 a5,da0 


move.1 (sp)+,a5 
rts 


; here begins the system interface commands. When the user calls 


; has already put our library pointer in A6é for us. Exec has turned 
; off task switching while in these routines (via Forbid/Permit), so 


; into a call to the following routines (Open/Close/Expunge). Exec 
; we should not take too long in then. 


; Open returns the library pointer in dO if the open 
3; was successful. If the open failed then null is returned. 





i; It might fail if we allocated memory on each open, or 


; OpenLibrary/CloseLibrary/RemoveLibrary, this eventually gets translated 








Oct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 4 


if only open application could have the library open 
at a time... 


Open: ; ( libptr:a6é, version:d0 ) 


po mark us aS having another opener 
addq.w #1, LIB_OPENCNT( a6) 


jcccce prevent delayed expunges 
belr #LIBB_DELEXP,sb_Flags(a6) 


move.1 a6,do 
rts 


; There are two different things that might be returned from 
; the Close routine. If the library is no longer open and 

; there is a delayed expunge then Close should return the 

; segment list (as given to Init). Otherwise close should 

; return NULL. 


Close: i; ( libptr:a6 ) 


joc set the return value 
CLEAR ao 


ae mark us as having one fewer openers 
subq.w #1, LIB_LOPENCNT(a6) 


poco see if there is anyone left with us open 
bne.s 1$ 


po see if we have a delayed expunge pending 
btst #LIBB_DELEXP,sb Plags(a6) 
beq.s 1$ 


}-——--- do the expunge 
bsr  Expunge 


ls: 
rts 
; There are two different things that might be returned from 
; the Expunge routine. If the library is no longer open 
; then Expunge should return the segment list (as given to 
; Init). Otherwise Expunge should set the delayed expunge 
; flag and return NULL. 
; One other important note: because Expunge is called from 
; the memory allocator, it may NEVER Wait() or otherwise 
; take long time to complete. 

Expunge: ; ( libptr: a6 ) 


movem.1 d2/a5/a6,-(sp) 
move.1 a6,a5 
move. 1 sb_SysLib(a5),a6 


ju-7777- «see if anyone has us open 
tst.w LIB_OPENCNT(a5) 
beq 1$ 


pu it is still open. set the delayed expunge flag 
bset #LIBB_DELEXP,sb_Flags(a5) 

CLEAR do 

bra.s Expunge_End 


1s: 
j7——->- go ahead and get rid of us. Store our seglist in d2 
move. 1 sb SegList(a5),d2 

















foct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 5 Oct 7 20:31 1988 SampleLibrary/library/sample.library.asm Page 6 


; the rom tag -~ that way you are always safe. I put 
j-—--—+ unlink from library list ; it here because it happens to be the “right" thing 
move.1 a5,al ; to do, and I know that it is safe in this case. 


CALLSYS Remove EndCode: 


: END 
; device specific closings here... 


i 


jo7c77- «close the dos library 
move.1 sb _DosLib(a5),al 
CALLSYS  CloseLibrary 


po free our memory 
CLEAR do 

move. 1 a5,al 

Move.w  LIB_NEGSIZE(a5),d0 


sub.1  d0,al 
add.w LIB_POSSIZE(a5),d0 


CALLSYS FreeMem 


poo set up our return value 
move.1 da2,d0 


Expunge_End: 
movem. 1 (sp)+,d2/a5/a6 
rts 


Null: 
CLEAR do 
rts 


; Here begins the library specific functions. 
; Both of these simple functions are entirely in assembler, but you 


can write your functions in C if you wish and interface to them here. 
If, for instance, the bulk of the AddThese function was written 








; in C, you could interface to it as follows: 
i - write a C function addTheseC(nl,n2) and compile it 
j ~ XDEP _addThese C in this library code 
i - change the AddThese function code below to: 
; move.1 dl,-(sp) ;push rightmost C arg first 
; move.1 d0,-(sp) ;push other C arg(s), right to left 
} jsr _addTheseC ;eall the C code 
i addq #8,sp ;fix stack 
; rts ;return with result in d0 
*————— Double(d0) 
Double: 
Isl #1,d0 
rts 
kon AddThese(d0,dl) 
AddThese: 
add.1  d1,do 
rts 
; EndCode is a marker that show the end of your code. 
; Make sure it does not span sections nor is before the 
; rom tag in memory! It is ok to put it right after 

















8T - 9 














Oct 7 20:32 1988 SampleLibrary/test/alibtest.asm Page 1 


HK KI IK IKK IKK IRI KIRK IIR KKK KKK IIR EK K AKER ER KERR RK KKK RRR RE KEKE KKK KEK 


alibtest.asm —- Asm example that calls the Sample.library functions 


Copyright 1988 Commodore Amiga Inc. All rights reserved. 


FROM Astartup.obj, alibtest.o 
LIBRARY LIB:amiga.lib, LIB:sample.lib 


* 
* 
* 
* 
* 
x 
* 
* 
TO ALibTest ; 
* 


* 
* 
*x 
* 
x 
* Linkage Info: 
* 
* 
* 
* 
* 


HRI IKI KK KIKI AKI KIRA KKK KIKI IK IK EK KIRK REE KK IEE KEK REE KIRKE RK KKREKEEKE 


INCLUDE "“exec/types.i" 
INCLUDE ‘“exec/libraries.i" 
INCLUDE “asmsupp. i" 
INCLUDE "samplebase.i" 





ABSEXECBASE EQU 4 
XDEF —_main 
XREF _ printf 
XREF _ LVODouble 
XREFP _LVOAddThese 


XLIB  OpenLibrary 
XLIB CloseLibrary 


main 
pr open the test library: this will bring it in from disk 
move.1 ABSEXECBASE , a6 
lea sampleName(pc) ,al 
moveq #0,d0 
jsr _LvooOpenLibrary (a6) 
tst.1 do 
bne.s 1$ 
ccc couldn't find the library 
pea sampleName (pc) 
pea nolibmsg (pc) 
jsr _printf 
addq.1 #8,sp 
bra main_end 
1s: 


move.1 d0,a6 ;sample.library base to a6 


wT print the library name, version, and revision 


elr.1 ao 

move.w LIB REVISION(a6),d0 

move.1 d0,~(sp) 

move.w LIB_VERSION(a6) ,d0 

move.1 @0,-(sp) 

move.1 LN_NAME(a6) ,~(Sp) 

pea verRevMsg(pc) 

jsr _printf ;call Amiga.lib printf 


adda.l1  #16,sp ;fix 4 long stack pushes 
Te call the first test function 

moveq #-7,d0 

jsxr _LvODouble(a6) 
move.1 d0,-(sp) 

pea doubleMsg(pc) 








Oct 7 20:32 1988 SampleLibrary/test/alibtest.asm Page 2 


jsr _printf 
lea 8(sp),sp ;fix 2 long stack pushes 
co call the second test function 

moveq #21,a0 

moveq #4,da1 


jsr _LVOAddThese (a6) 
move. 1 d0,-(sp) 

pea addTheseMsg (pc) 
jsr _printf 

lea 8(sp),sp 


icc close the library 
move. 1 a6,al 

move.I ABSEXECBASE, a6 

jsr _LVO0CloseLibrary (a6) 


main_end: 
rts 


sampleName: SAMPLENAME 


nolibmsg: de.b ‘can not open library "%s"',10,0 
doubleMsg: dc.b ‘Function Double(~-7) returned %1d',10,0 
addTheseMsg: dc.b 'Punction AddThese(21,4) returned %1d',10,0 
verRevMsg: dc.b 'S$s Version %ld Revision %1d',10,0 

END 








6T - 9 





Oct 8 04:21 1988 SampleLibrary/test/clibtest.c Page 1 


/* 
* clibtest.c ~- C example that calls the Sample.library functions 
* 

* Copyright 1988 Commodore Amiga Inc. All rights reserved. 
* 

* Linkage Info: 

* FROM Astartup.obj, clibtest.o 

* LIBRARY LIB:amiga.lib, LIB:sample.lib 

* TO CLibTest 

*/ 


#include <exec/types.h> 
#include <exec/libraries.h> 
#include <libraries/dos.h> 


#include ‘samplebase.h" 
struct SampleBase *SampleBase; 
void main() 


LONG n; 
struct Library *slib; 


/* Open sample.library */ 
if(!(SampleBase=(struct SampleBase *)OpenLibrary("sample. library",0))) 
{ 


printf("Can't open sample. library\n") ; 
exit (RETURN_FAIL) ; 
} 


/* Print library name, version, revision */ 
slib = &SampleBase—)>LibNode; 
printf("%s Version $ld Revision %ld\n", 
slib->lib_Node.1n_ Name, slib->lib Version, slib->lib Revision); 


/* Call the two functions */ 
n = Double(-7); 
printf{("Function Double(-7) returned %ld\n", n); 


n = AddThese(21,4); 
printf("Function AddThese(21,4) returned $ld\n", n); 


CloseLibrary(SampleBase) ; 
exit (RETURN_OK) ; 
] 











|) 


Section H 


Reference Charts 


This section contains several handy reference charts. These are often useful when search- 
ing memory or scanning structures during debugging. The charts are: 


oO 


1.3 Function Offsets - The Amiga libraries are listed, with a separate entry for each 
library function. The chart lists the function’s negative offset from the library base 
and a short summary of register usage. 


Assembly Prefix Reference - Structure members in the assembly language include 
files often have a prefix associated with them. This chart lists the name of the 
include file that each prefix is associated with. 


Structure Offset Reference - Lists the Amiga structures individually by name, fol- 
lowed by the structure size and offset of each member. This chart is typically used 


when you know the base address of a structure and wish to examine its members. 


Hardware Register Map - A short reference listing of each chip register in the sys- 
tem, for those developers that must access the hardware directly. For more detail 
see the Amiga Hardware Manual. 


© Language Cross-Reference - Each element from the Amiga include files is listed 
along with its resolved value, the location where it was defined, and each place that 
references it. Since the elements have similar names, this chart is also useful for 
assembly language users. 





Sep 20 13:50 1988 1.3 _Base_Offset_Reference Page 1 


KHKKKKKEKEKEKEREKKEKEKHEKEKEK cia.resource WHEE KKER KERIKERI HIEKIKE KK KEKE KEKEK 

##bias 6 
6 $fffa -$0006 AddICRVector(bit,interrupt)(d0,al) 
12 $f£f£4 -$000c RemICRVector (bit) (d0) 

18 $ffee -$0012 AbleICR(mask)(d0) 

24 $ffe8 -$0018 SetICR(mask) (d0) 


FOO OOOO IIIIN IOC COnSO Le. GeVL Ce OI III III Ik 
##base _ConsoleDevice 


#ibias 42 
42 $ffd6 -$002a CDInputHandler(events,device) (A0/A1) 
48 $f£f£d0 -$0030 RawKeyConvert(events,buffer,length,keyMap) (A0/Al,D1/A2) 


KEKE KEK EKER REESE diskfont. library KEK KKREKE KERIKERI EKER 
titbase _DiskfontBase 

##bias 30 
30 $ffe2 -$00le OpenDiskFont (textAttr) (A0) 


36 


Sffde —$0024 


*—-—- Added as of 


42 
48 


JOIOICIOI TOU IOKI® dos, Library FOCI IOI III IIOI OI TOT TIO TIO IOI III IA 


S££a6 -$002a 
$Sf££a0 —-$0030 


##base _DOSBase 
##bias 30 


156 


$ffe2 -$00le 
S$ffdc -$0024 
Sffd6 -$002a 
$ff£d0 —$0030 
Sffca —$0036 
$ffc4 —$003c 
$ffbe -$0042 
S£fbB -$0048 
Sffb2 -$004e 
Sffac —$0054 
$ffa6 -$005a 
$ffa0 -$0060 
$ff£9a -$0066 
$££94 -$006c 
$f£f£8e -$0072 
$f££88 -$0078 
Sf££82 -$007e 
$ff7e -$0084 
Sf££76 -$008a 
$££70 -$0090 
$ff6a -$0096 
$££64 -$009c 


##private 


162 
168 


$ff5e —$00a2 
$f££58 -$00a8 


##public 


174 
180 
186 
192 
198 
204 
210 
216 
222 


$££52 -$00ae 
Sff4c -$00b4 
$££46 -$00ba 
$f££40 -$00c0 
Sf£f£3a —$00c6 
$££34 -$00cc 
$f£f2e -$00d2 
$f££28 -$00d8 
$ff£22 -$00de 


AvailFonts(buffer, bufBytes , flags) (A0,DO/D1) 
version 34 (distributed on V1.3 Workbench) --~ 
NewFontContents( fontsLock, fontName) (A0/A1) 
DisposeFontContents ( fontContentsHeader) (Al) 


Open (name, accessMode) (D1/D2) 

Close( file) (D1) 
Read(file,buffer,length) (D1/D2/D3) 
Write(file,buffer, length) (D1/D2/D3) 
Input () 

Output() 

Seek (file, position,offset) (D1/D2/D3) 
DeleteFile(name) (D1) 

Rename (oldName , newName) (D1/D2) 

Lock (name, type) (D1/D2) 

UnLock (lock) (DL) 

DupLock( lock) (D1) 

Examine( lock, fileInfoBlock) (D1/D2) 
ExNext (lock, fileInfoBlock) (D1/D2) 
Info(lock,parameterBlock) (D1/D2) 
CreateDir(name) (D1) 

CurrentDir (lock) (D1) 

ToErr({ ) 

CreateProc (name, pri,segList,stackSize) (D1/D2/D3/D4) 
Exit (returnCode) (D1) 

LoadSeg( fileName) (D1) 

UnLoadSeg (segment) (D1) 


GetPacket (wait) (D1) 
QueuePacket (packet) (D1) 


DeviceProc (name) (D1) 
SetComment (name, comment.) (D1/D2) 
SetProtection (name ,mask) (D1/D2) 
DateStamp (date) (D1) 

Delay (timeout) (D1) 
WaitForChar(file,timeout) (D1/D2) 
ParentDir(lock) (D1) 
IsInteractive( file) (Dl) 
Execute(string, file, file) (D1/D2/D3) 


KEK ERK ERE KEK KEKE KKK KEKE KEKE exec. library KIKKKKEKREKREE KEE KK KKEK EKER KE 
#t#tbase _SysBase 
#ttbias 30 
#ttprivate 














Sep 20 13:50 1988 1.3_Base_Offset_Reference Page 2 





*---——— special functions ~--~ 
30 $ffe2 -$00le Supervisor() 
36 $ffde -$0024 ExitIntr() 

42 $ffd6 -$002a Schedule() 
48 $f£f£d0 —-$0030 Reschedule() 
54 $ffca -$0036 Switch() 

60 $ffc4 -$003c Dispatch() 
66 $ffbe -$0042 Exception() 

##public 

72 $ffb8 -$0048 InitCode(startClass, version) (D0/D1) 

78 $ffb2 -$004e InitStruct(initTable,memory,size) (A1/A2,D0) 

84 $ffac -$0054 MakeLibrary(funcInit,structInit,libInit,dataSize,codeSize) 
(AO/A1/A2 ,D0/D1) 

90 $ffa6 —-$005a MakeFunctions(target,functionArray, funcDispBase) {A0,Al1,A2) 

96 $ffa0 -$0060 FindResident (name) (Al) 

102 $ff£9a -$0066 InitResident (resident ,segList) (Al,Dl) 

108 $££94 -$006c Alert(alertNum, parameters) (D7,A5) 

114 $f£f£8e -$0072 Debug() 

-_ TNC LUPE i 

120 $f££88 -$0078 Disable() 

126 $££82 -$007e Enable() 

132 $f££7¢e ~-$0084. Forbid() 

138 $f£76 —$008a Permit() 

144 $f££70 -$0090 SetSR(newSR,mask)(DO/D1) 

150 $ff6a -$0096 SuperState() 

156 $ff64 -$009c UserState(sysStack) (D0) 

162 $ff5e -$00a2 SetIntVector(intNumber, interrupt) (D0/A1) 

168 $f££58 -~$00a8 AddIntServer(intNumber, interrupt) (D0/A1) 

174 $ff£52 -$00ae RemintServer(intNumber, interrupt) (D0/A1) 

180 $ff£4c -$00b4 Cause(interrupt) (Al) 

oe memory allocation: 

186 $££46 -$O00ba Allocate(freeList, pytesize) (A0, DO) 

192 $f££40 -$00c0 Deallocate( freeList ,memoryBlock ,byteSize) (A0/Al,D0) 

198 $ff£3a -$00c6 AllocMem(byteSize, requirements) (DO/D1) 

204 $f££34 -$00cc AllocAbs(byteSize, location) (DO/A1) 

210 $ff2e -$00d2 FreeMem(memoryBlock ,byteSize) (Al,D0) 

216 $£f28 -$00d8 AvailMem( requirements) (D1) 

222 $f££22 -$00de AllocEntry(entry) (A0) 

228 $ffle -$00e4 FreeEntry(entry) (A0) 

Ban lists: 

234 $f£f16 -$00ea Insert(list,node, pred) (A0/A1/A2) 

240 $ff£10 -$00f0 AddHead{ list ,node) (A0/Al) 

246 $ff£0a -S$O0f6 AddTail(list,node) (A0/Al) 

252 $ff£04 -$00fc Remove(node) (Al) 

258 $fefe -$0102 RemHead( list) (A0) 

264 $fef8 -$0108 RemTail(list) (AO) 

270 $fef2 -$010e Enqueue(list ,node) (A0/A1) 

276 Sfeec -$0114 FindName(list,name)(A0/A1) 

BEAK 

282 $fee6 -$Olla AddTask(task,initPC, finalPC) (Al1/A2/A3) 

288 S$fee0 -$0120 RemTask( task) (Al) 

294 $feda -$0126 FindTask(name) (Al) 

300 $fed4 -$012c SetTaskPri(task, priority) (Al,D0) 

306 $fece -$0132 SetSignal(newSignals,signalSet) (D0/D1) 

312 $fec8 -$0138 SetExcept (newSignals,signalSet) (D0/D1) 

318 $fec2 -$013e Wait(signalSet) (DO) 

324 $febc -$0144 Signal(task,signalSet) (Al ,D0) 

330 $feb6 ~-$0l4a AllocSignal(signalNum) (D0) 

336 $febO -$0150 FreeSignal(signalNum) (D0) 

342 $feaa -$0156 AllocTrap(trapNum) (D0) 

348 $fea4 -$015c FreeTrap(trapNum) (D0) 
oe MES SAQOS 2 i a 

354 $fe9e -$0162 AddPort( port) (Al) 

360 $fe98 -S0168 RemPort (port) (AL) 

366 $fe92 -$0l6e PutMsg(port,message) (A0/Al1) 

372 $fe8c -$0174 GetMsg(port)(A0) 

378 $fe86 -$017a ReplyMsg(message) (Al) 

384 $fe80 -$0180 WaitPort(port) (A0) 

390 $fe7a -$0186 FindPort (name) (Al) 














Bone libraries: —------------—— 


20 13:50 1988 1.3 Base_Offset_Reference Page 3 


$fe74 -$018c 
Sfebe -$0192 
$fe68 -$0198 
$fe62 ~$019e 
$feSc —$0la4 
$fe56 —-SOlaa 


Bo devices: 


*—— resources: ~——T TT —— 


$fe50 -$01b0 
S$fe4a -$01b6 
$fe44 -$0lbc 
Sfe3e ~-$01c2 
$fe38 -$01c8 
$fe32 -$Olce 
$fe2ec -$01d4 
$fe26 -S$Olda 
$fe20 -$01e0 


Sfela -$01le6 
$fel4 -$Olec 
$fe0e -$01f2 


AddLibrary (library) (Al) 

RemLibrary (library) (Al) 

OldoOpenLibrary (libName) (Al) 
CloseLibrary(library) (Al) 
SetFunction(library, funcOffset, funcEntry) (Al,A0,D0) 
SumLibrary (library) (Al) 

AddDevice (device) (Al) 

RemDevice(device) (Al) 

OpenDevice(devName, unit, ioRequest , flags) (A0,D0/Al,D1) 
CloseDevice( ioRequest) (Al) 

DoIO( ioRequest) (Al) 

SendIO(ioRequest ) (Al) 

CheckIO(ioRequest ) (Al) 

WaitIO(ioRequest) (Al) 

Abort10(ioRequest ) (Al) 


AddResource (resource) (Al) 
RemResource (resource) (Al) | 
OpenResource(resName, version) (Al,D0) 


*-—--—— new functions: 
#t#private 


504 
510 
516 


$fe08 -$01f£8 
$fe02 -$0lfe 
$fdfc -$0204 


##public 


522 
528 
534 
540 
546 
552 


$fdf6 —$020a 
$faf£0 -30210 
$fdea -$0216 
$fde4 —$021c 
$fdde -$0222 
$fad8 ~$0228 


RawlOInit() 
RawMayGetChar() 
RawPutChar( char) (a0) 


RawDoFmt () (A0/A1/A2/A3) 

GetCCc() 

TypeofMem( address) (Al); 
Procure(semaport ,bidMsg) {A0/A1) 
Vacate(semaport) (A0) 

OpenLibrary (libName, version) (Al,D0) 


*—---——— 1.2 new semaphore support 

558 $fdd2 -$022e InitSemaphore(sigSem) (A0) 

564 $fdce -$0234 ObtainSemaphore(sigSem) (AO) 

570 $fac6 -$023a ReleaseSemaphore(sigSem) (A0) 

576 $fdcO -$0240 AttemptSemaphore(sigSem) (A0) 

582 $fdba -$0246 ObtainSemaphoreList (sigSem) (AQ) 

588 $fdb4 -$024c ReleaseSemaphoreList(sigSem) (A0) 

594 $fdae -$0252 FindSemaphore(sigSem) (Al) 

600 $fda8 -$0258 AddSemaphore(sigSem) (Al) 

606 $fda2 -$025e RemSemaphore(sigSem) (Al) 

*-—---- 1.2 rom "kickstart" support + memory support 

612 $fd9c —-$0264 SumKickData() 

618 $f£d96 —$026a AddMemList(size,attributes , pri,base,name) (D0/D1/D2/A0/Al1) 
624 $£d90 -$0270 CopyMem(source, dest, size) (A0/A1,D0) 

630 $fd8a -$0276- CopyMemQuick(source,dest, size) (A0/Al ,D0) 


FOI IIIT AE expansion. Library III III IR RAI IIIA RIE I 


##base _ExpansionBase 
##bias 30 


30 


$ffe2 -$00le 


##private 


36 


$ffde -$0024 


##public 


Sffd6 ~$002a 
$ffd0 -$0030 
$ffca -$0036 
$ffce4 -$003c 
Sffbe —$0042 
$ffb8 -$0048 
$f£f£b2 -$004e 
S$ffac -$0054 
$ffa6 -$005a 
$ffa0 -$0060 
$f££9a —-$0066 
$££94 -$006c 


AddConfigbev(configDev) (A0) 
expansionUnused( ) 


AllocBoardMem(slotSpec) (D0) 
AllocConfigDev() 
AllocExpansionMem(numSlots,SlotAlign, Slotoffset) (D0/D1/D2) 
ConfigBoard (board, configDev) (A0/Al) 
configChain(baseAddr) (A0) 

FindConfigbev(oldConfigDev ,manufacturer , product) (A0,D0/D1) 
FreeBoardMem(startSlot,slotSpec) (D0/D1) 
FreeConfigbdev(configDev) (A0) 
FreeExpansionMem(startSlot ,numSlots) (D0/D1) 
ReadExpansionByte(board,offset)(A0,D0) 
ReadExpansionRom( board, configDev) (A0/Al) 
RemConfigDev(configbdev) (A0) 


Sep 20 13:50 1988 1.3_Base_Offset_Reference Page 4 


114 $f£8e -$0072 WriteExpansionByte(board,offset,byte) (A0,D0/D1) 

120 $££88 —$0078 ObtainConfigBinding( ) 

126 $f£82 -$007e ReleaseConfigBinding{ ) 

132 $ff7c.-$0084 SetCurrentBinding(currentBinding ,bindingSize) (A0,D0) 
138 $f£76 -$008a GetCurrentBinding(currentBinding,bindingSize) (A0,D0) 
144 $££70 -$0090 MakeDosNode(paxrmPacket) (A0) : 

150 $f£f£6a —$0096 AddDosNode(bootPri , flags ,dosNode) (D0/D1/A0) 


KEKKKKKKEEEKERKEKEKREREKEKKEKREK graphics. library KKK KIKI IKK KK EKER ERE KERR EEE 


##base _GfxBase 
#t#bias 30 
*——---~ Text routines 
30 $ffe2 -$00le B1tBitMap(srcBitMap,srcX,srcY,destBitMap,destx,destY,sizeXx, 
sizeY ,minterm,mask, tempA) (A0,D0/D1,Al ,D2/D3/D4/D5/D6/D7/A2) 
36 $ffdc -$0024 BltTemplate(source,srcX,srcMod,destRastPort ,destx,destY, 
sizeX,sizeY)(A0,D0/D1/Al ,D2/D3/D4/D5) 
42 $ffd6 -$002a ClearEOL(rastPort) (Al) 
48 Sffd0 -$0030 ClearScreen(rastPort) (Al) 
54 $ffca -$0036 TextLength(RastPort,string, count) (Al,A0,D0) 
60 $ffc4 -$003c Text(RastPort,string,count) (Al,A0,D0) 
66 $ffbe ~$0042 SetFont(RastPortID, textFont) (Al,A0) 
72 S$ffb8 -$0048 OpenFont(textAttr) (AQ) 
78 $ffb2 -$004e CloseFont(textFont) (Al) 
84 S$ffac —-$0054 AskSoftStyle(rastPort) (Al) 
90 $ffa6 -$005a. SetSoftStyle(rastPort,style,enable) (Al,D0/D1) 
Kom Gels routines —---~- 
96 $ffa0 -$0060 AddBob(bob,rastPort) (A0,Al) 
102 $f££9a ~$0066 AddVSprite(vSprite,rastPort) (AQ/A1) 
108 $f££94 -$006c DoCollision(rasPort) (Al) 
114 $f££8e -$0072 DrawGList(rastPort,viewPort) (Al ,A0) 
120 $f£f£88 -$0078 InitGels(dummyHead , dummyTail ,GelsInfo) (AQ/A1/A2) 
126 $££82 ~$007e InitMasks(vSprite) (A0) 
132 $f£7c -$0084 RemIBob(bob, rastPort , viewPort) (A0/A1/A2) 
138 $f££76 -$008a RemVSprite(vSprite) (A0) : 
144 $££70 -$0090 SetCollision(type, routine,gelsInfo) (D0/A0/A1) 
150 $ff6a -$0096 SortGList(rastPort) (Al) 
156 $f£64 -$009c AddAnimOb(cbj ,animationkey, rastPort) (AQ/A1/A2) 
162 $ff£5e -$00a2 Animate(animationKey,rastPort) (A0/A1) 
168 $f£58 -S00a8 GetGBuffers(animationObj,rastPort ,doubleBuffer) (A0/A1,D0) 
174 $f££52 -$00ae InitGMasks(animationObj) (A0) 
180 S$ff£4c ~-$00b4 DrawEllipse(rastPort,cx,cy,a,b) (Al,D0/D1/D2/D3) 
186 $f£46 -$00ba AreaEllipse(rastPort ,cx,cy,a,b)(Al,D0/D1/D2/D3) 
*—----— Remaining graphics routines ~---— 
192 $f£40 -$00c0. LoadRGB4 ( viewPort ,colors, count) (AQ/A1,D0) 
198 $f£f3a -$00c6 InitRastPort(rastPort) (Al) 
204 Sf££34 ~$00ce InitVPort(viewPort) (A0) 
210 $ff2e -$00d2 MrgCop( view) (Al) 
216 $f££28 ~$00d8 MakeVPort( view, viewPort) (A0/Al1) 
222 $f£22 -$00de LoadView( view) (Al) 
228 $fflc -$00e4 WaitBlit() 
234 S$ff16 -$00ea SetRast(rastPort,color)(Al,D0) 
240 $£f£10 ~SO0f0 Move(rastPort,x,y)(Al,DO/D1) 
246 Sf£0a -SO0f6 Draw(rastPort,x,y)(Al,D0/D1) 
252 $f££04 -$00fc AreaMove(rastPort,x,y)(Al,D0/D1) 
258 $fefe -$0102 AreaDraw(rastPort,x,y)(Al,DO/D1) 
264 $fef8 -$0108 AreaEnd(rastPort) (Al) 
270 $fef2 -$010e WaitTOF() 
276 $feec -$0114 QBlit(blit) (Al) 
282 $fee6 ~$Olla InitArea(areaInfo, vectorTable, vectorTableSize) (A0/Al,D0) 
288 $fee0 -$0120 SetRGB4(viewPort ,index,r,g,b)(A0,D0/D1/D2/D3) 
294 $feda ~$0126 QBSBlit(blit) (Al) 
300 $fed4 -$012c BltClear(memory,size, flags) (Al1,D0/D1) 
306 $fece -$0132 RectFill(rastPort,xl,yl,;xu,yu) (Al ,DO/D1/D2/D3) 
312 $fec8 -$0138 BltPattern(rastPort,ras,xl,yl,maxX ,maxY,fillBytes) 
(al,a0,D0/D1/D2/D3/D4) 
318 S$fec2 ~$013e ReadPixel (rastPort,x,y)(Al,DO0/D1) 
324 S$febc -$0144 WritePixel (rastPort,x,y)(Al,DO/D1) 
330 $feb6 -$014a Flood(rastPort ,mode,x,y)(A1,D2,D0/D1) 











Sep 20 13:50 1988 1.3 _Base_Offset_Reference Page 5 


$feb0O 
S$feaa 
Sfea4 
Sfe%e 
$fe98 
$fe92 
$fe8c 
$fe86 
$fes0o 
Sfe7a 
$fe74 


Sfebe 
$fe68 
$fe62 
Sfe5ca 
$fe56 
$fe50 
Sfeda 
$fe44 
Sfe3e 
$fe38 
$fe32 
S$fe2c 
$fe26 
$fe20 
Sfela 
$fel4 
$fele 
$fe08 
$fe02 
$fdfc 
$faf6 
Sfdfo 
$fdea 
$fde4 
$fdde 
$fdd8 


$fdada2 
S$fdcc 
Sfdc6 
$fdcO 
$fdba 
$fdb4 
$fdae 
$fda8 
$fda2 


$f£d9c 
$f£d96 
$f£a90 
$fd8a 
$f£d84 


##private 


-$0150 
~$0156 
-S$O01L5c 
-$0162 
-$0168 
-$0l6e 
-$0174 
-$O0l7a 
—-$0180 
-$0186 
-$018c 


—$0192 
—$0198 
-$019e 
~$0la4 
-SOlaa 
~$01b0 
—$01b6 
-$0lbc 
-$01c2 
~$01c8 
-$0lce 
-$01d4 
—$0lda 
—-$01e0 
-$0le6 
-$0lec 
-$O1£2 
-$01f8 
-$0lfe 
-$0204 
-$020a 
~-$0210 
—$0216 
-$021c 
~$0222 
-$0228 


-$022e 
—$0234 
—-$023a 
~-$0240 
—$0246 
-$024c 
-$0252 
-$0258 
-$025e 


~$0264 
—$026a 
—$0270 
-$0276 
—-$027¢ 


PolyDraw(rastPort, count ,polyTable) (A1,D0,A0) 
SetAPen(rastPort,pen)(Al,D0) 
SetBPen(rastPort,pen)(Al,D0) 
SetDrMd(rastPort ,drawMode) (Al ,D0) 
InitView( view) (Al) 
CBump (copperList) (Al) 
CMove(copperList ,destination,data) (Al,D0/D1) 
CWait(copperList ,x,y)(Al,DO0/D1) 
VBeamPos( ) 
InitBitMap(bitMap,depth,width, height) (A0,D0/D1/D2) 
ScrollRaster(rastPort ,dX,dY,minx ,miny ,maxx ,maxy) 
(Al ,D0/D1/D2/D3/D4/D5) 
WaitBOVP (viewport) (a0) 
GetSprite(simplesprite,num) (a0,d0) 
FreeSprite(num) (d0) 
ChangeSprite(vp,simplesprite,data)(a0/al/a2) 
MoveSprite(viewport,simplesprite,x,y)(a0/al,d0/dl) 
LockLayerRom({ layer) (a5) 
UnlockLayerRom( layer) (a5) 
SyncSBitMap(1)(a0) 
CopySBitMap(1) (a0) 
OwnBlitter()() 
DisownBlitter()() 
InitTmpRas(tmpras ,buff,size)(a0/al ,d0) 
AskFont(rastPort, textAttr) (Al,A0) 
AddFont (textFont) (Al) 
RemFont(textFont) (Al) 
AllocRaster(width,height) (D0/D1) 
FreeRaster(planeptr,width,height) (A0,DO/D1) 
AndRectRegion(rgn, rect) (A0/A1) 
OrRectRegion(rgn, rect) (A0/AL) 
NewRegion( )() 
ClearRectRegion(rgn)(A0/A1) 
ClearRegion(rgn) (A0) 
DisposeRegion(rgn) (A0) 
FreevPortCopLists (viewport) (a0) 
FreeCopList(coplist) (a0) 
ClipBlit(srcerp,srcX,srcY,destrp,destX,destY,sizex,sizeY, 
minterm) (A0,D0/D1, Al ,D2/D3/D4/D5/D6) © 
XorRectRegion(rgn, rect) (a0/al) 
FreeCprList(cprlist) (a0) 
GetColorMap(entries) (d0) 
FreeColorMap(colormap) (a0) 
GetRGB4(colormap, entry) (a0,d0) 
ScrollvPort (vp) (a0) 
UCopperListInit (copperlist,num) (a0,d0) 
FreeGBuf fers (animationObj, rastPort ,doubleBuffer) (A0/Al,DO) 
B1tBitMapRastPort (srcbm,srcx,srcy,destrp,destX,destY,sizex, 
sizeY,mintemm) (A0,D0/D1,A1,D2/D3/D4/D5/D6 ) 
OrRegionRegion(srce,dst)(a0/al) 
XorRegionRegion(sre,dst)(a0/al) 
AndRegionRegion(src,dst)(a0/al) 
SetRGB4CM(cm,i,r,g,b) (a0,d0/d1/d2/d3) 
BltMaskBitMapRastPort (srcbm,srcx,srcy,destrp,destX,destyY, 
sizeX,sizeY,mintezm,bltmask) (A0,D0/D1,A1,D2/D3/D4/D5/D6 , A2) 
GraphicsReserved1()() 
GraphicsReserved2()() 


AttemptLockLayerRom( layer) (a5) 


FER IGIICIISIICI IOI TOOT FCOD. Da Ty OA III III TOI IO TO IORI IK 
##base _IconBase 


##bias 30 


30 $ffe2 -S$00le GetWBObject()() 
0) 


36 $ffde 
42 $ffd6 
48 $ffdo 


—$0024 
—$002a 
-$0030 


PutWBObject ( 
GetIcon()() 
PutIcon()() 


Sep 20 13 


#i#public 
54 $ffca 
#ttprivate 
60 $ffc4 


-$0036 


-$003c 
-$0042 


~$0048 


:50 1988 1.3 Base_Offset_Reference Page 6 


FreeFreeList (freelist) (A0) 


FreeWBObject (WBOb ject) (A0) 
AllocwBobject(){) 


AddFreeList(freelist ,mem,size) (AO/A1/A2) 


normal functions 


$f£fb2 


-$004e 


GetDiskObject (name) (A0) 


$ffac -$0054 PutDiskObject (name ,diskobj)(A0,A1) 
FreeDiskObject (diskobj) (A0) 
FindToolType(toolTypeArray , typeName) (A0/A1) 
MatchToolValue(typeString, value) (A0/A1) 
BumpRevision(newname ,oldname) (A0/A1) 


$ffa6 
$ffad 
Sff9a 
$ff£94 


-$005a 
-$0060 
~$0066 
-$006c 


HEKEERKKEERKEKKE REE KEEKKREKKESK intuition. library KRKKKKKEKKKEKEEKEKEEKKKKEKKEKKKK 
##base _IntuitionBase 


#ttbias 30 
$ffe2 
Sffde 
$ffd6é 
$ffdo 
$ffca 
$ffic4 
Sfifbe 
$ffbs8 
$ffb2 
Sffac 
Sffa6 
$ffa0 
$ff9a 
$f££94 
Sf£fBe 
Sff£88 
$f££82 
$f£f£7e 
$ff£76 
Sf££70 
S$ff6a 
$f£f64 


Sff5e 
$ff£58 
$f£52 
Sff4e 
$ff46 
$f£f£40 
Sff3a 
$f££34 
$ff2e 
$ff28 
$f££22 
S$ffle 


* The official calling sequence for ReportMouse is. given below. 


-$00le 
~$0024 
-$002a 
-$0030 
-$0036 
-$003c 
-$0042 
-$0048 
-$004e 
-$0054 
-$005a 
-$0060 
—$0066 
-$006c 
-$0072 
-$0078 
~$007e 
-$0084 
-$008a 
-$0090 
-$0096 
-$009c 


-$00a2 
-$00a8 
-$00ae 
-$00b4 
—-$00ba 
~$00c0 
-$00c6 
-$00cc 
-$00d2 
—$00d8 
~$00de 
-$00e4 


OpenIntuition()() 

Intuition(ievent ) (AQ) 

AddGadget (AddPtr ,Gadget , Position) (A0/Al1,D0) 

ClearDMRequest (Window) (A0) 

ClearMenuStrip (Window) (A0) 

ClearPointer (Window) (A0) 

CloseScreen (Screen) (A0) 

CloseWindow( Window) (A0) 

CloseWorkBench()() 

CurrentTime (Seconds ,Micros) (A0/Al1) 

DisplayAlert(AlertNumber , String ,Height) (D0/A0,D1) 

DisplayBeep( Screen) (A0) 

DoubleClick(sseconds,smicros ,cseconds,cmicros) (D0/D1/D2/D3) 

DrawBorder (RPort, Border, LeftOffset ,Topoffset ) (A0/Al,D0/D1) 

DrawImage(RPort, Image, LeftOffset , Topoffset ) (A0/Al,D0/D1) 

EndRequest ( requester , window) (A0/A1) 

GetDefPrefs (preferences ,size) (A0,D0) 

GetPrefs (preferences ,size) (A0,D0) 

InitRequester (req) (AQ) 

ItemAddress(MenuStrip ,MenuNumber) (A0,D0) 

Modi fyIDCMP (Window, Flags) (A0,D0) 

Modi fyProp (Gadget , Ptr, Req, Flags ,HPos , VPos , HBody , VBody ) 
(AO/AL/A2 ,D0/D1/D2/D3/D4 ) 

MoveScreen (Screen, dx ,dy)(A0,D0/D1) 

MoveWindow(window,dx,dy) (A0,D0O/D1) 

of fGadget (Gadget , Ptr,Req) (A0/A1/A2) 

Of {Menu (Window ,MenuNumber ) (A0,D0) 

OnGadget (Gadget , Ptr, Req) (A0/A1/A2) 

OnMenu (Window, MenuNumber ) (A0,D0) 

OpenScreen(OSargs) (A0) 

OpenWindow(OWargs) (A0) 

OpenWorkBench( ) () 

PrintIText(rp,itext, left, top) (A0/Al ,DO/D1) 

RefreshGadgets (Gadgets ,Ptr,Req) (A0/A1/A2) 

RemoveGadget (RemPtr, Gadget ) (A0/A1) 

Note the 


* register order. For the complete story, read the ReportMouse AutoDoc. 


$f£f16 
Sff£10 
$ff0a 
$ff£04 
$fefe 
Sfef8 
$fef2 


$feec 
Sfee6 
$fee0 
$feda 
$fed4 


-$00ea 
-$00f0 
~$00f6 
-$00fe 
-$0102 
-$0108 
-$010e 


-$0114 
—$o0lla 
—-$0120 
~$0126 
—-$012c 


ReportMouse (Boolean , Window) (D0/A0) 

Request (Requester , Window) (A0/Al1) 

ScreenToBack (Screen) (A0) 

SereenToFront (Screen) (A0) 

SetDMRequest (Window, req) (A0/A1) 

SetMenuStrip (Window, Menu) (A0/A1) 

SetPointer(Window, Pointer ,Height , Width, Xoffset , Yoffset) 
(A0/A1 ,DO/D1/D2/D3) 

SetWindowTitles(window,windowtitle,screentitle) (A0/A1/A2) 

ShowTitle( Screen, ShowIt) (A0,D0) 

SizeWindow(window,dx,dy) (A0,DO0/D1) 

ViewAddress()() 

ViewPortAddress (window) (AQ) 





Sep 20 13:50 1988 1.3 Base Offset_Reference Page 7 





306 $fece -$0132 WindowToBack (window) (A0) 
312 $fec8 -$0138 WindowToFront (window) (AQ) 
318 $fec2 -$013e WindowLimits (window ,minwidth ,minheight ,maxwidth ,maxheight) 





(A0,D0/D1/D2/D3) 
*-—- start of next generation of names —-~~~7>eOO rns 
324 S$febc ~$0144 SetPrefs(preferences,size, flag) (A0,D0/D1) 
*-—-— start of next next generation Of MAM mmr 


330 $feb6 -$014a IntuiTextLength(itext) (AO) 

336 $feb0 —-$0150 WBenchToBack()() 

342 Sfeaa —$0156 WBenchToFront()() 

*-—- start of next next next generation of names —mr mtorr 

348 $fea4 —$015¢c AutoRequest (Window, Body, PText ,NText, PFlag,NFlag,W,H) 
(A0,A1,A2,A3,D0,D1,D2,D3) 

354 $fe9e -$0162 BeginRefresh(Window) (A0) 

360 $fe98 -$0168 BuildSysRequest (Window, Body, PosText ,NegText , Flags ,W,H) 
(AO, Al,A2,A3,D0,D1,D2) 

366 $fe92 -$0l6e EndRefresh(Window, Complete) (A0,D0) 

372 $fe8c -$0174 FreeSysRequest (Window) (A0) 

378 $fe86 -$017a MakeScreen(Screen) (A0) 

384 $fe80 -$0180 RemakeDisplay()() 

390 $fe7a —-$0186 RethinkDisplay()() : 

*-~~ start of next next next next generation of names —-—— 73 

396 $fe74 -$018c AllocRemember (Rememberkey ,Size,Flags) (A0,D0,D1) 

402 $fe6e —$0192 AlohaWorkbench(wbport) (A0) 

408 $fe68 -$0198 FreeRemember (RememberKey , ReallyForget) (A0,D0) 

* PointerColors(Screen,Red,Gren,Blue) (A0,D0,D1,D2) 

*--- start of 15 Nov 85 names -----——ooe rt 

414 $fe62 ~$019e LockIBase(dontknow) (D0) 

420 $fe5c —$0la4 UnlockIBase(IBLock) (A0) 

x-~- start of post-1.1 names ——-~ 

426 $fe56 ~-SOlaa GetScreenData(buffer,size,type, screen) (A0,D0,D1,Al) 

432 $fe50 -$01b0 RefreshGList (Gadgets ,Ptr,Req,NumGad) (A0/A1/A2 ,D0) 

438 $fe4a -$01b6 AddGList(AddPtr,Gadget , Position , NumGad, Requester) 
(A0/Al ,D0/D1/A2) 

444 $fe44 -SOlbc RemoveGList(RemPtr , Gadget ,NumGad) (A0/A1 ,D0) 

450 $fe3e -$01lc2 ActivateWindow( Window) (A0) 

456 $fe38 -$0lc8 RefreshWindowFrame (Window) (A0) 

462 $fe32 -$Olce ActivateGadget (Gadgets , Window, Req) (A0/A1/A2) 

468 S$fe2c -$01d4 NewModifyProp(Gadget , Ptr, Req, Flags ,HPos , VPos , HBody , VBody,, 
NumGad) (A0/A1/A2 ,D0/D1/D2/D3/D4/D5) 


FOI TOI IK ISR IA ISAK, Layers LL Dray RRR RR RIKI RI IR IRR IRR IR IRR ERE 
#t#base _LayersBase 


##bias 30 
30 $ffe2 -$00le InitLayers(1li)(A0) 
36 $ffde -$0024 CreateUpfrontLayer(li,bm,x0,y0,x1,yl, flags, bm2) 
(A0/A1 ,D0/D1/D2/D3/D4 , A2) 
42 $ffd6 -$002a CreateBehindLayer(1i,bm,x0,y0,x1,yl1,flags,bm2) 
(A0/Al ,D0/D1/D2/D3/D4 , A2) 
48 $ffd0 -$0030 UpfrontLayer(1li, layer) (A0/Al1) 
54 $ffca -$0036 BehindLayer(li, layer) (A0/Al) 
60 $ffc4 -$003c MoveLayer(1i,layer,dx,dy)(A0/Al ,D0/D1) 
66 $ffbe -$0042 SizeLayer(li,layer,dx,dy)(A0/Al,D0/D1) 
72 $ff£b8 -$0048 ScrollLayer(li,layer,dx,dy)(A0/Al,D0/D1) 
78 S$ffb2 -$004e BeginUpdate( layer) (A0) 
84 $ffac -$0054 EndUpdate(layer, flag) (A0,d0) 
90 $ffa6 -$005a DeleteLayer(li, layer) (A0/A1) 
96 $ffa0 -$0060 LockLayer(1li,layer) (A0/A1) 
102 $f££9a -$0066 UnlockLayer(layer) (A0) 
108 $£f£94 ~$006¢ LockLayers(1i)(A0) 
114 $f£ff£8e -$0072 UnlockLayers(1i)(A0) 
120 $££88 -$0078 LockLayerInfo(1i) (AQ) 
126 $ff£82 -$007e SwapBitsRastPortClipRect (rp,cr) (A0/Al) 
132 $f£7c —$0084 WhichLayer(1li,x,y) (a0,d0/d1) 
138 $f££76 -$008a UnlockLayerInfo(1i)(A0) 
144 $££70 -$0090 NewLayerInfo()() 
150 $ff6a -$0096 DisposeLayerInfo(11i) (a0) 
156 $ff£64 -$009c FattenLayerInfo(1li) (a0) 





Sep 20 13:50 1988 1.3 Base_Offset_Reference Page 8 


162 $ff5e -$00a2 ThinbayerInfo(1i) (a0) 

168 $££58 -$00a8 MoveLayerInFrontOf(layer_to_move, layer_to_be_infront_of) 
(a0/al) 

174 $££52 -$00ae InstallClipRegion(layer,region) (a0/al) 


JOE OOOO IO KEIR MAthi Ep. Library eter een eee aaa K REAR ERR ER ERE 


#tbase _MathBase 

##bias 30 

30 $ffe2 -$00le SPFix( float) (D0) 

36 $ffde -$0024 SPF1lt(integer) (D0) 

42 $f£fd6 -$002a SPCmp(leftFloat,rightFloat) (D1,D0) 
48 $ff£d0 -$0030 SPTst( float) (D1) 

54 $ffca ~$0036 SPAbs(float) (D0) 

60 $ffc4 -$003c SPNeg( float) (D0) 

66 $ffbe -$0042 SPAdd(leftFloat,rightFloat) (D1,D0) 
72 $ffb8 ~$0048 SPSub(leftFloat,rightFloat)(D1,D0) 
78 $ffb2 -$004e SPMul(leftFloat,rightFloat) (D1,D0) 
84 $ffac -$0054 SPDiv(leftFloat,rightFloat)(D1,D0) 
* New functions added for release 1.2 

90 $ffa6 -$005a SPFloor( float) (DO) 

96 $f£fa0 ~$0060 SPCeil( float) (DO) 


KREKEKREEEKKRE KEKE EREEERKEK mathieeedoubbas. library KREKKKEKEKKEEKKREREKREKKEEEE 
#t#base _MathIeeeDoubBasBase 
##bias 30 

30 $ffe2 -$00le IEEEDPFix(double) (D0/D1) 

36 $ffdce -$0024 IEEEDPF1t (integer) (D0) 

42 $ffd6 ~-$002a IEEEDPCmp(double, double) (D0/D1/D2/D3) 
48 Sf£d0 -$0030 IEEEDPTst (double) (D0/D1) 

54 $ffca -$0036 IEEEDPAbs(double) (D0/D1) 

60 $ffc4 -$003c IEEEDPNeg(double) (D0/D1) 

66 $ffbe -$0042 IEEEDPAdd (double, double) (D0/D1/D2/D3) 
72 $ff£b8 -$0048 IEEEDPSub(double, double) (D0/D1/D2/D3 ) 





78 $ffb2 -$004e IEEEDPMul (double, double) (D0/D1/D2/D3 ) 
84 Sffac -$0054 IBEEDPDiv(double, double) (D0/D1/D2/D3) 
* New functions added for release 1.2 

90 $ffa6 -$005a IEEEDPFloor(double) (D0/D1) 

96 $ffa0 -$0060 IEREDPCeil (double) (D0/D1) 





RAKKKEKRKEKEKRKEKEEKKEKKEEEEKKEEER mathieeedoubtrans. library HERE KKKKEKKEERKEKRKEEEEKEK 
#t#base _MathIeeeDoubTransBase 

##bias 30 

30 $ffe2 -$00le IEEEDPAtan(double) (D0/D1) 

36 $ffde -$0024 IBEEDPSin(double) (D0/D1) 

42 $ffd6 -$002a IEEEDPCos(double) (D0/D1) 

48 $ffd0 -$0030 IEEEDPTan(double) (DO0/D1) 

54 $ffca ~$0036 IEEEDPSincos (double, pf2)(A0,D0/D1) 
60 $ffc4 -$003c IEEEDPSinh(double)(D0/D1) 

66 $ffbe -$0042 IEEEDPCosh(double) (D0/D1) 

72 $ffb8 -$0048 IEEEDPTanh(double) (DO/D1) 

78 $ffb2 -$004e IEEEDPExp({double) (D0/D1) 

84 $ffac -$0054 IEEEDPLog(double) (D0/D1) 

90 $f£fa6 -$005a IEEEDPPow(exp,arg) (D2/D3 ,D0/D1) 

96 $ffa0 -$0060 IEEEDPSqrt (double) (D0/D1) 

102 $££9a -$0066 IEEEDPTieee(double) (D0/D1) 

108 $f££94 -$006c IEEEDPFieee(single) (D0) 

114 $ff£8e —$0072 IEEEDPAsin(double) (D0/D1) 

120 $££88 -$0078 IEBEEDPAcos(double) (D0/D1) 

126 $f£82 -$007e IEEEDPLogl0(double) (D0/D1) 


FOI TIO IIR IAI IAA ERATE MACHerans Library KAKA IKK RRA KR KKK EK RER ERE 
##base _MathTransBase 


t#bias 30 
30 $ffe2 -$00le SPAtan( float) (DO) 


36 $f£fdc -$0024 SPSin(float) (D0) 








Sep 20 13:50 1988 1.3 _Base Offset_Reference Page 9 


$ff£d6 ~-$002a SPCos(float) (D0) 
$ff£d0 -$0030 sPTan(float) (D0) 
$ffca -$0036 SPSincos(leftFloat,rightFloat)(D1,D0) 
$ffc4 -$003c SPSinh( float) (D0) 
$ffbe -$0042 SPCosh( float) (D0) 
$ffb8 -$0048 SPTanh( float) (DO) 
$ffb2 -$004e SPExp(float) (D0) 
$ffac -$0054 SPLog( float) (D0) 
$ffa6 -$005a SPPow(leftFloat,rightFloat) (D1,D0) 
$ffa0 -$0060 SPSqrt(float) (D0) 
$f££9a -$0066 SPTieee( float) (DO) 
$££94 -$006c SPFieee( integer) (D0) 
New functions added for Release 1.1 
SPAsin( float) (D0) 
SPAcos( float) (DO) 
126 $££82 -$007e SPLogl0( float) (DO) 


RHKKEKEKKKEKEKEREKREKKREKEKKKEK potgo. resource KEKKEKEKKEKEKKKRKKKKKKKEKEKEKKEKKEE 
##base _PotgoBase 
##bias 6 
6 $fffa ~$0006 AllocPotBits(bits) (D0) 
12 $ff£f£4 -$000c FreePotBits (bits) (D0) 
18 $ffee —$0012 WritePotgo(word,mask) (DO,D1) 


KEKEKKKEKKHEKKRERREKREKEKEKEEEKKK timer .device KAKA K IRE KK KEKE KEKE EE KEERER 
#ttbase _TimerBase 

#tbias 42 

42 $ffd6 -$002a AddTime(dest,src) (A0/A1) 

48 $ffd0 -$0030 SubTime(dest, sre) (AQ/A1} 

54 $ffca -$0036 CmpTime(dest, src) (A0/A1) 


KRKEEKEKEKIKEKREKKKKKEKREKREKEKREK translator. library RREKKKKKKKKKKKKKRKEKREEKKEERKEEK 

##base _TranslatorBase 

##bias 30 

30 $ffe2 -$00le Translate(inputString, inputLength, outputBuf fer ,bufferSize) 
(A0,DO/Al1,D1) 





Sep 20 14:00 1988 Assembly_Prefix_Reference Page 1 





ac_ graphics/gels.i 

af_ libraries/diskfont.i 
ahf_ libraries/diskfont.i 
ai_ graphics/rastport.i 
ao_ graphics/gels.i 

BB_ devices/bootblock.i 
bd_ intuition/intuition.i 
bi_ intuition/intuition.i 
bm_ graphics/gfx.i 

bn_ hardware/blit.i 

bob_ graphics/gels.i 

cbh_ libraries/configvars. i 
cd_ libraries/configvars. i 
ci_ graphics/copper.i 

cli_ libraries/dosextens.i 
el_ graphics/copper.i 

cm_ graphics/view.i 
copinit_ graphics/copper.i 

cp_ graphics/view.i 

erl_ graphics/copper. i 

cr_ graphics/clip.i 

cu_ devices/clipboard.i 

cu devices/conunit.i 

da_ libraries/configregs.i 
dbp_ graphics/gels.i 

dd_ devices/prtbase.i 

DD_ exec/devices.i 

dd_ workbench/workbench. i 
dfh_ libraries/diskfont.i 
di_ libraries/dosextens.i 
dl_ libraries/dosextens.i 
di_ libraries/dosextens-i 
an_ libraries/filehandler.i 
do_ workbench/workbench. i 
dp_ libraries/dosextens.i 
DRU_ resources/disk.i 

DR_ resources/disk.i 

ds_ libraries/dos.i 

ec_ libraries/configregs.i 
er_ libraries/configregs.i 
fch_ libraries/diskfont.i 
fc_ libraries/diskfont.i 
fh_ libraries/dosextens.i 
fib_ libraries/dos.i 

fl_ libraries/dosextens.i 
fl_ workbench/workbench. i 
fssm_ libraries/filehandler.i 
gb_ graphics/gfxbase.i 

gg_ intuition/intuition. i 
gi_ graphics/rastport.i 
gpt_ devices/gameport .i 

ib_ intuition/intuitionbase. i 
id_ libraries/dos.i 

ie_ devices/inputevent.i 
ig_ intuition/intuition.i 
in_ intuition/intuition.i 
ioa_ devices/audio.i 

locpr_ devices/printer.i 
iocr_ devices/clipboard.i 
iodrpr_ devices/printer.i 
IOEXPar_ devices/parallel.i 
IOEXTSER_ devices/serial.i 
IOSTD_ exec/io.i 

IOTD_ devices/trackdisk.i 
IOTV_ devices/timer.i 

IO_ devices/parallel.i 

Io_ exec/io.i 

lio_ devices/clipboard.i 


io_ devices/printer.i 





Sep 20 14:00 1988 Assembly Prefix_Reference Page 2 


Is_ exec/interrupts.i 

it_ intuition/intuition.i 
Iv_ exec/interrupts.i 
kn_ devices/keymap.i 

kn_ devices/keymap.i 

kr_ devices/keymap.i 

LH_ exec/lists.i 

LIB_ exec/libraries.i 

lie_ graphics/layers.i 

li graphics/layers.i 

LN_ exec/nodes.i 

ipd_ devices/prtbase.i 

ir graphics/clip. i 

MC_ exec/memory . 1 

ME_ exec/memory.i 

MH_ exec/memory.i 

mi intuition/intuition.i 
MLH_ exec/lists.i 

MLN_ exec/nodes.i 

ML_ exec/memory.i 

MN_ exec/ports.i 

MP_ exec/ports.i 

MRB_ devices/narrator.i 
mr_ resources/misc.i 

mu_ intuition/intuition.i 
NDI_ devices/narrator.i 
ns_ intuition/intuition.i 
nw_ intuition/intuition.i 
ped_ devices/prtbase.i 

pf_ intuition/intuition.i 
pi_ intuition/intuition.i 
pr_ libraries/dosextens.i 
ps_ devices/prtbase.i 
PTERMARRAY_ devices/parallel.i 
ra_ graphics/gfx.i 

rg_ graphics/regions. i 
ri_ graphics/view. i 

m_ intuition/intuition.i 
rm_ libraries/dosextens.i 
rp graphics/rastport.i 
rq_ intuition/intuition i 
rr_ graphics/regions.i 
RT_ exec/resident.i 

sc_ intuition/intuition.i 
SH_ exec/interrupts. i 

si_ intuition/intuition.i 
sm_ devices/clipboard.i 
SM_ exec/semaphores.i 
sm_ workbench/startup. i 
sp_ libraries/dosextens.i 
SSR_ exec/semaphores.i 

ss_ exec/semaphores. i 

ss_ graphics/sprite.i 

ta_ graphics/text.i 

TC exec/tasks .i 

TDU_ devices/trackdisk. i 
TERMARRAY  devices/serial.i 

tf_ graphics/text.i 

tr_ graphics/rastport.i 
TV devices/timer.i 

ucl_ graphics/copper.i 
UNIT_ exec/devices.i 

vp_ graphics/view.i 

vs_ graphics/gels.i 

v_ graphics/view.i 

wa_ workbench/startup.i 
wd _ intuition/intuition.i 


13:06 1988 C_Language_Cross-Reference Page 2 









Sep 21 13:06 1988 C_Language_Cross-Reference Page 1 















+0x0022 graphics/gfxbase.h: *26 


| cliprects pointer to struct ClipRect in struct Layer 
ac_dat unsigned short int in struct AudChannel 


+0x0040 graphics/clip.h: *42 































































































_ Cophist pointer to struct CopList in struct CopList +0x000a hardware/custom.h: *90 

+0x0004 graphics/copper.h: *58 ac_len unsigned short int in struct AudChannel 
| pl pointer to struct ClipRect in struct ClipRect +0x0004 hardware/custom.h: *87 

+0x0018 graphics/clip.h: *61 ac_pad array [2] of unsigned short int in struct AudChannel 
| p2 pointer to struct ClipRect in struct ClipRect +0x000c hardware/custom.h: *91 

+0x00le graphics/clip.h: *61 ac_per unsigned short int in struct AudChannel 
_ ViewPort pointer to struct ViewPort in struct CopList +0x0006 hardware/custom.h: *88 

+0x0008 graphics/copper.h: *59 ac_ptr pointer to unsigned short int in struct AudChannel 
ABC #define 0x80 =0x00000080 hardware/blit.h: *22 +0x0000 hardware/custom.h: *86 
aBMS #define 63 =0x0000003f devices/printer.h: *119 ac_vol unsigned short int in struct AudChannel 
ABNC #define 0x40 =0x00000040 hardware/blit.h: *23 +0x0008 hardware/custom.h: *89 
abs extern function returning float libraries/mathffp.h: *62 ADALLOC_MAXPREC #define 127 =0x0000007f devices/audio.h: *22 
ABSOLUTE DIMENSIONS #define 0x0020 =0x00000020 intuition/preferences.h: *243 ADALLOC_MINPREC #define -128 =Oxffffff80 devices/audio.h: *21 
aCAM #define 66 =0x00000042 devices/printer.h: *122 ADCMDB_NOUNIT #define 5 =0x00000005 devices/audio.h: *30 
ACCESS_READ #déefine -2 -=-Oxfffffffe libraries/dos.h: *45 ADCMDF_NOUNIT #define (1<<5) =0x00000020 devices/audio.h: *31 
ACCESS_WRITE #define -1 =Oxffffffff libraries/dos.h: *47 ADCMD_ALLOCATE #define (ADCMDF_NOUNIT+0) =0x00000020 devices/audio.h: *32 
acos #tdefine SPAcos =0x00000000 libraries/mathffp.h: *40 ADCMD_FINISH #define (CMD_NONSTD+2) =0x0000000b devices/audio.h: *26 
acos #define IEEEDPAcos =0x00000000 libraries/mathieeedp.h: *41 ADCMD_FREE #define (CMD_NONSTD+0) =0x00000009 devices/audio.h: *24 
ACTION _COPY_DIR #define 19 =0x00000013 libraries/dosextens.h: *130 ADCMD_LOCK #define (CMD_NONSTD+4) =0x0000000d devices/audio.h: *28 
ACTION CREATE DIR #define 22 =0x00000016 libraries/dosextens.h: *133 ADCMD_PERVOL #define (CMD_NONSTD+3) =0x0000000c devices/audio.h: *27 
ACTION CURRENT. ‘VOLUME #define 7 =0x00000007 libraries/dosextens.h: *121 ADCMD_SETPREC #define (CMD_NONSTD+1) =0x0000000a devices/audio.h: *25 
ACTION_DELETE_ OBJECT #define 16 =0x00000010 libraries/dosextens.h: *127 ADCMD WAITCYCLE #define (CMD_NONSTD+5) =0x0000000e devices/audio.h: *29 
ACTION _DIE #define 5 =0x00000005 libraries/dosextens.h: *119 AddFreeList extern function returning void workbench/icon.h: *31 













































ACTION_DISK.CHANGE #define 33 =0x00000021 libraries/dosextens.h: *144 aDEN1 #define 26 =0x000000la devices/printer.h: *61 
ACTION_DISK_INFO #define 25 =0x00000019 libraries/dosextens.h: *136 aDEN2 #define 25 =0x00000019 devices/printer.h: *60 
ACTION_DISK_TYPE #define 32 =0x00000020 libraries/dosextens.h: *143 aDEN3 #define 24 =0x00000018 devices/printer.h: *59 
ACTION_END #define 1007 =0x000003ef libraries/dosextens.h: *155 aDEN4 tdefine 23 =0x00000017 devices/printer.h: *58 
ACTION_EVENT #define 6 =0x00000006 libraries/dosextens.h: *120 aDEN5S #tdefine 22 =0x00000016 devices/printer.h: *57 
ACTION EXAMINE NEXT #define 24 =0x00000018 libraries/dosextens.h: *135 aDEN6 #define 21 =0x00000015 devices/printer.h: *56 
ACTION_EXAMINE OBJECT #define 23 =0x00000017 libraries/dosextens.h: *134 ADHARD_CHANNELS #define 4 =0x00000004 devices/audio.h: ¥*19 
ACTION_FINDINPUT #define 1005 =0x000003ed libraries/dosextens.h: *153 ADIOB_NOWAIT #define 6 =0x00000006 devices/audio.h: *38 
ACTION_FINDOUTPUT #define 1006 =0x000003ee libraries/dosextens.h: *154 ADIOB_PERVOL #define 4 =0x00000004 devices/audio.h: *34 





ADIOB_SYNCCYCLE #define 5 =0x00000005 devices/audio.h: *36 
ADIOB_WRITEMESSAGE #define 7 =0x00000007 devices/audio.h: *40 
ADIOERR_ALLOCFAILED #define ~1l =Oxfffffff{5 devices/audio.h: *44 
ADIOERR_CHANNELSTOLEN #define -12 =Oxfffff{ff4 devices/audio.h: *45 
ADIOERR_NOALLOCATION #define -10 =Oxfffffff6 devices/audio.h: *43 
ADIOF_NOWAIT #define (1<<6) =0x00000040 devices/audio.h: *39 
ADIOF_PERVOL #define (1<<4) =0x00000010 devices/audio.h: *35 
ADIOF_SYNCCYCLE #define (1<<5) =0x00000020 devices/audio.h: *37 
ADIOF_WRITEMESSAGE #define (1<<7) =0x00000080 devices/audio.h: *41] 
ADKB_FAST #define 8 =0x00000008 hardware/adkbits.h: *20 
ADKB MFMPREC #define 12 =0x0000000c hardware/adkbits.h: *16 
ADKB_MSBSYNC #tdefine 9 =0x00000009. hardware/adkbits.h: *19 
ADKB_PRECOMPO #define 13 =0x0000000d hardware/adkbits.h: *15 
ADKB_PRECOMP1 #define 14 =0x0000000e hardware/adkbits.h: *14 
ADKB_SETCLR #define 15 =0x0000000f hardware/adkbits.h: *13 
ADKB_ UARTBRK #define 11 =0x0000000b hardware/adkbits.h: *17 


ACTION_FINDUPDATE #define 1004 =0x000003ec libraries/dosextens.h: *152 
ACTION_FLUSH #define 27 =0x0000001b libraries/dosextens.h: *138 
ACTION_FREE_LOCK #define 15 =0x0000000f libraries/dosextens.h: *126 
ACTION_GET_BLOCK #define 2 =0x00000002 libraries/dosextens.h: *117 
ACTION INFO #define 26 =0x0000001la libraries/dosextens.h: *137 
ACTION_INHIBIT  #define 31 =0x0000001f libraries/dosextens.h: *142 
ACTION _LOCATE_OBJECT #define 8 =0x00000008 libraries/dosextens.h: *122 
. JACTION_MORE_CACHE #define 18 =0x00000012 libraries/dosextens.h: *129 
ACTION_NIL . #define 0 =0x00000000 libraries/dosextens.h: *116 
ACTION_PARENT #define 29 =0x0000001d libraries/dosextens.h: *140 
ACTION_READ #define 'R' =0x00000052 libraries/dosextens.h: *125 
ACTION _READ ) RETURN #define 1001 =0x000003e9 libraries/dosextens.h: *149 
ACTION_RENAME DISK #define 9 =0x00000009 libraries/dosextens.h: *123 
ACTION RENAME | | OBJECT #define 17 =0x00000011 libraries/dosextens.h: *128 
ACTION SCREEN MODE #define 994 =0x000003e2 libraries/dosextens.h: *147 
ACTION SEEK #define 1008 =0x000003f0 libraries/dosextens.h: *151 












































































































ACTION_SET_COMMENT #define 28 =0x000000lc libraries/dosextens.h: *139 ADKB_USEOP1L #define 4 =0x00000004 hardware/adkbits.h: *24 
ACTION _SET_ DATE | #define 34 =0x00000022 libraries/dosextens.h: *145 ADKB_USEOV1 #define 0 =0x00000000 hardware/adkbits.h: *28 
ACTION SET MAP  #define 4 =0x00000004 libraries/dosextens.h: *118 ADKB_USE1P2 #define 5 =0x00000005 hardware/adkbits.h: *23 
ACTION_SET PROTECT #define 21 =0x00000015 libraries/dosextens.h: *132 ADKB_USE1V2 #define 1 =0x00000001 hardware/adkbits.h: *27 
ACTION TIMER #define 30 =0x000000le libraries/dosextens.h: *141 ADKB_USE2P3 #tdefine 6 =0x00000006 hardware/adkbits.h: *22 
ACTION_TRUNCATE #define 1022 =0x000003fe libraries/dosextens.h: *156 ADKB_USE2V3 #define 2 =0x00000002 hardware/adkbits.h: *26 
ACTION_WAIT CHAR #define 20 =0x00000014 libraries/dosextens.h: *131 ADKB_USE3PN #define 7 =0x00000007 hardware/adkbits.h: *21 
ACTION _WRITE #define 'W' =0x00000057 libraries/dosextens.h: *124 ADKB_USE3VN #define 3 =0x00000003 hardware/adkbits.h: *25 
ACTION_WRITE PROTECT #define 1023 =0x000003ff libraries/dosextens.h: *157 ADKB_WORDSYNC #define 10 =0x0000000a hardware/adkbits.h: *18 
ACTION WRITE RETURN #define 1002 =0x000003ea -libraries/dosextens.h:. *150 adkcon unsigned short int in struct Custom 
ACTIVATE #define 0x1000 =0x00001000 intuition/intuition.h: *822 +0x009e hardware/custom.h: *84 
Activation unsigned short int in struct Gadget adkconr unsigned short int in struct Custom 
+0x000e intuition/intuition.h: *202 +0x0010 hardware/custom.h: *28 
ActiveScreen pointer to struct Screen in struct IntuitionBase ADKF_FAST #define (1<<8) =0x00000100 hardware/adkbits.h: *37 
+0x0038 intuition/intuitionbase.h: *153 ADKF _MFMPREC #define (1<<12) =0x00001000 hardware/adkbits.h: *33 
ACTIVEWINDOW #define 0x00040000 =0x00040000 intuition/intuition.h: *656 ADKF_MSBSYNC #define (1<<9) =0x00000200 hardware/adkbits.h: *36 
ActiveWindow pointer to struct Window in struct IntuitionBase ADKF_PREOOONS #define 0 =0x00000000 hardware/adkbits.h: *47 





ADKF_PRE140NS #define (ADKF_PRECOMPO) =0x00002000 hardware/adkbits.h: *48 


+0x0034 intuition/intuitionbase.h: *152 
ADKF_PRE280NS #define (ADKF_PRECOMP1) =0x00004000 hardware/adkbits.h: *49 


Actiview pointer to struct View in struct GfxBase 











Sep 21 13:06 1988 C_Language_Cross-Reference Page 3 


ADKF_PRE560NS 


ADKF_PRECOMPO 
ADKF PRECOMP1 
ADKF_SETCLR 
ADKF_UARTBRK 
ADKF USEOP1 
ADKF_USEOV1 
ADKF USE1P2 
ADKF_USE1V2 
ADKF_USE2P3 
ADKF_USE2V3 
ADKF_USE3PN 
ADKF _USE3VN 
ADKF_WORDSYNC 
ADNB_STARTPROC 
ADNF_STARTPROC 
aEXTEND 

AFB 68010 
AFB_68020 
AFB_68881 
AFB_DISK 
AFB_MEMORY 
AFB_RESERVED8 
AFB_RESERVED9 


AFF_68010 
AFF_68020 
AFF_68881 
AFF_DISK 
AFF MEMORY 
afh_NumEntries 
+0x0000 
aFNTO 
aFNT1 
aFNT1O 
aFNT2 
aFNT3 
aFNT4 
aFNTS 
aFNT6 
aFNT7 
aFNT8 
aFNT9 
afp 
After 
+0x000e 
af_Attr 
+0x0002 
af_Type 
+0x0000 
AGNUS 
AG_IOError 
AG_MakeLib 


AG_NoMemory 


AG_NoSignal 

AG_OpenDev 

AG_OpenLib 

AG_OpenRes 

aHTS 

aIND 

aJFYO 

aJFY1 

aJFY3 

aJFY5 

aJFY6 

aJFY7 

AlertData 
+0x004a 

ALERTLAYERSNOMEM 


#define (ADKF_PRECOMPO|ADKF PRECOMP1) =0x00006000 


hardware/adkbits.h: 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
unsign 


*50 


(1<<13) =0x00002000 hardware/adkbits.h: *32 
(1<<14) =0x00004000 hardware/adkbits.h: *31 
(1<<15) =0x00008000 hardware/adkbits.h: *30 
(1<<11) =0x00000800 hardware/adkbits h h: *34 


(1<<4) =0x00000010 
(1<<0) =0x00000001 
(1<<5) =0x00000020 
(1<<1) =0x00000002 
(1<<6) =0x00000040 
(1<<2) =0x00000004 
(1<<7) =0x00000080 
(1<<3) =0x00000008 
(1<<10) =0x00000400 hardware/adkbits. h: 


hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 
hardware/adkbits. 


0 =0x00000000 libraries/expansion.h: 


(1<<0) =0x00000001 libraries/expansion.h: 
75 =0x0000004b devices/printer.h: 
exec/execbase.h: 
exec/execbase.h: 
exec/execbase.h: 
libraries/diskfont.h: 
libraries/diskfont.h: 
exec/execbase.h: 
exec/execbase.h: 


0 
1 
4 
1 
0 
8 


9 


=0x00000000 
=0x00000001 
=0x00000004 
=0x00000001 
=0x00000000 
=0x00000008 
=0x00000009 


*127 
*128 
*129 


*141 
*142 


(1<<0) =0x00000001 exec/execbase.h: 
(1<<1) =0x00000002 exec/execbase.h: 
(1<<4) =0x00000010 exec/execbase.h: 
2 =0x00000002 libraries/diskfont.h: 
1 =0x00000001 libraries/diskfont.h: 


libraries/diskfont.h: 


#define 3 


#define 
#define 
#tdefine 
#tdefine 
#define 
#define 
#tdefine 
#define 
#define 
#define 


43 


=0x00000022 
=0x00000023 
=0x0000002c 
=0x00000024 
=0x00000025 
=0x00000026 
=0x00000027 
=0x00000028 
=0x00000029 
=0x0000002a 
=0x0000002b 


STOOP Pres 


*41 
*45 
*40 
*44 
*39 
*43 
*38 
*42 


*16 


*132 


*62 
*60 


*131 
*132 
*133 
*63 
*61 


*35 
*18 


devices/printer 


devices/printer. 
devices/printer. 
devices/printer. 
devices/printer. 
devices/printer. 
extern function returning float Libraries/mathf fp. h: 


pointer to struct Bob in struct Bob 


graphics/gels.h: 


*153 


struct TextAttr (size 
libraries/diskfont.h: 
unsigned short int in 
libraries/diskfont.h: 


#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 
#define 
#tdefine 
#tdefine 
#define 
#tdefine 
#define 
#define 
#tdefine 
pointer 


#define 0x83010000 ~0x83010000 graphics/layers.h: 


ox 
Ox 
Ox 
Ox 
Ox 
ox 
Ox 


67 =0x00000043 devices/printer.h: 


*16 


BB bt br br bt ot bt Br bt be 


00060000 =0x00060000 exec/alerts. 
00020000 =0x00020000 exec/alerts. 
00010000 =0x00010000 exec/alerts. 
00070000 =0x00070000 exec/alerts. 
00040000 =0x00040000 exec/alerts. 
00030000 =0x00030000 exec/alerts. 
00050000 =0x00050000 exec/alerts. 


2 =0x00000002 devices/printer.h: *3 


to 


=0x00000034 devices/printer. 
=0x00000036 devices/printer. 
=0x00000035 devices/printer. 
=0x00000031 devices/printer. 
=0x00000033 devices/printer. 
=0x00000032 devices/printer. 


PERE Eb 


ed short int in struct AvailFontsHeader 
*71 

devices/printer. 
devices/printer. 
devices/printer. 
devices/printer. 
devices/printer. 


*71 
*72 
*81 
*73 
*74 
*75 
*76 
*77 
*78 
*79 
*80 


4 


0x0008) in struct AvailFonts 
*67 

struct AvailFonts 
*66 
=0x00000000 graphics/gfx.h: 


*46 


PERE ere 


«42 
AL 
«47 
*44 
*43 
45 


*124 


h: *106 
*108 
*107 
*103 
*105 
*104 


pointer to char in struct ExecBase 
exec/execbase.h: *44 


*50 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 4 


ALERT TYPE 

AlgoStyle 
+0x0038 

AllocConfigDev 


#define 0x80000000 =0x80000000 intuition/intuition.h: *986 

char in struct RastPort 

graphics/rastport.h: *73 

extern function returning pointer to struct ConfigDev (size 0x44) 
libraries/configvars.h: *56 


libraries/expansion.h: *23 


AllocExpansionMem extern function returning "CPTR" libraries/expansion.h: *24 


AllocTable 
+0x0058 
AllocWBObject. 


aLMS 
ALPHA_P_101 
ALTKEYMAP 
AltKeyMap 
+0x0020 
ALTLEFT 


ALTRIGHT 
AMIGAKEYS 
AMIGALEFT 
AMIGARIGHT 


ANBC 
ANBNC 
aNEL 
ANFRACSIZE 
AnimBob 

+0x0022 
AnimComp 

size 0x0026 

AnimCRoutine 

+0x0016 
ANIMHALF 
AnimOb 

size 0x002a 

AnimORoutine 

+0x0020 
AnoO1dx 

+0x000e 
AnOldy 

+0x000c 
ANTI_ALIAS 
AnX 

+0x0012 
AnY 

+0x0010. 
AN_AddswGadget 
AN_AsyncPkt 
AN_AudioDev 
AN BadChksum 


AN_BadExpansionFree #define 0x0A000001 —0x0a000001 exec/alerts.h: 


AN_BadGadget. 
AN_BadMessage 
AN_BadOverlay 
AN_BadSegList 
AN_BadState 
AN_BaseChkSum 
AN_BitMap 
AN_B1tBitMap 
AN_BogusExcpt 
AN _BootError 
AN_BootStrap 
AN_CIARsre 
AN_CListLib 
AN_ConsoleDev 


array {256] of char in struct ExpansionBase 
libraries/expansionbase.h: *53 

extern function returning pointer to struct WBObject (size 0x000) 
workbench/icon.h: *28 

#define 60 =0x0000003c devices/printer.h: *116 
#tdefine 0x01 =0x00000001 intuition/preferences.h: 
#define 0x1000 =0x00001000 intuition/intuition.h: 
pointer to struct KeyMap in struct StringInfo 
intuition/intuition.h: *479 

#define (IEQUALIFIER_LALT) =0x00000010 
intuition/intuition.h: *1010 

#define (IEQUALIFIER_RALT) =0x00000020 
intuition/intuition.h: *1011 

#define (AMIGALEFT | AMIGARIGHT) =0x000000c0 
intuition/intuition.h: *1014 

#define (IEQUALIFIER_LCOMMAND) =0x00000040 
intuition/intuition.h: *1012 

#define (IEQUALIFIER_RCOMMAND) =0x00000080 
intuition/intuition.h: *1013 

#define 0x20 =0x00000020 hardware/blit.h: *24 
#define 0x10 =0x00000010 hardware/blit.h: *25 
#define 3 =0x00000003 devices/printer.h: *35 
#define 6 =0x00000006 graphics/gelis.h: *40 
pointer to struct Bob in struct AnimComp 
graphics/gels.h: *196 

structure tag 

graphics/gels.h: 157, *164, 182, 183, 186, 187, 221 
pointer to function returning short int in struct AnimComp 
graphics/gels.h: *189 

#tdefine 0x0020 =0x00000020 graphics/gels.h: *41 

structure tag 

graphics/gels. h: 194, *199, 202 

pointer to function returning short int in struct AnimOb 
graphics/gels.h: *218 

short int in struct AnimOb 

graphics/gels. h: *207 

short int in struct AnimOb 

graphics/gels.h: *207 

#define 0x0800 =0x00000800 intuition/preferences.h: 
short int in struct AnimoOb 

graphics/gels.h: *210 

short int in struct AnimOb 

graphics/gels.h: *210 

#define 0x8401000A =0x8401000a exec/alerts.h: 
#define 0x07000004 =0x07000004 exec/alerts.h: 
#define 0x10000000 =0x10000000 exec/alerts.h: 
#tdefine 0x07000009 =0x07000009 exec/alerts.h: 


*187 
*323 


*253 


*119 
*138 
*160 
*143 
*157 


#define 0x04000001 =0x04000001 exec/alerts.h: *110 
#define 0x8400000D =0x8400000d exec/alerts.h: *122 
#define 0x0700000C =0x0700000c exec/alerts.h: *146 
#define 0x08000001 =0x08000001 exec/alerts.h: *150 
#define 0x8400000C =0x8400000c exec/alerts.h: *121 
#define 0x81000002 =0x81000002 exec/alerts.h: *82 

#define 0x07000007 =0x07000007 exec/alerts.h: *141 
#define 0x8201000A =0x8201000a exec/alerts.h: *98 

#tdefine 0x8100000A =0x8100000a exec/alerts.h: *90 

#define 0x30000001 =0x30000001 exec/alerts.h: *194 
#define 0x30000000 =0x30000000 exec/alerts.h: *193 
#tdefine 0x20000000 =0x20000000 exec/alerts.h: *182 
#define 0x06000000 =0x06000000 exec/alerts.h: *131 
#define 0x11000000 =0x11000000 exec/alerts.h: *163 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 5 Sep 21 13:06 1988 C_Language_Cross-—Reference Page 6 


AO_ExpansionLib #define 0x0000800A =0x0000800a exec/alerts. 
AO_GamePortDev #define 0x00008012 =0x00008012 exec/alerts. 
AO_GraphicsLib #define 0x00008002 =0x00008002 exec/alerts. 
AO_IconLib #define 0x00008009 =0x00008009 exec/alerts. 
AO_Intuition #define 0x00008004 =0x00008004 exec/alerts. 
AO_KeyboardDev #define 0x00008013 =0x00008013 exec/alerts. 
AO_LayersLib #define 0x00008003 =0x00008003 exec/alerts. 
AO_MathLib #define 0x00008005 =0x00008005 exec/alerts. 
AO_MiscRsre #define 0x00008022 =0x00008022 exec/alerts. 
AO_RAMLib #define 0x00008008 =0x00008008 exec/alerts. 
AO_TimerDev #tdefine 0x00008015 =0x00008015 exec/alerts. 
AO_TrackDiskDev #define 0x00008014 =0x00008014 exec/alerts. 
AO_Workbench #define 0x00008031 =0x00008031 exec/alerts. 
E] #define 58 =0x0000003a devices/printer.h: *113 
#tdefine 59 =0x0000003b devices/printer.h: *114 
#tdefine 33 =0x00000021 devices/printer.h: *69 
#define 32 =0x00000020 devices/printer.h: *68 
#tdefine 47 =0x0000002f devices/printer.h: *101 
#define 46 =0x0000002e devices/printer.h: *100 

h 

h 

h 

h 


AN_CreatePort #define 0x84010002 =0x84010002 exec/alerts. 
AN_DiskBlkSeq #define 0x07000006 =0x07000006 exec/alerts. 
AN_DiskCopy #define 0x32000000 =0x32000000 exec/alerts. 
AN_DiskError #define 0x0700000A =0x0700000a exec/alerts. 
AN_DiskRsre #define 0x21000000 =0x21000000 exec/alerts. 
AN_DOSLib #define 0x07000000 =0x07000000 exec/alerts. 
AN_DRHasDisk #define 0x21000001 =0x21000001 exec/alerts. 
AN_DRIntNoAct #define 0x21000002 =0x21000002 exec/alerts. 
#define 0x07000002 =0x07000002 exec/alerts. 
#define 0x81000001 =0x81000001 exec/alerts. 
#define 0x01000000 =0x01000000 exec/alerts. 
#define 0x0A000000 =0x0a000000 exec/alerts. 
#define 0x81000009 =0x81000009 exec/alerts. 
#define 0x07000005 =0x07000005 exec/alerts 
#define 0x84000001 =0x84000001 exec/alerts. 
#define 0x12000000 =0x12000000 exec/alerts. 
#define 0x82011234 =0x82011234 exec/alerts. 
#define 0x82010000 =0x82010000 exec/alerts. 
AN | GraphicsLib #define 0x02000000 =0x02000000 exec/alerts. 
AN_IconLib #define 0x09000000 =0x09000000 exec/alerts. 
AN_InitaPtr #define 0x81000007 =0x81000007 exec/alerts. 
AN_IntrMem #define 0x81000006 =0x81000006 exec/alerts. 
AN_Intuition #define 0x04000000 =0x04000000 exec/alerts. 
AN_ItemAlloc #define 0x04010003 =0x04010003 exec/alerts. 
AN_ItemBoxTop #define 0x84000006 =0x84000006 exec/alerts. 
AN_KeyboardDev #define 0x13000000 =0x13000000 exec/alerts. 
AN_KeyFree #define 0x07000008 =0x07000008 exec/alerts. 
AN_KeyRange #define 0x0700000B =0x0700000b exec/alerts. 
AN_LayersLib #define 0x03000000 =0x03000000 exec/alerts. 
AN_LayersNoMem #define 0x83010000 =0x83010000 exec/alerts. 
i #define 0x81000003 =0x81000003 exec/alerts. 
#define 0x81000004 =0x81000004 exec/alerts. 
#define 0x82010006 =0x82010006 exec/alerts. 
#define 0x82010030 =0x82010030 exec/alerts. 
#define 0x05000000 =0x05000000 exec/alerts. 
#define 0x81000005 =0x81000005 exec/alerts. 
#define 0x22000000 =0x22000000 exec/alerts. 
#define 0x8400000F =0x8400000f exec/alerts. 
#define 0x84010007 =0x84010007 exec/alerts. 
#define 0x84010008 =0x84010008 exec/alerts. 
#define 0x8401000B =0x8401000b exec/alerts. 
#define 0x84010005 =0x84010005 exec/alerts. 
#define 0x07000003 =0x07000003 exec/alerts. 
#define 0x08000000 =0x08000000 exec/alerts. 
#define 0x8201000B =0x8201000b exec/alerts. 
#define 0x81000008 =0x81000008 exec/alerts. 
#define 0x82010007 =0x82010007 exec/alerts 
#define 0x07010001 =0x07010001 exec/alerts 
#define 0x04010004 =0x04010004 exec/alerts 
#define 0x84000009 =0x84000009 exec/alerts 
#define 0x14000001 =0x14000001 exec/alerts 
#define 0x14000002 =0x14000002 exec/alerts 
#define 0x02010009 =0x02010009 exec/alerts 
#define 0x15000000 =0x15000000 exec/alerts 
#define 0x15000001 =0x15000001 exec/alerts 
#define 0x15000002 =0x15000002 exec/alerts 
AN_TrackDiskDev #define 0x14000000 =0x14000000 exec/alerts. 
AN WeirdEcho #define 0x8400000R =0x8400000e exec/alerts. #define 19 ~0x00000013 devices/printer.h: *53 
AN Workbench #define 0x31000000 =0x31000000 exec/alerts. #define SPAsin =0x00000000 libraries/mathf fp. h: *42 
AO1lPen char in struct RastPort i #define IEEEDPAsin =0x00000000 libraries/mathieeedp.h: *43 
+0x001lb graphics/rastport.h: *61 #define 57 =0x00000039 devices/printer.h: *112 
AO_AudioDev #define 0x00008010 =0x00008010 exec/alerts. #define 65 =0x00000041 devices/printer.h: *121 
AO_BootStrap #define 0x00008030 =0x00008030 exec/alerts. #define 0x00 =0x00000000 intuition/preferences.h: *170 
AO_CIARsrc #define 0x00008020 =0x00008020 exec/alerts. fdefine 0x01 =0x00000001 intuition/preferences.h: *171 
AO_CListLib #define 0x00008006 =0x00008006 exec/alerts. #define 64 =0x00000040 devices/printer.h: *120 
AO_ConsoleDev #define 0x00008011 =0x00008011 exec/alerts. #tdefine 31 =0x0000001f devices/printer.h: *67 
AO_DiskRsre #define 0x00008021 =0x00008021 exec/alerts. tdefine 28 =0x000000le devices/printer.h: *64 
AO_DOSLib #define 0x00008007 =0x00008007 exec/alerts. fdefine 27 =0x0000001b devices/printer.h: *63 
AO_ExecLib #define 0x00008001 =0x00008001 exec/alerts. #tdefine 30 =0x000000le devices/printer.h: *66 


POOP Pree rer 


#define 45 =0x0000002d devices/printer.h: *99 
typedef pointer to "STRPTR" 
many references; defined in exec/types. 
#define 76 =0x0000004c devices/printer. 
Macro (4 arguments) graphics/gfxmacros. 
structure tag 
graphics/rastport.h: *17, 56 
pointer to struct AreaInfo in struct RastPort 
graphics/rastport.h: *56 
#define 0x08 =0x00000008 graphics/rastport.h: *101 
pointer to unsigned short int in struct RastPort 
graphics/rastport.h: *54 
char in struct RastPort 
graphics/rastport.h: *63 
#define 4 =0x00000004 devices/printer.h: *36 
#define 1 =0x00000001 devices/printer.h: *33 
#define 0 =0x00000000 devices/printer.h: *32 
#define 61 =0x0000003d devices/printer.h: *117 
unsigned short int in struct ExpansionInt 
libraries/expansionbase.h: *38 
unsigned short int in struct ExpansionInt 
libraries/expansionbase.h: *39 
#define 13 =0x0000000d devices/printer.h: *46 
#define 12 =0x0000000c devices/printer.h: *45 
#tdefine 5 =0x00000005 devices/printer.h: *38 
#define 10 =0x0000000a devices/printer.h: *43 
#define 11 =0x0000000b devices/printer.h: *44 
#define 7 =0x00000007 devices/printer.h: *40 
#define 9 =0x00000009 devices/printer.h: *42 
#define 6 =0x00000006 devices/printer.h: *39 
#define 8 =0x00000008 devices/printer.h: *41 
#define 12 =0x0000000c hardware/blit.h: *53 
#define 14 =0x0000000e devices/printer. *48 
#define 16 =0x00000010 devices/printer.h: *50 
#define 15 =0x0000000f devices/printer.h: *49 
#tdefine 18 =0x00000012 devices/printer.h: *52 
#define 17 =0x00000011 devices/printer.h: *51 
#define 20 =0x00000014 devices/printer.h: *54 


: *30 
: *134 
: *38 


DESDE DPSS PSPS SDP OSE SPE ESS SSS PSP bbb bb bbb bb bb bb 





OT - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 7 


aSuSs4 
atan 
atan 
aTBCO 
aTBClL 
aTBC3 
aTBC4 
aTBCALL 
aTBSALL 
aTMS 
aTSS 
AttnFlags 
+0x0128 
AttnResched 
+0x012a 
AT_DeadEnd 
AT_Recovery 
aud 
+0x00a0 
AudChannel 
size 0x0010 
AUDIONAME 
AUL 
AUserExt 
+0x0028 
AUserStuff 
AUTOBACKPEN 
AUTODRAWMODE 
AUTOFRONTPEN 
AUTOITEXTFONT 
AUTOKNOB 
AUTOLEFTEDGE 
AUTONEXTTEXT 
AUTOTOPEDGE 
AvailFonts 
size 0x000a 
AvailFontsHeader 
size 0x0002 
aVERPO 
aVERP1 
avTs 
A_OR_B 


A_OR_C 


A_TO_D 
A_XOR_C 


B2BOBBER 
B2NORM 
B2SWAP 
back 
+0x0004 
BACKDROP 
BackFill 
+0x00le 
BackPen 
+0x0001 
BackPen 
+0x0005 
BACKSAVED 
BadBlockBlock 
BadBlockEntry 
BADDR 
BarHBorder 
+0x0020 
BarHeight 
+0x00le 
BarLayer 


#tdefine 29 =0x0000001d devices/printer.h: *65 
#define SPAtan =0x00000000 libraries/mathffp.h: *38 
#define IEEEDPAtan =0x00000000 libraries/mathieeedp.h: *39 


#define 69 =0x00000045 devices/printer.h: *126 
#define 71 =0x00000047 devices/printer.h: *128 
#define 70 =0x00000046 devices/printer.h: *127 
#define 72 =0x00000048 devices/printer.h: *129 
#define 73 =0x00000049 devices/printer.h: *130 
#define 74 =0x0000004a devices/printer.h: *131 
#define 62 =0x0000003e devices/printer.h: *118 
#define 48 =0x00000030 devices/printer.h: *102 


unsigned short int in struct ExecBase 
exec/execbase.h: *64 

unsigned short int in struct ExecBase 
exec/execbase.h: *65 

#define 0x80000000 =0x80000000 exec/alerts.h: *37 
#define 0x00000000 =0x00000000 exec/alerts.h: *38 
array [4] of struct AudChannel (size 0x0010) in struct Custom 
hardware/custom.h: *92 

structure tag in struct Custom 

hardware/custom.h: *85 

#define "audio.device" devices/audio.h: *17 

#define 0x4 =0x00000004 hardware/blit.h: *68 

short int in struct AnimOob 

graphics/gels.h: *223 

#define SHORT =0x00000000 graphics/gels.h: *60, 223 

#define 1 =0x00000001 intuition/intuition.h: *997 

#define JAM2 =0x00000001 intuition/intuition.h: *998 

#define 0 =0x00000000 intuition/intuition.h: *996 

#define NULL =0x00000000 intuition/intuition.h: *1001 
#tdefine 0x0001 =0x00000001 intuition/intuition.h: *429 
#define 6 =0x00000006 intuition/intuition.h: *999 

#define NULL =0x00000000 intuition/intuition.h: *1002 
#define 3 =0x00000003 intuition/intuition.h: *1000 

structure tag 

libraries/diskfont.h: *65 

structure tag 

libraries/diskfont.h: *70 

#define 55 =0x00000037 devices/printer.h: *110 

#define 56 =0x00000038 devices/printer.h: *111 

#define 68 =0x00000044 devices/printer.h: *125 

#define ABC|ANBC|NABC | ABNC|ANBNC|NABNC =0x000000fc 
hardware/blit.h: *32 

#define ABC|NABC|ABNC | ANBC|NANBC|ANBNC =0x000000fa 
hardware/blit.h: *33 

#define ABC|ANBC|ABNC|ANBNC =0x000000f0 hardware/blit.h: *35 
#define NABC|ABNC | NANBC|ANBNC =0x0000005a 

hardware/blit.h: *34 

#define 2 =0x00000002 graphics/gels.h: *254 

#define 0 =0x00000000 graphics/gels.h: *252 

#define 1 =0x00000001 graphics/gels.h: ¥*253 

pointer to struct Layer in struct Layer 

graphics/clip.h: *27 

#define 0x0100 =0x00000100 intuition/intuition.h: *814 

char in struct Requester 

intuition/intuition.h: *155 

char in struct IntuiText 

intuition/intuition.h: *496 

char in struct Border 

intuition/intuition.h: *525 

#define 0x0100 =0x00000100 graphics/gels.h: *21 

structure tag size 0x0200 devices/hardblocks.h: *112 
structure tag size 0x0008 devices/hardblocks.h: *107, 119 
Macro (1 argument) libraries/dos.h: *100 
char in struct Screen 
intuition/screens.h: *56 

char in struct Screen 
intuition/screens.h: *56 

pointer to struct Layer in struct Screen 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 8 


+0x01l4e 
BarVBorder 

+0x001LE 
BaudRate 

+0x0002 
BAUD_110 
BAUD_1200 
BAUD_19200 
BAUD _2400 
BAUD_300 
BAUD_4800 
BAUD_9600 
BAUD_MIDI 
bbb_BlockPairs 


+0x0018 
bbb_ChkSum 
+0x0008 
bbb_HostID 
+0x000c 
bbb_ID 
+0x0000 
bbb_Next 
+0x0010 
bbb_Reserved 
+0x0014 
bbb_SummedLongs 
+0x0004 
bbe_BadBlock 
+0x0000 
bbe_GoodBlock 
+0x0004 
BBID_DOS 
BBID_KICK 
BBNAME_DOS 


BBNAME_KICK 


bb_chksum 

+0x0004 
bb_dosblock 

+0x0008 
bb_id 

+0x0000 
BCOB DEST 
BCOB_SRCA 
BCOB_SRCB 
BCOB_SRCC 
BCOF_DEST 
BCOF_SRCA 
BCOF_SRCB 
BCOF_SRCC 
BCIF_DESC 
BDRAWN 
BeamSync 

+0x00a2 
beamsync 

+0x000c 
BeatX 

+0x001a 
BeatY 

+0x001c¢ 
BEEP ING 
Before 


BgPen 
+0x001la 
BindSemaphore 
+0x0158 


+0x000a 


intuition/screens.h: *81 

char in struct Screen 
intuition/screens.h: *56 

unsigned short int in struct Preferences 
intuition/preferences.h: *51 


#define 0x00 =0x00000000 intuition/preferences.h: *139 
#define 0x02 =0x00000002 intuition/preferences.h: *141 
#define 0x06 =0x00000006 intuition/preferences.h: *145 
#define 0x03 =0x00000003 intuition/preferences.h: *142 
#define 0x01 =0x00000001 intuition/preferences.h: *140 
#define 0x04 =0x00000004 intuition/preferences.h: *143 
#define 0x05 =0x00000005 intuition/preferences.h: *144 
#define 0x07 =0x00000007 intuition/preferences.h: *146 
array [61] of struct BadBlockEntry (size 0x0008) in struct 


BadBlockBlock 

devices/hardblocks.h: *119 

int in struct BadBlockBlock 

devices/hardblocks.h: *115 

unsigned int in struct BadBlockBlock 
devices/hardblocks.h: *116 

unsigned int in struct BadBlockBlock 
devices/hardblocks.h: *113 

unsigned int in struct BadBlockBlock 
devices/hardblocks.h: *117 

unsigned int in struct BadBlockBlock 
devices/hardbiocks.h: *118 

unsigned int in struct BadBlockBlock 
devices/hardblocks.h: *114 

unsigned int in struct BadBlockEntry 
devices/hardblocks.h: *108 

unsigned int in struct BadBlockEntry 
devices/hardblocks.h: *109 

#tdefine { 'D', 'O', 'S', '\O' } devices/bootblock.h: *21 
#define { 'K', 'I', 'C', 'K'! } devices/bootblock.h: *22 
#define (('D'<<24) |('O'<<16) | ('S'<<8)) =0x444£5300 
devices/bootblock.h: *24 

#define (('K'<<24)|('I'<<16) | ('C'<<8) |('K')) =0x4b49434b 
devices/bootblock.h: *25 

int in struct BootBlock 
devices/bootblock.h: *15 

int in struct BootBlock 
devices/bootblock.h: *16 

array [4] of char in struct BootBlock 
devices/bootblock.h: *14 

#define 8 =0x00000008 hardware/blit.h: *37 
#define 11 =0x0000000b. hardware/blit.h: *40 
#define 10 =0x0000000a hardware/blit.h: *39 
#define 9 =0x00000009 hardware/blit.h: ¥*38 
#define 0x100 =0x00000100 hardware/blit.h: 
#define 0x800 =0x00000800 hardware/blit.h: 
#define 0x400 =0x00000400 hardware/blit.h: 
#define 0x200 =0x00000200 hardware/blit.h: 
#define 2 =0x00000002 hardware/blit.h: *46 
#define 0x0200 =0x00000200 graphics/gels.h: *33 

short int in struct GfxBase 

graphics/gfxbase.h: *40 

short int in struct bltnode 

hardware/blit.h: *86 

short int in struct Menu 

intuition/intuition.h: *67 

short int in struct Menu 

intuition/intuition.h: *67 

#define 0x0020 =0x00000020 intuition/screens.h: *100 
pointer to struct Bob in struct Bob 

graphics/gels.h: *152 

char in struct RastPort 

graphics/rastport.h: *60 

struct SignalSemaphore (size 0x002e) in struct ExpansionBase 
libraries/expansionbase.h: *54 


*41 
44 
*43 
*42 








Il -H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 9 


p 
size 0x0028 


+0x000c 
+0x0004 
+0x0004 
+0x0022 
+0x00b8 


BITSPERBYTE 
BITSPERLONG 


+0x000b 
+0x0074 
+0x0044 
+0x0046 
+0x0064 
+0x0050 
+0x0072 
+0x0062 
+0x004c 
+0x0070 
+0x0060 
+0x0040 
+0x0042 


#define 0 =0x00000000 graphics/gfx.h: *14 
structure tag 

graphics/gfx.h: *36 

graphics/clip.h: 34, 59 

graphics/view.h: 72 

graphics/rastport.h: 53 
intuition/intuition.h: 167, 887 
intuition/screens.h: 64, 139 

pointer to struct BitMap in struct ClipRect 
graphics/clip.h: *59 

pointer to struct BitMap in struct RasInfo 
graphics/view.h: *72 

pointer to struct BitMap in struct RastPort 
graphics/rastport.h: *53 

pointer to struct BitMap in struct NewWindow 
intuition/intuition.h: *887 

struct BitMap (size 0x0028) in struct Screen 
intuition/screens.h: *64 

#define 0x8000 =0x00008000 graphics/gfx: h: *13 
#define 8 =0x00000008 libraries/dos.h: *37 
#define 32 =0x00000020 libraries/dos.h: *39 
pointer to short int in struct Layer_Info 


graphics/layers. h: 


*45 


short int in struct GfxBase 


graphics/gfxbase.h: 
#define 4 =0x00000004 graphics/gfxbase.h: 


*45 


short int in struct GfxBase 


graphics/gfxbase.h: 
pointer to struct Task in struct GfxBase 
graphics/gfxbase.h: 
#define 0x2 =0x00000002 hardware/blit.h: 


*46 
*49 


short int in struct bltnode 
hardware/blit.h: *85 


pointer to long int in struct GfxBase 
graphics/gfxbase.h: 
struct List (size 0x000e) in struct GfxBase 
graphics/gfxbase.h: 


*29 
*48 


char in struct Window 
intuition/intuition.h: .*757 
char in struct NewWindow 
intuition/intuition.h: *855 
char in struct Screen 


* Intuition/screens.h: *73 


char in struct NewScreen 
intuition/screens.h: *121 


unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
pointer to pointer 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
pointer to pointer 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 
unsigned short int 
hardware/custom.h: 


in struct Custom 
*68 
in struct Custom 
*53 
in struct Custom 
*54 
in struct Custom 
*63 


to char in struct Custom 
*57 


in struct Custom 
*67 
in struct Custom 
*62 


to char in struct Custom 
*56 


in struct Custom 
*66 
in struct Custom 
*61 
in struct Custom 
*51 


in struct Custom 
*52 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 10 


bltcpt 
+0x0048 
bltddat. 


+0x003e 
BNDRYOFF 
bn_DeviceNode 

+0x0010 


size 0x0020 
BobComp 
+0x0016 
BOBISCOMP 
BOBNIX 
BOBSAWAY 
BOBUPDATE 
BobVSprite 
+0x0012 
BOOL 


BOOLEXTEND 
BOOLGADGET 
Boolinfo 

size 0x000a 
BOOLMASK 
BootBlock 

size 0x000c 


size 0x0014 
BOOTSECTS 
Border 

size 0x0010 


+0x0036 


+0x0037 


pointer to pointer to char in struct Custom 
hardware/custom.h: *55 

unsigned short int in struct Custom 
hardware/custom.h: *20 

unsigned short int in struct Custom 
hardware/custom.h: *64 

pointer to pointer to char in struct Custom 
hardware/custom.h: *58 

pointer to struct bitnode in struct GfxBase 
graphics/gfxbase.h: *32 

structure tag 

graphics/gfxbase.h: 32, 33 

hardware/blit.h: *80, 82 

unsigned short int in struct Custom 
hardware/custom.h: *59 

struct Interrupt (size 0x0016) in struct GfxBase 
graphics/gfxbase.h: *34 

pointer to struct bltnode in struct GfxBase 
graphics/gfxbase.h: *32 

Macro (1 argument) graphics/gfxmacros.h: *30 
unsigned int in struct BootNode 
libraries/romboot_base.h: *44 

unsigned short int in struct BootNode 
libraries/romboot_ base.h: *43 

struct Node (size 0x000e) in struct BootNode 
libraries/romboot_base.h: *42 

struct List (size 0x000e) in struct ExpansionBase 
libraries/expansionbase.h: *51 

structure tag 

graphics/gels.h: 115, *135, 152, 153, 196 
pointer to struct AnimComp in struct Bob 
graphics/gels.h: *157 


#define 0x0002 =0x00000002 graphics/gels.h: *30 
#define 0x0800 =0x00000800 graphics/gels.h: *35 
#define 0x0400 =0x00000400 graphics/gels.h: *34 
#define 0x0200 =0x00000200 graphics/gels.h: *22 


pointer to struct VSprite in struct Bob 
graphics/gels.h: *155 

typedef short int 

exec/types.h: *47 

intuition/preferences.h: 78 

#define 0x2000 =0x00002000 intuition/intuition.h: *325 
#define 0x0001 =0x00000001 intuition/intuition.h: *348 
structure tag 

intuition/intuition.h: *360 

#define 0x0001 =0x00000001 intuition/intuition.h: *376 
structure tag 

devices/bootblock.h: *13 

struct. List (size 0x000e) in struct RomBootBase 
libraries/romboot_base.h: *36 

structure tag 

libraries/romboot_base.h: *40 

#define 2 =0x00000002 devices/bootblock.h: *19 
structure tag 

intuition/intuition.h: 150, *522, 529 

char in struct Window 

intuition/intuition.h: *730 

#define 0 =0x00000000 graphics/collide.h: *21 

char in struct Window 

intuition/intuition.h: *730 

#define 0x0800 =0x00000800 intuition/intuition.h: *820 
pointer to short int in struct VSprite 
graphics/gels.h: *109 

char in struct Window 

intuition/intuition.h: *730 

pointer to struct RastPort in struct Window 
intuition/intuition.h: *731 

char in struct Window 

intuition/intuition.h: *730 





BOTTOMBORDER 
BOTTOMHIT 

bot tommost 
+0x001c 
+0x0010 
+0x0010 
+0x0008 
+0x0000 
+0x0108 


+0x010a 









+0x0100 
+0x0102 
+0x0104 

















+0x0110 
+0x00e0 


fT - H 


+0x0008 

















+0x00la 


CBD_POST 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 11 


#define 0x0080 =0x00000080 intuition/intuition.h: *314 
#define 2 =0x00000002 graphics/collide.h: *31 

short int in struct GelsInfo 

graphics/rastport.h: *46 


BOUNDED DIMENSIONS #define 0x0010 =0x00000010 intuition/preferences.h: *242 


struct Rectangle (size 0x0008) in struct Layer 
graphics/clip.h: *30 ‘ 

struct Rectangle (size 0x0008) in struct ClipRect 
graphics/clip.h: *60 

struct Rectangle (size 0x0008) in struct RegionRectangle 
graphics/regions.h: * . 

struct Rectangle (size 0x0008) in struct Region 
graphics/regions.h: *25 

unsigned short int in struct Custom 

hardware/custom.h: *99 

unsigned short int in struct Custom 

hardware/custom.h: *100 

unsigned short int in struct Custom 

hardware/custom.h: *95 

unsigned short int in struct Custom 

hardware/custom.h: *96 

unsigned short int in struct Custom 

hardware/custom.h: *97 

array [6] of unsigned short int in struct Custom 
hardware/custom.h: *102 

array [6] of pointer to pointer to char in struct Custom 
hardware/custom.h: *93 

typedef long int 

many references; defined in libraries/dos.h: *92 
#tdefine 0x02 =0x00000002 intuition/preferences.h: *188 
pointer to struct bltnode in struct GfxBase 


_ graphics/gfixbase.h: *33 


pointer to struct bltnode in struct GfxBase 
graphics/gfxbase.h: *33 

#define 12 =0x0000000c hardware/blit.h: *54 
typedef long int 

many references; defined in libraries/dos.h: *93 
pointer to short int in struct DBufPacket 
graphics/gels.h: *236 

pointer to char in struct StringInfo 
intuition/intuition.h: *454 

short int in struct StringInfo 
intuition/intuition.h: *456 

pointer to struct VSprite in struct DBufPacket 
graphics/gels.h: *232 

short int in struct DBufPacket 

graphics/gels.h: *231 

short int in struct DBufPacket 

graphics/gels.h: *231 

short int in struct Bob 

graphics/gels.h: *161 

#define OxO0OFF =0x000000ff graphics/gels.h: *28 
#define SHORT =0x00000000 graphics/gels.h: *56, 161 
#define 0x0100 =0x00000100 graphics/gels.h: *32 
typedef char 

many references; defined in exec/types.h: *26 
typedef unsigned char 

exec/types.h: *28 

#define OxFF =0x000000ff exec/types.h: *54 

char in struct GfxBase 

graphics/gfxbase.h: *43 

#define 4 =0x00000004 libraries/dos.h: *38 
unsigned short int in struct BitMap 
graphics/gfx.h: *38 

int in struct Isrvstr 

graphics/graphint.h: *24 


CBD_CURRENTREADID #define (CMD_NONSTDt1) =0x0000000a devices/clipboard.h: *24 
CBD _CURRENTWRITEID #define (CMD NONSTD+2) =0x0000000b devices/clipboard.h: *25 


#define (CMD_NONSTDt0) =0x00000009 devices/clipboard.h: *23 











CBERR_OBSOLETEID 
CBM_MPS1000 
cb_ConfigDev 













+0x0000 
cb_FileName 

+0x0004 
cb_ Product String 

+0x0008 
cb_ToolTypes 

+0x000c 
ccode 

+0x0016 








CDF_CONFIGME 
CDF_SHUTUP 








CD_ASKKEYMAP 









+0x002c 











+0x000f 







cd_Rom 
+0x0010 







CD_SETKEYMAP 
ed_SlotaAddr 
+0x0028 
ed_Slotsize 
+0x002a 
cd_Unused 
+0x0034 























+0x0004 









CHeight. 
+0x000c 





ChkBase 






+0x0026 





ChkSum 






+0x0052 
ch_masks 
+0x0038 








cia 
+0x002a 





CIA 






size 0x0f01 






Sep 21 13:06 1988 C_Language_Cross-Reference Page 12 



















#define 1 =0x00000001 devices/clipboard.h: *27 
#tdefine 0x03 =0x00000003 intuition/preferences.h: *189 
pointer to struct ConfigDev in struct CurrentBinding 
libraries/configvars.h: *49 

pointer to char in struct CurrentBinding 
libraries/configvars.h: *50 

pointer to char in struct CurrentBinding 
libraries/configvars.h: *51 

pointer to pointer to char in struct CurrentBinding 
libraries/configvars.h: *52 

pointer to function returning int in struct Isrvstr 
graphics/graphint.h: *23 

#define 1 =0x00000001 libraries/configvars.h: *42 
#define 0 =0x00000000 libraries/configvars.h: *41 
#define 0x02 =0x00000002 libraries/configvars.h: *45 
#define 0x01 =0x00000001 libraries/configvars.h: *44 


CD_ASKDEFAULTKEYMAP #define (CMD_NONSTD+2) =0x0000000b devices/console.h: *20 


#define (CMD_NONSTD+0) =0x00000009 devices/console.h: *18 
pointer to pointer to char in struct ConfigDev 
libraries/configvars.h: ¥*31 

pointer to pointer to char in struct ConfigDev 
libraries/configvars.h: *32 

pointer to pointer to char in struct ConfigDev 
libraries/configvars.h: *35 

char in struct ConfigDev 

libraries/configvars.h: *28 

pointer to struct ConfigDev in struct ConfigDev 
libraries/configvars.h: *36 

struct Node (size 0x000e) in struct ConfigDev 
libraries/configvars.h: *27 

char in struct ConfigDev 

libraries/configvars.h: *29 

struct ExpansionRom (size 0x0010) in struct ConfigDev 
libraries/configvars.h: *30 


CD_SETDEFAULTKEYMAP #define (CMD_NONSTD+3) =0x0000000c devices/console.h: *21 


#define (CMD_NONSTD+t1) =0x0000000a devices/console.h: *19 
unsigned short int in struct ConfigDev 
libraries/configvars.h: *33 

unsigned short int in struct ConfigDev 
libraries/configvars.h: *34 

array [4] of unsigned int in struct ConfigDev 
libraries/configvars.h: *37 

#define SPCeil =0x00000000 libraries/mathffp.h: *35 
#define IEEEDPCeil =0x00000000 libraries/mathieeedp.h: *36 
Macro (1 argument) graphics/gfxmacros.h: *35 

#define 0x0008 =0x00000008 intuition/preferences.h: *239 
char in struct narrator_rb 

devices/narrator.h: *78 

#define 0x0100 =0x00000100 intuition/intuition.h: *127 
#define 0x0001 =0x00000001 intuition/intuition.h: *113 
pointer to struct Image in struct Window 
intuition/intuition.h: *763 

pointer to struct Image in struct NewWindow 
intuition/intuition.h: *872 

#define 19 =0x00000013 intuition/intuition.h: *976 
pointer to struct Layer in struct Layer _Info 
graphics/layers.h: *35 

unsigned short int in struct PropInfo 
intuition/intuition.h: *421 

unsigned int in struct ExecBase 

exec/execbase.h: *35 

unsigned short int in struct ExecBase 

exec/execbase.h: *47 

pointer to char in struct narrator_rb 
devices/narrator-h: *73 

pointer to long int in struct GfxBase 
graphics/gfxbase.h: *28 

structure tag 

hardware/cia.h: *22 


Sep 21 13:06 1988 C_Language_Cross—Reference Page 13 


CIAB_COMCTS 
CIAB_COMDSR 
CIAB_COMDTR 
CIAB_COMRTS 
CIAB_DSKCHANGE 
CIAB DSKDIREC 
CIAB_DSKMOTOR 
CIAB_DSKPROT 
CIAB_DSKRDY 
CIAB_DSKSELO 
CIAB_DSKSEL1 
CIAB_DSKSEL2 
CIAB_DSKSEL3 
CIAB_DSKSIDE 
CIAB_DSKSTEP 
CIAB_DSKTRACKO 
CIAB_GAMEPORTO 
CIAB_GAMEPORT1 
CIAB_LED 
CIAB_OVERLAY 
CIAB_PRTRBUSY 
CIAB_PRTRPOUT 
CIAB_PRTRSEL 
ciacra 


#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#tdefine 
#define 
#define 
#tdefine 
#tdefine 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
char in 


"“cliaa. resource" 
“ciab. resource" 
(5) =0x00000005 
=0x00000004 
=0x00000003 
=0x00000007 
=0x00000006 
=0x00000002 
=0x00000001 
=0x00000007 
=0x00000003 
=0x00000005 
=0x00000003 
=0x00000004 
=0x00000005 
=0x00000006 
=0x00000002 
=0x00000000 
=0x00000004 
=0x00000006 
=0x00000007 
=0x00000001 
=0x00000000 
=0x00000000 
=0x00000001 
(2) =0x00000002 
struct CIA 


~ 
a 
~~ 


PRR RRR RRR RR RRR RR RAR 
SS SS SS SSS See 


FPOORPNNEPONDUEPWUIWAT EN ANT 
~ 


resources/cia.h: 
resources/cia. h: 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia 
hardware/cia 
hardware/cia 
hardware/cia 
hardware/cia 
hardware/cia. 
hardware/cia 
hardware/cia 
hardware/cia 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia 
hardware/cia 
hardware/cia 


PELLEEC EL EEL EE Ee Eee e tee! 


*13 

*14 
*140 
*141 
*142 
*138 
*139 
*131 
*154 
*148 
*130 
*128 
*152 
*151 
*150 
*149 
#153 
*155 
*129 
*127 
*126 
*132 
*133 
*145 
*144 
*143 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 14 


CIAF_COMCTS 
CIAF_COMDSR 


CIAF_DSKMOTOR 
CIAF_DSKPROT 
CIAF_DSKRDY 
CIAF_DSKSELO 
CIAF_DSKSEL1 
CIAF_DSKSEL2 
CIAF_DSKSEL3 
CIAF_DSKSIDE 
CIAF_DSKSTEP 
CIAF_DSKTRACKO 
CIAF_GAMEPORTO 
CIAF_GAMEPORT1 
CIAF_LED 
CIAF_OVERLAY 
CIAF_PRTRBUSY 
CIAF_PRTRPOUT 
CIAF_PRTRSEL 
ciaicr 


char in struct 


hardware/cia.h: 


(1<<5) 
(1<<4) 
(1<¢3) 
(1<<7) 
(1<<6) 
(1<<2) 
(1<<1) 
(1<<7) 
(1¢<3) 
(1<<5) 
(1<¢3) 
(1<<4) 
(1<<5) 
(1<<6) 
(1<¢2) 
(1<<0) 
(1<<4) 
(1<<6) 
(1<<7) 
(1<<1) 
(1<<0) 
(1<<0) 


#define 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
#tdefine 
#tdefine 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define 
#define (1<<1) 
#define (1<<2) 
char in struct 


CIA 
*29 

=0x00000020 
=0x00000010 
=0x00000008 
=0x00000080 
=0x00000040 
=0x00000004 
=0x00000002 
=0x00000080 
=0x00000008 
=0x00000020 
=0x00000008 
=0x00000010 
=0x00000020 
=0x00000040 
=0x00000004 
=0x00000001 
=0x00000010 
=0x00000040 
=0x00000080 
=0x00000002 
=0x00000001 
=0x00000001 
=0x00000002 
=0x00000004 
CIA 


hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 


PEPER PEPE PEPE S Sheba bebe 


+0x0e00 hardware/cia.h: *51 +0x0d00 hardware/cia.h: *49 


CIACRAB_INMODE 
CIACRAB_LOAD 
CIACRAB_OUTMODE 
CIACRAB PBON 
CIACRAB_RUNMODE 
CIACRAB SPMODE 
CIACRAB_START 


#define 
#define 
#define 
#tdefine 


#define 
#define 


5 


=0x00000005 
=0x00000004 
=0x00000002 
=0x00000001 


=0x00000006 
=0x00000000 


hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 


hardware/cia. 
hardware/cia. 


: *72 
2 *71 
: *69 
: *68 
: *70 
: *73 
: *67 


CIATCRB_ALRM 
CIAICRB_FLG 
CIAICRB_IR 
CIAICRB_SETCLR 
CIAICRB_SP 
CIAICRB_TA 


#define 
#tdefine 
#define 
#define 
#tdefine 
#define 
#tdefine 


2 


4 
7 
7 
3 
0 
1 


=0x00000002 
=0x00000004 
=0x00000007 
=0x00000007 
=0x00000003 
=0x00000000 
=0x00000001 


hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 


hardware/cia. 


: *60 
: *62 
: *63 
: *64 
: *61 
: *58 


x59 


€T -— H 


4 
2 
1 
#define 3 =0x00000003 hardware/cia. 
6 
0 
7 


(1<<CIAICRB_ALRM) ~0x00000004 hardware/cia.h: *89 
(1<<CIAICRB_FLG) =0x00000010 hardware/cia.h: *9] 
(1<<CIAICRB_IR) =0x00000080 hardware/cia.h: *92 

(1<<CIAICRB_SETCLR) =0x00000080 hardware/cia.h: 

(1<<CIAICRB_SP) =0x00000008 hardware/cia.h: *90 

#define (1<<CIAICRB_TA) =0x00000001 hardware/cia.h: *87 

#tdefine (1<<CIAICRB_TB) =0x00000002 hardware/cia.h: *88 

char in struct CIA 

hardware/cia.h: *23 - 

char in struct CIA 

hardware/cia.h: *25 

char in struct CIA 

hardware/cia.h: *47 

char in struct CIA 

hardware/cia.h: *33 


#define 
#tdefine 
#tdefine 
#define 
#tdefine 


#define 
#define 
#define 
#define 
#define 
#tdefine 
#define 


=0x00000007 hardware/cia. *74 
(1<<CIACRAB_INMODE) =0%00000020 hardware/cia.h: *101 
(1<<CIACRAB_LOAD) =0x00000010 hardware/cia.h: *100 
(1<<CIACRAB_OUTMODE) =0x00000004 hardware/cia.h: *98 
(1<<CIACRAB_PBON) =0x00000002 hardware/cia.h: *97 
(1<<CIACRAB_RUNMODE) =0x00000008 hardware/cia.h: 
(1<<CIACRAB_SPMODE) =0x00000040 hardware/cia.h: 
#define (1<<CIACRAB_ START) =0x00000001 hardware/cia.h: 
#tdefine (1<<CIACRAB_TODIN) =0x00000080 hardware/cia.h: 
char in struct CIA 
hardware/cia.h: *53 
#define 7 =0x00000007 hardware/cia. 
#define 5 =0x00000005 hardware/cia. 
#define 0x00000006 hardware/cia. 
#define 0x00000004 hardware/cia. 


~ *93 
CIACRAF_RUNMODE 
CIACRAF_SPMODE 
CIACRAF_START 
CIACRAF_TODIN 


CIAICRF_SP 
CIAICRF_TA 
CIAICRF_TB 


*99 
*102 
*96 
*103 +0x0000 
+0x0100 
: *84 
: *82 
: *83 
: *81 


CIACRBB_INMODEO +0x0c00 
CIACRBB_INMODE1 


+0x0500 


#define 
#tdefine 
#define 
#define 


5 
6 
4 
2 
1 
3 
0 


=0x00000002 
=0x00000001 
=0x00000003 
=0x00000000 


hardware/cia. 
hardware/cia. 
hardware/cia. 
hardware/cia. 


: *79 
: *78 
: *80 


*77 


+0x0400 
+0x0700 


char in struct 


hardware/cia.h: 


char in struct 


hardware/cia.h: 


CIA 
*31 

CIA 
*37 


char in struct CIA 

hardware/cia.h: *35 

char in struct CIA 

hardware/cia.h: *43 

char in struct CIA 

hardware/cia.h: *39 

char in struct CIA 

hardware/cia.h: *41 

Macro (2 arguments) graphics/gfxmacros.h: 
unsigned int in struct IntuiMessage 
intuition/intuition.h: *603 

#tdefine CLEANUP =0x00000040 hardware/blit.h: *92 
pointer to function returning int in struct blitnode 
hardware/blit.h: *87 

#define 0x40 =0x00000040 hardware/blit.h: 


#define 


(1<<CIACRBB_ALARM) =0x00000080 hardware/cia.h: *113 
#define 


(1<<CIACRBB_INMODEO) =0x00000020 hardware/cia.h: *111 
CIACRBF_INMODE1] #define (1<<CIACRBB_INMODE1) =0x00000040 hardware/cia.h: *112 
CIACRBF_IN_CNT #define (CIACRBF_INMODEO) =0x00000020 hardware/cia.h: *117 
CIACRBF IN _( CNT_TA #define (CIACRBF_ INMODEO | CIACRBF__ INMODE1) =0x00000060 
hardware/cia-h: *119 

#define 0 =0x00000000 hardware/cia.h: *116 

#tdefine (CIACRBF_INMODE1) =0x00000040 hardware/cia.h: *118 
#define (1<<CIACRBB_LOAD) =0x00000010 hardware/cia.h: *110 
#define (1<<CIACRBB_OUTMODE) =0x00000004 hardware/cia.h: *108 
#define (1<<CIACRBB_PBON) =0x00000002 hardware/cia.h: *107 
#define (1<<CIACRBB_RUNMODE) =0x00000008 hardware/cia.h: *109 
#tdefine (1<<CIACRBB_START) =0x00000001 hardware/cia.h: *106 
char in struct CIA 

hardware/cia.h: *27 


CIACRBF_INMODEO +0x0600 


CIACRBF_IN_PHI2 
CIACRBF_IN_TA 
CIACRBF_LOAD 
CIACRBF_OUTMODE 
CIACRBF_PBON 
CIACRBF_RUNMODE 
CIACRBF_START 
ciaddra 


*32 


+0x0200 x91 





tT - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 15 


ClearPath 
+0x000e 
CLeft 
+0x0014 


pointer to struct VSprite in struct vVSprite 
graphics/gels.h: *80 

short int in struct StringInfo 
intuition/intuition.h: *464 


ClipboardUnitPartial structure tag 


size 0x0012 
ClipRect 
size 0x0024 
ClipRect 
+0x0008 
ClipRegion 
+0x007e 
cli_Background 
+0x002c 
c1i_CommandDir 
+0x0008 
cli_CommandFile 
+0x0024 
¢c1i_CommandName 
+0x0010 
ecli_CurrentInput 
+0x0020 


devices/clipboard.h: *30 

structure tag 

graphics/clip.h: 28, 35, 40, 41, 42, *54, 56, 57, 61 
pointer to struct Cliprect in struct Layer 
graphics/clip.h: *28 

pointer to struct Region in struct Layer 
graphics/clip. h: *46 

int in struct CommandLineInterface 
libraries/dosextens.h: *209 

int in struct CommandLinetnterface 
libraries/dosextens.h: *200 

int in struct CommandLineInterface 
libraries/dosextens.h: *207 

int in struct CommandLineInterface 
libraries/dosextens.h: *202 

int in struct CommandLineInterface 
libraries/dosextens.h: *206 


cli_CurrentoOutput int in struct CommandLineInterface 


+0x0030 
cli_DefaultStack 
+0x0034 
cli_FailLevel 
+0x0014 
cli_Interactive 
+0x0028 
cli_ Module 
+0x003c 
cli_ Prompt 
+0x0018 
cli_Result2 
+0x0000 
cli_ReturnCode 
+0x000c 
cli_SetName 
+0x0004 


libraries/dosextens.h: *210 
int in struct CommandLineInterface 
libraries/dosextens.h: *211 
int in struct CommandLineInterface 
libraries/dosextens.h: *203 
int in struct CommandLineInterface 
libraries/dosextens.h: *208 
int in struct CommandLineInterface 
libraries/dosextens.h: *213 
int- in struct CommandLineInterface 
libraries/dosextens.h: *204 
int in struct CommandLineInterface 
libraries/dosextens.h: *198 
int in struct CommandLineInterface 
libraries/dosextens.h: *201 
int in struct CommandLineInterface 
libraries/dosextens.h: *199 


cli_StandardInput int in struct CommandLineInterface 


+0x001¢ 


libraries/dosextens.h: *205 


cli_Standardoutput int in struct CommandLineInterface 


+0x0038 
Clock 

+0x0008 
CLOSE 
CLOSEWINDOW 
Clrins 

+0x0010 
elxcon 

+0x0098 
elxdat 

+0x000e 
CMD_CLEAR 
CMD FLUSH 
CMD_INVALID 
CMD" NONSTD 
CMD_READ 
CMD_RESET 
CMD_START 
CMD STOP 
CMD_UPDATE 
CMD _ WRITE 
CMOVE 
Code 

+0x0018 
code 

+0x0012 


libraries/dosextens.h: *212 

int in struct AnimOb 

graphics/gels.h: *205 

#define 0x0080 =0x00000080 intuition/intuition.h: *346 
#define 0x00000200 =0x00000200 intuition/intuition.h: 
pointer to struct CopList in struct ViewPort 
graphics/view.h: *37 

unsigned short int in struct Custom 
hardware/custom.h: *81 

unsigned short int in struct Custom 
hardware/custom.h: *27 


*647 


#define 5 =0x00000005 exec/io.h: *54 
#define 8 =0x00000008 exec/io.h: *57 
#define 0 =0x00000000 exec/io.h: *49 
#define 9 =0x00000009 exec/io.h: *59 
#define 2 =0x00000002 exec/fio.h: *51 
#define 1 =0x00000001 exec/io.h: *50 
#define 7 =0x00000007 exec/io.h: *56 
#define 6 =0x00000006 exec/io.h: *55 
#define 4 =0x00000004 exec/io.h: *53 
#define 3 =0x00000003 exec/io.h: %*52 


Macro (3 arguments) graphics/gfxmacros. h: *33 
unsigned short int in struct IntuiMessage 
intuition/intuition. h: *606 

pointer to function returning int in struct Isrvstr 
graphics/graphint.h: *22 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 16 


ColdCapture 
+0x002a 
collHandler 
+0x0012 
CollMask 
+0x002c 
collPtrs 


+0x0000 
collTable 
size 0x0040 


color 

+0x0180 
color0 

+0x006e 
coliorl 

+0x0070 
colorl7 

+0x0066 
colorl18 

+0x0068 
colorl9 

+0x006a 
color2 

+0x0072 
color3 

+0x0074 
colorByte 

+0x0000 
colorEntry 

size 0x0004 

colorLong 

+0x0000 
ColorMap 

size 0x0008 


ColorMap 
+0x0004 
COLORON 
colorsByte 
+0x0000 
ColorTable 
+0x0004 
ColumnSizeChange 
+0x0049 
Command 
+0x001a 


pointer to pointer to char in struct ExecBase 
exec/execbase.h: *36 

pointer to struct collTable in struct GelsInfo 
graphics/rastport.h: *45 

pointer to short int in struct VSprite 
graphics/gels.h: *110 

array [16] of pointer to function returning int in struct 
collTable 
graphics/gels.h: 
structure tag 
graphics/rastport.h: 45 

graphics/gels.h: *259 

array [32] of unsigned short int in struct Custom 
hardware/custom.h: *111 

unsigned short int in struct Preferences 
intuition/preferences.h: *68 

unsigned short int in struct Preferences 
intuition/preferences.h: *69 

unsigned short int in struct Preferences 
intuition/preferences.h: *62 

unsigned short int in struct Preferences 
intuition/preferences.h: *63 

unsigned short int in struct Preferences 
intuition/preferences.h: *64 

unsigned short int in struct Preferences 
intuition/preferences.h: *70 

unsigned short int in struct Preferences 
intuition/preferences.h: *71 

array [4] of char in union colorEntry 
devices/prtgfx.h: *24 

union tag 
devices/prtgfx.h: *22, 34, 35, 36, 

unsigned int in union colorEntry 
devices/prtgfx.h: *23 

structure tag 

devices/printer.h: 158 

graphics/view.h: *21, 33 

pointer to struct ColorMap in struct ViewPort 
graphics/view.h: *33 

#define 0x0200 =0x00000200 graphics/display.h: *19 
array [4] of char in union colorEntry 
devices/prtgfx.h: *25 

pointer to pointer to char in struct ColorMap 
graphics/view.h: *26 

char in struct Preferences 

*113 


*261 


37, 38 


intuition/preferences.h: 
char in struct MenuItem 


intuition/intuition.h: *101 


CommandLineInterface structure tag 


size 0x0040 
COMMSEQ 
COMMWIDTH 
COMPLEMENT 
ConfigDev 

size 0x0044 


ConUnit 
size 0x0128 
CoolCapture 
+0x002e 
coplle 
+0x0080 
cop2lc 
+0x0084 
copcon 
+0x002e 
copinit : 
size 0x005c 


libraries/dosextens.h: *197 

#define 0x0004 =0x00000004 intuition/intuition.h: 
#define 27 =0x0000001b intuition/intuition.h: *977 
#define 2 =0x00000002 graphics/rastport.h: *90 
structure tag 
libraries/configvars.h: *26, 
libraries/expansion.h: 23, 
structure tag 
devices/conunit.h: *34 
pointer to pointer to char in struct ExecBase 
exec/execbase.h: *37 

unsigned int in. struct Custom 
hardware/custom.h: *71 

unsigned int in struct Custom 
hardware/custom.h: *72 

unsigned short int in struct Custom 
hardware/custom.h: *42 

structure tag 

graphics/copper.h: *76 

graphics/gfxbase.h: 27 


#115 


36, 49, 56 





ST -H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 17 


copinit 
+0x0026 

Copins 
size 0x0006 


+0x0014 
COPPER_MOVE 
COPPER_WAIT 


CORRECT_GREEN 
CORRECT_RED 
CORRECT _RGB_MASK 


+0x0002 
+0x0010 
+0x0007 
+0x001c 


+0x0024 
+0x0026 
+0x0030 
+0x0034 


crnew 
+0x0038 


pointer to struct copinit in struct Gf£xBase 
graphics/gfxbase.h: *27 

structure tag 

graphics/copper.h: *18, 60, 61 

pointer to struct CopIns in struct CopList 
graphics/copper.h: *60 

unsigned short int in struct Custom 
hardware/custom.h: *75 

unsigned short int in struct Custom 
hardware/custom.h: *73 

unsigned short int in struct Custom 
hardware/custom.h: *74 

structure tag 

graphics/view.h: 35,. 36, 37 

graphics/copper.h: 23, *55, 57, 58, 72, 73 
pointer to struct CopList in struct UCopList 
graphics/copper.h: *73 

pointer to unsigned short int in struct CopList 
graphics/copper.h: *62 

#define 0 =0x00000000 graphics/copper.h: *13 
#define 1 =0x00000001 graphics/copper.h: *14 
pointer to struct CopIns in struct CophList 
graphics/copper.h: *61 

pointer to unsigned short int in struct CopList 
graphics/copper.h: *63 

#tdefine 0x0004 =0x00000004 intuition/preferences.h: 
#define 0x0002 =0x00000002 intuition/preferences.h: *236 
#define 0x0001 =0x00000001 intuition/preferences.h: *235 
#define (CORRECT_RED|CORRECT_GREEN|CORRECT BLUE) =0x00000007 
intuition/preferences.h: *258 

#define SPCos =0x00000000 libraries/mathffp.h: *39 
#define IEEEDPCos =0x00000000 libraries/mathieeedp.h: *40 
#define SPCosh =0x00000000 libraries/mathffp.h: *50 


*237 


#define IEEEDPCosh =0x00000000 libraries/mathieeedp.h: 
typedef short int 


*51 


exec/types.h: *45 

unsigned short int in struct ColorMap 
graphics/view.h: *25 

short int in struct AreaInfo 
graphics/rastport.h: *23 

char in struct Border 
intuition/intuition.h: *527 

short int in struct Cophist 

graphics/copper.h: *64 

structure tag 

graphics/view.h: 50, 51 

graphics/copper.h: *48, 50 

#define 2 =0x00000002 graphics/copper.h: *15 
#define 0x8000 =0x00008000 graphics/copper.h: *16 
#define 0x4000 =0x00004000 graphics/copper.h: *17 
typedef ULONG 

exec/types.h: *35 

libraries/expansion.h: 24 
libraries/romboot_base.h: 44 
resources/filesysres.h: 42 

short int in struct RastPort 

graphics/rastport.h: *68 

short int in struct RastPort 

graphics/rastport.h: *68 

pointer to struct ClipRect in struct Layer 
graphics/clip.h: *40 

pointer to struct ClipRect in struct Layer 
graphics/clip. h: *40 

pointer to struct ClipRect in struct Layer 
graphics/clip.h: *40 


CR_NEEDS NO CONCEALED _RASTERS #define 1 =0x00000001 graphics/clip.h: *69 


CTC_HCLRTAB_ 
CTC_HCLRTABSALL 
CTC” HSETTAB 


#define 2 =0x00000002 devices/console.h: *80 
#define 5 =0x00000005 devices/console.h: *81 
#define 0 =0x00000000 devices/console.h: *79 











Sep 21 13:06 1988 C_Language_Cross-Reference Page 18 


+0x0002 


+0x0016 
Current Binding 
size 0x0010 


CurrentBinding 
+0x002c 
CURSORDOWN 
CURSORLEFT 
CURSORRIGHT 
CURSORUP 
CUSTOM 
Custom 
size 0x01c0 
CUSTOMBITMAP 
CustomBitMap 
+0x001c 
CUSTOMSCREEN 
CUSTOM_NAME 
cu_AlgoStyle 
+0x0118 
cu_AOLPen 
+0x0105 
cu_AreaPtrn 
+0x0108 
cu_AreaPtSz 
+0x0107 
cu_BgPen 
+0x0104 
cu_DrawMode 
+0x0106 
cu_FgPen 
+0x0103 
cu_Font 
+0x0114 
cu_KeyMapStruct 
+0x0042 
cu_Mask 
+0x0102 
cu_Minterms 
+0x010c 
cu_Modes 
+0x0122 
cu_MP 
+0x0000 
cu_Node 
+0x0000 
cu_RawEvents 
+0x0125 
cu_TabStops 
+0x0062 
cu_TxBaseline 
+0x0lle 
cu_TxFlags 
+0x0119 
cu_TxHeight. 
+0x0lla 
cu_TxSpacing 
+0x0120 
cu_TxWidth 
+0x0llc 
cu_UnitNum 
+0x000e 
cu_Window 
+0x0022 
cu_XCCP 
+0x003e 


unsigned short int in struct SpriteDef 
hardware/custom.h: *107 
short int in struct StringInfo 


intuition/intuition.h: *464 
structure tag 
libraries/configvars.h: *48 


libraries/expansionbase.h: 50 
struct CurrentBinding (size 0x0010) in struct ExpansionBase 
libraries/expansionbase.h: *50 


#define Ox4D =0x0000004d intuition/intuition.h: *1019 
#define Ox4F =0x0000004f intuition/intuition.h: *1017 
#define Ox4E =0x0000004e intuition/intuition.h: *1018 
#define 0x4c =0x0000004c intuition/intuition.h: *1016 
#define 0x40 =0x00000040 intuition/preferences.h: *183 
structure tag 

hardware/custom.h: *19 

#define 0x0040 =0x00000040 intuition/screens.h: *102 


pointer to struct BitMap in struct NewScreen 
intuition/screens.h: *139 

#define Ox000F =0x0000000f intuition/screens.h: *96 
#tdefine 0x00 =0x00000000 intuition/preferences.h: *186 
char in struct ConUnit 

devices/conunit .h: *69 

char in struct ConUnit 

devices/conunit.h: *63 

pointer to pointer to char in struct ConUnit 
devices/conunit.h: *66 

char in struct ConUnit 

devices/conunit.h: *65 

char in struct ConUnit 

devices/conunit.h: *62 

char in struct ConUnit 

devices/conunit.h: *64 

char in struct ConUnit 

devices/conunit.h: *61 

pointer to struct TextFont in struct ConUnit 
devices/conunit.h: *68 

struct KeyMap (size 0x0020) in struct ConUnit 
devices/conunit.h: *55 

char in struct ConUnit 

devices/conunit.h: *60 

array [8] of char in struct ConUnit 
devices/conunit.h: *67 

array [3] of char in struct ConUnit 
devices/conunit.h: *77 

struct MsgPort (size 0x0022) in struct ConUnit 
devices/conunit.h: *35 

struct Node (size 0x000e) in struct ClipboardUnitPartial 
devices/clipboard.h: *31 

array (3] of char in struct ConUnit 
devices/conunit.h: *78 

array [80] of unsigned short int in struct ConUnit 
devices/conunit.h: *57 

unsigned short int in struct ConUnit 
devices/conunit.h: *73 

char in struct ConUnit 

devices/conunit.h: *70 

unsigned short int in struct ConUnit 
devices/conunit.h: *71 

unsigned short int in struct ConUnit 
devices/conunit.h: *74 

unsigned short .int in struct ConUnit 
devices/conunit.h: *72 

unsigned int in struct ClipboardUnitPartial 
devices/clipboard.h: *32 

pointer to struct Window in struct ConUnit 
devices/conunit.h: *37 

short int in struct ConUnit 
devices/conunit.h: *50 


9T —-H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 19 


cu_XCP 

+0x0026 
cu_XMax 

+0x002a 
cu_XMinShrink 

+0x003a 
cu_XRExtant. 

+0x0036 
cu_XROrigin 

+0x0032 
cu_XRSize 

+0x002e 
cu_YCCP 

+0x0040 
cu_YCP 

+0x0028 
cu_YMax 

+0x002c 
cu_YMinShrink 

+0x003c 
cu_YRExtant 

+0x0038 
cu_YROrigin 

+0x0034 
cu_YRSize 

+0x0030 
CWAIT 
cWidth 

+0x000a 
DAC_BINDTIME 
DAC_BOOTTIME 
DAC_BUSWIDTH 
DAC_BYTEWIDE 
DAC_CONFIGTIME 
DAC_NEVER 
DAC_NIBBLEWIDE 
DAC_WORDWIDE 
DamageList 

+0x009c 
dataa 

+0x0004 
datab 

+0x0006 
DateStamp 

size 0x000c 


da_BootPoint 
+0x0006 
da_Config 
+0x0000 
da_DiagPoint 
+0x0004 
da_Flags 
+0x0001 
da_Name 
+0x0008 
da_Reserved01 
+0x000a 
da_Reserved02 
+0x000c 
da_Size 
+0x0002 
dbf 
DBLPF 
DBUFFER 
DBuffer 
+0x00la 
DBufPacket 
size 0x000c 


short int in struct ConUnit 
devices/conunit.h: *38 
short int in struct ConUnit 
devices/conunit.h: *40 
short int in struct ConUnit 
devices/conunit.h: *48 
short int in struct ConUnit 
devices/conunit.h: *46 
short int in struct ConUnit 
devices/conunit.h: *44 
short int in struct ConUnit 
devices/conunit.h: *42 
short int in struct ConUnit 
devices/conunit.h: *51 
short int in struct ConUnit 
devices/conunit.h: *39 
short int in struct ConUnit 
devices/conunit.h: *41 
short int in struct ConUnit 
devices/conunit.h: *49 
short int in struct ConUnit 
devices/conunit.h: *47 
short int in struct ConUnit 
devices/conunit.h: *45 
short int in struct ConUnit 
devices/conunit.h: *43 
Macro (3 arguments) graphics/gfxmacros.h: *34 
unsigned short int in struct PropInfo 
intuition/intuition.h: *420 


#define 0x20 =0x00000020 libraries/configregs.h: *215 
#tdefine 0x30 =0x00000030 libraries/configregs.h: *211 
#define OxCO =0x000000c0 libraries/configregs.h: *206 
#define 0x40 =0x00000040 libraries/configregs.h: *208 
#define 0x10 =0x00000010 libraries/configregs.h: *213 
#define 0x00 =0x00000000 libraries/configregs.h: *212 
#define 0x00 =0x00000000 libraries/configregs.h: *207 
#define 0x80 =0x00000080 libraries/configregs.h: *209 


pointer to struct Region in struct Layer 
graphics/clip.h: *50 

unsigned short int in struct SpriteDef 
hardware/custom.h: *108 

unsigned short int in struct SpriteDef 
hardware/custom.h: *109 

structure tag 

libraries/dos.h: *49, 66 
libraries/dosextens.h: 180, 230, 273 
unsigned short int in struct DiagArea 
libraries/configregs.h: *196 

char in struct DiagArea 
libraries/configregs.h: *192 

unsigned short int in struct DiagArea 
libraries/configregs.h: *195 

char in struct DiagArea 
libraries/configregs.h: *193 

unsigned short int in struct DiagArea 
libraries/configregs.h: *197 

unsigned short int in struct DiagArea 
libraries/configregs.h: *201 

unsigned short int in struct DiagArea 
libraries/configregs.h: *202 

unsigned short int in struct DiagArea 
libraries/configregs.h: *194 

extern function returning float libraries/mathffp.h: *76 
#define 0x400 =0x00000400 graphics/display-h: *20 
#define 0x04 =0x00000004 graphics/rastport.h: *97 
pointer to struct DBufPacket in struct Bob 
graphics/gels.h: *159 

structure tag 

graphics/gels.h: 159, *229 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 20 


ddfstop 
+0x0094 
ddfstrt 
+0x0092 
dd_CmdBytes 
+0x002e 
dd_CmdVectors 
+0x002a 
dd_Currentx 
+0x0030 
dd_CurrentY 
+0x0034 
dd_Device 
+0x0000 
dd_ExecBase 
+0x0026 
dd_Library 
+0x0000 
dd_NewWindow 
+0x0000 
dd_NumCommands 
+0x0032 
dd_ Segment 
+0x0022 
DEADEND_ALERT 
Debug 
+0x00al 
DebugData 
+0x0046 
DebugEntry 
+0x0042 
DefaultFont 
+0x009a 
DefaultTitle 
+0x001a 
DefaultTitle 
+0x0014 
DEFERREFRESH 
DEFFREQ 
DEFMODE 
DEFPITCH 
DEFRATE 
DEFSEX 
DEFVOL 
DELTAMOVE 
Depth 
+0x0005 
Depth 
+0x0008 
Depth 
+0x0008 
Depth 
+0x00le 
Descendant 
+0x0046 
DEST 
DestAddr 
+0x0000 
DESTADDR 


DestData 
+0x0000 
DESTDATA 


DetailPen 
+0x0062 

DetailPen 
+0x0008 

DetailPen 


unsigned short int in struct Custom 
hardware/custom.h: *79 

unsigned short int in struct Custom 
hardware/custom.h: *78 

pointer to pointer to char in struct DeviceData 
devices/prtbase.h: *51 

pointer to pointer to char in struct DeviceData 
devices/prtbase.h: *50 

int in struct DrawerData 

workbench/workbench.h: *43 

int in struct DrawerData 

workbench/workbench.h: *44 

struct Library (size 0x0022) in struct DeviceData 
devices/prtbase.h: *47 

pointer to pointer to char in struct DeviceData 
devices/prtbase.h: *49 

struct Library (size 0x0022) in struct Device 
exec/devices.h: *25 

struct NewWindow (size 0x0030) in struct DrawerData 
workbench/workbench.h: *42 

unsigned’ short int in struct DeviceData 
devices/prtbase.h: *52 

pointer to pointer to char in struct DeviceData 
devices/prtbase.h: *48 

#define 0x80000000 =0x80000000 intuition/intuition.h: *988 
char in struct GfxBase 

graphics/gfxbase.h: *39 

pointer to pointer to char in struct ExecBase 
exec/exechase.h: *43 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *42 

pointer to struct TextFont in struct GfxBase 
graphics/gfxbase.h: *36 

pointer to char in struct Screen 
intuition/screens.h: *53 

pointer to char in struct NewScreen 
intuition/screens.h: *129 

tdefine 0x8000 =0x00008000 intuition/intuition.h: *183 
#define 22200 =0x000056b8 devices/narrator.h: *42 
#define NATURALFO =0x00000000 devices/narrator.h: *48 
#tdefine 110 =0x0000006e devices/narrator.h: *39 
#tdefine 150 =0x00000096 devices/narrator.h: *40 
#define MALE =0x00000000 devices/narrator.h: *47 
#define 64 =0x00000040 devices/narrator.h: *41 
#define 0x00100000 =0x00100000 intuition/intuition.h: *658 
char in struct BitMap 

graphics/gfx.h: *41 

short int in struct Image 

intuition/intuition.h: *548 

short int in struct NewScreen 
intuition/screens.h: *119 

short int in struct VSprite 

graphics/gels.h: *99 

pointer to struct Window in struct Window 
intuition/intuition.h: *742 

#define 0x100 =0x00000100 hardware/blit.h: *48 
short int in union (no tag) 

graphics/copper.h: *29 

#define u3.u4.ul.DestAddr 

graphics/copper.h: *42 

short int in union (no tag) 

graphics/copper.h: *34 

#define u3.u4.u2.DestData 

graphics/copper.h: *44 

char in struct Window 

intuition/intuition.h: *757 

char in struct NewWindow 

intuition/intuition.h: *855 

char in struct Screen 





LT — H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 21 Sep 21 13:06 1988 C_Language_Cross-Reference Page 22 













































+0x014a intuition/screens.h: *73 +0x002c libraries/filehandler.h: *43 
DetailPen char in struct NewScreen DE_NUMBUFFERS #define 11 =0x0000000b libraries/filehandler.h: *66 
+0x000a_ intuition/screens.h: *121 DE_NUMHEADS #define 3 =0x00000003 libraries/filehandler.h: *58 
Device structure tag de_PreAlloc unsigned int in struct DosEnvec 
size 0x0022 exec/devices.h: *24 +0x00le libraries/filehandler.h: *39 
exec/io.h: 20, 29 DE_PREFAC #define 7 =0x00000007 libraries/filehandler.h: *62 
devices/clipboard.h: 39 de_Reserved unsigned int in struct DosEnvec 






devices/printer.h: 138, 152 
DeviceData structure tag 


+0x0018 libraries/filehandler.h: *38 
DE_RESERVEDBLKS #define 6 =0x00000006 libraries/filehandler.h: *61 























































size 0x0034 devices/prtbase.h: *46, 60 de_SecOrg unsigned int in struct DosEnvec 
DeviceList struct List (size 0x000e) in struct ExecBase +0x0008 Jlibraries/filehandler.h: *34 
+0x015e exec/execbase.h: *79 : DE_SECORG #define 2 =0x00000002 libraries/filehandler.h: *57 
DeviceList structure tag DE_SECSPERBLK #define 4 =0x00000004 libraries/filehandler.h: *59 
size 0x002c libraries/dosextens.h: *225 de_SectorPerBlock unsigned int in struct DosEnvec 
DeviceNode structure tag +0x0010 libraries/filehandler.h: *36 











size 0x002c libraries/expansion.h: 26 de_SizeBlock unsigned int in struct DosEnvec 



































































libraries/filehandler.h: *96 +0x0004 libraries/filehandler.h: ¥*33 

DEVICES AUDIO_H #define =0x00000000 devices/audio.h: *2 DE_SIZEBLOCK #define 1 =0x00000001 libraries/filehandler.h: *56 
DEVICES BOOTBLOCK_H #define =0x00000000 devices/bootblock.h: *2 de_Surfaces unsigned int ‘in struct DosEnvec 
DEVICES _( ; CLIPBOARD H #define =0x00000000 devices/clipboard.h: *2 +0x000c libraries/filehandler.h: *35 
DEVICES CONSOLE_H #define =0x00000000 devices/console.h: *2 de_TableSize unsigned int in struct DosEnvec 
DEVICES CONUNIT_H #define =0x00000000 devices/conunit.h: *2 +0x0000 libraries/filehandler.h: *32 
DEVICES _GAMEPORT_H #define =0x00000000 devices/gameport.h: *2 DE_TABLESI ZE #define 0 =0x00000000 libraries/filehandler.h: *55 
DEVICES HARDBLOCKS H #define =0x00000000 devices/hardblocks.h: *2 DE_UPPERCYL #define 10 =0x0000000a libraries/filehandler.h: *65 
DEVICES INPUTEVENT_H #define =0x00000000 devices/inputevent.h: *2 dfh_DF struct Node (size 0x000e) in struct DiskFontHeader 
DEVICES INPUT_H #define =0x00000000 devices/input.h: *2 +0x0000 libraries/diskfont.h: *51 
DEVICES KEYBOARD_H #define =0x00000000 devices/keyboard.h: *2 dfh_FileID unsigned short int in struct DiskFontHeader 
DEVICES | KEYMAP_H | #define =0x00000000 devices/keymap.h: *2 +0x000e libraries/diskfont.h: *52 
DEVICES NARRATOR_H #define =0x00000000 devices/narrator.h: *2 DFH_ID #define Ox0f£80 =0x00000f80 libraries/diskfont.h: *40 
DEVICES PARALLEL _H #define =0x00000000 devices/parallel.h: *2 dfh_ Name array (32] of char in struct DiskFontHeader 
DEVICES PRINTER_H #define =0x00000000 devices/printer.h: *2 _+0x0016 libraries/diskfont.h: *55 
DEVICES PRTBASE_H #define =0x00000000 devices/prtbase.h: *2 dfh_Revision unsigned short int in struct DiskFontHeader 
DEVICES PRTGFX_H #define =0x00000000 devices/prtgfx.h: *2 +0x0010 libraries/diskfont.h: *53 
DEVICES SCSIDISK_H #define =0x00000000 devices/scsidisk.h: *2 dfh_Segment int in struct DiskFontHeader 
DEVICES SERIAL H #define =0x00000000 devices/serial.h: *2 +0x0012 libraries/diskfont.h: *54 
DEVICES_TIMER_H #define =0x00000000 devices/timer.h: *2 dfh_Tr struct TextFont (size 0x0034) in struct. DiskFontHeader 
DEVICES TRACKDISK_H #define =0x00000000 devices/trackdisk.h: *2 +0x0036 libraries/diskfont.h: *56 
DeviInfo structure tag DFTCH_MASK #define OxFF =0x000000ff graphics/display.h: *35 

size 0x002c libraries/dosextens.h: *239 DHeight short int in struct ViewPort 
DEV_ABORTIO #define (—-36) =Oxffffffde exec/io.h: *42 +0x00la graphics/view.h: *39 
DEV_BEGINIO #tdefine (~-30) =Oxffffffe2 exec/io.h: *41 DIAB_630 #define 0x04 =0x00000004 intuition/preferences.h: *190 
DE_BLKSPERTRACK #define 5 =0x00000005 libraries/filehandler.h: *60 DIAB_ADV_D25 #define 0x05 =0x00000005 intuition/preferences.h: *191 
de_BlocksPerTrack unsigned int in struct DosEnvec DIAB_C_150 #define 0x06 =0x00000006 intuition/preferences.h: *192 

+0x0014 libraries/filehandler. h: *37 DiagArea structure tag 
de_BootPri int in struct DosEnvec size 0x000e libraries/configregs.h: *191 
+0x003c libraries/filehandler.h: *47 diagstrt array [4] of unsigned short int in struct copinit 

DE_BOOTPRI #define 15 =0x0000000f libraries/filehandler.h: *72 +0x0000 graphics/copper.h: *78 





DIMENSIONS_MASK #define (BOUNDED_] DIMENSIONS | ABSOLUTE] DIMENSIONS | 
PIXEL , DIMENSIONS |MULTIPLY_] DIMENSIONS) =0x000000f0 
intuition/preferences.h: *259 





de_BufMemType unsigned int in struct DosEnvec 
+0x0030 libraries/filehandler.h: *44 
DE_BUFMEMTYPE #define 12 =0x0000000c libraries/filehandler.h: *69 
































































de_DosType unsigned int in struct DosEnvec DiscResource structure tag 
+0x0040 libraries/filehandler.h: *48 size 0x0090 resources/disk.h: *48 
DE_DOSTYPE #define 16 =0x00000010 libraries/filehandler.h: *75 DiscResourceUnit structure tag 
de_Highcyl unsigned int in struct DosEnvec size 0x0056 resources/disk.h: *41, 50 
+0x0028 libraries/filehandler.h: *42 DiskFontHeader structure tag 
de_Interleave unsigned int in struct DosEnvec size 0x006a Jlibraries/diskfont.h: *43 
+0x0020 libraries/filehandler.h: *40 DISKINSERTED #define 0x00008000 =0x00008000 intuition/intuition.h: *653 
DE_INTERLEAVE #define 8 =0x00000008 libraries/filehandler. h: *63 DISKNAME #define “disk.resource" resources/disk.h: *99 
de_LowCyl unsigned int in struct DosEnvec Diskobject structure tag 
+0x0024 libraries/filehandler.h: *41 size 0x004e workbench/icon.h: 29 
DE_LOWCYL #define 9 =0x00000009 libraries/filehandler.h: *64 workbench/workbench.h: *51 
de_Mask unsigned int in struct DosEnvec DISKREMOVED #define 0x00010000 =0x00010000 intuition/intuition.h: *654 
+0x0038 libraries/filehandler.h: *46 DispCount unsigned int in struct ExecBase 
DE_MASK #define 14 =0x0000000e libraries/filehandler.h: *71 +0x0llc exec/execbase.h: *57 
de MaxTransfer unsigned int in struct DosEnvec DispCount short int in struct StringInfo 
+0x0034 libraries/filehandler.h: *45 +0x0012 intuition/intuition.h: *463 
DE_MAXTRANSFER #define 13 =0x0000000d libraries/filehandler.h: *70 DisplayFlags unsigned short int in struct GfxBase 


+0x00ce graphics/gfxbase.h: *51 


DE_MEMBUFTYPE #define 12 =0x0000000c libraries/filehandler.h: *67 
short int in struct StringInfo 


de_NumBuffers unsigned int in struct DosEnvec 





8T - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 23 


+0x000c 
DITHERING_MASK 


diwstop 
+0x0090 
diwstrt 
+0x008e 
DIW_HORIZ POS 
DIW_VRTCL_POS 


intuition/intuition.h: *458 

#define (HALFTONE DITHERING|FLOYD DITHERING) =0x00000600 
intuition/preferences.h: *260 

unsigned short int in struct Custom 

hardware/custom.h: *77 

unsigned short. int in struct Custom 

hardware/custom.h: *76 

#define Ox7F =0x0000007f graphics/display.h: *30 

#tdefine OxlFF =0x000001ff graphics/display.h: *31 


DIW_VRTCL_POS SHIFT #define 7 =0x00000007 graphics/display.h: *32 


di_Devices 
+0x0008 
di_DevInfo 
+0x0004 
di_Handlers 
+0x000c 
di_McName 
+0x0000 
di_NetHand 
+0x0010 
DLT_DEVICE 
DLT_DIRECTORY 
DLT_VOLUME 
dl_A2 
+0x002a 


+0x000c 
dl_LockList 
+0x001c 


dl_VolumeDate 

+0x0010 
DMAB_AUDO 
DMAB_AUD1 
DMAB_AUD2 
DMAB_AUD3 
DMAB_BLITHOG 
DMAB_BLITTER 
DMAB_BLTDONE 
DMAB_BLTNZERO 
DMAB_COPPER 
DMAB_ DISK 
DMAB_ MASTER 
DMAB_ RASTER 
DMAB_SETCLR 
DMAB_SPRITE 
dmacon 

+0x0096 


int in struct DosInfo 
libraries/dosextens.h: 
int in struct DosInfo 
libraries/dosextens.h: 
int in struct DosInfo 
libraries/dosextens.h: 
int in struct DosInfo 
libraries/dosextens.h: *187 

pointer to pointer to char in struct DosInfo 
libraries/dosextens.h: *191 

#define 0 =0x00000000 libraries/dosextens.h: 
#tdefine 1 =0x00000001 libraries/dosextens.h: 
#define 2 =0x00000002 libraries/dosextens.h: 
int in struct DosLibrary 
libraries/dosextens.h: *168 

int in struct DosLibrary 
libraries/dosextens.h: *169 

int in struct DosLibrary 
libraries/dosextens.h: *170 

int in struct DeviceList 
libraries/dosextens.h: *232 

pointer to pointer to char in struct DosLibrary 
libraries/dosextens.h: *167 

struct Library (size 0x0022) in struct DosLibrary 
libraries/dosextens. h: *165 

int in struct DeviceList 

libraries/dosextens.h: *229 

int in struct DeviceList 

libraries/dosextens.h: *231 

pointer to int in struct DeviceList 
libraries/dosextens.h: *234 

int in struct DeviceList 

libraries/dosextens.h: *226 

pointer to pointer to char in struct DosLibrary 
libraries/dosextens.h: *166 

pointer to struct MsgPort in struct DeviceList 
libraries/dosextens.h: *228 

int in struct DeviceList 

libraries/dosextens.h: *227 

int in struct DeviceList 

libraries/dosextens.h: *233 

struct DateStamp (size 0x000c) in struct DeviceList 
libraries/dosextens.h: *230 

#define 0 =0x00000000 hardware/dmabits.h: *35 
#define 1 =0x00000001 hardware/dmabits.h: *36 
#define 2 =0x00000002 hardware/dmabits.h: *37 
#define 3 =0x00000003 hardware/dmabits.h: *38 
#define 10 =0x0000000a hardware/dmabits.h: *45 
#define 6 =0x00000006 hardware/dmabits.h: *41 
#tdefine 14 =0x0000000e hardware/dmabits.h: *46 
#tdefine 13 =0x0000000d hardware/dmabits.h: *47 
#define 7 =0x00000007 hardware/dmabits.h: *42 
#define 4 =0x00000004 hardware/dmabits.h: *39 
#define 9 =0x00000009 hardware/dmabits.h: *44 
#define 8 =0x00000008 hardware/dmabits.h: *43 
#define 15 =0x0000000f hardware/dmabits.h: *34 
#tdefine 5 =0x00000005 hardware/dmabits.h: *40 
unsigned. short int in struct Custom 
hardware/custom.h: *80 


*189 
*188 
*190 


*285 
*286 
*287 





Sep 21 13:06.1988 C_Language_Cross-Reference Page 24 


dmaconr 

+0x0002 
DMAF_ALL 
DMAF_AUDO 
DMAF_AUD1 
DMAF_AUD2 
DMAF_AUD3 
DMAF_AUDIO 
DMAF_BLI'THOG 
DMAF_ BLITTER 
DMAF_BLTDONE 
DMAF_ BLTNZERO 
DMAF COPPER 
DMAF_DISK 
DMAF_MASTER 
DMAF_RASTER 
DMAF_SETCLR 
DMAF_SPRITE 
DMRequest 

+0x0028 
dn_GlobalVec 

+0x0024 
dn_Handler 

+0x0010 
dn_Lock 

+0x000c 
dn_Name 

+0x0028 
dn_Next 

+0x0000 
dn_Priority 

+0x0018 
dn_SegList 

+0x0020 
dn_StackSize 

+0x0014 
dn_Startup 

+0x001c 
dn_Task 

+0x0008 
dn 

+0x0004 
dol_DiskType 

+0x0010 
dol_GlobVec 

+0x0014 
dol_Handler 

+0x0000 
dol_handler 

+0x0000 
dol_Lock 

+0x000e 
dol_Lockhist 

+0x000ce 
dol_misc 


+0x0000 
dol_Priority 
+0x0008 
dol_SegList 
+0x0010 
dol_StackSize 
+0x0004 
dol_Startup 
+0x000c 
dol_Task 


unsigned short int in struct Custom 
hardware/custom.h: *21 

#define Ox01FF =0x000001ff hardware/dmabits. 
#define 0x0001 =0x00000001 hardware/dmabits. 
#define 0x0002 =0x00000002 hardware/dmabits. 
#define 0x0004 =0x00000004 hardware/dmabits. 
#define 0x0008 =0x00000008 hardware/dmabits. 
#define Ox000F =0x0000000f hardware/dmabits. 
#define 0x0400 =0x00000400 hardware/dmabits. 
#define 0x0040 =0x00000040 hardware/dmabits 
#define 0x4000 =0x00004000 hardware/dmabits. 
#define 0x2000 =0x00002000 hardware/dmabits. 
#define 0x0080 =0x00000080 hardware/dmabits. 
#define 0x0010 =0x00000010 hardware/dmabits 
#define 0x0200 =0x00000200 hardware/dmabits 
#define 0x0100 =0x00000100 hardware/dmabits. 
#define 0x8000 =0x00008000 hardware/dmabits. 
#define 0x0020 =0x00000020 hardware/dmabits. 
pointer to struct Requester in struct Window 
intuition/intuition.h: *713 

int in struct DeviceNode 
libraries/filehandler.h: *109 
int in struct DeviceNode 
libraries/filehandler.h: 
int in struct DeviceNode 
libraries/filehandler.h: 
int in struct DeviceNode 
libraries/filehandler.h: 
int in struct DeviceNode 
libraries/filehandler.h: *97 
int in struct DeviceNode 
libraries/filehandler.h: 
int in struct DeviceNode 
libraries/filehandler.h: *107 

unsigned int in struct DeviceNode 
libraries/filehandler.h: *104 

int in struct DeviceNode 
libraries/filehandler.h: *106 

pointer to struct MsgPort in struct DeviceNode 
libraries/filehandler.h: *99 

unsigned int in struct DeviceNode 
libraries/filehandler.h: *98 

int in struct (no tag) 
libraries/dosextens.h: 
int in struct (no tag) 
libraries/dosextens.h: 
int in struct (no tag) 
libraries/dosextens.h: *262 

struct (no tag) (size 0x0018) in union (no tag) 
libraries/dosextens.h: *270 

int in struct DosList 
libraries/dosextens.h: *259 

int in struct (no tag) 

libraries/dosextens.h: *274 

union (no tag) (size 0x0018) in struct DosList 
libraries/dosextens.h: *278 

int in struct DosList 
libraries/dosextens.h: 
int in struct DosList 
libraries/dosextens.h: 
int in struct (no tag) 
libraries/dosextens.h: 
int in struct (no tag) 
libraries/dosextens.h: 
int in struct (no tag) 
libraries/dosextens.h: *263 

unsigned int in struct (no tag) 
libraries/dosextens.h: *265 

pointer to struct MsgPort in struct DosList 


How 


I ol ot 


DR bbb Bb bb bbb bt bb 


*103 
*102 
*117 


*105 


*275 
*267 


*280 
*256 
*264 
*266 


*27 
*16 
*17 
*18 
*19 
*15 
*26 
*22 
«31 
*32 
*23 
*20 
*25 
*24 
*14 
*21 


6T - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 25 


+0x0008 
+0x0004 


+0x0000 
DosEnvec 
size 0x0044 


size 0x0014 
DosLibrary 

size 0x0036 
DosList 

size 0x002c 


do_DrawerData 
+0x0042 
do_Gadget 
+0x0004 
do Magic 
+0x0000 
do_StackSize 
+0x004a 
do_ToolTypes 
+0x0036 
do_ToolWindow 
+0x0046 
do_! 
+0x0030 
do_Version 
+0x0002 


DP_2DFACSHIFT 

DP_2DINDEXMASK 
+0x0014 
+0x0018 
+0x001c 
+0x0020 
+0x0024 
+0x0028 
+0x002c 

dp_BufAddr 


dp Link 
+0x0000 


libraries/dosextens.h: *258 

int in struct DosList 

libraries/dosextens.h: *257 

struct (no tag) (size 0x0014) in union (no tag) 
libraries/dosextens.h: *276 

struct DateStamp (size 0x000c) in struct (no tag) 
libraries/dosextens.h: *273 

structure tag 

libraries/filehandler.h: *31 

#define (OL) libraries/dos.h: *22 

structure tag © 

libraries/dosextens.h: *186 

structure tag 

libraries/dosextens.h: *164 

structure tag 

libraries/dosextens.h: *255 

#define "dos.library" libraries/dos.h: *17 
structure tag 

libraries/dosextens.h: *79, 112 

#define (-1L) libraries/dos.h: *21 

typedef. double exec/types.h: *44 

struct timeval (size 0x0008) in struct Preferences 
intuition/preferences.h: *56 

int in struct Diskobject 

workbench/workbench.h: ¥*58 

int in struct DiskObject 

workbench/workbench.h: *59 

pointer to char in struct DiskObject 
workbench/workbench.h: *56 

pointer to struct DrawerData in struct DiskObject 
workbench/workbench.h: *60 

struct Gadget (size 0x002c) in struct DiskObject 
workbench/workbench.h: *54 

unsigned short int in struct DiskObject 
workbench/workbench.h: *52 

int in struct Diskobject 

workbench/workbench.h: *62 

pointer to pointer to char in struct DiskObject 
workbench/workbench.h: *57 

pointer to char in struct Diskobject 
workbench/workbench.h: *61 

char in struct DiskObject 
workbench/workbench.h: *55 

unsigned short int in struct Diskobject 
workbench/workbench.h: *53 

#define 3 =0x00000003 devices/keymap.h: *67 
#define 0 =0x00000000 devices/keymap.h: *65 
#define 0x08 =0x00000008 devices/keymap.h: *68 
#define 0x01 =0x00000001 devices/keymap.h: *66 
#define 4 =0x00000004 devices/keymap.h: *71 
#define Ox0f =0x0000000f devices/keymap.h: *70 
#define dp Type =0x00000000 libraries/dosextens.h: *93 
int in struct DosPacket 

libraries/dosextens.h: *97 

int in struct DosPacket 

libraries/dosextens.h: *98 

int in struct DosPacket 

libraries/dosextens.h: *99 

int in struct DosPacket 

libraries/dosextens.h: *100 

int in struct DosPacket. 

libraries/dosextens.h: *101 

int in struct DosPacket 

libraries/dosextens.h: *102 

int in struct DosPacket 

libraries/dosextens.h: *103 

#define dp _Argl =0x00000000 libraries/dosextens.h: *96 
pointer to struct Message in struct DosPacket 
libraries/dosextens.h: *80 












Sep 21 13:06 1988 C_Language_Cross-Reference Page 26 


dp_Type 


DRAFT 

DrawCircle 

DrawerData 
size 0x0038 


+0x0008 


pointer to struct MsgPort in struct DosPacket. 
libraries/dosextens.h: *81 

int in struct DosPacket 

libraries/dosextens.h: *86 

int in struct DosPacket 

libraries/dosextens.h: *90 

#define dp_Resl =0x00000000 libraries/dosextens.h: *94 
#define dp Res2 ~0x00000000 libraries/dosextens.h: *95 
int in struct DosPacket 

libraries/dosextens.h: *83 

#define 0x000 =0x00000000 intuition/preferences.h: *158 
Macro (4 arguments) graphics/gfxmacros.h: *37 
structure tag 

workbench/workbench.h: *41, 60 


DRAWERDATAFILESIZE #define (sizeof( struct DrawerData )) 


DrawMode 
+0x001c 


DRT_37422D2S 
DRT_AMIGA 
DRT_EMPTY 
dru_DiscBlock 
+0x0014 
dru_DiseSync 
+0x002a 
dru_Index 
+0x0040 
dru_Message 
+0x0000 
DR_ALLOCUNIT 


dr_CiaResource 
+0x002c 
dr_Current 
+0x0022 
dr_DiscBlock 
+0x004e 
dr_DiscSyne 
+0x0064 


DR_FREEUNIT 
DR_GETUNIT 
DR_GETUNITID 


DR_GIVEUNIT 


dr_Index 
+0x007a 


workbench/workbench.h: *48 

char in struct RastPort 
graphics/rastport.h: *62 

char in struct IntuiText 
intuition/intuition.h: *497 

char in struct Border 
intuition/intuition.h: *526 

pointer to struct VSprite in struct VSprite 
graphics/gels.h: *79 

#define 7 =0x00000007 resources/disk.h: *67 


#tdefine 0 =0x00000000 resources/disk.h: *63 
#define 1 =0x00000001 resources/disk.h: *64 
#define 2 =0x00000002 resources/disk.h: *65 
#define 3 =0x00000003 resources/disk.h: *66 


#define (1<<7) =0x00000080 resources/disk.h: *73 

#define (1<<0) =0x00000001 resources/disk.h: *69 

#define (1<<1) =0x00000002 resources/disk.h: *70 

#define (1<<2) =0x00000004 resources/disk.h: *71 

#define (1<<3) =0x00000008 resources/disk.h: *72 

#define 1 =0x00000001 devices/trackdisk.h: *148 

#define 2 =0x00000002 devices/trackdisk.h: *149 

#define (0x55555555) =0x55555555 resources/disk.h: *118 
#define (0x00000000) =0x00000000 resources/disk.h: *117 
#define (OxFFPFFFFF) =Oxffffffff resources/disk.h: *119 
struct Interrupt (size 0x0016) in struct DiscResourceUnit 
resources/disk.h: *43 

struct Interrupt (size 0x0016) in struct DiscResourceUnit 
resources/disk.h: *44 

struct Interrupt (size 0x0016) in struct DiscResourceUnit 
resources/disk.h: *45 

struct Message (size 0x0014) in struct DiscResourceUnit 
resources/disk.h: *42 

#define (LIB BASE - O*LIB VECTSIZE) =Oxfffffffa 
resources/disk.h: *102 

pointer to struct Library in struct DiscResource 
resources/disk.h: *54 

pointer to struct DiscResourceUnit in struct DiscResource 
resources/disk.h: *50 

struct Interrupt (size 0x0016).in struct DiscResource 
resources/disk.h: *57 

struct Interrupt (size 0x0016) in struct DiscResource 
resources/disk.h: *58 

char in struct DiscResource 

resources/disk.h: *51 

#define (LIB_BASE — 1*LIB_VECTSIZE) =Oxfffffff4 
resources/disk.h: *103 

#define (LIB_BASE - 2*LIB_VECTSIZE) =Oxffffffee 
resources/disk.h: *104 

#define (LIB BASE — 4*LIB VECTSIZE) =Oxffffffe2 
resources/disk.h: *106 

#define (LIB BASE ~- 3*LIB_VECTSIZE) =Oxffffffe8 
resources/disk.h: *105 

struct Interrupt (size 0x0016) in struct DiscResource 
resources/disk.h: *59 


0@ -—H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 27 


DR_LASTCOMM 
dr_Library 

+0x0000 
dr_pad 

+0x0027 
dr_SysLib 

+0x0028 
dr_UnitID 

+0x0030 
dr_ Waiting 

+0x0040 
dskbytr 

+0x00la 
dskdat 

+0x0026 
dskdatr 

+0x0008 
DSKDMAOFF 
dsklen 

+0x0024 
dskpt 

+0x0020 
dsksync 

+0x007e 
DspIns 

+0x0008 
DSR_CPR 
ds_ Days 

+0x0000 
ds_Minute 

+0x0004 
ds_Tick 

+0x0008 
DUALPF 
di 

+0x001f£ 
davi_GlobVec 

+0x0024 
dvi_Handler 

+0x0010 
dvi_Lock 

+0x000c 
dvi_Name 

+0x0028 
dvi_Next 

+0x0000 
dvi_Priority 

+0x0018 
dvi_SegList 

+0x0020 
dvi_StackSize 

+0x0014 
dvi_Startup 

+0x001c 
dvi_Task 

+0x0008 


#define (DR_GIVEUNIT) =Oxffffffe8 resources/disk.h: *109 
struct Library (size 0x0022) in struct DiscResource 
resources/disk.h: *49 

char in struct DiscResource 

resources/disk.h: *52 

pointer to struct Library in struct DiscResource 
resources/disk.h: *53 

array [4] of unsigned int in struct DiscResource 
resources/disk.h: *55 

struct List (size 0x000e) in struct DiscResource 
resources/disk.h: *56 

unsigned short int in struct Custom 
hardware/custom.h: *33 

unsigned short int in struct Custom 
hardware/custom.h: *38 

unsigned short int in struct Custom 
hardware/custom.h: *24 

#define 0x4000 =0x00004000 resources/disk.h: *84 
unsigned short int in struct Custom 
hardware/custom.h: *37 

pointer to pointer to char in struct Custom 
hardware/custom.h: *36 

unsigned short int in struct Custom 
hardware/custom.h: *70 

pointer to struct CopList in struct ViewPort 
graphics/view.h: *35 

#define 6 =0x00000006 devices/console.h: *76 

int in struct DateStamp 

libraries/dos.h: *50 

int in struct DateStamp 

libraries/dos.h: *51 

int in struct DateStamp 

libraries/dos.h: *52 

#define 0x400 =0x00000400 graphics/view.h: *59 
char in struct RastPort 

graphics/rastport.h: *65 

int in struct DevInfo 


libraries/dosextens.h: *249 
int in struct DeviInfo 
libraries/dosextens.h: *244 
int in struct Devinfo 
libraries/dosextens.h: *243 
int in struct Devinfo 
libraries/dosextens.h: *250 
int in struct DevInfo 
libraries/dosextens.h: *240 
int in struct DevInfo 
libraries/dosextens.h: *246 
int in struct DeviInfo 
libraries/dosextens.h: *248 
int in struct DevInfo 
libraries/dosextens.h: *245 
int in struct DevInfo 
libraries/dosextens.h: *247 


pointer to pointer to char in struct Devinfo 


libraries/dosextens.h: *242 
int in struct Devinfo 
libraries/dosextens.h: *241 


short int in struct ViewPort 
graphics/view.h: *39 

short int in struct ViewPort 
graphics/view.h: *40 

short int in struct View 
graphics/view.h: *52 

short int in struct ViewPort 
graphics/view.h: *40 

short int in struct View 
graphics/view.h: *52 

short int in struct CopList 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 28 


+0x0020 
E 
ECIB_INT2PEND 
ECIB_INT6PEND 
ECIB_INT7PEND 
ECIB_INTENA 


graphics/copper.h: *66 
#define ((float) 2.718281828459045) iibraries/mathffp. h: 
#define 4 =0x00000004 libraries/configregs.h: *1 


tdefine 5 =0x00000005 libraries/configregs.h: x14 

#define 6 =0x00000006 libraries/configregs.h: *143 

- #define 1 =0x00000001 libraries/configregs.h: *139 
ECIB INTERRUPTING #define 7 =0x00000007 libraries/configregs.h: *144 
#tdefine 3 =0x00000003 libraries/configregs.h: *140 


ECIB_ RESET 


ECIF_INT2PEND #define (1<<4) =0x00000010 libraries/configregs.h: *148 
ECIF_INT6PEND #define (1<<5) =0x00000020 libraries/configregs.h: *149 
ECIF_INT7PEND #define (1<<6) =0x00000040 libraries/configregs.h: *150 
ECIF INTENA #define (1<<1) =0x00000002 libraries/configregs.h: *146 
ECIF INTERRUPTING #define (1<<7) =0x00000080 libraries/configregs.h: *151 
ECIF_RESET #define (1<<3) =0x00000008 libraries/configregs.h: *147 
ECOFFSET Macro (1 argument). libraries/configregs.h: *160 
ec_BaseAddress char in struct ExpansionControl 

+0x0002 libraries/configregs.h: *47 
ec_Interrupt char in struct ExpansionControl 

+0x0000 libraries/configregs.h: *45 
EC_MEMADDR Macro (1 argument) libraries/configregs.h: *155 
ec_Reservedli char in struct ExpansionControl 

+0x0001 libraries/configregs.h: *46 
ec_Reservedl4 char in struct ExpansionControl 

+0x0004 libraries/configregs.h: *49 
ec_Reserved15 char in struct ExpansionControl 

+0x0005 libraries/configregs.h: *50 
ec_Reserved16 char in struct ExpansionControl 

+0x0006 libraries/configregs.h: *51 
ec_Reserved17 char in struct ExpansionControl 

+0x0007 libraries/configregs.h: *52 
ec_Reserved18 char in struct ExpansionControl 

+0x0008 libraries/configregs.h: *53 
ec_Reservedl9 char in struct ExpansionControl 

+0x0009  libraries/configregs.h: *54 
ec_Reservedla char in struct ExpansionControl 

+0x000a libraries/configregs.h: *55 
ec_Reserved]b char in struct ExpansionControl 

+0x000b libraries/configregs.h: *56 
ec_Reservedle char in struct ExpansionControl 

+0x000c lLibraries/configregs.h: *57 
ec_Reservedld char in struct ExpansionControl 

+0x000d libraries/configregs.h: *58 
ec_Reservedle char in struct ExpansionControl 

+0x000e libraries/configregs.h: *59 
ec_Reservedlf char in struct ExpansionControl 

+0x000f libraries/configregs.h: *60 
ec_Shutup char in struct ExpansionControl 

+0x0003 libraries/configregs.h: *48 
EIGHT LPI #define 0x200 =0x00000200 intuition/preferences.h: *163 
Elapsed unsigned short int in struct ExecBase 

+0x0122 exec/execbase.h: *59 
ELITE #define 0x400 =0x00000400 intuition/preferences.h: *154 
EnablecLI short int in struct Preferences 

+0x007c intuition/preferences.h: *78 
ENDGADGET #define 0x0004 =0x00000004 intuition/intuition.h: *294 
EPSON #define 0x07 =0x00000007 intuition/preferences.h: *193 
EPSON_JX_80 #define 0x08 =0x00000008 intuition/preferences.h: *194 
ERFB_MEMSPACE #define 7 =0x00000007 libraries/configregs.h: *120 
ERFB_NOSHUTUP #define 6 =0x00000006 libraries/configregs.h: *124 
ERFF_MEMSPACE #define (1<<7) =0x00000080 libraries/configregs.h: *126 
ERFF_NOSHUTUP #define (1<<6) =0x00000040 libraries/configregs.h: *127 
EROFFSET Macro (1 argument) libraries/configregs.h: *158 
ERROR_ACTION_NOT_| KNOWN #define 209 =0x000000d1. libraries/dos.h: *145 
ERROR_BAD STREAM NAME #define 206 =0x000000ce libraries/dos.h: *143 
ERROR_COMMENT_TOO_ BIG #define 220 =0x000000de libraries/dos.h: *156 
ERROR DELETE PROTECTED #define 222 =0x000000de libraries/dos.h: *158 
ERROR_DEVICE NOT_MOUNTED #define 218 =0x000000da libraries/dos.h: *154 
ERROR _DIRECTORY_NOT_EMPTY #define 216 =0x000000d8 libraries/dos.h: *152 


ERROR_DIR_NOT_] FOUND #define 204 =0x000000cc libraries/dos.h: 


*141 


*20 


Tf? — H 


Sep 21 13:06 1988 C _Language_Cross~Reference Page 29 


ERROR DISK FULL #define 221 =0x000000dd libraries/dos.h: *157 

ERROR_DISK NOT VALIDATED #define 213 =0x000000d5 libraries/dos.h: *149 
ERROR_DISK_ WRITE PROTECTED #define 214 =0x000000d6 libraries/dos.h: *150 
ERROR FILE NOT_OBJECT #define 121 =0x00000079 libraries/dos.h: *136 

ERROR _ INVALID_( COMPONENT _NAME #define 210 =0x000000d2 libraries/dos. h: *146 
ERROR_INVALID LOCK #define 211 =0x000000d3 libraries/dos.h: *147 
ERROR_INVALID | ) RESIDENT LIBRARY #define 122 =0x0000007a libraries/dos. h: *137 
ERROR LINE TOO LONG #define 120 =0x00000078 libraries/dos.h: *135 
ERROR_NOT_A DOS DISK #define 225 =0x000000el libraries/dos.h: *161 
ERROR_NO DEFAULT DIR #define 201 =0x000000c9 libraries/dos.h: *138 
ERROR_NO_DISK “tdefine 226 =0x000000e2 libraries/dos.h: *162 

ERROR_NO FREE STORE #define 103 =0x00000067 libraries/dos.h: *133 
ERROR_NO_MORE ENTRIES #define 232 =0x000000e8 libraries/dos.h: *163 
ERROR_OBJECT EXISTS #define 203 =0x000000cb libraries/dos.h: *140 
ERROR_OBJECT_IN USE #define 202 =0x000000ca libraries/dos.h: *139 

ERROR_( - OBJECT NOT _FOUND #define 205 =0x000000cd libraries/dos.h: *142 
ERROR OBJECT_TOO LARGE #define 207 =0x000000cf libraries/dos.h: *144 
ERROR_OBJECT WRONG_TYPE #define 212 =0x000000d4 libraries/dos.h: *148 
ERROR_READ | PROTECTED #define 224 =0x000000e0 libraries/dos.h: *160 
ERROR_RENAME ACROSS DEVICES #define 215 =0x000000d7 libraries/dos.h: *151 
ERROR_SEEK_ERROR #define 219 =0x000000db libraries/dos.h: *155 
ERROR_TASK TABLE_FULL #define 105 =0x00000069 libraries/dos.h: *134 
ERROR_TOO_MANY LEVELS #define 217 =0x000000d9 libraries/dos.h: *153 
ERROR_WRITE PROTECTED #define 223 =0x000000df libraries/dos.h: *159 
ERTB_CHAINEDCONFIG #define 3 =0x00000003 libraries/configregs.h: *108 
ERTB DIAGVALID #define 4 =0x00000004 libraries/configregs.h: *109 
ERTB_MEMLIST #define 5 =0x00000005 libraries/configregs.h: *110 
ERTF_CHAINEDCONFIG #define (1<<3) =0x00000008 libraries/configregs.h: *112 
ERTF DIAGVALID #define (1<<4) =0x00000010 libraries/configregs.h: *113 
ERTF_MEMLIST #define (1<<5) =0x00000020 libraries/configregs.h: *11l4 


ERT_MEMBIT #define 0 =0x00000000 libraries/configregs.h: *103 
ERT_MEMMASK #define 0x07 =0x00000007 libraries/configregs.h: *102 
ERT_MEMNEEDED Macro (1 ar mt) libraries/configregs.h: *132 
ERT_MEMSIZE #define 3 =0x00000003 librariés/configregs.h: *104 


ERT_NEWBOARD #define OxcO =0x000000c0 libraries/configregs.h: *98 
ERT_SLOTSNEEDED Macro (1 argument) libraries/configregs.h: *136 
ERT_TYPEBIT #define 6 =0x00000006 libraries/configregs.h: *96 
ERT_TYPEMASK #define OxcO =0x000000c0 libraries/configregs.h: *95 
ERT_TYPESIZE #define 2 =0x00000002 libraries/configregs.h: *97 
er_Flags char in struct ExpansionRom 
+0x0002 libraries/configregs. h: *33 
er_InitDiagVec unsigned short int in struct ExpansionRom 
+0x000a libraries/configregs.h: *37 
er Manufacturer unsigned short int in struct ExpansionRom 
+0x0004 libraries/configregs.h: *35 
er_Product char in struct ExpansionRom 
+0x0001 libraries/configregs.h: *32 
er_Reserved03 char in struct ExpansionRom 
+0x0003 libraries/configregs.h: *34 
er_Reserved0c char in struct ExpansionRom 
+0x000c libraries/configregs.h: *38 
er_Reserved0d char in struct ExpansionRom 
+0x000d libraries/configregs.h: *39 
er_Reserved0e char in struct ExpansionRom 
+0x000e libraries/configregs.h: *40 
er_Reserved0f char in struct ExpansionRom 
+0x000f libraries/configregs.h: *41 
er_SerialNumber unsigned int in struct ExpansionRom 
+0x0006 libraries/configregs.h: *36 
er! char in struct ExpansionRom 
+0x0000 libraries/configregs.h: *31 


ETD_CLEAR #define (CMD_CLEAR | TDF_EXTCOM) =0x00008005 
devices/trackdisk.h: *103 

ETD_FORMAT #define (TD _FORMAT|TDF_EXTCOM) =0x0000800b 
devices/trackdisk.h: *101 

ETD_MOTOR #define (TD MOTOR |TDF_EXTCOM) =0x00008009 
devices/trackdisk.h: *99 

ETD_RAWREAD #define (TD _RAWREAD|TDF_EXTCOM) =0x00008010 


devices/trackdisk.h: *104 








Sep 21 13:06 1988 C_Language_Cross-Reference Page 30 


#define (TD_RAWWRITE|TDF_EXTCOM) =0x00008011 


ETD_RAWWRITE 
devices/trackdisk.h: *105 


ETD_READ #define (CMD READ|TDF_EXTCOM) =0x00008002 
devices/trackdisk.h: *98 

ETD_SEEK #define (TD_| SEEK |TDF_] EXTCOM) =0x0000800a 
devices/trackdisk.h: *100 

ETD_UPDATE #define (CMD UPDATE |TDF_EXTCOM) =0x00008004 
devices/trackdisk.h: *102 

ETD WRITE ¥define (CMD WRITE|TDF_EXTCOM) =0x00008003 


devices/trackdisk.h: *97 
EXCLUSIVE LOCK #define -1 =Oxffffffff libraries/dos.h: *46 
ExecBase structure tag 
size 0x024c exec/execbase.h: *30 
libraries/romboot_base.h: 35 
pointer to pointer to char in struct ExpansionBase 
+0x0024 libraries/expansionbase.h: *48 
pointer to struct ExecBase in struct RomBootBase 
+0x0022 libraries/romboot_base.h: *35 
ExecBaseNewReserved array [20] of char in struct ExecBase 
+0x0238 exec/execbase.h: *120 
ExecBaseReserved array [10] of char in struct ExecBase 
+0x022e exec/execbase.h: *119 
ExecMessage struct Message (size 0x0014) in struct IntuiMessage 
+0x0000 intuition/intuition.h: *598 
#define "exec.library" exec/execname.h: *13 
#define =0x00000000 exec/alerts.h: *2 
EXEC_DEVICES_H #define =0x00000000 exec/devices.h: *2 
EXEC_ERRORS_H #define =0x00000000 exec/errors.h: *2 
EXEC_EXECBASE_H #define =0x00000000 exec/execbase.h: *2 
EXEC_EXECNAME H #define =0x00000000 exec/execname.h: *2 
EXEC_EXEC_H #define =0x00000000 exec/exec.h: *2 
EXEC_INTERRUPTS_H #define =0x00000000 exec/interrupts.h: *2 
EXEC_IO_H #define =0x00000000 exec/io.h: *2 
EXEC_LIBRARIES_H #define =0x00000000 exec/libraries.h: *2 
EXEC_LISTS_H #define =0x00000000 exec/lists.h: *2 
EXEC_MEMORY_H #define =0x00000000 exec/memory.h: *2 
EXEC_NODES_H #define =0x00000000 exec/nodes.h: *2 
EXEC_PORTS_H #define =0x00000000 exec/ports.h: *2 
EXEC RESIDENT H #define =0x00000000 exec/resident.h: *2 
EXEC_SEMAPHORES_H #define =0x00000000 exec/semaphores.h: ¥*2 
EXEC_TASKS_H #define =0x00000000 exec/tasks.h: *2 
EXEC_TYPES_H #define =0x00000000 exec/types.h: *2 


ExecBase 


ExecBase 


EXECNAME 
EXEC_ALERTS H 


exp #define SPExp =0x00000000 libraries/mathffp.h: *43 
exp #define IEEEDPExp =0x00000000 libraries/mathieeedp.h: *44 
ExpansionBase structure tag 


size 0x0lc8 libraries/expansionbase.h: *43 
ExpansionControl structure tag 
size 0x0010 libraries/configregs.h: *44 
ExpansionInt structure tag 
size 0x0006 libraries/expansionbase.h: *35 
EXPANSIONNAME #define “expansion.library" libraries/expansion.h: *13 
ExpansionRom structure tag 
size 0x0010 libraries/configregs.h: *30 
libraries/configvars. h: 30 
pointer to char in struct Window 
+0x0074 intuition/intuition.h: *781 
pointer to char in struct Screen 
+0x0152 intuition/screens.h: *83 
EXTRA_HALFBRITE #define 0x80 ~0x00000080 graphics/view.h: *67 
ext_size char in. struct Preferences 
+0x00e7 intuition/preferences.h: *125 
E_EXPANSIONBASE #define Oxe80000 =0x00e80000 libraries/configregs.h: 
E_EXPANSIONSIZE #define 0x080000 =0x00080000 libraries/configregs.h: 
E_EXPANSIONSLOTS #define 8 =0x00000008 libraries/configregs.h: *84 
E_MEMORYBASE #define 0x200000 =0x00200000 libraries/configregs.h: *86 
h: 
8 


ExtData 


ExtData 


*B2 
*83 


E_MEMORYSIZE #define 0x800000 =0x00800000 libraries/configregs. *87 
E_MEMORYSLOTS #define 128 =0x00000080 libraries/configregs.h: *8 
E_SLOTMASK #define Oxffff =Ox0000ffff libraries/configregs.h: *76 
E_SLOTSHIFT #define 16 =0x00000010 libraries/configregs.h: *77 


cc -— H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 31 


E_SLOTSIZE 
fabs 
fabs 
FALSE 
FANFOLD 
fatten_count 
+0x005a 
fch_FileID 
+0x0000 
FCH_ID 
fch_NumEntries 
+0x0002 
fc_FileName 
+0x0000 
fc_Flags 
+0x0103 
fc_Style 
+0x0102 
fe_YSize 
+0x0100 
FEMALE 
FgPen 
+0x0019 
fhb_ChkSum 
+0x0008 
fhb_DosType 
+0x0020 
fhb_ Flags 
+0x0014 
fhb_Globalvec 
+0x004c 
fhb_Handler 
+0x0038 
fhb_HostID 
+0x000c 


+0x0010 
fhb_PatchFlags 
+0x0028 
fhb_ Priority 
+0x0040 
fhb_Reservedi 
+0x0018 
fhb_Reserved2 
+0x0050 
fhb_Reserved3 
+0x00ac 


#define 0x10000 =0x00010000 libraries/configregs.h: *75 
#define SPAbs =0x00000000 libraries/mathffp.h: *33 
#define IEEEDPAbs =0x00000000 libraries/mathieeedp.h: *34 
#define 0 =0x00000000 exec/types.h: *51 

#define 0x00 =0x00000000 intuition/preferences.h: *149 
char in struct Layer_Info 

graphics/layers.h: *42 

unsigned short int in struct FontContentsHeader 
libraries/diskfont.h: *35 

#define Ox0f00 =0x00000f00 libraries/diskfont.h: *32 
unsigned short int in struct FontContentsHeader 
libraries/diskfont.h: *36 

array [256] of char in struct FontContents 
libraries/diskfont.h: *26 

char in struct FontContents 

libraries/diskfont.h: *29 

char in struct FontContents 

libraries/diskfont.h: *28 

unsigned short int in struct FontContents 
libraries/diskfont.h: *27 

#tdefine 1 =0x00000001 devices/narrator.h: *44 

char in struct RastPort 

graphics/rastport.h: *59 

int in struct FileSysHeaderBlock 

devices/hardblocks.h: *153 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *158 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *156 

int in struct FileSysHeaderBlock 

devices/hardblocks.h: *175 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *168 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *154 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *151 

unsigned int in struct FileSysHeaderBlock 
devices/hardbiocks.h: *167 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *155 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *161 

int in struct FileSysHeaderBlock 

devices/hardblocks.h: *170 

array [2] of unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *157 

array (23] of unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *176 

array [21] of unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *177 


fhb_SegListBlocks int in struct FileSysHeaderBlock 


+0x0048 
fhb_StackSize 

+0x003¢ 
fhb_Startup 

+0x0044 
fhb_SummedLongs 

+0x0004 
fhb_Task 

+0x0030 
fhb_' 


+0x002c 
fhb_ Version 

+0x0024 
fh_Argl 
fh_Arg2 

+0x0028 
fh_Args 


devices/hardblocks.h: *172 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *169 

int in struct FileSysHeaderBlock 
devices/hardblocks.h: *171 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *152 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *166 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *165 

unsigned int in struct FileSysHeaderBlock 
devices/hardblocks.h: *160 

#define fh_Args =0x00000000 libraries/dosextens.h: *73 
int in struct FileHandle 
libraries/dosextens.h: *74 

int in struct FileHandle 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 32 


+0x0024 
fh_ Buf 

+0x000c 
fh_End 

+0x0014 
fh_Funel 
fh_Func2 

+0x001c 
fh_Func3 

+0x0020 
fh_Funcs 

+0x0018 


+0x0008 
FIBB_ARCHIVE 
FIBB_DELETE 
FIBB_EXECUTE 
FIBB_ PURE 
FIBB_READ 
FIBB_SCRIPT 
FIBB WRITE 
FIBF_ARCHIVE 
FIBF_DELETE 
FIBF_EXECUTE 
FIBF_PURE 
FIBF_READ 
FIBF_SCRIPT 
FIBF_WRITE 
fib Comment 
+0x0090 
fib Date 
+0x0084 
fib_Dirknt: 
+0x0004 
fib_DiskKey 
+0x0000 
fib _EntryType 
+0x0078 
fib FileName 
+0x0008 
fib_NumBlocks 
+0x0080 
fib Protection 
+0x0074 
fib Reserved 
+0x00e0 
fib_Size 
+0x007c 
FileHandle 
size 0x002c 
FileInfoBlock 
size 0x0104 
FileLock 
size 0x0014 
FILENAME _SIZE 
FilesysEntry 
size 0x003e 


libraries/dosextens.h: *72 

int in struct FileHandle 
libraries/dosextens.h: *65 

int in struct FileHandle 
libraries/dosextens.h: *67 

#define fh_Funes =0x00000000 libraries/dosextens.h: *69 
int in struct FileHandle 
libraries/dosextens.h: *70 

int in struct FileHandle 
libraries/dosextens.h: *71 

int in struct FileHandle 
libraries/dosextens.h: *68 

pointer to struct Message in struct FileHandle 
libraries/dosextens.h: *61 

pointer to struct MsgPort in struct FileHandle 
libraries/dosextens.h: *62 

int in struct FileHandle 
libraries/dosextens.h: *66 

pointer to struct MsgPort in struct FileHandle 
libraries/dosextens.h: *63 


#define 4 =0x00000004 libraries/dos.h: *76 
#define 0 =0x00000000 libraries/dos.h: *80 
#define 1 =0x00000001 libraries/dos.h: *79 
#define 5 =0x00000005 libraries/dos.h: *75 
#tdefine 3 =0x00000003 libraries/dos.h: *77 
#define 6 =0x00000006 libraries/dos.h: *74 
#define 2 =0x00000002 libraries/dos.h: *78 


#define (1<<FIBB_ARCHIVE) =0x00000010 libraries/dos.h: *83 
#define (1<<FIBB_DELETE) =0x00000001 libraries/dos.h: *87 
#define (1<<FIBB_EXECUTE) =0x00000002 libraries/dos.h: *86 
#define (1<<FIBB_PURE) =0x00000020 libraries/dos.h: *82 
#define (1<<FIBB_READ) =0x00000008 libraries/dos.h: *84 
#tdefine (1<<FIBB_SCRIPT) =0x00000040 libraries/dos.h: *81 
#tdefine (1<<FIBB_ WRITE) =0x00000004 libraries/dos.h: *85 
array [80] of char in struct FileInfoBlock 
libraries/dos.h: *67 

struct DateStamp (size 0x000c) in struct FileInfoBlock 
libraries/dos.h: *66 

int in struct FileInfoBlock 

libraries/dos.h: *59 

int in struct FileInfoBlock 

libraries/dos.h: *58 

int in struct FileInfoBlock 

libraries/dos.h: *63 

array [108] of char in struct FileInfoBlock 
libraries/dos.h: *61 

int in struct FileInfoBlock 

libraries/dos.h: *65 

int in struct FileInfoBlock 

libraries/dos.h: *62 

array [36] of char in struct FileInfoBlock 
libraries/dos.h: *68 

int in struct FileInfoBlock 

libraries/dos.h: *64 

structure tag 

libraries/dosextens.h: *60 

structure tag 

libraries/dos.h: *57 

structure tag 

libraries/dosextens.h: *290 

#define 30 =0x000000le intuition/preferences.h: *26, 82, 110 
structure tag 

resources/filesysres.h: *32 


FileSysHeaderBlock structure tag 


size 0x0100 
FileSysResource 
size 0x0020 


devices/hardblocks.h: *150 
structure tag 
resources/filesysres.h: *26 


FileSysStartupMsg structure ta 


size 0x0010 


g 
libraries/filehandler.h: *81 








€f -—H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 33 


FILL_CARRYIN 


FILL_OR 
FILL_XOR 
FindConfigDev 
FindToolType 
FINE 
firstBlissobj 

+0x00le 
FirstCopList 

+0x0004 
FirstGadget 

+0x003e 
FirstGadget 

+0x0012 
FirstGadget 

+0x0146 
FirstItem 

+0x0012 
FirstRequest 

+0x0024 
FirstScreen 

+0x003c 
FirstWindow 

+0x0004 
FirstX 

+0x0014 
FirstY 

+0x0016 
FlagPtr 

+0x000c¢ 
Flags 

+0x0004 
Flags 

+0x00le 
Plags 

+0x0000 
Flags 

+0x0001 
Flags 

+0x0020 
Flags 

+0x0058 
Flags 

+0x000c 
Flags 

+0x000c 
Flags 

+0x001c 
Plags 

+0x000c 
Flags 

+0x0000 
Flags 

+0x0000 
Flags 

+0x0018 
Flags 

+0x000e 
Flags 

+0x0014 
Flags 

+0x0014 
Flags 

+0x0000 
Flags 

+0x0000 


Flags 


#define 0x4 =0x00000004 hardware/blit.h: *60 
#define 0x8 =0x00000008 hardware/blit.h: *58 
#define 0x10 =0x00000010 hardware/blit.h: *59 


extern function returning pointer to struct ConfigDev (size 0x44) 
libraries/configvars.h: *56 

libraries/expansion.h: *25 

extern function returning pointer to char workbench/icon.h: 
#define 0x800 =0x00000800 intuition/preferences.h: *155 
pointer to pointer to char in struct GelsInfo 
graphics/rastport. h: *47 

pointer to struct CopList in struct UCopList 
graphics/copper.h: *72 
pointer to struct Gadget in 
intuition/intuition.h: *739 
pointer to struct Gadget in 
intuition/intuition.h: *866 
pointer to struct Gadget in 
intuition/screens.h: *71 
pointer to struct MenuItem in struct Menu 
intuition/intuition.h: *64 

pointer to struct Requester in struct Window 
intuition/intuition.h: *711 

pointer to struct Screen in struct IntuitionBase 
intuition/intuitionbase.h: *158 

pointer to struct Window in struct Screen 
intuition/screens.h: *43 

short int in struct AreaInfo 
graphics/rastport.h: *25 

short int in struct AreaInfo 
graphics/rastport.h: *25 

pointer to char in struct Areainfo 
graphics/rastport.h: *22 
char in struct BitMap 
graphics/gfx.h: *40 

unsigned short int in struct 
graphics/clip.h: *33 

char in struct ColorMap 
graphics/view.h: *23 

char in struct GelsInfo 
graphics/rastport.h: ¥*39 
unsigned short int in struct 
graphics/rastport.h: *66 
unsigned short int in struct 
graphics/layers.h: *41 
unsigned short int in 
intuition/intuition.h: 
unsigned short int in 
intuition/intuition.h: 
unsigned short int in 
intuition/intuition.h: 
unsigned short int in 
intuition/intuition.h: 
unsigned short int in 
intuition/intuition.h: 
unsigned short int in struct 
intuition/intuition.h: *386 
unsigned int in struct Window 
intuition/intuition.h: *705 

unsigned int in struct NewWindow 
intuition/intuition.h: *859 

unsigned short int in struct Screen 
intuition/screens.h: *50 

short int in struct VSprite 
graphics/gels.h: *88 

short int in struct Bob 
graphics/gels.h: *141 

short int in struct AnimComp 
graphics/gels.h: *169 

unsigned short int in struct GfxBase 


*32 


struct Window 
struct: NewWindow 


struct Screen 


Layer 


RastPort 
Layer_Info 
struct Menu 
*62 
struct 
*90 
struct 
*152 
struct 
*200 
struct 
*362 


MenuItem 
Requester 
Gadget 
BoolInfo 


Propinfo 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 34 


+0x00a8 
Flags 

+0x0040 
Flags 

+0x0022 


FlagTbl 
+0x0008 
FLOAT 


floor 
floor 
FLOYD_DITHERING 
f1_Access 

+0x0008 
fl Key 

+0x0004 
fl_Link 

+0x0000 
fl_MemList 

+0x0002 
f1_NumFree 

+0x0000 
f1_Task 

+0x000c 
f1_Volume 

+0x0010 
FOLLOWMOUSE 
Font 

+0x0034 
Font 

+0x0028 
Font 

+0x0010 
FontContents 

size 0x0104 


graphics/gfxbase.h: *44 

unsigned int in struct IntuitionBase 
intuition/intuitionbase.h: *160 

char in struct ExpansionBase 
libraries/expansionbase.h: *46 

pointer to char in struct AreaInfo 
graphics/rastport.h: *21 

typedef float 

exec/types.h: *43 

#define SPFloor =0x00000000 libraries/mathffp.h: *34 


#define IEEEDPFloor =0x00000000 libraries/mathieeedp.h: *35 


FontContentsHeader structure tag 


size 0x0004 
FontHeight 
+0x0000 
FOREVER 
FPB_DESIGNED 
FPB_DISKFONT 
FPB_PROPORTIONAL 
FPB_REMOVED 
FPB_REVPATH 
FPB_ROMFONT 
FPB_TALLDOT 
FPB_WIDEDOT 
FPF_DESIGNED 
FPF_DISKFONT 
FPF_PROPORTIONAL 
FPF_REMOVED 
FPF_REVPATH 
FPF _ROMFONT 
FPF _TALLDOT 
FPF_WIDEDOT 
FPHALF 
FPHALF 
FPONE 
FPONE 
FPTEN 
FPTEN 
FPZERO 
FPZERO 
FreeClipRects 
+0x000c 
FreeFreeList 
FREEHORIZ 
FreeList 


#define 0x0400 =0x00000400 intuition/preferences.h: *251 
int in struct FileLock 

libraries/dosextens.h: *293 

int in struct PileLock 

libraries/dosextens.h: *292 

int in struct FileLock 

libraries/dosextens.h: *291 

struct List (size 0x000e) in struct FreeList 
workbench/workbench.h: *71 

short int in struct FreeList 
workbench/workbench.h: *70 

pointer to struct MsgPort in struct FileLock 
libraries/dosextens.h: *294 

int in struct FileLock 

libraries/dosextens.h: *295 

#define 0x0008 =0x00000008 intuition/intuition.h: *305 
pointer to struct TextFont in struct RastPort 
graphics/rastport.h: *72 

pointer to struct TextAttr in struct Screen 
intuition/screens.h: *59 

pointer to struct TextAttr in struct NewScreen 
intuition/screens.h: *127 

structure tag 

libraries/diskfont.h: *25 

libraries/diskfont.h: *34 

char in struct Preferences 
intuition/preferences.h: *45 

#define for(;;) intuition/intuition.h: *968 
#define 6 =0x00000006 graphics/text.h: *41 
#define 1 =0x00000001 graphics/text.h: ¥*31 
#define 5 =0x00000005 graphics/text.h: *39 
#define 7 =0x00000007 graphics/text.h: *43 
#define 2 =0x00000002 graphics/text.h: *33 
#define 0 =0x00000000 graphics/text.h: *29 
#define 3 =0x00000003 graphics/text.h: *35 
#define 4 =0x00000004 graphics/text.h: *37 
#define (1<<6) =0x00000040 graphics/text.h: *42 
#define (1<<1) =0x00000002 graphics/text.h: *32 
#define (1<<5) =0x00000020 graphics/text.h: *40 
#define (1<<7) =0x00000080 graphics/text.h: *44 
#define (1<<2) =0x00000004 graphics/text.h: *34 
#define (1<<0) =0x00000001 graphics/text.h: *30 
#define (1<<3) =0x00000008 graphics/text.h: *36 
#define (1<<4) =0x00000010 graphics/text.h: *38 
#define ((float) 0.5) libraries/mathffp.h: *26 
#define ((double) 0.5) libraries/mathieeedp.h: *28 
#define ((float) 1.0) libraries/mathffp.h: *25 
#define ((double) 1.0) libraries/mathieeedp.h: *27 
#define ((float) 10.0) libraries/mathffp.h: *24 
#define ((double) 10.0) libraries/mathieeedp.h: *26 
#define ((float) 0.0) libraries/mathffp.h: *27 
#define ((double) 0.0) libraries/mathieeedp.h: *29 
struct MinList (size 0x000c) in struct Layer_Info 
graphics/layers-h: *37 

extern function returning void workbench/icon.h: *31 
#define 0x0002 =0x00000002 intuition/intuition.h: *430 


structure tag 











size 0x0010 





fse_GlobalVec 
+0x003a 
fse_Handler 
+0x0026 
fse_Lock 
+0x0022 
fse_Node 
+0x0000 
fse_PatchFlags 
+0x0016 
fse_Priority 
+0x002e 


v2 - H 





FSF_EXTENDED 
FSF_ITALIC 
FSF_UNDERLINED 
FSRNAME 
fsr_Creator 
+0x000e 


+0x0012 


size 0x002c 





GADGET0002 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 35 












workbench/workbench.h: *69 

#define 0x0004 =0x00000004 intuition/intuition.h: *431 
extern function returning void workbench/icon.h: *31 
pointer to struct Layer in struct Layer 
graphics/clip.h: *27 

char in struct IntuiText 

intuition/intuition.h: *496 

char in struct Border 

intuition/intuition.h: *525 

#define 0x0] =0x00000001 graphics/rastport.h: *94 
#define 1 =0x00000001 graphics/text.h: *23 
#define 3 =0x00000003 graphics/text.h: *19 
#define 2 =0x00000002 graphics/text.h: *21 
#define 0 =0x00000000 graphics/text.h: *25 
unsigned int in struct FileSysEntry 
resources/filesysres.h: *35 

int in struct FileSysEntry 
resources/filesysres.h: *49 

int in struct FileSysEntry 
resources/filesysres.h: *44 

int in struct FileSysEntry 
resources/filesysres.h: *43 

struct Node (size 0x000e) in struct FileSysEntry 
resources/filesysres.h: *33 

unsigned int in struct FileSysEntry 
resources/filesysres.h: *37 

int in struct FileSysEntry 
resources/filesysres.h: *46 

int in struct FileSysEntry 
resources/filesysres.h: *48 

unsigned int in struct FileSysEntry 
resources/filesysres.h: *45 

int in struct FileSysEntry 
resources/filesysres.h: *47 

unsigned int in struct FileSysEntry 
resources/filesysres.h: *42 

unsigned int in struct FileSysEntry 
resources/filesysres.h: *41 

unsigned int in struct FileSysEntry 
resources/filesysres.h: *36 

#define (1<<1) =0x00000002 graphics/text.h: *24 
#define (1<<3) =0x00000008 graphics/text.h: *20 
#tdefine (1<<2) =0x00000004 graphics/text.h: *22 
#define (1<<0) =0x00000001 graphics/text.h: *26 
#define "FileSystem. resource" resources/filesysres.h: *24 
pointer to char in struct FileSysResource 
resources/filesysres.h: *28 


fsr_FileSysEntries struct List (size 0x000e) in struct FileSysResource 


resources/filesysres.h: *29 
struct Node (size 0x000e) in struct FileSysResource 
resources/filesysres.h: *27 

int in struct FileSysStartupMsg 
libraries/filehandler.h: *83 

int in struct FileSysStartupMsg 
libraries/filehandler.h: *84 

unsigned int in struct FileSysStartupMsg 
libraries/filehandler.h: *85 

unsigned int in struct FileSysStartupMsg 
libraries/filehandler.h: *82 

#define 0 =0x00000000 graphics/text.h: *18 

pointer to function returning int in struct bltnode 
hardware/blit.h: *83 

#define 0x0001 =0x00000001 workbench/workbench.h: *92 
#define 0x0100 =0x00000100 intuition/intuition.h: *276 
structure tag 
intuition/intuition.h: 149, 
intuition/screens.h: 71, 
workbench/workbench.h: 54 
#define 0x0002 =0x00000002 intuition/intuition.h: 


*193, 195, 739, 866 






GADGETDOWN 
GadgetID 

+0x0026 
GadgetRender 

+0x0012 
Gadgets 

+0x0018 
GadgetText 

+0x001a 
GadgetType 

+0x0010 
GADGETTYPE 
GADGETUP 
GADGHBOX 
GADGHCOMP 
GADGHIGHBITS 
GADGHIMAGE 
GADGHNONE 
GADGIMAGE 
GADGIMMEDIATE 
GamePortTrigger 

size 0x0008 

GELGONE 
gelHead 

+0x0002 
GelsInfo 

size 0x0026 





























+0x0006 






GENLOC 

GENLOCK_AUDIO 
GENLOCK_VIDEO 
GetDiskObject 









GetIcon 
Get WBObject 








GfxBase 

size 0x0148 
GIMME ZEROZERO 
GLOBAL 
GPCT_ABSJOYSTICK 
GPCT_ALLOCATED 
GPCT_MOUSE 











GPCT_] " RELJOYSTICK 
GPDERR_ SETCTYPE 
GPD_ASKCTYPE 
GPD_ASKTRIGGER 
GPD_READEVENT 
GPD_SETCTYPE 
GPD_SETTRIGGER 
GPTB_DOWNKEYS 
GPTB_UPKEYS 
GPTF _DOWNKEYS 
GPTF_UPKEYS 
t_ Keys 
oP +0x0000 
gpt_Timeout 
+0x0002 





















GRAPHICS_CLIP_H 
GRAPHICS COLLIDE_! 
GRAPHICS _COPPER_H 







Sep 21 13:06 1988 C_Language_Cross-Reference Page 36 


#define 0x00000020 =0x00000020 intuition/intuition.h: *643 
unsigned short int in struct Gadget 

intuition/intuition.h: *236 

pointer to pointer to char in struct Gadget 
intuition/intuition.h: *210 

pointer to struct Gadget in struct NewScreen 
intuition/screens.h: *131 

pointer to struct IntuiText in struct Gadget 
intuition/intuition.h: *217 

unsigned short int in struct Gadget 

intuition/intuition.h: *204 

#define OxFCO0 =0x0000fc00 intuition/intuition.h: *333 
#define 0x00000040 =0x00000040 intuition/intuition.h: *644 
#define 0x0001 =0x00000001 intuition/intuition.h: *245 


#define 0x0000 =0x00000000 intuition/intuition.h: *244 
#define 0x0003 =0x00000003 intuition/intuition.h: *243 
#define 0x0002 =0x00000002 intuition/intuition.h: *246 
#define 0x0003 =0x00000003 intuition/intuition.h: *247 
#define 0x0004 =0x00000004 intuition/intuition.h: *252 
#define 0x0002 =0x00000002 intuition/intuition.h: *289 


structure tag 

devices/gameport.h: *28 

#define 0x0400 =0x00000400 graphics/gels.h: *23 
pointer to struct VSprite in struct Gelsinfo 
graphics/rastport.h: *40 

structure tag 
graphics/rastport.h: *35, 57 

pointer to struct GelsInfo in struct RastPort 
graphics/rastport.h: *57 

pointer to struct VSprite in struct Gelsinfo 
graphics/rastport.h: *40 

#define 2 =0x00000002 graphics/gfxbase.h: *69 

#define 0x100 =0x00000100 graphics/view.h: *65 

#define 2 =0x00000002 graphics/view.h: *66 

extern function returning pointer to struct DiskObject , 
(size 0x004e) workbench/icon.h: *29 

extern function returning "LONG" workbench/icon.h: *30 
extern function returning pointer to struct WBObject (size 
0x0000) workbench/icon.h: *28 

structure tag 

graphics/gfxbase.h: *23 

#define 0x0400 =0x00000400 intuition/intuition.h: *818 
#define extern =0x00000000 exec/types.h: *13 

#tdefine 3 =0x00000003 devices/gameport.h: *41 

#tdefine ~l1 =Oxffffffff devices/gameport.h: *36 

#tdefine 1 =0x00000001 devices/gameport.h: *39 


GPCT_NOCONTROLLER #define 0 =0x00000000 devices/gameport.h: *37 


#define 2 =0x00000002 devices/gameport.h: *40 

#define 1 =0x00000001 devices/gameport.h: *45 

#define (CMD_NONSTD+1) =0x0000000a devices/gameport.h: *15 
#define (CMD_NONSTD+3) =0x0000000c devices/gameport.h: *17 
#define (CMD_NONSTD+0) .=0x00000009 devices/gameport.h: *14 
#define (CMD_NONSTD+2) =0x0000000b devices/gameport.h: *16 
#define (CMD_NONSTD+4) =0x0000000d devices/gameport.h: *18 
#define 0 =0x00000000. devices/gameport.h: *23 

#define 1 =0x00000001 devices/gameport.h: *25 

#define (1<<0) =0x00000001 devices/gameport.h: *24 

#define (1<<1) =0x00000002 devices/gameport.h: *26 
unsigned short int in struct GamePortTrigger - 
devices/gameport.h: *29 
unsigned short int in struct GamePortTrigger 
devices/gameport.h: *30 
unsigned short int in struct GamePortTrigger 
devices/gameport.h: *31 
unsigned short int in struct GamePortTrigger 
devices/gameport .h: *32 

#define =0x00000000 graphics/clip.h: *2 
H #define =0x00000000 graphics/collide.h: *2 

H #define =0x00000000 graphics/copper.h: *2 


GZ-H 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 37 


GRAPHICS DISPLAY_H #define =0x00000000 graphics/display.h: *2 
GRAPHICS _GELS_H  #define =0x00000000 graphics/gels.h: *2 
GRAPHICS _GFXBASE_H #define =0x00000000 graphics/gfxbase.h: *2 
GRAPHICS_GFXMACROS_H #define =0x00000000 graphics/gfxmacros.h: *2 
GRAPHICS GFX_H 
GRAPHICS GRAPHINT_H #define =0x00000000 graphics/graphint.h: *2 
GRAPHICS LAYERS H #define =0x00000000 graphics/layers.h: *2 
GRAPHICS RASTPORT_H #define =0x00000000 graphics/rastport.h: *2 


GRAPHICS _REGIONS_H 


GRAPHICS | SPRITE _H 


GRAPHICS_TEXT H 
GRAPHICS " | VIEW_H 


GRELBOTTOM 
GRELHEIGHT 
GRELRIGHT 
GRELWIDTH 
GREY_SCALE2 


gs_Head 


+0x0046 


GZZGADGET 
GZZHeight 


+0x0072 


GZ2ZMousex 


+0x006c 


GZZMouseY 


+0x006e 


G2ZWidth 


HALFTONE DITHERING #define 0x0200 =0x00000200 intuition/preferences. h: 


HAM 


+0x0070 


#define =0x00000000 graphics/gfx.h: *2 


H #define =0x00000000 graphics/regions.h: *2 
#define =0x00000000 graphics/sprite.h: *2 
#define =0x00000000 graphics/text.h: *2 
#define =0x00000000 graphics/view.h: *2 
#define 0x0008 =0x00000008 intuition/intuition.h: 
#define 0x0040 =0x00000040 intuition/intuition.h: 
#define 0x0010 =0x00000010 intuition/intuition.h: 
#define 0x0020 =0x00000020 intuition/intuition.h: 
#define 0x1000 =0x00001000 intuition/preferences.h: 
struct List (size 0x000e) in struct Layer Info 
graphics/layers.h: *39 
#define 0x2000 =0x00002000 intuition/intuition.h: 
short int in struct Window 
intuition/intuition.h: *779 
short int in struct Window 
intuition/intuition.h: *773 
short int in struct Window 
intuition/intuition.h: *774 
short int in struct Window 
intuition/intuition.h: *778 


*259 
*264 
*260 
*262 
*254 


*336 


*250 
#define 0x800 =0x00000800 graphics/view.h: *62 


HARDWARE _ADKBITS H #define =0x00000000 hardware/adkbits.h: *2 
HARDWARE _BLIT_H #define =0x00000000 hardware/blit.h: *2 
HARDWARE CIA_H 
HARDWARE _CUSTOM_H #define =0x00000000 hardware/custom.h: *2 
HARDWARE DMABITS H #define =0x00000000 hardware/dmabits.h: *2 
HARDWARE_INTBITS | | H #define =0x00000000 hardware/intbits.h: *2 
HD. ) SCSTCMD 
HeadComp 


HeadoOb 
height 
Height 
Height 
Height 
Height 
Height 
Height 
Height 
Height 
Height 
Height 
height 


+0x0024 
+0x00le 
+0x0047 
+0x000a 
+0x000a 
+0x000a 
+0x000a 
+0x0006 
+0x000a 
+0x0006 
+0x000e 
+0x0006 
+0x00la 
+0x0004 


HFERR_BadStatus 
HFERR_DMA 
HFERR_NoBoard 
HFERR_ Parity 


#define =0x00000000 hardware/cia.h: *2 


“¥define 28 =0x0000001c devices/scsidisk.h: *59 
pointer to struct AnimComp in struct Animob 
graphics/gels.h: *221 

pointer to struct AnimOb in struct AnimComp 
gvaphics/gels.h: *194 

char in struct mouth_rb 

devices/narrator.h: *90 

short int in struct Menu 
intuition/intuition.h: *61 

short int in struct MenuItem 
intuition/intuition.h: *89 

short int in struct Requester 
intuition/intuition.h: *146 

short int in struct Gadget 
intuition/intuition.h: *198 

short int in struct Image 
intuition/intuition.h: *548 

short int in struct Window 
intuition/intuition.h: *698 

short int in struct NewWindow 
intuition/intuition.h: *853 

short int in struct Screen 
intuition/screens.h: *46 

short int in struct NewScreen 
intuition/screens.h: *119 

short int in struct VSprite 

graphics/gels.h: *97 

unsigned short. int in struct SimpleSprite 
graphics/sprite.h: *18 

#define 45 =0x0000002d devices/scsidisk.h: *90 
#define 41 =0x00000029 devices/scsidisk.h: *86 
#define 50 =0x00000032 devices/scsidisk.h: *93 
#define 43 =0x0000002b devices/scsidisk.h: *88 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 38 


HFERR_Phase 
HFERR_SelfuUnit 
HFERR_Sel Timeout 
HIGHBOX 
HIGHCOMP 
HIGHFLAGS 
HIGHIMAGE 
HIGHITEM 
HIGHNONE 
HIRES 
HitMask 
+0x0022 
HOLDNMODIFY 
HorizBody 
+0x0006 
HorizPot 
+0x0002 
HPotRes 
+0x000e 
HP_LASERJET 
HP_LASERJET_PLUS 
HSIZEBITS 
HSIZEMASK 
HWaitPos 
+0x0000 
HWAITPOS 
TAddress 
+0x001c 
ICONNAME 
IDCMPFlags 
+0x0052 
IDCMPFlags 
+0x000a 
IDCMPWindow 
+0x002c 
IdleCount 
+0x0118 
IDNAME_BADBLOCK 


#define 42 =0x0000002a devices/scsidisk.h: *87 
#define 40 =0x00000028 devices/scsidisk.h: *85 
#define 44 =0x0000002c devices/scsidisk.h: *89 
#define 0x0080 =0x00000080 intuition/intuition. 
#define 0x0040 =0x00000040 intuition/intuition. 
#define 0x00CO =0x000000c0 intuition/intuition. 
#define 0x0000 =0x00000000 intuition/intuition. 
#define 0x2000 =0x00002000 intuition/intuition. 
#define 0x00CO =0x000000c0 intuition/intuition. 
#define 0x8000 =0x00008000 graphics/view.h: *60 
short int in struct VSprite 

graphics/gels.h: *102 

#define 0x800 =0x00000800 graphics/display.h: *21 
unsigned short. int in struct PropInfo 
intuition/intuition.h: *416 

unsigned short int in struct PropInfo 
intuition/intuition.h: *396 

unsigned short int in struct PropInfo 
intuition/intuition.h: *422 

#define 0x0B =0x0000000b intuition/preferences.h: 
#define Ox0C =0x0000000c intuition/preferences.h: 
#tdefine 6 =0x00000006 hardware/blit.h: *13 
#define Ox3f =0x0000003f hardware/blit.h: *15 
short int in union (no tag) 

graphics/copper.h: *33 

#define u3.u4.u2.HWaitPos graphics/copper.h: *43 
pointer to pointer to char in struct IntuiMessage 
intuition/intuition.h: *614 

#define “icon.library" workbench/icon.h: *20 
unsigned int in struct Window 
intuition/intuition.h: *753 

unsigned int in struct NewWindow 
intuition/intuition.h: *857 

pointer to struct Window in struct IntuiMessage 
intuition/intuition.h: *630 

unsigned int in struct ExecBase 

exec/exechase. h: *56 

#define (('B'<<24) /('A'<<16)[('D'<<8)]('B')) =0x42414442 
devices/hardblocks. h: *123 


*123 
*122 
*120 
*121 
*131 
*124 


PERE Ee 


*198 
*199 


IDNAME_FILESYSHEADER #define (('F'! <<24) | (1S! <<16) | (1H <<8) |('D')) -=0x46534844 


IDNAME_LOADSEG 
IDNAME_PARTITION 
IDNAME_RIGIDDISK 


IDNestCnt 
+0x0126 
id_BytesPerBlock 
4+0x0014 
id_Diskstate 
+0x0008 
id_DiskType 
+0x0018 
ID_DOS_DISK 


id_InUse 
+0x0020 


devices/hardblocks, h: *180 

#define (('L'<<24)]('S'<<16) | ('B'<<8)[('G")) =0x40534547 
devices/hardblocks, h: *193 

tdefine (('P'<<24) |('A'<<16) | ('R'<<8) [('T')) =0x50415254 
devices/hardblocks, h: *142 

#define (('R'<<24) |(¢' Di <<16)|(" $8'<<8)|('K')) =0x5244534b 
devices/hardblocks.h: *8 

char in struct ExecBase 

exec/execbase.h: *61 

int in struct InfoData 

libraries/dos.h: *113 

int in struct InfoData 

libraries/dos.h: *110 

int in struct InfoData 

libraries/dos.h: *114 

#define (('D'<<24) | ('0'<<16) | ('S'<<8)) =0x444£5300 
libraries/dos.h: *128 

int in struct InfoData 

libraries/dos.h: *116 


ID_KICKSTART DISK #define (('K'<<24) | ('I'<<16) | ('C'<<8) | ('K')) =0x4b49434b 


libraries/dos.h: *130 


ID_NOT REALLY DOS #define (('N'<<24) | ('D'<<16) | ('O'<<8) | ('S')) =0x4e444£53 


ID_NO_DISK PRESENT #define (-1) =Oxffffffff libraries/dos.h: 


id_NumBlocks 
+0x000c 

id_NumBlocksUsed 
+0x0010 

id_NumSoftErrors 


libraries/dos.h: *129 

*126 
int in struct InfoData 

libraries/dos.h: *111 

int in struct InfoData 

libraries/dos.h: *112 

int in struct InfoData 


9€ - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 39 


+0x0000 libraries/dos.h: *108 
id_UnitNumber int in struct InfoData 

+0x0004 libraries/dos.h: *109 
ID_UNREADABLE_DISK #define (('B'<<24) | ('A'<<16) | ('D'<<8)) =0x42414400 
libraries/dos.h: *127 
#define 82 =0x00000052 libraries/dos.h: 
#define 81 =0x00000051 libraries/dos.h: 
id_VoluméNode int in struct InfoData 

+0x001lc libraries/dos.h: *115 
ID_WRITE_PROTECTED #define 80 =0x00000050 libraries/dos.h: *121 
IECLASS_ACTIVEWINDOW #define 0x11 =0x00000011 devices/inputevent.h: *53 
IECLASS CLOSEWINDOW #define 0x0B =0x0000000b devices/inputevent.h: *41 
IECLASS_DISKINSERTED #define 0x10 =0x00000010 devices/inputevent.h: *51 
IECLASS_DISKREMOVED #define Ox0F =0x0000000f devices/inputevent.h: *49 
IECLASS EVENT #define 0x03 =0x00000003 devices/inputevent.h: *27 
IECLASS_GADGETDOWN #define 0x07 =0x00000007 devices/inputevent.h: *33 
IECLASS ; GADGETUP #define 0x08 =0x00000008 devices/inputevent.h: *35 
IECLASS INACTIVEWINDOW #define 0x12 =0x00000012 devices/inputevent.h: *55 
IECLASS_MAX #define 0x12 =0x00000012 devices/inputevent.h: *59 

devices/conunit.h: 78 

IECLASS_MENULIST #define Ox0A =0x0000000a devices/inputevent.h: *39 
IECLASS_NEWPREFS #define Ox0E =0x0000000e devices/inputevent.h: *47 
IECLASS_NULL #define 0x00 =0x00000000 devices/inputevent.h: *21 
IECLASS_POINTERPOS #define 0x04 =0x00000004 devices/inputevent.h: *29 
IECLASS RAWKEY  #define 0x01 =0x00000001 devices/inputevent.h: *23 
IECLASS_RAWMOUSE #define 0x02 =0x00000002 devices/inputevent . h: *25 
IECLASS_REFRESHWINDOW #define 0x0D =0x0000000d devices/inputevent.h: *45 
IECLASS REQUESTER #define 0x09 =0x00000009 devices/inputevent.h: *37 
IECLASS_SIZEWINDOW #define Ox0C =0x0000000c devices/inputevent.h: *43 
IECLASS_TIMER #define 0x06 ~0x00000006 devices/inputevent.h: *31 
IECODE_ASCII_DEL #define 0x7F =0x0000007f devices/inputevent.h: *76 
IECODE_ASCII FIRST #define 0x20 =0x00000020 devices/inputevent.h: *74 
IECODE_ASCIT | _LAST #define 0x7E =0x0000007e devices/inputevent.h: *75 
IECODE_CO ) FIRST #define 0x00 =0x00000000 devices/inputevent.h: *72 
IECODE_CO_LAST #define OxiF =0x0000001f devices/inputevent.h: *73 
IECODE_Cl FIRST #define 0x80 =0x00000080 devices/inputevent.h: *77 
IECODE_Cl_LAST #define Ox9F =0x0000009f devices/inputevent.h: *78 
IECODE_COMM | CODE_FIRST #define 0x78 =0x00000078 devices/inputevent.h: *68 
IECODE_COMM CODE LAST #define 0x7F =0x0000007f£ devices/inputevent.h: *69 
IECODE_KEY -_CODE | FIRST #define 0x00 =0x00000000 devices/inputevent.h: *66 
IECODE_KEY | - CODE_LAST #define 0x77 =0x00000077 devices/inputevent.h: *67 
IECODE_LATIN1 _FIRST #define 0xA0 =0x000000a0 devices/inputevent.h: *79 
IECODE_LATINI_LAST #define OxFF =0x000000ff devices/inputevent.h: *80 
IECODE_LBUTTON #define 0x68 =0x00000068 devices/inputevent.h: *83 


*123 


ID_VALIDATED 
*122 


ID_VALIDATING 


IECODE_MBUTTON #define 0x6A =0x0000006a devices/inputevent.h: *85 
IECODE_NEWACTIVE #define 0x01 =0x00000001 devices/inputevent.h: *89 
IECODE_NOBUTTON #define OxFF =0x000000ff devices/inputevent.h: *86 
TECODE_RBUTTON #define 0x69 =0x00000069 devices/inputevent.h: *84 
IECODE_REQCLEAR #define 0x00 =0x00000000 devices/inputevent.h: *97 
IECODE_REQSET #define 0x01 =0x00000001 devices/inputevent.h: *95 
IECODE_UP_PREFIX #define 0x80 =0x00000080 devices/inputevent.h: *65 
IEEEDPAbs extern function returning double libraries/mathieeedp.h: 
IEEEDPACos extern function returning double libraries/mathieeedp.h: 
IEEEDPAdG extern function returning double libraries/mathieeedp.h: 
IEEEDPASin extern function returning double libraries/mathieeedp.h: 
IEBEEDPAtan extern function returning double libraries/mathieeedp.h: 
IEEEDPCeil extern function returning double libraries/mathieeedp.h: 
IEEEDPCmp extern function returning int libraries/mathieeedp.h: 
IEEEDPCos extern function returning double libraries/mathieeedp.h: 
TEEEDPCosh extern function returning double libraries/mathieeedp.h: 
IEEEDPDiv extern function returning double libraries/mathieeedp.h: 
IEEEDPExp extern function returning double libraries/mathieeedp.h: 
IEEEDPFieee extern function returning double libraries/mathieeedp.h: 
IEEEDPFix extern function returning int libraries/mathieeedp.h: 
IEEEDPFloor extern function returning double libraries/mathieeedp.h: 
IEEEDPF1t extern function returning double libraries/mathieeedp.h: 
IEEEDPLog extern function returning double libraries/mathieeedp.h: 
IEEEDPLoOg10 extern function returning double libraries/mathieeedp.h: 
IEEEDPMuL extern function returning double libraries/mathieeedp.h: 


*69 
*56 
*71 
*57 
*55 
*76 
*67 
*56 
*62 
*74 
*58 
*64 
*66 
*715 


*58 
*60 
*73 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 40 


IEEEDPNeg extern function returning double libraries/mathieeedp.h: *70 
IEEEDPPow extern function returning double libraries/mathieeedp.h: *60 
IEEEDPSin extern function returning double libraries/mathieeedp.h: *57 
IEEEDPSincos extern function returning double libraries/mathieeedp.h: *61 
IEEEDPSinh extern function returning double libraries/mathieeedp.h: *62 
IEEEDPSqrt extern function returning double libraries/mathieeedp.h: *59 
IEEEDPSub extern function returning double libraries/mathieeedp.h: *72 
IEEEDPTan extern function returning double libraries/mathieeedp.h: *55 
IEEEDPTanh extern function returning double libraries/mathieeedp.h: *62 
IEEEDPTieee extern function returning float libraries/mathieeedp.h: *63 
IEEEDPTst extern function returning int libraries/mathieeedp.h: *67 
IEQUALIFIERB_CAPSLOCK #define 2 =0x00000002 devices/inputevent.h: *120 
IEQUALIFIERB_CONTROL #define 3 =0x00000003 devices/inputevent.h: *121 


IEQUALIFIERB_INTERRUPT #define 10 =0x0000000a devices/inputevent.h: *128 
IEQUALIFIERB_LALT #define 4 =0x00000004 devices/inputevent.h: *122 
IEQUALIFIERB_LCOMMAND #define 6 =0x00000006 devices/inputevent.h: 
IEQUALIFIERB_LEFTBUTTON #define 14 =0x0000000e devices/inputevent.h: 
IEQUALIFIERB_LSHIFT #define 0 =0x00000000 devices/inputevent.h: *118 
IEQUALIFIERB_MIDBUTTON #define 12 =0x0000000c devices/inputevent.h: *130 
IEQUALIFIERB_MULTIBROADCAST #define 11 =0x0000000b devices/inputevent .h: 
IEQUALIFIERB_NUMERICPAD #define 8 =0x00000008 devices/inputevent.h: *126 
IEQUALIFIERB_RALT #define 5 =0x00000005 devices/inputevent.h: *123 
IEQUALIFIERB_RBUTTON #define 13 =0x0000000d devices/inputevent.h: *131 
IEQUALIFIERB_RCOMMAND #define 7 =0x00000007 devices/inputevent.h: *125 
IEQUALIFIERB_RELATIVEMOUSE #define 15 =0x0000000f devices/inputevent.h: 
IEQUALIFIERB_REPEAT #define 9 =0x00000009 devices/inputevent.h: *127 
IEQUALIFIERB_RSHIFT #define 1 =0x00000001 devices/inputevent.h: *119 
IEQUALIFIER_CAPSLOCK #define 0x0004 =0x00000004 devices/inputevent.h: 
IEQUALIFIER_CONTROL #define 0x0008 =0x00000008 devices/inputevent.h: 
IEQUALIFIER_INTERRUPT #define 0x0400 =0x00000400 devices/inputevent.h: 
IEQUALIFIER_LALT #define 0x0010 =0x00000010 devices/inputevent.h: *105 
IEQUALIFIER_LCOMMAND #define 0x0040 =0x00000040 devices/inputevent .h: 
IEQUALIFIER_LEFTBUTTON #define 0x4000 =0x00004000 devices/inputevent.h: 
IEQUALIFIER_LSHIFT #define 0x0001 =0x00000001 devices/inputevent.h: *101 
TEQUALIFIER_MIDBUTTON #define 0x1000 =0x00001000 devices/inputevent.h: *113 
IEQUALIFIER MULTIBROADCAST #define 0x0800 =0x00000800 devices/inputevent.h: 
IEQUALIFIER_NUMERICPAD #define 0x0100 =0x00000100 devices/inputevent.h: *109 
IEQUALIFIER_RALT #define 0x0020 =0x00000020 devices/inputevent.h: *106 
IEQUALIFIER_RBUTTON #define 0x2000 =0x00002000 devices/inputevent.h: *114 
IEQUALIFIER_RCOMMAND #define 0x0080 =0x00000080 devices/inputevent.h: *108 
IEQUALIFIER_RELATIVEMOUSE #define 0x8000 =0x00008000 devices/inputevent .h: 


*124 
*132 


*129 


*133 


*103 
*104 
*111 
*107 
*115 


*112 


*116 


IEQUALIFIER_REPEAT #define 0x0200 =0x00000200 devices/inputevent.h: *110 
IEQUALIFIER_RSHIFT #define 0x0002 =0x00000002 devices/inputevent.h: *102 
ie_addr pointer to pointer to char in union (no tag) 

+0x0000 devices/inputevent.h: *148 
ie_Class char in struct InputEvent 

+0x0004 devices/inputevent.h: *139 
ie_Code unsigned short int in struct InputEvent 

+0x0006 devices/inputevent.h: *141 
ie_EventAddress #define ie _position.ie_addr devices/inputevent.h: *155 


ie_NextEvent pointer to struct InputEvent in struct InputEvent 


+0x0000 devices/inputevent.h: *138 
ie_position union (no tag) (size 0x0004) in struct InputEvent 
+0x000a devices/inputevent.h: *149 
ie Qualifier unsigned short int in struct InputEvent 
+0x0008 devices/inputevent.h: *142 
ie_SubClass char in struct InputEvent 
+0x0005 devices/inputevent.h: *140 
ie_TimeStamp struct timeval (size 0x0008) in struct InputEvent 
+0x000e devices/inputevent.h: *150 
le x short int in struct (no tag) 
+0x0000 devices/inputevent.h: *145 
ie X tdefine ie position.ie xy.ie x devices/inputevent.h: *153 
ie_x struct (no tag) (size 0x0004) in union (no tag) 
+0x0000 devices/inputevent.h: *147 
iey short int in struct (no tag) 
+0x0002 devices/inputevent.h: *146 
ie_Y #define ie_position.ie_xy.ie_y devices/inputevent.h: *154 
IFont pointer to struct TextFont in struct Window 











4@-4H 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 41 


+0x0080 


IGNORE_DIMENSIONS #define 0x0000 =0x00000000 intuition/preferences.h: 


Image 
size 0x0014 
ImageBMap 
+0x0044 
ImageData 
+0x000a 
ImageData 
+0x0024 
ImageShadow 
+0x0006 
IMAGE_NEGATIVE 
IMAGE_POSITIVE 
IMPORT 
INACTIVEWINDOW 
IND_ADDHANDLER 
IND_REMHANDLER 
IND_SETMPORT 
IND_SETMTRIG 
IND_SETMTYPE 
IND_SETPERIOD 
IND_SETTHRESH 
IND_WRITEEVENT 
InfoData 
size 0x0024 
InitAnimate 
InputEvent 
size 0x0016 
INREQUEST 
Int2List 
+0x0186 
Inté6List 
+0x019c 
Int7List 
+0x01b2 
INTB_AUDO 
INTB_AUD1 
INTB_AUD2 
INTB_AUD3 
INTB_BLIT 
INTB_COPER 
INTB_DSKBLK 
INTB_DSKSYNC 
INTB_EXTER 
INTB_INTEN 
INTB_NMI 
INTB_ PORTS 
INTB_RBF 
INTB_SETCLR 
INTB_SOFTINT 
INTB_TBE 
INTB_VERTB 
INTEGER_SCALING 
intena 
+0x009a 
intenar 
+0x001c 
INTERLACE 
Interrupt 
size 0x0016 


INTF_AUDO 
INTF_AUD1 
INTF_AUD2 
INTF_AUD3 
INTF_BLIT 


intuition/intuition.h: *793 

*241 
structure tag 

intuition/intuition.h: *543, 585, 763, 872 
pointer to struct BitMap in struct Requester 
intuition/intuition. h: *167 

pointer to unsigned short int in struct Image 
intuition/intuition. h: *549 

pointer. to short int in struct VSprite 
graphics/gels. h: *104 

pointer to short int in struct Bob 
graphics/gels.h: *147 

#deftine 0x01 =0x00000001 intuition/preferences.h: 
#define 0x00 =0x00000000 intuition/preferences.h: 
#define extern =0x00000000 exec/types.h: *14 
#define 0x00080000 =0x00080000 intuition/intuition.h: *657 
#define (CMD_NONSTD+0) =0x00000009 devices/input.h: *17 


*167 
*166 


#define (CMD_NONSTDt1) =0x0000000a devices/input.h: *18 
#define (CMD_NONSTD+5) =0x0000000e devices/input.h: *22 
#define (CMD _NONSTD+7) =0x00000010 devices/input.h: *24 
#define (CMD_NONSTD+6) =0x0000000f devices/input.h: *23 
#define (CMD_NONSTD+4) =0x0000000d devices/input.h: *21 
#define (CMD_NONSTD+3) =0x0000000c devices/input.h: *20 
#define (CMD_NONSTD+2) =0x0000000b devices/input.h: *19 
structure tag 

libraries/dos.h: *107 

Macro (1 argument) graphics/gels.h: *246 

structure tag in struct InputEvent 
devices/inputevent.h: *137, 138 

#define 0x4000 =0x00004000 intuition/intuition.h: *826 


struct Interrupt (size 0x0016) in struct ExpansionBase 
libraries/expansionbase.h: *55 

struct Interrupt (size 0x0016) in struct ExpansionBase 
libraries/expansionbase.h: *56 

struct Interrupt (size 0x0016) in struct ExpansionBase 
libraries/expansionbase.h: *57 

#define (7) =0x00000007 hardware/intbits.h: *23 
#define. (8) =0x00000008 hardware/intbits.h: *22 
tdefine (9) =0x00000009 hardware/intbits-h: *21 
#define (10) =0x0000000a hardware/intbits.h: *20 
tdefine (6) =0x00000006 hardware/intbits.h: *24 
#define (4) =0x00000004 hardware/intbits.h: *26 
#define (1) =0x00000001 hardware/intbits.h: *29 
#define (12) =0x0000000c hardware/intbits.h: *18 
#define (13) =0x0000000d hardware/intbits.h: *17 
#define (14) =0x0000000e hardware/intbits.h: *16 
#define 15 =0x0000000f exec/interrupts.h: *44 
#define (3) =0x00000003 hardware/intbits.h: *27 
#define (11) =0x0000000b hardware/intbits.h: *19 
#define (15) =0x0000000f hardware/intbits.h: *13 
#define (2) =0x00000002 hardware/intbits.h: *28 
#define (0) =0x00000000 hardware/intbits.h: *30 
#define (5) =0x00000005 hardware/intbits.h: *25 
#define 0x0100 =0x00000100 intuition/preferences.h: 
unsigned short int in struct Custom 
hardware/custom.h: *82 

unsigned short int in struct. Custom 
hardware/custom.h: *34 

tdefine 4 =0x00000004 graphics/display.h: *22 
structure tag 

exec/interrupts.h: *22 

graphics/gfxbase.h: 34 

libraries/expansionbase.h: 55, 56, 57 
resources/disk.h:. 43, 44, 45, 57, 58, 59 

#define (1<<7) =0x00000080 hardware/intbits.h: "42 
#tdefine (1<<8) =0x00000100 hardware/intbits.h: *41 
#define (1<<9) =0x00000200 hardware/intbits.h: *40 
#define (1<<10) =0x00000400 hardware/intbits.h: *39 
#define (1<<6) =0x00000040 hardware/intbits.h: *43 


247 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 42 


INTF_COPER 
INTF_DSKBLK 
INTF_DSKSYNC 
INTF_EXTER 
INTF_INTEN 
INTF_NMI 
INTF_PORTS 
INTF_RBF 
INTF_SETCLR 
INTF_SOFTINT 
INTF_TBE 
INTF_VERTB 
IntMask 
+0x0000 
intreq 
+0x009c 
intreqr 
+0x00le 
IntrList 
+0x016c 
IntuiMessage 
size 0x0034 
IntuiText 
size 0x0014 
INTUITICKS 
IntuitionBase 
size 0x0050 


#define (1<<4) =0x00000010 hardware/intbits.h: *45 
#tdefine (1<<1) =0x00000002 hardware/intbits.h: *48 
#define (1<<12) =0x00001000 hardware/intbits.h: *37 
#define (1<<13) =0x00002000 hardware/intbits.h: *36 
#define (1<<14) =0x00004000 hardware/intbits.h: *35 
#define (1<<15) =0x00008000 exec/interrupts.h: *45 
#define (1<<3) =0x00000008 hardware/intbits.h: *46 
#define (1<<11) =0x00000800 hardware/intbits.h: *38 
#define (1<<15) =0x00008000 hardware/intbits.h: *34 
#define (1<<2) =0x00000004 hardware/intbits.h: *47 
#define (1<<0) =0x00000001 hardware/intbits.h: *49 
#define (1<<5) =0x00000020 hardware/intbits.h: *44 
unsigned short int in struct ExpansionInt 
libraries/expansionbase.h: *37 

unsigned short int in struct Custom 
hardware/custom.h: *83 

unsigned short int in struct Custom 
hardware/custom.h: *35 

struct List (size 0x000e) in struct ExecBase 
exec/execbase.h: *80 
structure tag 
intuition/intuition.h: 
structure tag 
intuition/intuition.h: 151, 217, *494, 502 

#tdefine 0x00400000 =0x00400000 intuition/intuition.h: 
structure tag 
intuition/intuitionbase.h: 


*596, 633, 755 


*660 
*144 


INTUITION_INTUITIONBASE_H #define =0x00000000 intuition/intuitionbase.h: *2 
INTUITION _INTUITION_H #define =0x00000000 intuition/intuition.h: *2 
INTUITION PREFERENCES _H #define =0x00000000 intuition/preferences.h:. *2 
INTUITION _SCREENS_H #define =0x00000000 intuition/screens.h: *2 


IntVector _ 
size 0x000c 


IntVects 


+0x0054 
INVERSVID 
IOAudio 
size 0x0044 
ioa_AllocKey 
.+0x0020 
ioa_Cycles 
+0x002e 
ioa_Data 
+0x0022 
ioa_Length 
+0x0026 
ioa_Period 
+0x002a 
ioa_Request 
+0x0000 
ioa_Volume 
+0x002c 
ioa_WriteMsg 
+0x0030 
IOB_QUICK 
IOCLipReg 
size 0x0034 
IODRPReq 
size 0x003e 
IOERR_ABORTED 
IOERR_BADLENGTH 
IOERR_NOCMD 
IOERR_OPENFAIL 
IOExtPar 
size 0x003e 


IOExtSer 


structure tag 

exec/interrupts.h: *29 

exec/execbase.h: 51 

array [16] of struct IntVector (size 0x000c) in struct 
ExecBase 

exec/exechbase.h: *51 

#tdefine 4 =0x00000004 graphics/rastport.h: *91 
structure tag 

devices/audio.h: *47 

short int in struct IOAudio 

devices/audio.h: *49 

unsigned short int in struct IOAudio 
devices/audio.h: *54 

pointer to char in struct IOAudio 
devices/audio.h: *50 

unsigned int in struct IOAudio 

devices/audio.h: *51 

unsigned short int in struct I0Audio 
devices/audio.h: *52 

struct IORequest (size 0x0020) in struct TOAudio 
devices/audio.h: *48 

unsigned short int in struct I0Audio 
devices/audio.h: *53 

struct Message (size 0x0014) in struct I0Audio 
devices/audio.h: *55 

#tdefine 0 =0x00000000 exec/io.h: *45 

structure tag 

devices/clipboard.h: *37 

structure tag 
devices/printer.h: *150 


#define —2 =Oxfffffffe exec/errors.h: *14 
#define -4 =Oxfffffffc exec/errors.h: *16 
#define -3 =Oxfffffffd exec/errors.h: *15 
#define —-1 =0xffffffff exec/errors.h: *13 


structure tag 
devices/parallel.h: *27 
devices/prtbase.h: 70, 78 
structure tag 


8c -—H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 43 


size 0x0052 


IOEXt TD 

size 0x0038 
IOF_QUICK 
ToPar 

+0x0000 

IOPARB_ABORT 
LOPARB_ACTIVE 
IOPARB_QUEUED 
IOPARF_ABORT 
IOPARF_ ACTIVE 
IOPARF_QUEUED 
IOPArray 

size 0x0008 
ToPrtcmdReq 

size 0x0026 
IOPTB_PAPEROUT 
IOPTB_PARBUSY 
IOPTB_PARSEL 
IOPTB_RWDIR 
IOPTF_PAPEROUT 
IOPTF_PARBUSY 
IOPTF_PARSEL 
IOPTF_RWDIR 
TORequest 

size 0x0020 


IOSer 
+0x0000 
TostdReq 
size 0x0030 


ToTarray 
size 0x0008 
IOTDB_INDEXSYNC 
IOTDF_INDEXSYNC 
iotd_Count 
+0x0030 
lotd_Req 
+0x0000 
iotd_SecLabel 
+0x0034 
io Actual 
+0x0020 
io_Actual 
+0x0020 
io_Baud 
+0x003c 
io_BrkTime 
+0x0040 
io_ClipID 
+0x0030 
io_ColorMap 
+0x0024 
io_Command 
+0x001c 
io_Command 
+0x001le 
io_Command 
+0x001e 
io_Command 
+0x001c 
io_Command 
+0x001c¢ 


devices/serial.h: *37 

devices/prtbase.h: 71, 79 

structure tag 

devices/trackdisk.h: *113 

#define (1<<0) =0x00000001 exec/io.h: *46 

struct IOStdReq (size 0x0030) in struct IOExtPar 
devices/parallel.h: *28 

#define 5 =0x00000005 devices/parallel.h: *64 
#define 4 =0x00000004 devices/parallel.h: *66 
#define 6 =0x00000006 devices/parallel.h: *62 
#tdefine (1<<5) =0x00000020 devices/parallel.h: *65 
#define (1<<4) =0x00000010 devices/parallel.h: *67 
#define (1<<6) =0x00000040 devices/parallel.h: *63 
structure tag 

devices/parallel.h: *17, 53 

structure tag 

devices/printer.h: *136 

#define 1 =0x00000001 devices/parallel.h: *74 
#define 0 =0x00000000 devices/parallel.h: *76 
#define 2 =0x00000002 devices/parallel.h: *70 
#define 3 =0x00000003 devices/parallel.h: *68 
#tdefine (1<<1) =0x00000002 devices/parallel.h: ¥*75 
#define (1<<0) =0x00000001 devices/parallel.h: *77 
#define (1<<2) =0x00000004 devices/parallel.h: *73 
#define (1<<3) =0x00000008 devices/parallel.h: *69 
structure tag 

exec/fio.h: *18 

devices/audio.h: 48 

devices/timer.h: 29 

struct IoStdReq (size 0x0030) in struct IOExtSer 
devices/serial.h: *38 

structure tag 

exec/io.h: ¥*27 

devices/narrator.h: 68 

devices/parallel.h: 28 

devices/serial.h: 38 

devices/trackdisk.h: 114 

structure tag 

devices/serial.h: *21, 66 

#define 4 =0x00000004 devices/trackdisk.h: *124 
#define (1<<4) =0x00000010 devices/trackdisk.h: *125 
unsigned int in struct IOExtTD 
devices/trackdisk.h: *115 

struct IO0StdReq (size 0x0030) in struct IOExtTD 
devices/trackdisk.h: *114 

unsigned int in struct IOExtTD 
devices/trackdisk.h: *116 

unsigned int in struct IoStdReq 

exec/io.h: *34 

unsigned int in struct IOClipReq 
devices/clipboard.h: *44 

unsigned int in struct IOExtSer 

devices/serial.h: *64 

unsigned int in struct IOExtSer 

devices/serial.h: *65 

int in struct IOClipReq 

devices/clipboard.h: *48 

pointer to struct ColorMap in struct IODRPReq 
devices/printer.h: *158 

unsigned short int in struct IORequest 

exec/io.h: *22 

unsigned short int in struct IoStdReq 

exec/io.h: ¥*31 

unsigned short int in struct IoCclipReq 
devices/clipboard.h: *41 

unsigned short int in struct IoPrtCmdReq 
devices/printer.h: *140 

unsigned short int in struct IODRPReq 
devices/printer.h: *154 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 44 


io_CtlChar 
+0x0030 
io_Data 
+0x0028 
io _ Data 
+0x0028 
io_DestCols 
+0x0034 
io_DestRows 
+0x0038 
io Device 
+0x0014 
io_Device 
+0x0014 
io_Device 
+0x0014 
io_Device 
+0x0014 
jo_Device 
+0x0014 
jo_Error 
+0x001f 
io_Error 
+0x001LE 
io_Error 
+0x001£ 
io_Error 
+0x001f 
io_ Error 
+0x001LE 
io_ExtFlags 
+0x0038 
io_Flags 
+0x001le 
io_Flags 
+0x001le 
io_Flags 
+0x00le 
io_Flags 
+0x001le 
io_Flags 
+0x001le 
io_Length 
+0x0024 
io_Length 
+0x0024 
io Message 
+0x0000 
io Message 
+0x0000 
io_Message 
+0x0000 
io_ Message 
+0x0000 
io Message 
+0x0000 
io_Modes 
+0x0028 
io_Offset 
+0x002c 
io_Offset 
+0x002c 
io_ParFlags 
+0x0035 
io_Parm0 
+0x0022 


unsigned int in 


struct IOExtSer 


devices/serial.h: *61 
pointer to pointer to char in struct IOStdReq 


exec/io.h: *36 


pointer to char in struct IOClipReq 
devices/clipboard.h: *46 
int in struct IODRPReq 
devices/printer.h: *164 
int in struct IODRPReq 


devices/printer. 


h: *165 


pointer to struct Device in stru 


exec/io.h: *20 


pointer to struct Device in stru 


exec/io.h: *29 


pointer to struct Device in stru 
devices/clipboard.h: *39 
pointer to struct Device in stru 


devices/printer. 


h: *138 


pointer to struct Device in stru 


devices/printer. 


h: *152 


char in struct IO0Request 


exec/io.h: “*24 


char in struct I0StdReq 


exec/io.h: *33 


char in struct IOClipReg 
devices/clipboard.h: *43 
char in struct IoPrtCmdReg 


devices/printer. 


h: *142 


char in struct IODRPReq 


devices/printer. 


unsigned int in 


h: *156 
struct IOExtSer 


devices/serial.h: *63 
char in struct I0Request 


exec/io.h: ¥*23 


char in struct IOStdReq 


‘exec/io.h: *32 


char in struct IOClipReq 
devices/clipboard.h: *42 
char in struct IoPrtCmdReg 


Gevices/printer. 


h: *141 


char in struct IODRPReq 


devices/printer. 


unsigned int in 
exec/fio.h: *35 
unsigned int in 


h: *155 
struct I0StdReq 


struct I0CclipReq 


devices/clipboard.h: *45 
struct Message (size 0x0014) in 


exec/io.h: ¥*19 


struct Message (size 0x0014) in 


exec/io.h: *28 


struct Message (size 0x0014) in 
devices/clipboard.h: *38 
struct Message (size 0x0014) in 


devices/printer. 


h: *137 


struct Message (size 0x0014) in 
: *151 


devices/printer.h 


unsigned int in 


devices/printer. 


unsigned int in 
exec/io.h: *37 
unsigned int in 


struct IODRPReq 
h: *159 
struct I0StdReq 


struct IOCLipReq 


devices/clipboard.h: *47 
char in struct IOExtPar 
devices/parallel.h: *52 
char in struct IoPrtCmdReq 


devices/printer. 


h: *144 


char in struct IOPrtCmdReq 


devices/printer. 


h: *145 


char in struct IoprtcmdReq 


ct TORequest 


ct IostdReq 


ct I0clipReq 


ct IoPrtcmdReq 


ct IODRPReq 


struct 
struct 
struct 
struct 


struct 


TORequest. 
TostdReq 
IOClLipReq 
ToPrtcmdReg 
TODRPReq 





Sep 21 13:06 1988 C_Langquage_Cross-Reference Page 45 


io_Parm3 
io_PExtFlags 
io_PrtCommand 
io_PTermArray 


io_RastPort 


+0x0024 devices/printer.h: *146 

char in struct IOPrtCmdReq 

+0x0025 devices/printer. h: *147 

unsigned int in struct IOExtPar 

+0x0030 devices/parallel. h: *50 

unsigned short int in struct IoPrtCmdReq 
+0x0020 devices/printer.h: *143 

struct I0PArray (size 0x0008) in struct IOExtPar 
devices/parallel.h: *53 

pointer to struct RastPort in struct IODRPReq 
+0x0020 devices/printer. h: *157 


+0x0036 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 46 


+0x000e 
+0x0000 
ITEMENABLED 


ItemFill 
+0x0012 


exec/interrupts.h: *24 

struct Node (size 0x000e) in struct Interrupt 
exec/interrupts.h: *23 

struct Node (size 0x000e) in struct Isrvstr 
graphics/graphint.h: *20 

#define 0x0010 =0x00000010 intuition/intuition.h: *117 
pointer to pointer to char in struct MenuItem 
intuition/intuition.h: *94 

Macro (1 ar nt) intuition/intuition.h: *945 

#define 0x0002 =0x00000002 intuition/intuition.h: *114 
pointer to char in struct IntuiText 


io_RBufLen unsigned int in struct IOExtSer intuition/intuition.h: *501 
+0x0034 devices/serial.h: *62 pointer to struct TextAttr in struct IntuiText 
io_ReadLen char in struct IOExtSer intuition/intuition.h: *500 


io_SerFlags 


+0x004c devices/serial.h: *67 
char in struct IOExtSer 
+0x004f devices/serial.h: *70 


Macro (1 argument) libraries/mathffp.h: *31 
Macro (1 argument) libraries/mathieeedp.h: *32 
pointer to function returning void in struct IntVector 


6 — H 


+0x0004 exec/interrupts.h: *31 
pointer to pointer to char in struct IntVector 
exec/interrupts.h: *30 
pointer to struct Node in struct IntVector 
+0x0008 exec/interrupts.h: *32 
#define 0 =0x00000000 graphics/rastport.h: *88 
#define 1 =0x00000001 graphics/rastport.h: *89 
short int in struct Menu 
intuition/intuition.h: *67 
short int in struct Menu 
intuition/intuition.h: *67 
unsigned short int in struct Custom 

+0x000a hardware/custom.h: *25 

unsigned short int in struct Custom 
+0x000c hardware/custom.h: *26 
unsigned short int in struct Custom 

+0x0036 hardware/custom.h: *46 
KBD_ADDRESETHANDLER #define (CMD_NONSTD+2) =0x0000000b devices/keyboard.h: *19 
KBD_READEVENT #define (CMD_NONSTD+0) =0x00000009 devices/keyboard.h: *17 
KBD_READMATRIX  #define (CMD_NONSTD+1) =0x0000000a devices/keyboard.h: *18 


io_Special unsigned short int in struct IODRPReq 

+0x003c devices/printer.h: *166 
io_SrcHeight unsigned short int in struct IODRPReq 

+0x0032 devices/printer.h: *163 
io_SrewWidth unsigned short int in struct IODRPReq 
+0x0030 devices/printer.h: *162 

unsigned short-int in struct IODRPReq 
+0x002c devices/printer.h: *160 
unsigned short int in struct IODRPReq 

+0x002e devices/printer.h: *161 
IO_STATB_OVERRUN #define 8 =0x00000008 devices/serial.h: *125 
IO_STATB READBREAK #define 10 =0x0000000a devices/serial.h: *121] 
JO_STATB_WROTEBREAK #define 9 =0x00000009 devices/serial.h: *123 
IO_STATB_XOFFREAD #define 12 =0x0000000c devices/serial.h: *117 
IO_STATB_XOFFWRITE #define 11 =0x0000000b devices/serial.h: *119 
IO_STATF_OVERRUN #define (1<<8) =0x00000100 devices/serial.h: *126 
IO_STATF_READBREAK #define (1<<10) =0x00000400 devices/serial.h: *122 
IO_STATF_WROTEBREAK #define (1<<9) =0x00000200 devices/serial.h: *124 
IO_STATF_ XOFFREAD #define (1<<12) =0x00001000 devices/serial.h: *118 
IO_STATF_XOFFWRITE #define (1<<11) =0x00000800 devices/serial.h: *120 


+0x0000 


ilo_Srex 
io_SreY +0x0016 


+0x0018 


io Status char in struct IOExtPar KBD _REMRESETHANDLER #define (CMD_NONSTD+3) =0x0000000c devices/keyboard.h: *20 
+0x0034 devices/parallel.h: *51 KBD_RESETHANDLERDONE #define (CMD _NONSTD+4) =0x0000000d devices/keyboard.h: *21 
io_Status unsigned short int in struct IOExtSer KCB_ALT #tdefine 1 =0x00000001 devices/keymap.h: *47 
+0x0050 devices/serial.h: *71 KCB_CONTROL #define 2 =0x00000002 devices/keymap.h: *49 


#define 5 =0x00000005 devices/keymap.h: *54 
#define 3 =0x00000003 devices/keymap.h: *51 
#define 7 =0x00000007 devices/keymap.h: *60 
#define 0 =0x00000000 devices/keymap.h: *45 
#define 6 =0x00000006 devices/keymap.h: *57 
#tdefine 0x02 =0x00000002 devices/keymap 


io_StopBits char in struct IOExtSer 
+0x004e devices/serial.h: *69 : 
io_TermArray struct I0TArray (size 0x0008) in struct IOExtSer 
+0x0044 devices/serial.h: *66 
pointer to struct Unit in struct IORequest 


KCB_STRING 
+0x0018 exec/io.h: *21 


KCF ALT 


io_Unit 
*48 


io_Unit pointer to struct Unit in struct IostdReq KCF_CONTROL #define 0x04 =0x00000004 devices/keymap. *50 
+0x0018 exec/io.h: *30 KCF_DEAD #define 0x20 =0x00000020 devices/keymap.h: *55 
io_Unit pointer to struct Unit in struct IOClipReq KCF_DOWNUP #define 0x08 =0x00000008 devices/keymap. *52 


*61 
*46 
*58 


#define 0x80 =0x00000080 devices/keymap. 
#define 0x01 =0x00000001 devices/keymap 
#define 0x40 =0x00000040 devices/keymap. 
#define 0 =0x00000000 devices/keymap.h: *43 

#define 7 =0x00000007 devices/keymap.h: *44 

#define 0x35 =0x00000035 intuition/intuition. 
#define 0x37 =0x00000037 intuition/intuition. 
#define 0x36 =0x00000036 intuition/intuition. 
#define 0x10 =0x00000010 intuition/intuition. 


+0x0018 devices/clipboard.h: *40 
pointer to struct Unit in struct IoPrtCmdReq 
+0x0018 devices/printer.h: *139 
pointer to struct Unit in struct IODRPReq 
+0x0018 devices/printer.h: *153 
io _WriteLen char in struct IOExtSer 
+0x004d devices/serial.h: *68 
Iptr pointer to struct Isrvstr in struct Isrvstr 
+0x000e graphics/graphint.h: *2] 


io_Unit 


BB Sb a abr 


io Unit 


ISDRAWN #define 0x1000 =0x00001000 intuition/intuition.h: *130 #define 0x34 =0x00000034 intuition/intuition. 
ISGRTRX #define 4 =0x00000004 graphics/clip.h: *74 #define 0x32 =0x00000032 intuition/intuition. 
ISGRTRY #define 8 =0x00000008 graphics/clip.h: *75 p structure tag 

ISLESSX #define 1 =0x00000001 graphics/clip.h: *72 size 0x0020 devices/keymap:h: *20, 33 

ISLESSY #define 2 =0x00000002 graphics/clip.h: *73 devices/conunit.h: 55 

Isrvstr structure tag intuition/intuition.h: 479 


size 0x00le graphics/qraphint. h: *18, 21 KeyMapNode structure tag 





is_ Code pointer to function returning void in struct Interrupt size 0x002e devices/keymap.h: *31 
+0x0012 exec/interrupts.h: *25 KeyMapResource structure tag 
is Data pointer to pointer to char in struct Interrupt size 0x00lc devices/keymap.h: *37 















































KeyRptDelay 
+0x000c 


KickTagPtr 
+0x0226 

km_HiCapsable 
+0x0018 

km_HikeyMap 
+0x0014 


+0x0010 
km_HiRepeatable 
+0x001¢c 
km_LoCapsable 
+0x0008 
km_LoKeyMap 
+0x0004 


+0x0000 
km_LoRepeatable 

+0x000c 
KNOBHIT 
KNOBHMIN 


o€ -—H 


+0x00b9 
LACEWB 
LastAlert 

+0x0202 





size 0x00a0 


Layer 
+0x0000 
LAYERBACKDROP 
LayeriInfo 
+0x0044 









LayerInfo_extra 
size 0x0000 





LayerInfo_extra 


LayerPtr 





Sep 21 13:06 1988 C_Language_Cross~Reference Page 47 





struct timeval (size 0x0008) in struct Preferences 
intuition/preferences.h: *55 

struct timeval (size 0x0008) in struct Preferences 
intuition/preferences.h: *5 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *117 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *115 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *116 

pointer to char in struct KeyMap 

devices/keymap.h: *27 

pointer to unsigned int in struct KeyMap 
devices/keymap.h: *26 


km_HikeyMapTypes pointer to char in struct KeyMap 


devices/keymap.h: ¥*25 

pointer to char in struct KeyMap 
devices/keymap.h: *28 

pointer to char in struct KeyMap 
devices/keymap.h: *23 

pointer to unsigned int in struct KeyMap 
devices/keymap.h: *22 


km_LoKeyMapTypes pointer to char in struct KeyMap 


devices/keymap.h: *21 

pointer to char in struct KeyMap 

devices/keymap.h: *24 

#define 0x0100 =0x00000100 intuition/intuition.h: *433 
#define 6 =0x00000006 intuition/intuition.h: *435 
#define 4 =0x00000004 intuition/intuition.h: *436 
struct KeyMap (size 0x0020) in struct KeyMapNode 
devices/keymap.h: *33 

struct Node (size 0x000e) in struct KeyMapNode 
devices/keymap.h: *32 

struct List (size 0x000e) in struct KeyMapResource 
devices/keymap.h: *39 

struct Node (size 0x000e) in struct KeyMapResource 
devices/keymap.h: *38 

#define 4 =0x00000004 graphics/view.h: *61 

char in struct Preferences 
intuition/preferences.h: *108 

#define 0x01 =0x00000001 intuition/preferences.h: *131 
array [4] of int in struct ExecBase 
exec/execbase.h: *90 

pointer to pointer to char in struct GelsInfo 
graphics/rastport.h: *47 


LastChanceMemory pointer to struct SignalSemaphore in struct GfxBase 


graphics/gfxbase.h: *61 

pointer to pointer to short int in struct GelsInfo 
graphics/rastport.h: *44 

structure tag 

graphics/clip.h: *25, 27, 58 
graphics/rastport.h: 52 

graphics/layers.h: 34, 35, 36 
intuition/intuition.h: 157, 465, 788 
intuition/screens.h: 81 

pointer to struct Layer in struct RastPort 
graphics/rastport.h: *52 

#define 0x40 =0x00000040 graphics/layers.h: *25 
pointer to struct Layer_Info in struct Layer 
graphics/clip.h: *43 

struct Layer _Info (size 0x0066) in struct Screen 
intuition/sereens.h: *65 

structure tag 

graphics/layers.h: 46 

pointer to struct LayerInfo_extra in struct Layer_Info 
graphics/layers.h: *46 
size unsigned short int in struct Layer_Info 


+0x005c graphics/layers.h: *44 


pointer to struct Layer in struct StringInfo 


+0x0018 
LAYERREFRESH 
LAYERSIMPLE 
LAYERSMART 
LAYERSUPER 
LAYERUPDATING 





Layer Info 
size 0x0066 





lh_PosSize 
lh_Revision 


+0x000ce 
lh_Version 
LIBF_CHANGED 
LIBF_DELEXP 
LIBF_SUMMING 


LibNode 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 48 


intuition/intuition.h: *465 


#define 
#define 
#define 
#define 
#define 


LAYER_CLIPRECTS LOST #define 0x100 =0x00000100 graphics/layers.h: *27 
structure tag 

graphics/clip.h: 43 

graphics/layers.h: *32 

intuition/screens.h: 65 


pointer 


graphics/gfxbase.h: *62 


#define 


unsigned short int in struct PropInfo 
intuition/intuition.h: *423 
short int in struct Menu 
intuition/intuition.h: *60 
short int in struct MenuItem 
intuition/intuition.h: *88 
short int in struct Requester 
intuition/intuition.h: *145 
short int in struct Gadget 
intuition/intuition.h: *197 
short int in struct IntuiText 
intuition/intuition.h: *498 
short int in struct Border 
intuition/intuition.h: *524 
short int in struct Image 
intuition/intuition.h:. *545 
short int in struct Window 
intuition/intuition.h: *697 
short int in struct NewWindow 
intuition/intuition.h: *852 
short int in struct Screen 
intuition/screens.h: *45 
short int in struct NewScreen 
intuition/screens.h: *119 


#define 


short int in struct GelsInfo 
graphics/rastport.h: *46 


#tdefine 
#define 
pointer 


exec/lists.h: *20 


#define 
#define 
#define 
#define 
#define 
#define 
#define 
#tdefine 
pointer 


exec/lists.h: *21 


pointer 


exec/lists.h: *22 


char in 


exec/lists.h: *23 


#define 
#tdefine 
#define 
#tdefine 
#define 


struct List (size 0x000e) in struct ExecBase 
exec/execbase.h: *81 

struct Library (size 0x0022) in struct ExecBase 
exec/execbase.h: *31 . 

struct Library (size 0x0022) in struct GfxBase 


0x80 =0x00000080 graphics/layers.h: *26 
1 =0x00000001 graphics/layers.h: *21 
2 =0x00000002 graphics/layers.h: *22 
4 =0x00000004 graphics/layers.h: *23 
0x10 =0x00000010 graphics/layers.h: *24 


to unsigned short int in struct GfxBase 


0x0020 =0x00000020 intuition/intuition.h: *312 


4 =0x00000004 graphics/collide.h: *32 


0x100 =0x00000100 intuition/preferences.h: *159 
lib Flags =0x00000000 exec/libraries.h: *50 
to struct Node in struct List 


lib IdString =0x00000000 exec/libraries.h: *56 
lib_NegSize =0x00000000 exec/libraries.h: *52 
lib Node =0x00000000 exec/libraries.h: *49 
lib_Opencnt =0x00000000 exec/libraries.h: *58 
lib pad =0x00000000 exec/libraries.h: *51 

lib _PosSize =0x00000000 exec/libraries.h: *53 
lib Revision =0x00000000 exec/libraries.h: *55 
lib Sum =0x00000000 exec/libraries.h: *57 

to struct Node in struct List 


to struct Node in struct List 
struct List 


lib Version =0x00000000 exec/libraries.h: *54 
(1<<1) =0x00000002 exec/libraries.h: *44 
(1<<3) =0x00000008 exec/libraries.h: *46 
(1<<0) =0x00000001 exec/libraries.h: *43 
(1<<2) =0x00000004 exec/libraries.h: *45 





ce - H 


Sep 21 13:06 1988 C Language_Cross-Reference Page 51 


isb_Next 
+0x0010 
isb_SummedLongs 
+0x0004 
LW_RESERVED 
i_pad 
+0x000d 
MakeDosNode 


MALE 
Mask 
+0x0018 
Mask 
+0x0002 
MatchToolValue 
MathIEEEBase 
size 0x003c 


unsigned int in struct LoadSegBlock 
devices/hardblocks.h: *188 

unsigned int in struct LoadSegBlock 
devices/hardblocks.h: *185 

#define 1 =0x00000001 intuition/preferences.h: *132 
char in struct List 

exec/lists.h: *24 

extern function returning pointer to struct DeviceNode 
(size 0x002c) 

libraries/expansion.h: *26 

#define 0 =0x00000000 devices/narrator.h: *43 

char in struct RastPort 

graphics/rastport.h: *58 

pointer to unsigned short int in struct Boolinfo 
intuition/intuition.h: *363 

extern function returning "LONG" workbench/icon.h: *30 
structure tag 

libraries/mathlibrary.h: *21 


MathIEEEBase_68881 pointer to unsigned short int in struct MathIEEEBase 


+0x0024 


libraries/mathlibrary.h: *26 


IMathIEEEBase Flags unsigned char in struct MathIEEEBase 


+0x0022 


libraries/mathlibrary.h: *24 


MathIEEEBase_LibNode struct Library (size 0x0022) in struct MathIEEEBase 


+0x0000 


libraries/mathlibrary.h: *23 


MathIEEEBase_reservedl unsigned char in struct MathIEEEBase 


+0x0023 


libraries/mathlibrary.h: *25 


MathIEEEBase Resource pointer to struct MathIEBEEResource in struct 


+0x0030 


MathIEEEBase 
libraries/mathlibrary.h: *29 


MathIEEEBase_SegList pointer to pointer to char in struct MathIEEEBase 


+0x002¢ 


libraries/mathlibrary.h: *28 


MathIEEEBase SysLib pointer to pointer to char in struct MathIEEEBase 


+0x0028 


libraries/mathlibrary.h: *27 


MathIEEEBase_TaskCloseLib pointer to function returning int in struct 


+0x0038 


MathIEEEBase 
libraries/mathlibrary.h: *31 


MathIEEEBase_TaskOpenLib pointer to function returning int in struct 


+0x0034 


MathIEEEBase 
libraries/mathlibrary.h: *30 


MathIEEEResource structure tag 


size 0x002c 


libraries/mathlibrary.h: 29 
resources/mathresource.h: *35 


MATHIEEERESOURCEF_DBLBAS #define (1<<0) =0x00000001 


resources/mathresource.h: *49 


MATHIEEERESOURCEF_DBLTRANS #define (1<<1) =0x00000002 


resources/mathresource.h: *50 


MATHIEEERESOURCEF_EXTBAS #define (1<<4) =0x00000010 


resources/mathresource.h: *53 


MATHIEEERESOURCEF_EXTTRANS #define (1<<5) =0x00000020 


resources/mathresource.h: *54 


MATHIEEERESOURCEF_SGLBAS #define (1<<2) =0x00000004 


resources/mathresource.h: *51 


MATHIEEERESOURCEF SGLTRANS #define (1<<3} =0x00000008 


resources/mathresource.h: *52 


MathIEEEResource_BaseAddr pointer to unsigned short int in struct 


+0x0010 


MathIEEEResource 
resources/mathresource.h: *39 


MathIEEEResource DblBasInit pointer to function returning void in struct 


+0x0014 


MathIEEEResource 
resources/mathresource.h: *40 


MathIEEEResource_DblTransInit pointer to function returning void in struct 


+0x0018 


MathIEEEResource 
resources/mathresource.h: *41 


MathIEEEResource_ExtBasInit pointer to function returning void in struct 


+0x0024 


MathIEEEResource 
resources/mathresource.h: *44 


MathIEEEResource_ExtTransInit pointer to function returning void in struct 


+0x0028 


MathIEEEResource 
resources/mathresource.h: *45 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 52 


MathIEEEResource_Flags unsigned short int in struct MathIEEEResource 


+0x000e 


resources/mathresource.h: *38 


MathIEEEResource Node struct Node (size 0x000e) in struct MathIEEEResource 


+0x0000 


resources/mathresource.h: *37 


MathIFEEResource_SglBasInit pointer to function returning void in struct 


+0x001c 


MathIEBEResource 
resources/mathresource.h: *42 


MathIEFEResource_SglTransInit pointer to function returning void in struct 


+0x0020 
MAXBODY 
MAXBYTESPERROW 
MaxChars 
+0x000a 
MaxCount 
+0x0012 
MaxCount 
+0x0008 
MaxCount 
+0x00le 
MaxDisplayColumn 
4+0x00d6 
MaxDisplayRow 
+0x00d4 
MaxExtMem 
+0x004e 
MAXFONTNAME 
MAXFONTPATH 
MAXFREQ 
MaxHeight 
+0x0016 
MaxHeight. 
+0x002c 
MAXINT 
MaxLocMem 
+0x003e 
MAXP ITCH 
MAXPOT 
MAXRATE 
MAXTABS 
MAXVOL 
MaxWidth 
+0x0014 
MaxWidth 
+0x002a 
Maxx 
+0x0004 
MaxY 
+0x0006 
me_Bytes 
+0x0004 
me_Next 
+0x0000 
MeMask 
+0x0020 
MemChunk 
size 0x0008 
MemEntry 
size 0x0008 
MEMF CHIP 
MEME CLEAR 
MEMF FAST 
MEMF_LARGEST 
MEMF_PUBLIC 
MemHeader 
size 0x0020 
MemList 
size 0x0018 
MemList. 


MathIEEEResource 

resources/mathresource.h: *43 

#define OxFFFF =O0x0000ffff intuition/intuition.h: *437 
#define 128 =0x00000080 hardware/blit.h: *18 
short int in struct StringInfo 
intuition/intuition.h: *457 

short int in struct Areainfo 

graphics/rastport.h: *24 

short int in struct eprlist 

graphics/copper.h: *52 

short int in struct CopList 

graphics/copper.h: *65 

unsigned short int in struct GfxBase 
graphics/gfixbase.h: *55 

unsigned short int in struct GfxBase 
graphics/gfxbase.h: *54 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *45 

#define 32 =0x00000020 libraries/diskfont.h: *41, 55 
#define 256 =0x00000100 libraries/diskfont.h: *23, 26 
#define 28000 =0x00006d60 devices/narrator.h: *59 
unsigned short int in struct Window 
intuition/intuition.h: *703 

unsigned short int in struct NewWindow 
intuition/intuition.h: *902 

define Ox7FFFFFFF =Ox7fffffff libraries/dos.h: *40 
unsigned int in struct ExecBase 

exec/execbase.h: *41 

#define 320 =0x00000140 devices/narrator.h: *57 
tdefine OxFFFF =0x0000ffff intuition/intuition.h: *438 
#tdefine 400 =0x00000190 devices/narrator.h: *55 
#define 80 =0x00000050 devices/conunit.h: *31, 57 
#define 64 =0x00000040 devices/narrator.h: *61 
unsigned short int in struct Window 
intuition/intuition.h: *703 

unsigned short int in struct NewWindow 
intuition/intuition.h: *902 

short int in struct Rectangle 

graphics/gfx.h: *26 

short int in struct Rectangle 

graphics/gfx.h: *26 

unsigned int in struct MemChunk 

exec/memory.h: *22 

pointer to struct MemChunk in struct MemChunk 
exec/memory.h: *21 

short int in struct VSprite 

graphics/gels.h: *101 

structure tag 

exec/memory.h: *20, 21, 31 

structure tag 

exec/memory.h: *40, 58 

#define (1<<1) =0x00000002 exec/memory.h: *67 
#define (1<<16) =0x00010000 exec/memory.h: *70 
#define (1<<2) =0x00000004 exec/memory.h: *68 
#define (1<<17) =0x00020000 exec/memory.h: *71 
#define (1<<0) =0x00000001 exec/memory.h: *66 
structure tag 

exec/memory.h: *28 

structure tag 

exec/memory.h: *55 

struct List (size 0x000e) in struct ExecBase 


c€ - H 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 53 


+0x0142 
Memo. 

+0x0008 
MEM BLOCKMASK 
MEM _ BLOCKSTZE 
Menu 

size 0x00le 

MENUCANCEL 
MENUDOWN 


MENUENABLED 
MenuHBorder 

+0x0022 
MENUHOT 
Menultem 

size 0x0022 

MenuName 

+0x000e 
MENUNULL 
MENUNUM 
MENUPICK 
MENUSTATE 
MenuStrip 

+0x001c 
MENUTOGGLE 
MENUTOGGLED 
MENUUP 


MenuVBorder 
+0x0021 
MENUVERIFY 
MENUWAITING 
Message 
size 0x0014 


message 
+0x0000 
MessageKey 
+0x005e 
meu_Addr 
+0x0000 
meu_Reqs 
+0x0000 
me_Addr 
me_Length 
+0x0004 
me_Reqs 
me_Un 
+0x0000 
me_un 
mh_Attributes 
+0x000e 
mh_First 
+0x0010 


exec/execbase.h: *77 

pointer to char in struct Remember 
intuition/intuition.h: *932 

#define 7 =0x00000007 exec/memory.h: *74 

#define 8 =0x00000008 exec/memory.h: *73 

structure tag 

intuition/intuition.h: *57, 59, 707 

#define 0x0002 =0x00000002 intuition/intuition.h: *674 
#define (IECODE_RBUTTON) =0x00000069 
intuition/intuition.h: *1009 

#define 0x0001 =0x00000001 intuition/intuition.h: *72 
char in struct Screen 

intuition/screens.h: *56 

#define 0x0001 =0x00000001 intuition/intuition.h: *673 
structure tag 

intuition/intuition.h: 64, *85, 87, 103 

pointer to char in struct Menu 

intuition/intuition.h: *63 

#define OxFFFF =0x0000ffff intuition/intuition.h: *964 
Macro (1 argument) intuition/intuition.h: *944 

#define 0x00000100 =0x00000100 intuition/intuition.h: *646 
#define 0x8000 =0x00008000 intuition/intuition.h: *827 
pointer to struct Menu in struct Window 
intuition/intuition.h: *707 

#define 0x0008 ~0x00000008 intuition/intuition.h: *116 
#define 0x4000 =0x00004000 intuition/intuition.h: *132 
#define (IECODE_RBUTTON | IECODE_UP PREFIX) =0x000000e9 
intuition/intuition.h: *1008 

char in struct Screen 

intuition/screens.h: *56 

#define 0x00002000 =~0x00002000 intuition/intuition.h: *651 
#define 0x0003 =0x00000003 intuition/intuition.h: *675 
structure tag 

exec/ports.h: *47 

exec/io.h: 19, 28 

devices/audio.h: 55 

devices/clipboard.h: 38, 54 

devices/printer.h: 137, 151 

libraries/dosextens.h: 61, 80, 111 

graphics/text.h: 57 

intuition/intuition.h: 598 

resources/disk.h: 42 

workbench/startup.h: 26 

struct IOStdReq (size 0x0030) in struct narrator_rb 
devices/narrator.h: *68 

pointer to struct IntuiMessage in struct Window 
intuition/intuition.h: *755 

pointer to pointer to char in union (no tag) 
exec/memory.h: *43 

unsigned int in union (no tag) 

exec/memory.h: *42 

#define me_Un.meu_Addr exec/memory.h: *50 

unsigned int in struct MemEntry 

exec/memory.h: *45 

#define me_Un.meu_Regs exec/memory.h: *49 

union (no tag) (size 0x0004) in struct MemEntry 
exec/memory.h: *44 

#define me_Un =0x00000000 exec/memory.h: *48 

unsigned short int in struct MemHeader 

exec/memory.h: *30 

pointer to struct MemChunk in struct MemHeader 
exec/memory-h: *31 

unsigned int in struct MemHeader 

exec/memory.h: *34 

pointer to pointer to char in struct MemHeader 
exec/memory.h: *32 

struct Node (size 0x000e) in struct MemHeader 
exec/memory.h: *29 

pointer to pointer to char in struct MemHeader 





Sep 21 13:06.1988 C_Language_Cross-Reference Page 54 


+0x0018 


|Micros 


+0x0028 
Micros 

+0x004c 
MicrosPerLine 

+0x00e8 
MIDRAWN 
MinDisplayColumn 

+0x00ea 
MINFREQ 
MinHeight 

+0x0012 
MinHeight 

+0x0028 
MININT 
MinList 

size 0x000c 


MinNode 
size 0x0008 


MINPITCH 
MINRATE 
minterms 

+0x0028 
MINVOL 
MinWidth 

+0x0010 
MinWidth 

+0x0026 
MinX 

+0x0000 
MinY 

+0x0002 
MISCNAME 
MiscResource 

size 0x0032 

mlh_Head 

+0x0000 
mlh_Tail 

+0x0004 
mih_ TailPred 

+0x0008 
min Pred 

+0x0004 
mln Succ 

+0x0000 
ml_ME 

+0x0010 
ml_me 
ml_Node 

+0x0000 
ml_NumEntries 

+0x000e 
mn_Length 

+0x0012 
mn_Node 

+0x0000 
mn_ReplyPort 

+0x000e 
mode 

+0x0034 
Modes 

+0x0020 
Modes 

+0x0010 


exec/memory.h: *33 
unsigned int in struct IntuiMessage 
intuition/intuition.h: *625 
unsigned int in struct IntuitionBase 
intuition/intuitionbase.h: *164 

unsigned short int in struct GfxBase 
graphics/gfxbase.h: *63 


#define 0x0100 =0x00000100 intuition/intuition.h: 


unsigned short int in struct GfxBase 
graphics/gfxbase.h: *64 


#define 5000 =0x00001388 devices/narrator.h: *58 


short int in struct Window 
intuition/intuition.h: *702 
short int in struct NewWindow 
intuition/intuition.h: *901 
#define 0x80000000 =0x80000000 libraries/dos.h: *41 
structure tag 


exec/lists. 


h: *28 


exec/semaphores.h: 52 
graphics/layers.h: 37 
structure tag 


exec/nodes . 
exec/lists. 


h: *23, 24, 25 
h: 29, 30, 31 


exec/semaphores.h: 44 


#define 65 =0x00000041 devices/narrator.h: *56 
#define 40 =0x00000028 devices/narrator.h: *54 


array [8] of char in struct RastPort 
graphics/rastport.h: *69 


#define 0 =0x00000000 devices/narrator.h: *60 


short int in struct Window 


intuition/intuition.h: 


*702 


short int in struct NewWindow 


intuition/intuition.h: 
short int in struct 


graphics/gfx.h: *25 


short int in struct 


graphics/gfx.h: *25 


#define "misc.resource" resources/misc.h: *44 


structure tag 
resources/misc.h: *35 


pointer to 
exec/lists 
pointer to 
exec/lists 
pointer to 


exec/lists. 


pointer to 


exec/nodes. 


pointer to 


exec/nodes. 


struct MinNode 


-h: *29 


struct MinNode 


wh: *30 


struct MinNode 
h: *31 
struct MinNode 
h: *25 
struct MinNode 
h: *24 


*901 
Rectangle 


in 
in 
in 
in 


in 


array [1] of struct MemEntry 
exec/memory.h: *58 


#define ml_ME =0x00000000 exec/memory.h: *61 


Rectangle 


struct MinList 
struct MinList 
struct MinList 
struct MinNode 


struct MinNode 


*75 


(size 0x0008) in struct Membist 


struct Node (size 0x000e) in struct MemList 
exec/memory.h: *56 
unsigned short int in struct MemList 
exec/memory.h: *57 
unsigned short int in struct 


exec/ports. 


h: *50 


struct Node (size 0x000e) in 


exec/ports. 


h: *48 


pointer to struct MsgPort in 


exec/ports. 


h: *49 


unsigned short int in struct 
devices/narrator.h: *71] 
unsigned short int in struct 
graphics/view.h: *41 
unsigned short int in struct 
graphics/view.h: *54 


Message 

struct Message 
struct Message 
narrator_rb 
ViewPort 


View 





ve -— H 








Sep 21 13:061988 C Language_Cross~Reference Page 55 


+0x0020 
+0x000e 
+0x0012 
+0x0046 
+0x0022 
+0x000c 
+0x0010 
+0x0044 
+0x0042 


mouth_rb 
size 0x004a 


mp_SoftInt 
mr_AllocArray 
+0x0022 


unsigned short int in struct GfxBase 
graphics/gfxbase.h: *37 

#define 0x8000 =0x00008000 graphics/display.h: *14 
#define 1006 =0x000003ee libraries/dos.h: *28 
#define 1005 =0x000003ed libraries/dos.h: *26 
#define 1004 =0x000003ec libraries/dos.h: *30 
struct List (size 0x000e) in struct ExpansionBase 
libraries/expansionbase.h: *52 

#define 0x00000008 =0x00000008 intuition/intuition.h: *641 
#define 0x00000010 =0x00000010 intuition/intuition.h: *642 
short int in struct IntuiMessage 
intuition/intuition.h: *620 

short int in struct Window 
intuition/intuition.h: *700 

short int in struct Screen 

intuition/screens.h: *48 

short int in struct IntuitionBase 
intuition/intuitionbase.h: *161 

short int in struct IntuiMessage 
intuition/intuition.h: *620 

short int in struct Window 
intuition/intuition.h: *700 

short int in struct Screen 

intuition/screens.h: *48 

short int in struct IntuitionBase 
intuition/intuitionbase.h: *161 

char in struct narrator_rb - 

devices/narrator.h: *77 

structure tag 

devices/narrator.h: *87 

char in struct MsgPort 

exec/ports.h: *30 

struct List (size 0x000e) in struct MsgPort 
exec/ports.h: *33 

struct Node (size 0x000e) in struct MsgPort 
exec/ports.h: *29 

char in struct MsgPort 

exec/ports.h: *31 

pointer to struct Task in struct MsgPort 
exec/ports.h: *32 

define mp_SigTask =0x00000000 exec/ports.h: *36 
array [4] of unsigned int in struct MiscResource 
resources/mise.h: *37 


MR_ALLOCMISCRESOURCE #define (LIB_BASE) =Oxfffffffa resources/misc.h: *40 
MR_FREEMISCRESOURCE #define (LIB_BASE + LIB_VECSIZE) =Oxfffffffa 


mr Library 
+0x0000 

MR_PARALLELBITS 
MR_PARALLELPORT 
MR_SERIALBITS 
MR_SERIALPORT 
MsgPort 

size 0x0022 


MTYPE_CLOSEDOWN 
MTYPE_DISKCHANGE 
MTYPE IOPROC 
MTYPE_ PSTD 
MTYPE_ TIMER 
MTYPE_TOOLEXIT 


resources/misc.h: *41 

struct Library (size 0x0022) in struct MiscResource 
resources/misc.h: *36 

#define 3 =0x00000003 resources/misc.h: *31 
#define 2 =0x00000002 resources/mise.h: *30 
#define 1 =0x00000001 resources/misc.h: *29 
#define 0 =0x00000000 resources/misec.h: *28 
structure tag 

exec/ports.h: *28, 49 

exec/devices.h: 32 

exec/semaphores.h: 33 

devices/conunit.h: 35 

libraries/dosextens.h: 36, 62, 63, 81, 228, 258, 294 
intuition/intuition.h: 754 

devices/prtbase.h: 61, 86 
libraries/filehandler.h: 99 

workbench/startup.h: 27 

#tdefine 5 =0x00000005 workbench/workbench.h: *82 
#define 3 =0x00000003 workbench/workbench.h: *80 
#tdefine 6 =0x00000006 workbench/workbench.h: *83 
#define 1 =0x00000001 workbench/workbench.h: *78 
tdefine 4 =0x00000004 workbench/workbench.h:, *81 
tdefine 2 =0x00000002 workbench/workbench.h: *79 


MULTIPLY DIMENSIONS #define 0x0080 =0x00000080_intuition/preferences -h: *245 








Sep 21 13:06 1988 C_Language_Cross-Reference Page 56 


MUSTDRAW 
MutualExclude 
+0x000e 
MutualExclude 
+0x00le 
M_ASM 
M_AWM 
M_LNM 
n 
+0x0000 
NABC 
NABNC 
NANBC 
NANBNC 


narrator_rb 
size 0x0046 

NATURALFO 
ND_CantAlloc 
ND_Expunged 
ND_FreqErr 
ND_MakeBad 
ND _ModeErr 
ND_NoAudLib 
ND_NoMem 
ND_NoWrite 
ND_PhonErr 
ND_PitchErr 
ND_RateErr 
ND_SexErr 
ND_Unimpl 
ND_UnitErr 
ND_VolErr 


#define 0x0008 =0x00000008 graphics/gels.h: *19 
int in struct MenuItem 

intuition/intuition.h: *92 

int in struct Gadget 

intuition/intuition.h: *229 

#define '">1" devices/console.h: *89 

#define "?7" devices/console.h: *90 

#define 20 =0x00000014 devices/console.h: *88 
devices/conunit.h: 77 

pointer to struct bltnode in struct bltnode 
hardware/blit.h: *82 

#define 0x8 =0x00000008 hardware/blit.h: *26 
#aefine 0x4 =0x00000004 hardware/blit.h: *27 
#define 0x2 =0x00000002 hardware/blit.h: *28 
#define Oxl =0x00000001 hardware/blit.h: *29 
structure tag 

devices/narrator.h: *67, 88 

#define 0 =0x00000000 devices/narrator.h: *45 
#define -6 =Oxfffffffa devices/narrator.h: *23 
#define —9 =Oxfffffff7 devices/narrator.h: *26 
#define -25 =Oxffffffe7 devices/narrator.h: *32 
#define -4 =Oxfffffffc devices/narrator.h: *21 
#define —-24 =Oxffffffe8 devices/narrator.h: *31 
#define ~3 =Oxfffffffd devices/narrator.h: *20 
#define -2 =Oxfffffffe devices/narrator.h: *19 
#define -8 =Oxfffffff8 devices/narrator.h: *25 
#define -20 =Oxffffffec devices/narrator.h: *27 
#define -22 =Oxffffffea devices/narrator.h: *29 
#define -21 =Oxffffffeb devices/narrator.h: *28 
tdefine -23 =Oxffffffe9 devices/narrator.h: *30 
#define -7 =Oxfffffff9 devices/narrator.h: *24 
#define -5 =Oxfffffffb devices/narrator.h: *22 
#define -26 =Oxffffffe6 devices/narrator.h: *33 


NEWLAYERINFO_CALLED #define 1 =0x00000001 graphics/layers.h: *49 


NEWLOCKS 
NEWPREFS 
NewScreen 

size 0x0020 





NEWSIZE 
NewWindow 
size 0x0030 


Next 

+0x0000 
Next 

+0x0000 
Next. 

+0x0000 
Next 

+0x0000 
Next 

+0x0000 
Next 

+0x0000 
Next 

+0x0000 
NextBorder 

+0x000c 
NextComp 

+0x0006 
NextGadget 

+0x0000 
Next Image 

+0x0010 
NextItem 

+0x0000 
nextLine 

+0x000a 
NextMenu 


#define =0x00000000 graphics/clip.h: *23 
#define 0x00004000 =0x00004000 intuition/intuition.h: *652 
structure tag 

intuition/screens.h: *117 

#tdefine 0x00000002 =0x00000002 intuition/intuition.h: *639 
structure tag 

intuition/intuition.h: *850 
workbench/workbench.h: 42 

pointer to struct ClipRect in struct ClipRect 
graphics/clip.h: *56 

pointer to struct ViewPort in struct ViewPort 
graphics/view.h: *32 

pointer to struct RasInfo in struct RasInfo 
graphics/view.h: *71 

pointer to struct cprlist in struct cprlist 
graphics/copper.h: *50 

pointer to struct CopList in struct CopList 
graphics/copper.h: *57 

pointer to struct UCopList in struct UCopList 
graphics/copper.h: *71 

pointer to struct RegionRectangle in struct RegionRectangle 
graphics/regions.h: *19 

pointer to struct Border in struct Border 
intuition/intuition.h: *529 

pointer to struct AnimComp in struct AnimComp 
graphics/gels.h: *182 

pointer to struct Gadget in struct Gadget 
intuition/intuition.h: *195 

pointer to struct Image in struct Image 
intuition/intuition.h: *585 

pointer to struct MenuItem in struct MenuItem 
intuition/intuition.h: *87 

pointer to short int in struct GelsInfo 
graphics/rastport.h: *42 

pointer to struct Menu in struct Menu 












































































9€ -H 


+0x0023 
pad0o 

+0x0001 
padl 

+0x0101 
pad10 . 

+0x0a01 
padll 

+0x0b01 
padl2 

+0x0c01 
padl3 

+0x0d01 
padl4 

+0x0e01 
pad2 

+0x0201 
pad2d 

+0x005a 
pad3 

+0x0301 
pad34 

+0x0068 
pad3b 

+0x0076 
pad4 

+0x0401 
pad5 

+0x0501 
pad6 

+0x0601 
pad7 

+0x0701 
pad7c 

+0x00f8 
pads 

+0x0801 
pad83 

+0x0106 
pad86 

+0x010c 
pad8e 

+0x011lc 
padg 

+0x0901 
PAL 
PaperLength 

+0x00b2 
PaperSize 

+0x00b0 
Pape: 

+0x00b4 
PARALLELNAME 


PARALLEL_PRINTER 
PARB_ EOFMODE 
PARB_RAD BOOGIE 
PARB_ SHARED 
Parent 

+0x0042 
ParErr_BufTooBig 
ParErr_DevBusy 
ParErr_InitErr 
ParErr_InvParam 
ParErr_LineErr 
ParErr_NotOpen 
ParErr_PortReset 
PARF_EOFMODE 
PARF_RAD_ BOOGIE 
PARF_SHARED 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 59 


libraries/expansionbase.h: *47 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 


array [255] of 


hardware/cia.h: 
array [3] of unsigned short int in 


char 
*24 
char 
*26 
char 
*44 
char 
*46 
char 
*48 
char 
*50 
char 
*52 
char 
*28 


in 
in 
in 
in 
in 
in 
in 


in 


hardware/custom.h: *60 
array [255] of char in struct CIA 


hardware/cia.h: 
array [4] of unsigned short int in 


*30 


hardware/custom.h: *65 


array [4] of unsigned short int in 


hardware/custom.h: *69 
array [255] of char in struct CIA 


hardware/cia.h: 


*32 


struct CIA 
struct CIA 
struct. CIA 
struct CIA 
struct CIA 
struct CIA 
struct CIA 


struct CIA 


array [255] of char in struct CIA 


hardware/cia.h: 


*34 


array [255] of char in struct CIA 


hardware/cia.h: 


*36 


array [255] of char in struct CIA 


hardware/cia.h: 
array [4] of unsigned short int in 


*38 


hardware/custom.h: *94 
array [255] of char in struct CIA 


hardware/cia.h: 


*40 


unsigned short int in struct Custom 
hardware/custom.h: *98 


array [2] of unsigned short int in struct 


hardware/custom.h: *101 


array [2] of unsigned short int in struct 


hardware/custom.h: *103 
array [255] of char in struct CIA 


hardware/cia.h: 


*42 


#define 4 =0x00000004 
unsigned short int in 
intuition/preferences. 
unsigned short int in 


intuition/preferences 


unsigned short int in 
intuition/preferences. 


tdefine "parallel.device" devices/parallel.h: *80 
tdefine 0x00 =0x00000000 intuition/preferences.h: *135 


struct. 


struct 


struct 


struct 


graphics/gfxbase.h: 
struct Preferences 


h: *97 


struct Preferences 


wh: *96 


struct Preferences 


h: *98 


Custom 


Custom 


Custom 


Custom 


Custom 


Custom 


*70 


#define 1 =0x00000001 devices/parallel.h: *60 
#define 3 =0x00000003 devices/parallel.h: 
#define 5 =0x00000005 devices/parallel.h: 


pointer to struct Window in struct Window 


intuition/intuition.h: *742 


#define 2 =0x00000002 
#define 1 =0x00000001 
#define 7 =0x00000007 
#tdefine 3 =0x00000003 
tdefine 4 =0x00000004 
#tdefine 5 =0x00000005 
#tdefine 6 =0x00000006 


devices/parallel. 
devices/parallel. 
devices/parallel. 
devices/parallel. 
devices/parallel. 
devices/parallel. 
devices/parallel. 
tdefine (1<<1) =0x00000002 devices/parallel.h: *61 
#define (1<<3) =0x00000008 devices/parallel.h: *59 
#define (1<<5) =0x00000020 devices/parallel.h: *57 





PEPER SE 


*58 
*56 


*86 
*85 
*O1 
*87 
*88 
*89 
*90 


PartitionBlock 
size 0x0100 
PA_IGNORE 
PA_SIGNAL 
PA_SOFTINT 
PBFB_ BOOTABLE 
PBFB_NOMOUNT 
PBFF_BOOTABLE 
PBFF_NOMOUNT 
pb_CchksSum 
+0x0008 
pb_DevFlags 
+0x0020 
pb_DriveName 
+0x0024 
pb_Environment 
+0x0080 
pb_EReserved 
+0x00c4 
pb_Flags 
+0x0014 
pb HostID 
+0x000c 





pb_ID 

+0x0000 
pb_Next 

+0x0010 
pb_Reservedl 

+0x0018 
pb_Reserved2 

+0x0044 
pb_SummedLongs 

+0x0004 
PCC_4COLOR 
PCC_ADDITIVE 
PCC_BGR 
PCC_BGRW 
PCC_BGR_WB 
PCC_BW 
PCC_MULTI_PASS 
PCC_WB 
PCC_YMC 












PDCMD_QUERY 
PDCMD_SETPARAMS 


PDERR_CANCEL 


PDERR_INVERTHAM 
PDERR_NOERR 


| Device 
+0x0000 
pd_ Flags 
+0x09b6 
pd_iorO 
+0x006c 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 60 


structure tag 

devices/hardblocks.h: *126 

define 2 =0x00000002 exec/ports.h: *42 

#define 0 =0x00000000 exec/ports.h: *40 

#define 1 =0x00000001 exec/ports.h: *41 

#define 0 =0x00000000 devices/hardblocks.h: *144 
tdefine 1 =0x00000001 devices/hardblocks.h: *146 
#define 1L devices/hardblocks.h: *145 

#define 2L devices/hardblocks.h: *147 

int in struct PartitionBlock 

devices/hardblocks.h: *129 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *134 

array [32] of char in struct PartitionBlock 
devices/hardblocks.h: *135 

array {17] of unsigned int in struct PartitionBlock 
devices/hardblocks.h: *138 

array [15] of unsigned int in struct PartitionBlock 
devices/hardblocks.h: *139 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *132 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *130 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *127 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *131 

array [2] of unsigned int in struct PartitionBlock 
devices/hardblocks.h: *133 

array [15] of unsigned int in struct PartitionBlock 
devices/hardblocks.h: *137 

unsigned int in struct PartitionBlock 
devices/hardblocks.h: *128 


#define 0x04 =0x00000004 devices/prtbase.h: *111 
tdefine 0x08 =0x00000008 devices/prtbase.h: *112 
tdefine 0x0A =0x0000000a devices/prtbase.h: *114 
#define 0x0C =0x0000000c devices/prtbase.h: *116 
#define Ox0B =0x0000000b devices/prtbase.h: *115 
tdefine 0x01 =0x00000001 devices/prtbase.h: *107 
#define 0x10 =0x00000010 devices/prtbase.h: *124 
#define 0x09 =0x00000009 devices/prtbase.h: *113 
#define 0x02 =0x00000002 devices/prtbase.h: *108 
tdefine 0x04 =0x00000004 devices/prtbase.h: *110 
tdefine 0x03 =0x00000003 devices/prtbase.h: *109 


#tdefine 3 =0x00000003 devices/prtgfx.h: *16 

#define PCMYELLOW =0x00000000 devices/prtgfix.h: *17 
#define 2 =0x00000002 devices/prtgfx.h: *15 

#define PCMMAGENTA =0x00000001 devices/prtgfx.h: *18 
#define 1 =0x00000001 devices/prtgfx.h: *14 

define PCMCYAN =0x00000002 devices/prtgfx.h: *19 

#aefine PCMBLACK =0x00000003 devices/prtgfx.h: *20 
#define 0 =0x00000000 devices/prtgfx.h: *13 

#define (CMD _NONSTD) =0x00000009 devices/parallel.h: *82 
#define (CMD_NONSTD+1) =0x0000000a devices/parallel.h: *83 


PDERR_BADDIMENSION #define 4 =0x00000004 devices/printer.h: *201 
PDERR_BUFFERMEMORY #define 7 =0x00000007 devices/printer.h: *204 


#define 1 =0x00000001 devices/printer.h: *198 


PDERR_DIMENSIONOVELOW #define 5 =0x00000005 devices/printer.h: *202 
PDERR INTERNALMEMORY #define 6 =0x00000006 devices/printer.h: *203 


#define 3 =0x00000003 devices/printer.h: *200 
#define 0 =0x00000000 devices/printer.h: *197 


PDERR_NOTGRAPHICS #define 2 =0x00000002 devices/printer.h: *199 
PDERR_TOOKCONTROL #define 8 =0x00000008 devices/printer.h: *212 


struct DeviceData (size 0x0034) in struct PrinterData 
devices/prtbase.h: *60 

char in struct PrinterData 

devices/prtbase.h: *89 

union (no tag) (size 0x0052) in struct PrinterData 
devices/prtbase.h: *72 


LE — H 











Sep 21 13:06 1988 C_Language_Cross-Reference Page 61 


pd_iorl 
+0x00be 
pd_IORPort 
+0x0138 


+0x0000 


pd_pl 
+0x0000 
pd_pad 
+0x09b7 
pd_PBothReady 
+0x0068 
| PIORO 
| PIOR1 
pd_Preferences 
+0x09b8 
pd_PrintBuf 
+0x0060 


union (no tag) (size 0x0052) in struct PrinterData 
devices/prtbase.h: *80 

struct MsgPort (size 0x0022) in struct PrinterData 
devices/prtbase.h: *86 

struct IOExtPar (size 0x003e) in union (no tag) 
devices/prtbase.h: *70 

struct IOExtPar (size 0x003e) in union (no tag) 
devices/prtbase.h: *78 

char in struct PrinterData 

devices/prtbase.h: *90 

pointer to function returning int in struct PrinterData 


devices/prtbase.h: *68 
#define pd_ior0.pd_p0 devices/prtbase.h: *74 
#define pd_iorl.pd_pl devices/prtbase. h: *82 


struct Preferences (size 0x00e8) in struct PrinterData 
devices/prtbase.h: *91 

pointer to char in struct PrinterData 
devices/prtbase.h: *66 


pd_PrinterSegment int in struct PrinterData 


+0x0056 
pd_PrinterType 

+0x005a 
pd_PWaitEnabled 

+0x0aa0 
pd_PWrite 

+0x0064 
pd_so 


pd_sl 

+0x0000 
pd_SegmentData 

+0x005¢ 
pd_SIORO 
pd_SIOR1 
pd_stk 

+0x01b6 


+0x0000 


pd_Tc 

+0x015a 
pd_TIOR 

+0x0110 
pd_Unit 

+0x0034 
ped_8BitChars 

+0x0036 
ped_Close 

+0x0010 
ped_ColorClass 

+0x0015 
ped_Commands 


+0x0026 
ped_ConvFune 
+0x003e 
ped_DoSpecial 
+0x002a 
ped_Expunge 
+0x0008 
ped_Init 
+0x0004 
ped_MaxColumns 
+0x0016 
ped_MaxxDots 
+0x001a 
ped_MaxYDots 
+0x001le 
ped_NumCharSets 
+0x0017 
ped_NumRows 
+0x0018 








devices/prtbase.h: *62 
unsigned short int in struct PrinterData 
devices/prtbase.h: *63 

char in struct PrinterData 

devices/prtbase.h: *92 

pointer to function returning int in struct PrinterData 
devices/prtbase.h: *67 

struct IOExtSer (size 0x0052) in union (no tag) 
devices/prtbase.h: *71 

struct IOExtSer (size 0x0052) in union (no tag) 
devices/prtbase.h: *79 

pointer to struct PrinterSegment in struct PrinterData 
devices/prtbase.h: *65 

#define pd_ior0.pd_s0 devices/prtbase.h: *75 

#define pd_iorl.pd_sl devices/prtbase.h: *83 

array [2048] of char in struct PrinterData 

devices/prtbase.h: *88 

struct Task (size 0x005c) in struct PrinterData 
devices/prtbase.h: *87 

struct timerequest (size 0x0028) in struct PrinterData 
devices/prtbase.h: *85 

struct MsgPort (size 0x0022) ‘in struct PrinterData 
devices/prtbase.h: *61 

pointer to pointer to char in struct PrinterExtendedData 
devices/prtbase.h: *146 

pointer to function returning void in struct PrinterExtendedData 
devices/prtbase. h: *131 

char in struct PrinterExtendedData 

devices/prtbase.h: *133 

pointer to pointer to pointer to char in struct 
PrinterExtendedData 

devices/prtbase.h: *141 

pointer to function returning int in struct PrinterfxtendedData 
devices/prtbase.h: *150 

pointer to function returning int in struct PrinterExtendedData 
devices/prtbase.h: *142 

pointer to function returning void in struct PrinterExtendedData 
devices/prtbase.h: *129 

pointer to function returning void. in struct PrinterExtendedData 
devices/prtbase.h: *128 

char in struct PrinterExtendedData 

devices/prtbase.h: *134 

unsigned int in struct PrinterExtendedData 

devices/prtbase.h: *137 

unsigned int in struct PrinterExtendedData 

devices/prtbase.h: *138 

char in struct PrinterExtendedData 

devices/prtbase.h: *135 

unsigned short. int in struct PrinterExtendedData 
devices/prtbase.h: *136 





















Sep 21 13:06 198 


ped_Open 
+0x000c 
ped_PrinterClass 
+0x0014 
ped_PrinterName 
+0x0000 
ped_PrintMode 
+0x003a 
ped_Render 
+0x002e 
ped_TimeoutSecs 
+0x0032 
ped_xDotsInch 
+0x0022 
ped_YDotsInch 
+0x0024 
PenHeight 
+0x0032 
PenWidth 
+0x0030 
PF2PRI 
PFA_FINE_SCROLL 
PFBA 





8 C_Language_Cross-Reference Page 62 


pointer to function returning int in struct PrinterExtendedData 
devices/prtbase. h: *130 

char in struct PrinterExtendedData 

devices/prtbase.h: *132 

pointer to char in struct PrinterExtendedData 
devices/prtbase.h: *127 

int in struct PrinterExtendedData 

devices/prtbase.h: *147 

pointer to function returning int in struct PrinterExtendedData 
devices/prtbase.h: *143 

int in struct PrinterExtendedData 

devices/prtbase.h: *144 

unsigned short int in struct PrinterExtendedData 
devices/prtbase.h: *139 

unsigned short int in struct PrinterExtendedData 
devices/prtbase.h: *140 

short int in struct RastPort 

graphics/rastport.h: *71 

short int in struct RastPort 

graphics/rastport.h: *70 


#define 0x40 =0x00000040 graphics/display.h: *18 
#define OxF =0x0000000f graphics/display.h: *25 
#define 0x40 =0x00000040 graphics/view.h: *58 


PFB_FINE SCROLL SHIFT #define 4 =0x00000004 graphics/display.h: *26 
PF_ACTION #define 3 =0x00000003 exec/ports.h: *38 
PF_FINE_SCROLL_ MASK #define OxF =0x0000000f graphics/display.h: *27 
PI #define ((float) 3.141592653589793) libraries/matht tp. h: *14 
PI2 #define (PI / ((float) 2)) libraries/mathffp.h: *17 
PI2 #define (PI/{(double)2)) libraries/mathieeedp.h: *18 
PI4 #define (PI / ((float) 4)) libraries/mathffp.h: *18 
PI4 #define (PI/((double)4)) libraries/mathieeedp. h: *19 
PICA #define 0x000 =0x00000000 intuition/preferences.h: *153 
pitch unsigned short int in struct narrator_rb 

+0x0032 devices/narrator.h: *70 
PIXEL_DIMENSIONS #define 0x0040 =0x00000040 intuition/preferences.h: *244 
pi_ColorInt pointer to union colorEntry in struct PrtInfo 

+0x0018 devices/prtgfix.h: *32 
pi_dmatrix pointer to char in struct Prtinfo 

+0x0030 devices/prtgfx.h: *38 
pi_Scalex ‘pointer to unsigned short int in struct PrtInfo 

+0x0028 devices/prtgfx.h: *36 
pi_height unsigned short int in struct PrtInfo 

+0x005a devices/prtgfx.h: *57 
pi_threshold unsigned short int in struct PrtInfo 

+0x006c devices/prtgfx.h: *64 
pi_width unsigned short int in struct PrtInfo 

+0x0058 devices/prtgfx.h: *56 
pi_xpos unsigned short int in struct PrtInfo 

+0x006a_ devices/prtgfx.h: *63 
PlaneOnoff char in struct Image 

+0x000£ intuition/intuition.h: *579 
Planeonofft char in struct VSprite 

+0x0039 graphics/gels.h: *130 
PlanePick char in struct Image 

+0x000e intuition/intuition.h: *579 
PlanePick char in struct VSprite 

+0x0038 graphics/gels.h: *129 
PLANEPTR typedef pointer to "UBYTE" 

graphics/gfx.h: *34, 43 

Planes array [8] of pointer to char in struct BitMap 

+0x0008 graphics/gfx.h: *43 
PLNCNIMSK #define 0x7 =0x00000007 graphics/display.h: *15 
PLNCNT'SHFT #define 12 =0x0000000c graphics/display.h: *17 
PMB _ASM #define (M_LNM+1) =0x00000015 devices/conunit.h: *29, 77 
PMB_AWM #define (PMB _ASM+1) =0x00000016 devices/conunit.h: *30, 77 
Point typedef struct tPoint (size 0x0004) 

graphics/gfx.h: *32 

Pointer pointer to unsigned short int in struct Window 

+0x004a intuition/intuition.h: *747 





| 































8€ -—H 





Sep 21 13:06 1988 C_Language_Cross~Reference Page 63 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 64 





PointerMatrix array [36] of unsigned short int in struct Preferences PrinterType unsigned short int in struct Preferences 
+0x001lc intuition/preferences.h: *59 4+0x007e intuition/preferences.h: *81 
POINTERSIZE #define (1 + 16 + 1) * 2 =0x00000024 PrintFlags unsigned short int in struct Preferences 
intuition/preferences.h: *28, 59 +0x00da intuition/preferences.h: *115 
PointerTicks unsigned short int in struct Preferences PrintImage unsigned short int in struct Preferences 
+0x006c intuition/preferences.h: *65 +0x00a8 intuition/preferences.h: *90 
POINTREL #define 0x0001 =0x00000001 intuition/intuition.h: *174 PrintLeftMargin unsigned short int in struct Preferences 
Porthist struct List (size 0x000e) in struct ExecBase +0x00a4 intuition/preferences.h: *88 
+0x0188 exec/execbase.h: *82 PrintMaxHeight unsigned short int in struct Preferences 
pos unsigned short. int in struct SpriteDef +0x00de intuition/preferences.h: *117 
+0x0000 hardware/custom.h: *106 PrintMaxWidth unsigned short int in struct Preferences 
posctldata pointer to unsigned short int in struct SimpleSprite +0x00dce intuition/preferences.h: . *116 
+0x0000 graphics/sprite.h: *17 PrintPitch unsigned short int in struct Preferences 
pot0dat unsigned short int in struct Custom +0x009e intuition/preferences.h: *85 
+0x0012 hardware/custom.h: *29 PrintQuality unsigned short int in struct Preferences 
potldat unsigned short int in struct Custom +0x00a0 intuition/preferences.h: *86 
+0x0014 hardware/custom.h: *30 PrintRightMargin unsigned short int in struct Preferences 
potg unsigned short int in struct Custom +0x00a6 intuition/preferences.h: *89 
+0x0034 hardware/custom.h: *45 PrintShade unsigned short int in struct Preferences 
POTGONAME #tdefine “potgo.resource" resources/potgo.h: *13 +0x00ac intuition/preferences.h: *92 
potinp unsigned short int in struct Custom PrintSpacing unsigned short int in struct Preferences 
+0x0016 hardware/custom.h: *31 +0x00a2 intuition/preferences.h: *87 
pow Macro (2 arguments) libraries/mathffp.h: *44 PrintThreshold short int in struct Preferences 
pow Macro (2 arguments) libraries/mathieeedp.h: *45 +0x00ae intuition/preferences.h: *93 
PowerSupplyFrequency char in struct ExecBase Printxoffset char in struct Preferences 
+0x0213 exec/execbase.h: *105 +0x00el intuition/preferences.h: *119 
PPCB_COLOR #define 1 =0x00000001 devices/prtbase.h: *98 priority unsigned short int in struct Layer 
PPCB_GFX #define 0 =0x00000000 devices/prtbase.h: *96 +0x001lce graphics/clip.h: *32 
PPCF_COLOR #define 0x2 =0x00000002 devices/prtbase.h: *99 Process structure tag 
PPCF_GFX #define Oxl =0x00000001 devices/prtbase.h: *97 size 0x00bc libraries/dosextens.h: *34 
PPC_BWALPHA #define 0x00 =0x00000000 devices/prtbase.h: *101 PROPBORDERLESS #define 0x0008 =0x00000008 intuition/intuition.h: *432 
PPC_BWGFX #define 0x01 =0x00000001 devices/prtbase.h: *102 PROPGADGET #define 0x0003 =0x00000003 intuition/intuition.h: *350 
PPC_COLORALPHA  #define 0x02 =0x00000002 devices/prtbase.h: *103 PropInfo structure tag 
PPC_COLORGFX #define 0x03 =0x00000003 devices/prtbase.h: *104 size 0x0016 intuition/intuition.h: *384 
PRD_DUMPRPORT #define (CMD_NONSTD+2) =0x0000000b devices/printer.h: *27 PrtInfo structure tag 
PRD_PRTCOMMAND #define (CMD_NONSTD+1) =0x0000000a devices/printer.h: *26 size 0x0072 devices/prtgfx.h: *28 
PRD_QUERY #define (CMD_NONSTD+3) =0x0000000c devices/printer.h: *28 pr_CIs int in struct Process 
PRD_RAWWRITE #define (CMD _NONSTD+0) =0x00000009 devices/printer.h: *25 +0x009e Jibraries/dosextens.h: *45 
PREDRAWN #define 0x0002 =0x00000002 intuition/intuition.h: *175 pr_CLI int in struct Process 
Preferences structure tag 4+0x00ac libraries/dosextens.h: *49 
size 0x00e8 intuition/preferences.h: *42 pr_ConsoleTask pointer to pointer to char in struct Process 
devices/prtbase.h: 91 +0x00a4 libraries/dosextens.h: *47 
prev pointer to struct ClipRect in struct ClipRect pr_cos int in struct Process 
+0x0004 graphics/clip.h: *57 +0x00a0 libraries/dosextens.h: *46 
Pre pointer to struct RegionRectangle in struct RegionRectangle pr_CurrentDir int in struct Process 
+0x0004 graphics/regions.h: *19 +0x0098 libraries/dosextens.h: *44 
PrevComp pointer to struct AnimComp in struct. AnimComp pr_FileSystemTask pointer to pointer to char in struct Process 
+0x000a graphics/gels.h: *183 +0x00a8 libraries/dosextens.h: *48 
PrevOb pointer to struct AnimOb in struct AnimOb pr_GlobVec pointer to pointer to char in struct Process 
+0x0004 graphics/gels.h: *202 +0x0088 libraries/dosextens.h: *40 
PrevSeq pointer to struct AnimComp in struct AnimComp pr_MsgPort struct MsgPort (size 0x0022) in struct Process 
+0x0012 graphics/gels.h: *187 +0x005e libraries/dosextens.h: *36 
Prevvsprite pointer to struct VSprite in struct vSprite pr_Pad short int in struct Process 
+0x0004 graphics/gels.h: *73 +0x007e libraries/dosextens.h: *37 
PRIMARY_CLIP #define 0 =0x00000000 devices/clipboard.h: *51 pr_PktWait pointer to pointer to char in struct Process 
PrintAspect unsigned short int in struct Preferences +0x00b4 libraries/dosextens.h: *51 
+0x00aa intuition/preferences.h: *91 pr_Result2 int in struct Process 
PrintDensity char in struct Preferences +0x0094 libraries/dosextens.h: *43 
+0x00e0 intuition/preferences.h: *118 pr_ReturnAddr pointer to pointer to char in struct Process 
PrinterData structure tag in struct PrinterData +0x00b0 libraries/dosextens.h: *50 
size Ox0aal devices/prtbase.h: *59 pr_SegList int in struct Process 
PrinterExtendedData structure tag -+40x0080 libraries/dosextens.h: *38 
size 0x0042 devices/prtbase.h: *126, 158 pr_StackBase int in struct Process 
PrinterFilename array [30] of char in struct Preferences +0x0090 lLibraries/dosextens.h: *42 
+0x0080 intuition/preferences.h: *82 pr_StackSize int in struct Process 
PrinterPort char in struct Preferences +0x0084 libraries/dosextens.h: *39 
+0x0001 intuition/preferences.h: *48 pr_Task struct Task (size 0x005c) in struct Process 
PrinterSegment structure tag +0x0000 libraries/dosextens.h: *35 
size 0x004e devices/prtbase.h: 65, *153 pr_TaskNum int in struct Process 








6€ - H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 65 


+0x008c 


P_SAFESIZE 
P_STKSIZE 


size 0x000c 
RasInfo 
+0x0024 


+0x0054 


+0x0030 
RAWKEY 
RDBFB_CTRLRID 
RDBFB_DISKID 
RDBFB_LAST 
RDBFB_LASTLUN 
RDBFB_LASTTID 
RDBFB_NORESELECT 
RDBFF_CTRLRID 
RDBFF_DISKID 
RDBFF_LAST 
RDBFF_LASTLUN 
RDBFF_LASTTID 
RDBFF_NORESELECT 


libraries/dosextens.h: *41 

pointer to pointer to char in struct Process 
libraries/dosextens.h: *52 

unsigned int in struct PrinterSegment 
devices/prtbase.h: *154 

struct PrinterExtendedData (size 0x0042) in struct 
PrinterSegment 

devices/prtbase.h: *158 

unsigned short int in struct PrinterSegment 
devices/prtbase.h: *157 

unsigned int in struct PrinterSegment 
devices/prtbase.h: *155 

unsigned short int in struct PrinterSegment 
devices/prtbase.h: *156 

unsigned int in struct IOPArray 

devices/parallel.h: *18 

unsigned int in struct IOPArray 

devices/parallel.h: *19 

char in struct Window 

intuition/intuition.h: *748 

char in struct Window 

intuition/intuition.h: *749 

extern function returning "LONG" workbench/icon.h: *30 
extern function returning "LONG" workbench/icon.h: *30 
#tdefine 256 =0x00000100 devices/prtbase.h: *56 

#define 128 =0x00000080 devices/prtbase.h: . *57 

#define 0x0800 =0x00000800 devices/prtbase.h: *55, 88 
unsigned short int in struct IntuiMessage 
intuition/intuition.h: *609 

unsigned short int in struct ExecBase 

exec/execbase.h: *58 

#define Ox0A =0x0000000a intuition/preferences.h: *196 
structure tag 

graphics/view.h: 44, *69, 71 

pointer to struct RasInfo in struct ViewPort 
graphics/view.h:. *44 

pointer to char in struct TmpRas 

graphics/rastport.h: *30 

Macro (2 arguments) graphics/gfx.h: *46 

structure tag 

devices/printer.h: 157 

graphics/clip.h: 29 

graphics/rastport.h: *50 

intuition/intuition.h: 718, 731 

intuition/screens.h: 63 

devices/prtgfx.h: 30, 31 

struct RastPort (size 0x0064) in struct Screen 
intuition/sereens.h: *63 

unsigned short int in struct narrator_rb 
devices/narrator.h: *69 

#define 0x00000400 =0x00000400 intuition/intuition.h: *648 
#define 5 =0x00000005 devices/hardblocks.h: *103 
#define 4 =0x00000004 devices/hardblocks.h: *101 
#define 0 =0x00000000 devices/hardblocks.h: *93 
#define 1 =0x00000001 devices/hardblocks.h: *95 
#define 2 =0x00000002 devices/hardblocks.h: *97 
#define 3 =0x00000003 devices/hardblocks.h: *99 
#define 0x20L devices/hardblocks.h: *104 

#tdefine Oxl0L devices/hardblocks.h: *102 
#define 0x01L devices/hardblocks.h: *94 
#tdefine 0x02L devices/hardblocks.h: *96 
#define 0x04L devices/hardblocks.h: *98 
tdefine Ox08L devices/hardblocks.h: *100 


rdb_AutoParkSeconds unsigned int in struct RigidDiskBlock 


+0x0094 
rdb_BadBlockList 

+0x0018 
rdb_BlockBytes 

+0x0010 


devices/hardblocks.h: *77 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *54 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *51 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 66 


rdb_ChksSum int in struct RigidDiskBlock 
+0x0008 devices/hardblocks.h: *49 
rdb_ControllerProduct array [16] of char in struct RigidDiskBlock 
+0x00c4 devices/hardblocks.h: *84 
rdb_ControllerRevision array [4] of char in struct RigidDiskBlock 
+0x00d4  devices/hardblocks.h: *85 
rdb_ControllerVendor array [8] of char in struct RigidDiskBlock 
+0x00be devices/hardblocks.h: *83 
rdb_CylBlocks unsigned int in struct RigidDiskBlock 
+0x0090 devices/hardblocks.h: *76 
rdb_Cylinders unsigned int in struct RigidDiskBlock 
+0x0040 devices/hardblocks.h: *61 
rdb_DiskProduct array [16] of char in struct RigidDiskBlock 
+0x00a8 devices/hardblocks.h: *81 
rdb_DiskRevision array [4] of char in struct RigidDiskBlock 
+0x00b8 devices/hardblocks.h: *82 
rdb_DiskVendor array [8] of char in struct RigidDiskBlock 
+0x00a0 devices/hardblocks. h: *80 
rdb_DriveInit unsigned int in struct RigidDiskBlock 
+0x0024 devices/hardblocks.h: *57 
rdb_FileSysHeaderList unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *56 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *52 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *63 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *75 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *50 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *47 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *64 
RDB_LOCATION_LIMIT #define 16 =0x00000010 devices/hardblocks.h: *91 
rdb _LoCylinder , unsigned int in struct RigidDiskBlock 
+0x0088 devices/hardblocks.h: *74 
rdb_Park unsigned int in struct RigidDiskBlock 
+0x0050 devices/hardblocks.h: *65 
rdb_PartitionList unsigned int in struct RigidDiskBlock 
+0x001le devices/hardblocks.h: *55 
rdb_RDBBlocksHi unsigned int in struct RigidDiskBlock 
+0x0084 devices/hardblocks.h: *73 
rdb_RDBBlocksLo unsigned int in struct RigidDiskBlock 
+0x0080 devices/hardblocks.h: *72 
rdb_ReducedWrite unsigned int in struct RigidDiskBlock 
+0x0064 devices/hardblocks.h: *68 
rdb_Reservedl array {6] of unsigned int in struct RigidDiskBlock 
+0x0028 devices/hardblocks.h: *59 
rdb_Reserved2 array [3] of unsigned int in struct RigidDiskBlock 
+0x0054 devices/hardblocks.h: *66 
rdb_Reserved3 array [5] of unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *70 : 
array [2] of unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *78 
array [10] of unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *86 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *62 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *69 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *48 
unsigned int in struct RigidDiskBlock 
devices/hardblocks.h: *67 
#tdefine 0x00000000 =0x00000000 intuition/intuition.h: *987 
structure tag 
size 0x0008 graphics/gfx.h: *23 
graphics/clip.h: 30, 60 





Ov —H 


Sep 21 13:06 1988 C_Language_Cross~-Reference Page 67 


refptr 
+0x0028 
REFRESHBITS 
REFRESHWINDOW 
Region 
size 0x000c 


graphics/regions.h: 20, 25 

unsigned short int in struct Custom 

hardware/custom.h: *39 

#define 0x00CO =0x000000c0 intuition/intuition.h: *808 
#define 0x00000004 =0x00000004 intuition/intuition.h: *640 
structure tag 

graphics/clip.h: 46, 47, 50 

graphics/regions.h: *23 


Sep 2] 13:06 1988 C_Language_Cross-Reference Page 68 


4+0x0150 exec/execbase.h: *78 


RESOURCES_CIA_H 


#define =0x00000000 resources/cia.h: *2 


RESOURCES DISK_H #define =0x00000000 resources/disk.h: *2 
RESOURCES_FILESYSRES_H #define =0x00000000 resources/filesysres.h: *2 
RESOURCES MATHRESOURCE_H #define —0x00000000 resources/mathresource.h: *2 
RESOURCES MISC_H #define =0x00000000 resources/misc.h: *2 
RESOURCES_POTGO_H #define =0x00000000 resources/potgo.h: *2 


RETURN_ERROR 





#define 10 =0x0000000a libraries/dos.h: *169 


RegionRectangle structure tag RETURN_FAIL #define 20 =0x00000014 libraries/dos.h: *170 
size 0x0010 graphics/regions.h: *17, 19, 26 RETURN_OK #define 0 =0x00000000 libraries/dos.h: *167 
RegionRectangle pointer to struct RegionRectangle in struct Region RETURN_WARN #define 5 =0x00000005 libraries/dos.h: *168 
+0x0008 graphics/regions.h: *26 RIGHTBORDER #define 0x0010 =0x00000010 intuition/intuition.h: *31i1 
REGISTER #define register =0x00000000 exec/types.h: *16 RIGHTHIT #define 8 =0x00000008 graphics/collide.h: *33 
RelLeft short int in struct Requester rightmost short int in struct GelsInfo 
+0x000c =intuition/intuition.h: *147 +0x0018 graphics/rastport.h: *46 
RelTop short int in struct Requester RigidDiskBlock structure tag 
+0x000e intuition/intuition.h: *147 size 0x0100 devices/hardblocks.h: *46 
RELVERIFY #define 0x0001 =0x00000001 intuition/intuition.h: *283 RINGTRIGGER #define 0x0001 =0x00000001 graphics/gels.h: *42 
RemBob Macro (1 argument) graphics/gels.h: *247 RingXTrans short int in struct AnimOb 
Remember structure tag +0x00le graphics/gels.h: *216 
size 0x000c intuition/intuition.h: *928, 930 RingYTrans short int in struct AnimOb 
RememberSize unsigned int in struct Remember +0x00le graphics/gels.h: *216 
+0x0004 intuition/intuition.h: *931 RMBTRAP #define 0x00010000 =0x00010000 intuition/intuition.h: *830 
REPORTMOUSE #define 0x0200 =0x00000200 intuition/intuition.h: *816 rn_ConsoleSegment int in struct RootNode 
REQACTIVE tdefine 0x2000 =0x00002000 intuition/intuition.h: *181 +0x0004 libraries/dosextens.h: *179 
RegBorder pointer to struct Border in struct Requester m_FileHandlerSegment int in struct RootNode 
+0x0014. intuition/intuition.h: *150 +0x00lc libraries/dosextens.h: *183 
REQCLEAR #define 0x00001000 =0x00001000 intuition/intuition.h: *650 rn_Info int in struct RootNode 
ReqCount short int in struct Window +0x0018 libraries/dosextens.h: *182 
+0x002c intuition/intuition.h: *715 m_RestartSeg int in struct RootNode 
RegGadget pointer to struct Gadget in struct Requester +0x0014 libraries/dosextens.h: *181 
+0x0010. intuition/intuition.h: *149 rm_TaskArray int in struct RootNode 
REQGADGET #define 0x1000 =0x00001000 intuition/intuition.h: *337 +0x0000 libraries/dosextens.h: *176 
ReqLayer pointer to struct Layer in struct Requester rm_Time struct: DateStamp (size 0x000c) in struct RootNode 
+0x0020 intuition/intuition.h: *157 +0x0008 libraries/dosextens.h: *180 
REQOFFWINDOW #define 0x1000 =0x00001000 intuition/intuition.h: *180 ROBOTICFO #define 1 =0x00000001 devices/narrator.h: *46 
RegPadl array [32] of char in struct Requester RomBootBase structure tag 
+0x0024 intuition/intuition.h: *159 size 0x0044 libraries/romboot_base.h: *32 
RegPad2 array [36] of char in struct Requester ROMBOOT_NAME #define "romboot.library" libraries/romboot_base.h: *47 
+0x004c intuition/intuition.h: *169 RootNode structure tag 
REQSET #define 0x00000080 =0x00000080 intuition/intuition.h: *645 size 0x0020 libraries/dosextens.h: *175 
ReqText pointer to struct IntuiText in struct Requester round Maero (1 argument) libraries/mathffp.h: *30 
+0x0018 intuition/intuition.h: *151 round Macro (1 argument) libraries/mathieeedp.h: *31 
Requester structure tag Rows unsigned short int in struct BitMap 
size 0x0070 intuition/intuition.h: *141, 144, 711, 713 +0x0002 graphics/gfx.h: *39 
REQVERIFY #define 0x00000800 =0x00000800 intuition/intuition.h: *649 RowSizeChange char in struct Preferences 
reserved array [4] of char in struct Layer +0x00d8 intuition/preferences.h: *112 
+0x0018 graphics/clip.h: *31 rp pointer to struct RastPort in struct Layer 
reserved int in struct ClipRect +0x000c graphics/clip.h: *29 
+0x0020 graphics/clip.h: *62 RPort. pointer to struct RastPort in struct Window 
reserved char in struct ViewPort +0x0032 intuition/intuition.h: *718 
4+0x0023 graphics/view.h: *43 RP_User pointer to pointer to pointer to char in struct RastPort 
reserved array [8] of char in struct RastPort 4+0x0042 graphics/rastport.h: *79 
+0x005c graphics/rastport.h: *83 RTC_MATCHWORD #define Ox4AFC =0x00004afc exec/resident.h: *30 
Reserved unsigned int in struct BooliInfo RTF_AUTOINIT #define (1<<7) =0x00000080 exec/resident.h: *32 
+0x0006 intuition/intuition.h: *369 RTF_COLDSTART #tdefine (1<<0) =0x00000001 exec/resident.h: *33 
reserved array [23] of unsigned int in struct GfxBase RTM_WHEN #define 3 =0x00000003 exec/resident.h: *36 
4+0x00ec graphics/gfxbase.h: *65 RTW_COLDSTART #define 1 =0x00000001 exec/resident.h: *38 
Reserved array [4] of unsigned int in struct RomBootBase RTW_NEVER #define 0 =0x00000000 exec/resident.h: *37 
+0x0034 libraries/romboot_base.h: *37 rt_EndSkip pointer to pointer to char in struct Resident 
reserved2 array [22] of char in struct Layer +0x0006 exec/resident.h: *20 
+0x0086 graphics/clip.h: *48 rt_Flags char in struct Resident 
reserved3 array [8] of char in struct Layer +0x000a_ exec/resident.h: *21 
+0x0076 graphics/clip.h: *45 xrt_IdString pointer to char in struct Resident 
Resident structure tag +0x0012 exec/resident.h: *26 
size 0x00la exec/resident.h: *17, 19 rt_Init pointer to pointer to char in struct Resident 
ResModules pointer to pointer to char in struct ExecBase +0x0016 exec/resident.h: *27 
+0x012c exec/execbase.h: *66 rt_MatchTag pointer to struct Resident in struct Resident 
ResourceList struct List (size 0x000e) in struct ExecBase Pe +0x0002 exec/resident.h: *19 





Tb -H 






Sep 21 13:06 1988 C_Language_Cross~Reference Page 70 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 69 





















+0x0004 devices/scsidisk.h: *68 
sesi_Status char in struct SCSICmd 






























rt_MatchWord unsigned short int in struct Resident 
+0x0000 exec/resident . h: *18 





















































































































































































rt_Name pointer to char in struct Resident +0x0015 devices/scsidisk.h: *76 
+0x000e exec/resident.h: *25 SDCMD_BREAK #define (CMD_NONSTD+1) =0x0000000a devices/serial.h: *95 
rt_Pri char in struct Resident SDCMD_QUERY #define CMD_NONSTD =0x00000009 devices/serial.h: *94 
+0x000d exec/resident.h: *24 SDCMD_SETPARAMS #define (CMD_NONSTD+2) =0x0000000b devices/serial.h: *96 
_ char in struct Resident SDOWNBACK #define 0x0070 =0x00000070 intuition/intuition.h: *345 
+0x000c exec/resident.h: *23 SDRAGGING #define 0x0030 =0x00000030 intuition/intuition.h: *341 
rt_Version . char in struct Resident Seconds unsigned int in struct IntuiMessage 
+0x000b exec/resident.h: *22 +0x0024 intuition/intuition.h: *625 
RWindow pointer to struct Window in struct Requester Seconds unsigned int in struct IntuitionBase 
+0x0048 intuition/intuition.h: *168 +0x0048 intuition/intuitionbase.h: *163 
RxOffset short int in struct Rasinfo Seghist pointer to pointer to char in struct ExpansionBase 
+0x0008 graphics/view.h: *73 +0x0028 libraries/expansionbase.h: *49 
RyOffset short int in struct RasInfo SELECTDOWN #define (IECODE_LBUTTON) =0x00000068 
+0x000a_ graphics/view.h: *73 intuition/intuition.h: *1007 
sampfreq . unsigned short int in struct narrator_rb SELECTED #define 0x0080 =0x00000080 intuition/intuition.h: *269 
+0x0040 devices/narrator.h: *76 SelectFill pointer to pointer to char in struct MenuItem 
SatisfyMsg structure tag +0x0016 intuition/intuition.h: *99 
size 0x00la devices/clipboard.h: *53 SelectRender pointer to pointer to char in struct Gadget 
SAVEBACK #define 0x0002 =0x00000002 graphics/gels.h: *17 +0x0016 = intuition/intuition.h: *215 
SAVEBOB #define 0x0001 =0x00000001 graphics/gels.h: *29 SELECTUP #define (IECODE_LBUTTON | IECODE_UP_PREFIX) =0x000000e8 
SaveBuffer pointer to short int in struct Bob intuition/intuition.h: *1006 
+0x0002 graphics/gels.h: *144 Semaphore structure tag 
saveClipRects pointer to struct Region in struct Layer size 0x0024 exec/semaphores.h: *32 
+0x0082 graphics/clip.h: *47 SemaphoreList struct List (size 0x000e) in struct ExecBase 
SaveColor0 unsigned short int in struct Screen +0x0214 exec/execbase.h: *107 
+0x014c intuition/screens.h: *78 SemaphoreRequest structure tag 
SAVEPRESERVE #define 0x1000 =0x00001000 graphics/gels.h: *36 size 0x000c exec/semaphores-h: *43, 53 
SBUFSIZE_BITS #define 0x0F =0x0000000f intuition/preferences.h: *214 SERB_7WIRE #define 2 =0x00000002 devices/serial.h: *109 
SBUF_1024 #define 0x01 =0x00000001 intuition/preferences.h: *203 SERB_EOFMODE #define 6 =0x00000006 devices/serial.h: *101 
SBUF_16000 #define 0x05 =0x00000005 intuition/preferences.h: *207 SERB PARTY_ODD #define 1 =0x00000001 devices/serial.h: *111 
SBUF_2048 #define 0x02 =0x00000002 intuition/preferences.h: *204 SERB_PARTY_ON #define 0 =0x00000000 devices/serial.h: *113 
SBUF_4096 #define 0x03 =0x00000003 intuition/preferences.h: *205 SERB_QUEUEDBRK #define 3 =0x00000003 devices/serial.h: *107 
SBUF_512 #define 0x00 =0x00000000 intuition/preferences.h: *202 SERB_RAD BOOGIE #define 4 =0x00000004 devices/serial.h: *105 
SBUF_8000 #define 0x04 =0x00000004 intuition/preferences.h: *206 SERB_SHARED #tdefine 5 =0x00000005 devices/serial.h: *103 
Screen structure tag SERB_XDISABLED #define 7 =0x00000007 devices/serial.h: *99 
size 0x015a intuition/intuition.h: 717, 881 serdat unsigned short int in struct Custom 
intuition/screens.h: *40, 42 +0x0030 hardware/custom.h: *43 
intuition/intuitionbase.h: 153, 158 serdatr unsigned short int in struct Custom 
Screen pointer to struct Screen in struct NewWindow +0x0018 hardware/custom.h: *32 
+0x00le intuition/intuition.h: *881 SerErr BufErr #define 4 =0x00000004 devices/serial.h: *137 
SCREENBEHIND #define 0x0080 =0x00000080 intuition/screens.h: *106 SerErr_BufOverflow #define 12 =0x0000000c devices/serial.h: *142 
SCREENQUIET fdefine 0x0100 =0x00000100 intuition/sereens.h: *109 SerErr_ DetectedBreak #define 15 =0x0000000f devices/serial.h: *144 
ScreenTitle pointer to char in struct Window SerErr_DevBusy #define 1 =0x00000001 devices/serial.h: *136 
+0x0068 intuition/intuition.h: *765 SerErr_InvParam #define 5 =0x00000005 devices/serial.h: *138 
SCREENTYPE #define 0x000P =0x0000000f intuition/screens.h: *93 SerErr_LineErr #define 6 =0x00000006 devices/serial.h: *139 
SCRGADGET #define 0x4000 =0x00004000 intuition/intuition.h: *335 SerErr_NoDSR #define 13 =0x0000000d devices/serial.h: *143 
Scroll_X short int in struct Layer SerErr ParityErr #define 9 =0x00000009 devices/serial.h: *140 
+0x002c graphics/clip. h: *39 SerErr_TimerErr #define 11 =0x0000000b devices/serial.h: *141 
Scroll_Y short int in struct Layer SERF_7WIRE tdefine (1<<2) =0x00000004 devices/serial.h: *110 
+0x002e graphics/clip.h: *39 SERF_EOFMODE #define (1<<6) =0x00000040 devices/serial.h: *102 
scsicmd structure tag SERF_PARTY_ODD #define (1<<1) =0x00000002 devices/serial.h: *112 
size 0x0016 devices/scsidisk.h: *64 SERF_PARTY_ON #define (1<<0) =0x00000001 devices/serial.h: *114 
SCSIF_READ #define 1 =0x00000001 devices/scsidisk.h: *82 SERF_QUEUEDBRK #define (1<<3) =0x00000008 devices/serial.h: *108 
SCSIF_WRITE #define 0 =0x00000000 devices/scsidisk.h: *81 SERF_RAD BOOGIE #define (1<<4) =0x00000010 devices/serial.h: *106 
scsi_Actual unsigned int in struct ScSICcmd SERF_SHARED #define (1<<5) =0x00000020 devices/serial.h: *104 
+0x0008 devices/scsidisk.h: *71 SERF_XDISABLED #define (1<<7) =0x00000080 devices/serial.h: *100 
sesi_CmdActual unsigned short int in struct scsICcmd SERIALNAME #define "serial.device" devices/serial.h: *178 
+0x0012 devices/scsidisk.h: *74 SERIAL PRINTER #define 0x01 =0x00000001 intuition/preferences.h: *136 
scsi_CmdLength unsigned short int in struct scsIcmd SerParShk char in struct Preferences 
+0x0010 devices/scsidisk.h: *73 +0x00b8 intuition/preferences.h: *106 
scsi_Command pointer to char in struct Scsicmd serper unsigned short int in struct Custom 
+0x000c devices/scsidisk.h: *72 +0x0032 hardware/custom.h: *44 
scesi_Data pointer to unsigned short int in struct scsIcmd SerRWBits char in struct Preferences. 
+0x0000 devices/scsidisk.h: *65 +0x00b6 intuition/preferences.h: *102 
sesi_Plags char in struct SCcSICmd SerStopBuf char in struct Preferences 


+0x00b7 intuition/preferences.h: *104 


+0x0014 devices/scsidisk.h: *75 
SER_DEFAULT_CTLCHAR #define 0x11130000 =0x11130000 devices/serial.h: 


unsigned int in struct SCSICmd 





*27 
















































SetAfPt 
SetDrPt 
SetoPen 
SetWrMsk 
Sex 

+0x0036 
SEXTB_MARK 
SEXTB_MSPON 
SEXTF_MARK 
SEXTF_MSPON 
SF_ALERTWACK 
SGR_BLACK 
SGR_BLACKBG 
SGR_BLUE 
SGR_BLUEBG 
SGR_BOLD 
SGR_CLRO 


SGR_CLR3BG 
SGR_CLR4 


SGR_CLR7BG 
SGR_CYAN 
SGR_CYANBG 
SGR_DEFAULT 
SGR_DEFAULTBG 
SGR_GREEN 
SGR_GREENBG 
SGR_ITALIC 
SGR_MAGENTA 
SGR_MAGENTABG 
SGR_NEGATIVE 
SGR_PRIMARY 
SGR_RED 
SGR_REDBG 
SGR_UNDERSCORE 
SGR_WHITE 
SGR_WHITEBG 
SGR_YELLOW 
SGR_YELLOWBG 
SHADE BW 
SHADE_COLOR 
SHADE_GREYSCALE 
SHAKNUM 

sha 


cv - H 


+0x0048 
SHARED_LOCK 
SHFCprList 

+0x0008 


SHOWTITLE 
SHSHAKE NONE 
SHSHAKE RTS 


Macro (3 
Macro (2 
Macro (2 
Macro (2 
unsigned 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 71 


arguments) graphics/gfxmacros.h: *28 
arguments) graphics/gfxmacros.h: *26 
arguments) graphics/gfxmacros.h: *25 
arguments) graphics/gfxmacros.h: *27 
short int in struct narrator_rb 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 72 


SHSHAKE_XON 
sh_List 

+0x0000 
sh_Pad 

+0x000e 


#define 0 =0x00000000 intuition/preferences.h: *229 
struct List (size 0x000e) in struct SoftIntList 
exec/interrupts.h: *37 . 
unsigned short int in. struct SoftiIntbist 
exec/interrupts.h: *38 


devices/narrator.h: *72 SIGBREAKB_CTRL_C #define 12 =0x0000000c libraries/dos.h: *173 

#define 0 =0x00000000 devices/serial.h: *132 SIGBREAKB_CTRL_D #define 13 =0x0000000d libraries/dos.h: *174 

tdefine 1 =0x00000001 devices/serial.h: *129 SIGBREAKB CTRL E #define 14 =0x0000000e libraries/dos.h: *175 

#define (1<<0) =0x00000001 devices/serial.h: *133 SIGBREAKB CTRL _F #define 15 =0x0000000f libraries/dos.h: *176 

#define (1<<1) =0x00000002 devices/serial.h: *131 SIGBREAKF_CTRL_C #define (1<<SIGBREAKB_CTRL C) =0x00001000 libraries/dos.h: *180 
#define (1¢<1) =0x00000002 exec/alerts.h: *13 SIGBREAKF CTRL D #define (1<<SIGBREAKB_CTRL_D) =0x00002000: libraries/dos.h: *181 
#define 30 =0x000000le devices/console.h: *33 SIGBREAKF_CTRL_E #define (1<<SIGBREAKB CTRL _E) =0x00004000 libraries/dos.h: *182 
#define 40 =0x00000028 devices/console.h: *43 SIGBREAKF CTRL F #define (1<<SIGBREAKB CTRL_F) =0x00008000 libraries/dos.h: *183 
#define 34 =0x00000022 devices/console.h: *37 SIGB_ABORT #define 0 =0x00000000 exec/tasks.h: *71 

#define 44 =0x0000002c devices/console.h: *47 SIGB_BLIT #define 4 =0x00000004 exec/tasks.h: *73 

#define 1 =0x00000001 devices/console.h: *27 SIGB_CHILD #define 1 =0x00000001 exec/tasks.h: *72 

define 30 =0x000000le devices/console.h: *55 SIGB_DOS #define 8 =0x00000008 exec/tasks.h: *75 

#define 40 =0x00000028 devices/console.h: *64 SIGB_SINGLE #define 4 =0x00000004 exec/tasks.h: *74 

#define 31 =0x0000001f devices/console.h: *56 SIGF_ ABORT #define (1<<0) =0x00000001 exec/tasks.h: *77 

#define 41 =0x00000029 devices/console.h: *65 SIGF_BLIT #define (1<<4) =0x00000010 exec/tasks.h: *79 

#tdefine 32 =0x00000020 devices/console.h: *57 SIGF_CHILD #define (1<<1) =0x00000002 exec/tasks.h: *78 

#define 42 =0x0000002a devices/console.h: *66 SIGF_DOS #define (1<<8) =0x00000100 exec/tasks.h: *81 

#define 33 =0x00000021 devices/console.h: *58 SIGF_SINGLE #define (1<<4) =0x00000010 exec/tasks.h: *80 

#define 43 =0x0000002b devices/console.h: *67 SIGN Macro (1 argument) intuition/intuition.h: *969 

#define 34 =0x00000022 devices/console.h: *59 SignalSemaphore structure tag 

#define 44 =0x0000002c devices/console.h: *68 size 0x002e exec/semaphores.h: *49 

#define 35 =0x00000023 devices/console.h: *60 graphics/clip.h: 44 

#define 45 =0x0000002d devices/console.h: *69 graphics/layers.h: 38 

#define 36 =0x00000024 devices/console.h: *61 graphics/gfxbase.h: 61 

#define 46 =0x0000002e devices/console.h: *70 libraries/expansionbase.h: 54 

#define 37 =0x00000025 devices/console.h: *62 SIGNFLAG #define 0x40 =0x00000040 hardware/blit.h: *63 

#tdefine 47 =0x0000002f devices/console.h: *71 SIH_PRIMASK #define (Oxf0) =0x000000f0 exec/interrupts.h: *41 

#define 36 =0x00000024 devices/console.h: *39 SimpleSprite structure tag 

#define 46 =0x0000002e devices/console.h: *49 size 0x000c graphics/gfxbase.h: 53 

#define 39 =0x00000027 devices/console.h: *41 graphics/sprite.h: *15 

#define 49 =0x00000031 devices/console.h: *51 SimpleSprites pointer to pointer to struct SimpleSprite in struct GfxBase 
#define 32 =0x00000020 devices/console.h: *35 +0x00d0 graphics/gfixbase.h: *53 

tdefine 42 =0x0000002a devices/console.h: *45 SIMPLE REFRESH #define 0x0040 =0x00000040 intuition/intuition.h: *810 
#define 3 =0x00000003 devices/console.h: *28 sin #define SPSin =0x00000000 libraries/mathffp.h: *41 

#tdefine 35 =0x00000023 devices/console.h: *38 sin tdefine IEEEDPSin =0x00000000 libraries/mathieeedp.h: *42 
#define 45 =0x0000002d devices/console.h: *48 SINGLE #define 0x80 =0x00000080 intuition/preferences.h: *150 
#tdefine 7 =0x00000007 devices/console.h: *30 sinh #define SPSinh =0x00000000 libraries/mathffp.h: *49 
#define 0 =0x00000000 devices/console.h: *26 sinh #define IEEEDPSinh =0x00000000 libraries/mathieeedp.h: *50 
#define 31 =0x0000001f devices/console.h: *34 SIX_LPI #define 0x000 =0x00000000 intuition/preferences.h: *162 
#define 41 =0x00000029 devices/console.h: *44 Size int in struct TmpRas 

#define 4 =0x00000004 devices/console.h: *29 +0x0004 graphics/rastport.h: *31 

#define 37 =0x00000025 devices/console.h: *40 SIZEBBOTTOM #define 0x0020 =0x00000020 intuition/intuition.h: *804 
#define 47 =0x0000002f devices/console.h: *50 SIZEBRIGHT #define 0x0010 =0x00000010 intuition/intuition.h: *803 
#define 33 =0x00000021 devices/console.h: *36 SIZEVERIFY #define 0x00000001 =0x00000001 intuition/intuition.h: *638 
#define 43 =0x0000002b devices/console.h: *46 SIZING #define 0x0010 =0x00000010 intuition/intuition.h: *339 
#define 0x00 =0x00000000 intuition/preferences.h: *174 SMART _REFRESH #define 0x0000 =0x00000000 intuition/intuition.h: *809 
#define 0x02 =0x00000002 intuition/preferences.h: *176 sm_ArgList pointer to struct WBArg in struct WBStartup 

#define 0x01 =0x00000001 intuition/preferences.h: *175 +0x0024 workbench/startup.h: *31 

Macro (1 argument) intuition/intuition.h: *957 sm_Bids short int in struct Semaphore 

char in struct mouth_rb +0x0022 exec/semaphores.h: *34 

devices/narrator.h: *91 sm_ClipID int in struct SatisfyMsg 

#tdefine -2 =Oxfffffffe libraries/dos.h: *44 +0x0016 devices/clipboard.h: *56 

pointer to struct cprlist in struct View sm_LockMsg #tdefine mp_SigTask =0x00000000 exec/semaphores.h: *37 
graphics/view.h: *51 sm_Message struct Message (size 0x0014) in struct WBStartup 

pointer to unsigned short int in struct GfixBase +0x0000 workbench/startup.h: *26 

graphics/gfxbase.h: *31 sm_Ms struct Message (size 0x0014) in struct SatisfyMsg 

Macro (1 argument) intuition/intuition.h: *949 +0x0000 devices/clipboard.h: *54 

Macro (1 argument) intuition/intuition.h: *948 sm_MsgPort struct MsgPort (size 0x0022) in struct Semaphore 

Macro (1 argument) intuition/intuition.h: *950 +0x0000 exec/semaphores.h: *33 

typedef short int sm_NumArgs int in struct WBStartup 

many references; defined in exec/types.h: *38 +0x00le workbench/startup.h: *29 

#define 0x0010 =0x00000010 intuition/screens.h: *98 sm_Process pointer to struct MsgPort in struct WBStartup 

#tdefine 2 =0x00000002 intuition/preferences.h: *231 +0x0014 workbench/startup.h: *27 

#define 1 =0x00000001 intuition/preferences.h: *230 sm_ Segment int in struct WBStartup 











Sep 21 13:06 1988 C_Language_Cross-Reference Page 73 


+0x0018 
sm_ToolWindow 
+0x0020 
sm_Unit 
+0x0014 
SoftIntList 
size 0x0010 


SoftInts 


+0x01b2 
SoftVer 
+0x0022 
SPAbs 
SPAcos 
SPAdd 
SPARITY_ BITS 
SPARITY_EVEN 
SPARITY_NONE 
SPARITY_ODD 
SPARNUM 
SPAsin 
SPAtan 
SsPCeil 
SPCmp 
SPCos 
SPCosh 
SPDiv 
SpecialInfo 
+0x0022 
SpecialLink 
+0x0030 
SPECIAL ASPECT 
SPECIAL CENTER 
SPECIAL _DENSITY1 
SPECIAL DENSITY2 
SPECIAL DENSITY3 
SPECIAL DENSITY4 
SPECIAL_DENSITY5 
SPECIAL DENSITY6 
SPECIAL 3 , DENSITY7 


SPECIAL DENSITYMASK #define 0x0700.=0x00000700 devices/printer.h: 


workbench/startup.h: *28 

pointer to char in struct WBStartup 

workbench/startup.h: *30 

unsigned. short int in struct SatisfyMsg 
devices/clipboard.h: *55 

structure tag 

exec/interrupts.h: *36 

exec/execbase.h: 86 

array [5] of struct SoftIntList (size 0x0010) in struct 
ExecBase 

exec/execbase.h: *86 

unsigned short int in struct ExecBase 

exec/execbase.h: *33 

extern function returning float libraries/mathffp.h: *58 
extern function returning float libraries/mathffp.h: *70 
extern function returning float libraries/mathffp.h: *65 
#define OxFO =0x000000f0 intuition/preferences. h: *221 


#define 1 =0x00000001 intuition/preferences. h: *223 
#define 0 =0x00000000 intuition/preferences.h: *222 
#define 2 =0x00000002 intuition/preferences.h: *224 


Macro (1 argument) intuition/intuition.h: *956 

extern function returning float libraries/mathffp.h: *70 
extern function returning float libraries/mathffp.h: *70 
extern function returning float libraries/mathffp.h: *60 
extern function returning int libraries/mathffp.h: *56 
extern function returning float libraries/mathffp.h: *71 
extern function returning float libraries/mathffp.h: *72 
extern function returning float libraries/mathffp.h: *68 
pointer to pointer to char in struct Gadget 
intuition/intuition. h: *234 

pointer to struct IntuiMessage in struct IntuiMessage 
intuition/intuition.h: *633 


#define 0x0080 =0x00000080 devices/printer.h: *176 
#define 0x0040 =0x00000040 devices/printer.h: *175 
#define 0x0100 =0x00000100 devices/printer.h: *177 
#define 0x0200 =0x00000200 devices/printer.h: *178 
#define 0x0300 =0x00000300 devices/printer.h: *179 
#define 0x0400 =0x00000400 devices/printer.h: *180 
#define 0x0500 =0x00000500 devices/printer.h: *181 
#define 0x0600 =0x00000600 devices/printer.h: *182 
#define 0x0700 =0x00000700 devices/printer.h: *183 


*215 


SPECIAL_] DIMENSIONSMASK #define (SPECIAL | MILCOLS | SPECIAL , MILROWS | 


SPECIAL _FRACCOLS 
SPECIAL FRACROWS 
SPECIAL _FULLCOLS 
SPECIAL FULLROWS 
SPECIAL MILCOLS 
SPECIAL _MILROWS 


SPECIAL NOPRINT 


SPECIAL FULLCOLS | SPECIAL _FULLROWS | SPECIAL , FRACCOLS | 
SPECIAL | , FRACROWS | SPECIAL | 1 ASPECT) =0x000000bf 
devices/printer.h: *218 


#define 0x0010 =0x00000010 devices/printer.h: *173 
#define 0x0020 =0x00000020 devices/printer.h: *174 
#define 0x0004 =0x00000004 devices/printer.h: *171 
#define 0x0008 =0x00000008 devices/printer.h: *172 
#define 0x0001 =0x00000001 devices/printer.h: *169 
#define 0x0002 =0x00000002 devices/printer.h: *170 
SPECIAL NOFORMFEED #define 0x0800 =0x00000800 devices/printer.h: *184 
#define 0x2000._=0x00002000 devices/printer.h: *195 
#define 0x1000 =0x00001000 devices/printer.h: *185 


SPECIAL_TRUSTME 

SPExp 

SPFieee 

SPFix 

SPFloor 

SPFIt 

SPLog 

SPLOg1LO 

SPMul 

SPNeg 

SPPow 

spr 
+0x0140 

SprColors 
+0x0030 


extern function returning float libraries/mathffp.h: *73 
extern function returning float libraries/mathffp.h: *74 
extern function returning int libraries/mathffp.h: *54 
extern function returning float libraries/mathffp.h: *59 
extern function returning float libraries/mathffp.h: *55 
extern function returning float libraries/mathffp.h: *73 
extern function returning float libraries/mathffp.h: *73 
extern function returning float libraries/mathffp.h: *67 
extern function returning float libraries/mathffp.h: *64 
extern function returning float libraries/mathffp.h: *73 


array [8] of struct SpriteDef (size 0x0008) in struct Custom 


hardware/custom.h: *110 
pointer to short int in struct VSprite 
graphics/gels.h: *113 





Sep 21 13:06 1988 C_Language_Cross~Reference Page 74 


Sprins 
+0x000c 
SpriteDef 
size 0x0008 
SpritePriorities 
+0x0022 
SpriteReserved 
+0x00a6 
SPRITES 
SPRITE_ATTACHED 
sprpt 
+0x0120 
sprRsrvd 
+0x0000 
sprstop 
+0x0058 
sprstrtup 
+0x0008 
sPSin 
SPSincos 
sPSinh 
sPSqrt 
SPSub 
SPTan 
sPTanh 
SPTst 
sp_Msg 
+0x0000 
sp Pkt 
+0x0014 
sqrt 
sqrt 
SRBNUM 
SRCA 
SRCB 
SRCC 
SREAD_ BITS 
sr_Link 
+0x0000 
sr_ Waiter 
+0x0008 
SSBNUM 
SSTOP_BITS 
ss_Link 
+0x0000 
ss_MultipleLink 


+0x001c 
ss_NestCount 

+0x000e 
ss_ Owner 

+0x0028 
ss_QueueCount 

+0x002c 
ss_WaitQueue 

+0x0010 
StandardPacket 

size 0x0044 

start 

+0x0004 
stat 

+0x0008 
STATIC 
STDSCREENHEIGHT 
strequ 

+0x0038 
STRGADGET 
strhor 

+0x003¢ 


pointer to struct CopList in struct ViewPort 
graphics/view.h: *36 

structure tag in struct Custom 

hardware/custom.h: *105 

char in struct ViewPort 

graphics/view.h: *42 

char in struct GfxBase 

graphics/gfxbase.h: *42 

#define 0x4000 =0x00004000 graphics/view.h: *63 

#define 0x80 =0x00000080 graphics/sprite.h: *13 

array [8] of pointer to pointer to char in struct Custom 
hardware/custom.h: *104 

char in struct GelsInfo 

graphics/rastport .h: *37 

array {2] of unsigned short int in struct copinit 
graphics/copper.h: *80 

array [40] of unsigned short int in struct copinit 
graphics/copper.h: *79 

extern function returning float libraries/mathffp.h: *71 
extern function returning float libraries/mathffp.h: *71 
extern function returning float libraries/mathffp.h: *72 
extern function returning float libraries/mathffp.h: *74 
extern function returning float libraries/mathffp.h: *66 
extern function returning float libraries/mathffp.h: *71 
extern function returning float libraries/mathffp.h: *72 
extern function returning int libraries/mathffp.h: *57 
struct Message (size 0x0014) in struct StandardPacket 
libraries/dosextens.h: *111 

struct DosPacket (size 0x0030) in struct StandardPacket 
libraries/dosextens.h: *112 

#define SPSqrt =0x00000000 libraries/mathffp.h: *47 
#define IEEEDPSqrt =0x00000000 libraries/mathieeedp.h: *48 
Macro (1 argument) intuition/intuition.h: *953 

#define 0x800 =0x00000800 hardware/blit.h: *51 

#define 0x400 =0x00000400 hardware/blit.h: *50 

#define 0x200 =0x00000200 hardware/blit.h: *49 

#define OxFO =0x000000f0 intuition/preferences.h: *210 
struct MinNode (size 0x0008) in struct SemaphoreRequest 
exec/semaphores.h: *44 

pointer to struct Task in struct SemaphoreRequest 
exec/semaphores.h: *45 

Macro (1 argument) intuition/intuition.h: *955 

#define OxFO =0x000000f0 intuition/preferences.h: *213 
struct Node (size 0x000e) in struct SignalSemaphore 
exec/semaphores.h: *50 

struct SemaphoreRequest (size 0x000c) in struct 
SignalSemaphore 

exec/semaphores.h: *53 

short int in struct SignalSemaphore 

exec/semaphores.h: *51 

pointer to struct Task in struct SignalSemaphore 
exec/semaphores.h: *54 

short int in struct SignalSemaphore 

exec/semaphores.h: *55 

struct MinList (size 0x000c) in struct SignalSemaphore 
exec/semaphores.h: *52 

structure tag 

libraries/dosextens.h: *110 

pointer to unsigned short int in struct cprlist 
graphics/copper.h: *51 

char in struct bltnode 

hardware/blit.h: *84 

#define static =0x00000000 exec/types.h: *15 
#define -1 =Oxffffffff intuition/screens.h: 
unsigned short int in struct Custom 
hardware/custom.h: *47 

#define 0x0004 =0x00000004 intuition/intuition.h: 
unsigned short int in struct Custom 
hardware/custom.h: *49 


*111 


*351 





vy - H 


Sep 21 13:06 1988 C_Language_Cross~-Reference Page 75 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 76 


STRINGCENTER #define 0x0200 =0x00000200 intuition/intuition.h: *318 ta_Name pointer to char in struct TextAttr 
StringInfo structure tag +0x0000 graphics/text.h: *48 
size 0x0024 intuition/intuition.h: *451 ta_Style char in struct TextAttr 
STRINGRIGHT #define 0x0400 =0x00000400 intuition/intuition.h: *319 +0x0006 graphics/text.h: *50 
striong unsigned short int in struct Custom ta_YSize unsigned short int in struct TextAttr 
+0x003e hardware/custom.h: *50 +0x0004 graphics/text.h: *49 
STRPTR typedef pointer to unsigned char TBC_HCLRTAB #define 0 =0x00000000 devices/console.h: *84 
exec/types.h: *29, 30 TBC_HCLRTABSALL #define 3 =0x00000003 devices/console.h: *85 
devices/clipboard.h: 46 TB_EXCEPT #define 5 =0x00000005 exec/tasks.h: *50 
graphics/text.h: 48 TB_LAUNCH #define 7 =0x00000007 exec/tasks.h: *52 
strvbl unsigned short int in struct Custom TB_PROCTIME #define 0 =0x00000000 exec/tasks.h: *48 
+0x003a hardware/custom.h: *48 TB_STACKCHK #tdefine 4 =0x00000004 exec/tasks.h: *49 
SubItem pointer to struct MenuItem in struct MenuItem TB_SWITCH #tdefine 6 =0x00000006 exec/tasks.h: *51 
+0x00le intuition/intuition.h: *103 tc_ExceptCode pointer to pointer to char in struct Task 
SUBNUM Macro (1 argument) intuition/intuition.h: *946 +0x002a exec/tasks.h: *35 
sUD #define 0x10 =0x00000010 hardware/blit.h: *66 tc_ExceptData pointer to pointer to char in struct Task 
SUL #define 0x8 =0x00000008 hardware/blit.h: *67 +0x0026 exec/tasks.h: *34 
SuperBitMap pointer to struct BitMap in struct Layer te_Flags char in struct Task 
4+0x0020 graphics/clip.h: *34 +0x000e exec/tasks.h: *24 
SuperClipRect pointer to struct ClipRect in struct Layer tc_IDNestCnt char in struct Task 
+0x0024 graphics/clip.h: *35 +0x0010 exec/tasks.h: *26 
SuperSaveClipRects pointer to struct ClipRect in struct Layer tc_Launch pointer to function returning void in struct Task 
+0x003c graphics/clip.h: *41 +0x0046 exec/tasks.h: *42 
SUPER_BITMAP #define 0x0080 =0x00000080 intuition/intuition.h: *81] tc_MemEntry struct List (size 0x000e) in struct Task 
SUPER_UNUSED #define OxFCFC0000 =0xfefc0000 intuition/intuition.h: *839 +0x004a exec/tasks.h: *43 
SUPFRONT #define 0x0050 =0x00000050 intuition/intuition.h: *343 te_Node | struct Node (size 0x000e) in struct Task 
SUSERFLAGS #define Ox0OFF =0x000000ff graphics/gels.h: *15 +0x0000 exec/tasks.h: *23 
SWBNUM Macro (1 argument) intuition/intuition.h: *954 tc_SigAlloc unsigned int in struct Task 
SWRITE_BITS #define OxOF =0x0000000f intuition/preferences.h: *211 +0x0012 exec/tasks.h: *28 
SYSBASESIZE #define sizeof(struct ExecBase) te_SigExcept unsigned int in struct Task 
exec/execbase.h: *123 +0x00le exec/tasks.h: *31 
SysFlags unsigned short int in struct ExecBase tc_SigRecvd unsigned int in struct Task 
+0x0124 exec/execbase.h: *60 +0x00la exec/tasks.h: *30 
SYSGADGET #define 0x8000 =0x00008000 intuition/intuition.h: *334 te_Sigwait unsigned int in struct Task 
SYSREQUEST #define 0x4000 =0x00004000 intuition/intuition.h: *182 +0x0016 exec/tasks.h: *29 
SysStkLower pointer to pointer to char in struct ExecBase teo_SPLower pointer to pointer to char in struct Task 
+0x003a exec/execbase.h: *40 +0x003a exec/tasks.h: *39 
SysStkUpper pointer to pointer to char in struct ExecBase tc_SPReg pointer to pointer to char in struct Task 
+0x0036 exec/execbase.h: *39 +0x0036 exec/tasks.h: *38 
system _bplconO short int in struct GfxBase tc_SPUpper pointer to pointer to char in struct Task 
+0x00a4 graphics/gfxbase.h: *41 +0x003e exec/tasks.h: *40 
tan #define $PTan =0x00000000 libraries/mathffp.h: *37 tc_State char in struct Task 
tan #define IEFEDPTan =0x00000000 libraries/mathieeedp.h: *38 +0x000f exec/tasks.h: *25 
tanh #define SPTanh =0x00000000 libraries/mathffp.h: *51 te_Switch pointer to function returning void in struct Task 
tanh #define IEEEDPTanh =0x00000000 libraries/mathieeedp.h: *52 — +0x0042 exec/tasks.h: *41 . 
Task structure tag tc_TDNestcnt char. in struct Task 
size 0x005c exec/tasks.h: *22 +0x0011 exec/tasks.h: *27 
exec/ports.h: 32 tc_TrapAble unsigned short int in struct Task 
exec/execbase.h: 55 +0x0024 exec/tasks.h: *33 
exec/semaphores.h: 45, 54 te_TrapAlloc unsigned short int in struct Task 
libraries/dosextens.h: 35 +0x0022 exec/tasks.h: *32 
devices/prtbase.h: 87 tc_TrapCode pointer to pointer to char in struct Task 
graphics/gfxbase.h: 49 +0x0032 exec/tasks.h: *37 
TaskExceptCode pointer to pointer to char in struct ExecBase tce_TrapData pointer to pointer to char in struct Task 
+0x0134 exec/execbase.h: *69 +0x002e exec/tasks.h: *36 
TaskExitCode pointer to pointer to char in struct ExecBase tc_UserData pointer to pointer to char in struct Task 
+0x0138 exec/execbase.h: *70 +0x0058 exec/tasks.h: *44 
TaskReady struct List (size 0x000e) in struct ExecBase TDB_ALLOW_NON_3_5 #define 0 =0x00000000 devices/trackdisk.h: *138 
4+0x0196 exec/execbase.h: *83 TDERR_BadDriveType #define 33 =0x00000021 devices/trackdisk.h: *172 
TaskSigAlloc unsigned int in struct ExecBase TDERR_BadHdrSum #define 24 =0x00000018 devices/trackdisk.h: *163 
+0x013c exec/execbase.h: *71 TDERR_BadSecHdr #define 27 =0x000000lb devices/trackdisk.h: *166 
TaskTrapAlloc unsigned short int in struct ExecBase TDERR_BadSecID #define 23 =0x00000017 devices/trackdisk.h: *162 
+0x0140 exec/execbase.h: *72 TDERR_BadSecPreamble #define 22 =0x00000016 devices/trackdisk.h: *161 
TaskTrapCode pointer to pointer to char in struct ExecBase TDERR_BadSecSum. #define 25 =0x00000019 devices/trackdisk.h: *164 
+0x0130 exec/execbase.h: *68 TDERR_BadUnitNum #define 32 =0x00000020 devices/trackdisk.h: *171 
TaskWait struct List (size 0x000e) in struct ExecBase TDERR_DiskChanged #define 29 =0x0000001d devices/trackdisk.h: *168 
+0x0la4 exec/execbase.h: *84 TDERR_DriveInUse #define 34 =0x00000022 devices/trackdisk.h: *173 
ta_Flags char in struct TextAttr TDERR_NoMem #define 31 =0x0000001f devices/trackdisk-.h: *170 
+0x0007. graphics/text.h: *51 TDERR_NoSecHdr __#define 21 =0x00000015 devices/trackdisk.h: *160 








St -H 


Sep 2] 13:06 1988 C_Language_Cross-Reference Page 77 


TDERR_NotSpecified #define 20 =0x00000014 devices/trackdisk.h: 


TDERR_PostReset 
TDERR_SeekError 


TDERR_TooFewSecs #define 26 =0x000000la devices/trackdisk.h: 


TDERR_WriteProt 


TDF_ALLOW_NON_3_5 #define (1<<0) =0x00000001 devices/trackdisk.h: 


TDF _EXTCOM 
TDNestcnt 
+0x0127 
tdu_Comp01Track 
+0x0026 
tdu_Comp10Track 
+0x0028 
tdu_Comp11Track 
+0x002a 
TDU_PublicUnit 
size 0x0035 


+0x0000 
TD_ADDCHANGEINT 
TD_CHANGENUM 
TD_CHANGESTATE 
TD_FORMAT 
TD_GETDRIVETYPE 
TD_GETNUMTRACKS 
TD LABELSIZE 


TD_REMCHANGEINT 
TD_REMOVE 
TD _SECSHIFT 


size 0x0008 


TextFont 
size 0x0034 


-Itf Baseline 


+0x001a 
tf_BoldsSmear 
+0x001c 


*159 
*174 
*169 
*165 
*167 


#define 35 =0x00000023 devices/trackdisk.h: 
#define 30 =0x000000le devices/trackdisk.h: 


#define 28 =0x0000001c devices/trackdisk.h: 
*139 
#tdefine (1<<15) =0x00008000 devices/trackdisk.h: *71 
char in struct ExecBase 

exec/execbase.h: *62 

unsigned short int in struct TDU_PublicUnit 
devices/trackdisk.h: *186 

unsigned short int in struct TDU_PublicUnit 
devices/trackdisk.h: *187 

unsigned short int in struct TDU_PublicUnit 
devices/trackdisk.h: *188 

structure tag 

devices/trackdisk.h: *184 

char in struct TDU_PublicUnit 

devices/trackdisk.h: *191 

unsigned int in struct TDU_PublicUnit 
devices/trackdisk.h: *190 

unsigned int in struct TDU_PublicUnit 
devices/trackdisk.h: *189 

struct Unit (size 0x0026) in struct TDU_PublicUnit 
devices/trackdisk.h: *185 

#define (CMD_NONSTD+11) =0x00000014 devices/trackdisk.h: 
#define (CMD_NONSTD+4) =0x0000000d devices/trackdisk.h: 
#define (CMD_NONSTD+5) =0x0000000e devices/trackdisk.h: 
#define (CMD_NONSTD+2) =0x0000000b devices/trackdisk.h: 
#define (CMD_NONSTD+9) =0x00000012 devices/trackdisk.h: 
#tdefine (CMD_NONSTD+10) =0x00000013 devices/trackdisk.h: 
#define 16 =0x00000010 devices/trackdisk.h: *130 


#define (CMD_NONSTD+13) =0x00000016 devices/trackdisk.h: 


#define (CMD_NONSTD+0) =0x00000009 devices/trackdisk.h: 
#define "trackdisk.device" devices/trackdisk.h: *69 
#define (CMD_NONSTD+6) =0x0000000f devices/trackdisk-h: 
#define (CMD_NONSTD+7) =0x00000010 devices/trackdisk.h: 
#define (CMD_NONSTD+8) =0x00000011 devices/trackdisk.h: 
#define (CMD_NONSTD+12) =0x00000015 devices/trackdisk.h: 
#define (CMD_NONSTD+3) =0x0000000c devices/trackdisk.h: 
#tdefine 9 =0x00000009 devices/trackdisk.h: *48 

#define 512 =0x00000200 devices/trackdisk.h: *47 
#define (CMD_NONSTD+1) =0x0000000a devices/trackdisk.h: 
unsigned int in struct IOTArray 

devices/serial.h: *22 

unsigned int in struct IOTArray 

devices/serial.h: *23 

typedef unsigned char 

exec/types.h: *48 

structure tag 

graphics/text.h: *47 

intuition/intuition.h: 500 

intuition/screens.h: 59, 127 

libraries/diskfont.h: 67 

structure tag 

devices/conunit.h: 68 

graphics/rastport.h: 72 

graphics/text.h: *56 

intuition/intuition.h: 793 

graphics/gfxbase.h: 36 

libraries/diskfont.h: 56 

struct List (size 0x000e) in struct GfxBase 
graphics/gfxbase.h: *35 

unsigned short int in struct TextFont 

graphics/text.h: *66 

unsigned short int in struct TextFont 

graphics/text.h: *63 

unsigned short int in struct TextFont 

graphics/text.h: *64 


*85 
*78 
*79 
*76 
*83 

*B4 


*88 
*74 


*80 
*81 
*82 
*86 
*77 


*75 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 78 


tf_CharData 
Ox: 


+0x0026 
TF_PROCTIME 
TF_STACKCHK 


size 0x0028 


TIMERNAME 
TimeSet. 
+0x0004 
timeval 
size 0x0008 


+0x0060 
+0x0020 
+0x001la 
+0x0016 


+0x00c0 
TOGGLESELECT 
TOPAZ EIGHTY 


TopBorder 

+0x0014 
TopEdge 

+0x0006 
TopEdge 

+0x0006 


pointer to pointer to char in struct TextFont 
graphics/text.h: *70 

pointer to pointer to char in struct TextFont 
graphics/text.h: *76 

pointer to pointer to char in struct TextFont 
graphics/text.h: *73 

pointer to pointer to char in struct TextFont 
graphics/text.h: *75 

#tdefine (1<<5) =0x00000020 exec/tasks.h: 
char in struct TextFont 
graphics/text.h: *61 

char in struct TextFont 
graphics/text.h: *69 

#define (1<<7) =0x00000080 exec/tasks.h: 
char in struct TextFont 
graphics/text.h: *68 

struct Message (size 0x0014) in struct TextFont 
graphics/text.h: *57 

unsigned short int in struct TextFont 
graphics/text.h: *72 

#define (1<<0) =0x00000001 exec/tasks. 

#define (1<<4) =0x00000010 exec/tasks. 

char in struct TextFont 

graphics/text.h: *60 

#define (1<<6) =0x00000040 exec/tasks. 

unsigned short int in struct TextFont 
graphics/text.h: *62 

unsigned short int in struct TextFont 
graphics/text .h: *59 

pointer to struct Task in struct ExecBase 
exec/execbase.h: *55 

#define 50 =0x00000032 libraries/dos.h: 
short int in struct AnimComp 
graphics/gels.h: *175 

structure tag 

devices/timer.h: *28 
devices/prtbase.h: 85 

#define "timer.device" devices/timer.h: 
short int in struct AnimComp 
graphics/gels.h: *179 

structure tag 

devices/timer.h: *23, 30 
devices/inputevent.h: 150 
intuition/preferences.h: 54, 55, 56 
struct Interrupt (size 0x0016) in struct GfxBase 
graphics/gfxbase.h: *34 

pointer to char in struct Window 
intuition/intuition.h: *709 

pointer to char in struct NewWindow 
intuition/intuition. h: *874 

pointer to char in struct Screen 
intuition/screens.h: *52 

structure tag : 

graphics/rastport.h: *28, 55 

pointer to struct TmpRas in struct RastPort 
graphics/rastport.h: *55 

Macro (1 argument) graphics/gfx.h: *18 

struct List (size 0x000e) in struct GfxBase 
graphics/gfxbase.h: *50 

#define 0x0100 =0x00000100 intuition/intuition.h: 
#define 8 =0x00000008 intuition/preferences.h: *39 
#define 9 =0x00000009 intuition/preferences.h: *40 
#define 0x0040 =0x00000040 intuition/intuition.h: 
unsigned short int in struct PropIinfo 
intuition/intuition.h: *424 

short int in struct Menu 

intuition/intuition.h: *60 

short int in struct MenuItem 
intuition/intuition.h: *88 


*56 


*58 


«54 


*21 


*316 


*313 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 79 


TopEdge 

+0x0006 
TopEdge 

+0x0006 
TopEdge 

+0x0006 
TopEdge 

+0x0002 
TopEdge 

+0x0002 
TopEdge 

+0x0006 
TopkEdge 

+0x0002 
TopEdge 


+0x000a 


TopEdge 
+0x0002 
TOPHIT 
topmost 
+0x001la 
top_layer 
+0x0000 
TOTALSLOTS 
tPoint 
size 0x0004 
TRUB 
trunc 
trunc 
TR_ADDREQUEST 
TR_GETSYSTIME 


short int in struct Requester 
intuition/intuition.h: *145 

short int in struct Gadget 
intuition/intuition.h: *197 

short int in struct IntuiText 
intuition/intuition.h: *499 

short int in struct Border 
intuition/intuition.h: *524 

short int in struct Image 
intuition/intuition.h: *546 

short int in struct Window 
intuition/intuition.h: *697 

short int in struct NewWindow 
intuition/intuition.h: *852 

short int in struct Screen 
intuition/screens.h: *45 

short int in struct NewScreen 
intuition/screens.h: *119 

#define 1 =0x00000001 graphics/collide.h: *30 
short int in struct GelsInfo 
graphics/rastport.h: *46 

pointer to struct Layer in struct Layer_Info 
gxaphics/layers.h: *34 

#define 256 =0x00000100 libraries/expansionbase.h: *33, 53 
structure tag 

graphics/gfx.h: *29 

#define 1 =0x00000001 exec/types-h: *50 

Macro (1 argument) libraries/mathffp.h: *29 
Macro (1 argument) libraries/mathieeedp.h: *30 
#define CMD_NONSTD =0x00000009 devices/timer.h: *34 
#define (CMD_NONSTD+1) =0x0000000a devices/timer.h: *35 





Sep 21 13:06 1988 C_Language_Cross-Reference Page 80 


+0x0000 
ua 

+0x0002 
u3 

+0x0002 
u4 

+0x0000 
UBYTE 
UCopIns 

+0x0014 
UCopList 


size 0x000c 


UCOUNT 
ULONG 


UndoBuffer 
+0x0004 
UndoPos 
+0x000e 
Unit 
size 0x0026 


UNITF_ACTIVE 

UNITF_INTASK 

unit_flags 
+0x0022 


graphics/copper.h: *30 

union (no tag) (size 0x0002) in struct (no tag) 
graphics/copper.h: *35 

union (no tag) (size 0x0004) in struct CopIns 
graphics/copper.h: *37 

struct (no tag) (size 0x0004) in union (no tag) 
graphics/copper.h: *36 

typedef unsigned char 

many references; defined in exec/types.h: *27 
pointer to struct UCopList in struct ViewPort 
graphics/view.h: *38 

structure tag 

graphics/view.h: 38 

graphics/copper.h: *69, 71 

typedef unsigned short int exec/types.h: *46 
typedef unsigned long int 

many references; defined in exec/types.h: *21 
pointer to char in struct StringInfo 
intuition/intuition.h: *455 

short int in struct StringInfo 
intuition/intuition.h: *461 

structure tag 

exec/devices.h: *31 

execfio.h: 21, 30 

devices/clipboard.h: 40 

devices/printer.h: 139, 153 
devices/trackdisk.h: 185 

#define (1<<0) =0x00000001 exec/devices.h: *40 
#define (1<<1) =0x00000002 exec/devices.h: *41 
char in struct Unit 

exec/devices.h: *34 


TR_MakeBad #define —4 =Oxfffffffc libraries/translator.h: *15 UNIT_MICROHZ #tdefine 0 =0x00000000 devices/timer.h: *18 
tr_node struct IORequest (size 0x0020) in struct timerequest unit_MsgPort struct MsgPort (size 0x0022) in struct Unit 
+0x0000 devices/timer.h: *29 . +0x0000 exec/devices.h: *32 
TR_NoMem #define -2 =Oxfffffffe libraries/translator.h: *14 unit_OpenCnt unsigned short int in struct. Unit 
TR_NotUsed #define -1 =Oxffffffff libraries/translator.h: *13 +0x0024 exec/devices.h: *36 
TR_SETSYSTIME #define (CMD_NONSTD+2) =0x0000000b devices/timer.h: *36 unit_pad char in struct Unit 
tr_time struct timeval (size 0x0008) in struct timerequest +0x0023 exec/devices.h: *35 
+0x0020 devices/timer.h: *30 UNIT _VBLANK #define 1 =0x00000001 devices/timer.h: *19 
TS_ADDED #define 1 =0x00000001 exec/tasks.h: *62 unusedreg char in struct CIA 
TS_EXCEPT #define 5 =0x00000005 exec/tasks.h: *66 +0x0b00 hardware/cia.h: *45 
TS_INVALID #define 0 =0x00000000 exec/tasks.h: *61 UserData pointer to pointer to char in struct Gadget 
TS READY #define 3 =0x00000003 exec/tasks.h: *64 +0x0028 intuition/intuition.h: *237 
TS_REMOVED #define 6 =0x00000006 exec/tasks.h: *67 UserData pointer to char in struct Window 
TS_RUN #define 2 =0x00000002 exec/tasks.h: *63 +0x0078 intuition/intuition.h: *783 
TS WAIT #define 4 =0x00000004 exec/tasks.h: *65 UserData © pointer to char in struct Screen 
tv_micro unsigned int in struct timeval +0x0156 intuition/screens.h: *85 
+0x0004 devices/timer.h: *25 UserPort pointer to struct MsgPort in struct Window 
tv_secs unsigned int in struct timeval +0x0056 intuition/intuition.h: *754 
+0x0000 devices/timer.h: *24 USHORT typedef unsigned short int 
TWO_PI #tdefine (((float) 2) * PI) libraries/mathffp.h: *16 many references; defined in exec/types.h: *39 
TWO_PI #define (((double) 2) * PI) libraries/mathieeedp.h: *17 US_LEGAL #define 0x10 =0x00000010 intuition/preferences.h: *180 
TxBaseline unsigned short int in struct RastPort US_LETTER #define 0x00 =0x00000000 intuition/preferences.h: *179 
+0x003e graphics/rastport.h: *77 UWORD typedef unsigned. short int 
TxFlags char in struct RastPort many references; defined in exec/types.h: *24 
+0x0039 graphics/rastport.h: *74 VANILLAKEY #define 0x00200000 =0x00200000 intuition/intuition.h:. *659 
TxHeight unsigned short int in struct RastPort VBlank char in struct GfxBase 
+0x003a graphics/rastport.h: *75 +0x00a0Q graphics/gfxbase.h: *38 
TxSpacing short int in struct RastPort VBlankFrequency char in struct ExecBase 
+0x0040 graphics/rastport.h: *78 +0x0212 exec/execbase.h: *104 
TxwWidth unsigned short int in struct RastPort vbsrv struct Interrupt (size 0x0016) in struct GfxBase 
+0x003c graphics/rastport.h: *76 +0x004a graphics/gfxbase.h: *34 
char in struct ColorMap VetrPtr pointer to short int in struct AreaInfo 
+0x0001 graphics/view.h: *24 +0x0004 graphics/rastport.h: *20 
unsigned short int in struct NewWindow VetrTbl pointer to short int in struct AreaInfo 
+0x002e intuition/intuition.h: *909 +0x0000 graphics/rastport.h: *19 
unsigned short int in struct NewScreen VertBody unsigned short int in struct PropInfo 
+0x000e intuition/screens.h: *125 +0x0008 intuition/intuition.h: *417 
ul union (no tag) (size 0x0002) in struct (no tag) VertPot unsigned short int in struct PropInfo 








Lb’ -H 


Sep 21 13:06 1988 C_Language_Cross-Reference Page 81 


+0x0004 


vhposr 
+0x0006 


vhposw 


View 
size 0x0012 


+0x002c 


ViewInitx 
+0x0078 
ViewInitYy 
+0x007a 
ViewLord 
+0x0022 
ViewModes 
+0x000c 
ViewPort 
size 0x0028 


ViewPort 
+0x0000 
ViewPort 
+0x002¢c 
ViewxOffset. 
+0x0076 
ViewyOffset 
+0x0077 
voice 
+0x0000 
VOID 


volume 
+0x003e 


vposr 

+0x0004 
VPOSRLOF 
Vposw 

+0x002a 
VPotRes 

+0x0010 
'VP_HIDE 
VSBob 

+0x0034 
VSIZEBITS 
VSI ZEMASK 
VSOVERFLOW 
vSprite 

size 0x003c 


VSPRITE 
VUserExt 
+0x003a 
VUserStuff 
VWaitPos 
+0x0000 
'VWAITPOS 


WarmCapture 
+0x0032 
wa_Lock 
+0x0000 
wa_Name 


+0x0004 
WBALg 


intuition/intuition.h: *397 

unsigned short int in struct Custom 
hardware/custom.h: *23 

unsigned short int in struct Custom 
hardware/custom.h: *41 

structure tag 

graphics/view.h: *47 

graphics/gfxbase.h: 26 
intuition/intuitionbase.h: 150 

short int in struct Preferences 
intuition/preferences.h: *76 

short int in struct Preferences 
intuition/preferences.h: *76 

struct View (size 0x0012) in struct IntuitionBase 
intuition/intuitionbase.h: *150 

unsigned short int in struct NewScreen 
intuition/screens.h: *123 

structure tag 

graphics/view.h: *30, 32, 49 
intuition/screens.h: 62 

graphics/copper.h: 59 

pointer to struct ViewPort in struct View 
graphics/view.h: *49 

struct ViewPort (size 0x0028) in struct Screen 
intuition/screens.h: *62 

char in struct Preferences 
intuition/preferences.h: *74 

char in struct Preferences 
intuition/preferences.h: *75 

struct narrator_rb (size 0x0046) in struct mouth_rb 
devices/narrator.h: *88 

#define void =0x00000000 exec/types.h: *18 
exec/tasks.h: 41, 42 

exec/interrupts.h: 25, 31 

devices/prtbase.h: 128, 129, 131 
workbench/icon.h: 31 

unsigned short int in struct narrator_rb 
devices/narrator.h: *75 

unsigned short int in struct Custom 
hardware/custom.h: *22 

#define 0x8000 =0x00008000 graphics/display.h: *38 
unsigned short int in struct Custom 
hardware/custom.h: *40 

unsigned short int in struct PropInfo 
intuition/intuition.h: *422 

#define 0x2000 =0x00002000 graphics/view.h: *64 
pointer to struct Bob in struct VSprite 
graphics/gels.h: *115 

#define 16-HSIZEBITS =0x0000000a hardware/blit.h: *14 
#define Ox3FF =0x000003ff hardware/blit.h: *16 
#define 0x0800 =0x00000800 graphics/gels.h: *24 
structure tag 

graphics/rastport.h:. 40 

graphics/gels.h: *68, 72, 73, 79, 80, 155, 232 
#define 0x0001 =0x00000001 graphics/gels.h: *16 
short int in struct VSprite 

graphics/gels.h: *132 

#define SHORT =0x00000000 graphics/gels.h: *52, 132 
short int in union (no tag) 

graphics/copper.h: *28 

#define u3.u4.ul.VWaitPos 

graphics/copper.h: *41 

pointer to pointer to char in struct ExecBase 
exec/execbase.h: *38 

int in struct WBArg 

workbench/startup.h: *35 

pointer to char in struct WBArg 
workbench/startup.h: *36 

structure tag 





Sep 21 13:06 1988 C_Language_Cross~Reference Page 82 


_ size 0x0008 
WBDEVICE 
WBDISK 
WBDRAWER 
WBENCHCLOSE 
WBENCHMESSAGE 
WBENCHOPEN 
WBENCHSCREEN 
WBENCHWINDOW 
WBGARBAGE 
WBKICK 
WBObject. 

size 0x0000 
WBorBottom 
+0x0026 
WBorLeft 
+0x0024 
WBorRight 
+0x0025 
WBorTop 
+0x0023 
WBPROJECT 
WBStartup 
size 0x0028 
WBTOOL 
wb Depth 
+0x00e6 
WB_DISKMAGIC 
WB_DISKVERSION 


wb_Height 

+0x00e4 
wh_Width 

+0x00e2 
WDOWNBACK 
WDRAGGING 
width 

+0x0046 
Width 

+0x0008 
Width 

+0x0008 
Width 

+0x0008 
Width 

+0x0008 
Width 

+0x0004 
Width 

+0x0008 
Width 

+0x0004 
Width 

+0x000c 
Width 

+0x0004 
Width 

+0x001c 
Window 


size 0x0084 


Window 

+0x0028 
WINDOWACTIVE 
WINDOWCLOSE 
WINDOWDEPTH 
WINDOWDRAG 
WindowPort 


workbench/startup.h: 31, *34 

#define 6 =0x00000006 workbench/workbench.h: *38 
#define 1 =0x00000001 workbench/workbench.h: *33 
#define 2 =0x00000002 workbench/workbench.h: *34 
#define 0x0002 =0x00000002 intuition/intuition.h: *686 


#define 0x00020000 =0x00020000 intuition/intuition.h: *655 


#define 0x0001 =0x00000001 intuition/intuition.h: *685 
#define 0x0001 =0x00000001 intuition/screens.h: *95 


#define 0x02000000 =0x02000000 intuition/intuition.h: *836 


#define 5 =0x00000005 workbench/workbench.h: *37 
#define 7 =0x00000007 workbench/workbench.h: *39 
structure tag 

workbench/icon.h: 28 

char in struct Screen 

intuition/screens.h: *57 

char in struct Screen 

intuition/screens.h: *57 

char in struct Screen 

intuition/screens.h: *57 

char in struct Screen 

intuition/screens.h: *57 

#define 4 =0x00000004 workbench/workbench.h: *36 
structure tag 

workbench/startup.h: *25 

#define 3 =0x00000003 workbench/workbench.h: *35 

char in struct Preferences 

intuition/preferences.h: *123 

#define Oxe310 =0x0000e310 workbench/workbench.h: *66 
#define 1 =0x00000001 workbench/workbench.h: *67 
unsigned short int in struct Preferences 
intuition/preferences.h: *122 

unsigned short.int in struct Preferences 
intuition/preferences.h: *121 

#define 0x0060 =0x00000060 intuition/intuition.h: *344 
#define 0x0020 =0x00000020 intuition/intuition.h: *340 
char in struct mouth_rb 

devices/narrator.h: *89 

short int in struct Menu 

intuition/intuition.h: *61 

short int in struct Menultem 

intuition/intuition.h: *89 

short int in struct Requester 

intuition/intuition.h: *146 

short int in struct Gadget 

intuition/intuition.h: *198 

short int in struct Image 

intuition/intuition.h: *547 

short int in struct Window 

intuition/intuition.h:. *698 

short int in struct NewWindow 

intuition/intuition.h: *853 

short int in struct Screen 

intuition/sereens.h: *46 

short int in struct NewScreen 

intuition/screens.h: *119 

short int in struct VSprite 

graphics/gels.h: *98 

structure tag 

devices/conunit.h: 37 

intuition/intuition.h: 168, 630, *693, 695, 742 
intuition/screens.h: 43 

intuition/intuitionbase.h: 152 

pointer to pointer to char in struct Layer 
graphics/clip.h: *38 

#define 0x2000 =0x00002000 intuition/intuition.h: *825 
#tdefine 0x0008 =0x00000008 intuition/intuition.h: *801 
#define 0x0004 =0x00000004 intuition/intuition.h: *800 
#define 0x0002 =0x00000002 intuition/intuition.h: *799 
pointer to struct MsgPort in struct Window 


8% - H 


Sep. 21 13:06 1988 C_Language_Cross—Reference Page 83 


+0x005a 
WINDOWREFRESH 
WINDOWSI ZING 
WINDOWTICKED 
WLayer 

+0x007c 
WORD 


WORDBITS 


wordreserved 
+0x004e 


intuition/intuition.h: *754 

#define 0x01000000 =0x01000000 intuition/intuition.h: *835 
#define 0x0001 =0x00000001 intuition/intuition.h: *798 
#define 0x04000000 =0x04000000 intuition/intuition.h: *837 
pointer to struct Layer in struct Window 
intuition/intuition.h: *788 

typedef short int 

many references; defined in exec/types.h: *23 

typedef unsigned short int 

exec/types.h: *25 

array [7] of unsigned short int in struct RastPort 
graphics/rastport.h: *82 


WORKBENCH_ICON_H #define =0x00000000 workbench/icon-h: *2 
WORKBENCH _STARTUP_H #define =0x00000000 workbench/startup.h: *2 
WORKBENCH_WORKBENCH_H #define =0x00000000 workbench/workbench.h: *2 


WorkName 

+0x00ba 
WScreen 

+0x002e 
WUPFRONT 
W_TRACTOR 
x 

+0x0000 
x 

+0x0018 
x 

+0x0006 
XAccel 

+0x001a 
xOffset 

+0x0050 
xoffset 

+0x0064 
XTrans 

+0x001¢ 
XVel 

+0x0016 
XY 

+0x0008 
Y 

+0x0002 
Y 

+0x0016 
Y 

+0x0008 
YAccel 

+0x0018 
yoffset 

+0x0051 
yoffset 

+0x0065 
YTrans 

+0x001la 


YVel 


array [30] of char in struct Preferences 
intuition/preferences.h: *110 

pointer to struct Screen in struct Window 
intuition/intuition.h: *717 

#define 0x0040 =0x00000040 intuition/intuition.h: *342 
#define 0x30 =0x00000030 intuition/preferences.h: *182 
short int in struct tPoint 
graphics/gfx.h: *31 

short int in struct VSprite 
graphics/gels.h: *95 

unsigned short int in struct SimpleSprite 
graphics/sprite.h: *19 

short int in struct AnimOb 
graphics/gels.h: *214 

char in struct Window 
intuition/intuition.h: *750 

char in struct Preferences 
intuition/preferences.h: *60 

short int in struct AnimComp 
graphics/gels.h: *192 

short int in struct AnimOb 
graphics/gels.h: *213 

pointer to short int in struct Border 
intuition/intuition.h: *528 

short int in struct tPoint 
graphics/gfx.h: *31 

short int in struct VSprite 
graphics/gels.h: *95 


“unsigned short int in struct SimpleSprite 


graphics/sprite.h: *19 

short int in struct AnimOb 
graphics/gels.h: *214 

char in struct Window 
intuition/intuition.h: *750 
char in struct Preferences 
intuition/preferences.h: *61 
short int in struct AnimComp 
graphics/gels.h: *191 

short int in struct AnimOb 





6¢ - H 





Oct 5 22:42 1988 Chip _Register_Map Page 1 


A true software memory map, showing system utilization of the various sections 
of RAM and free space is not provided, or possible with the Amiga. All memory is 
dynamically allocated by the memory manager, and the actual locations may change 
from release—-to-release, machine-to-machine or boot—-to-boot (see the 
exec/AllocMem function for details). To find the locations of system structures 
software must use the defined access procedures, starting by fetching the 
address of the exec.library from location 4; the only absolute memory location 
in the system. All software is written so that it can be loaded and relocated 
anywhere in memory by the loader. What follows are maps that show the relative 
locations of all custom chip registers. This is provided for the convenience of 
the few developers that may need to directly access them. 


BRIEF CHIP REGISTER MAPS 


When dealing directly with the hardware, all unused bits must be written as 
zeros. The value of any unused read bit must not be trusted. 


The register names for the two 8520 Complex Interface Adapters are listed below. 
Under the multitasking Operating System, access is controlled by the 
cia.resource. The 8520's are byte-oriented; writing them as a word is NOT 
allowed (it affects both chips in strange ways). The address at which each 
register is to be accessed is given in this list: 


Address for: 


8520-A 8520-B | NAME | EXPLANATION 

BFEOOL BEDOOO =PRA Peripheral data register A 

BFE1O1] BFD100 PRB Peripheral data register B 

BFE201 BFD200 DDRB Data direction register A 

BFE301 BFD300 DDRA Data direction register B 

BFE401 BFD400 TALO TIMER A low register (.715909 Mhz under ) 
BFESO1 BFD500 TAHI TIMER A high register ( NTSC. Under PAL ) 
BFE601 BFD600 TBLO TIMER B low register ( these run at ) 
BFE701L BFD700 ‘BHI TIMER B high register (.709379 Mhz ) 
BFE8OL BFD800 Event LSB (A=VBlank B=HSync) 

BFE901 BED900 Event 8 - 15 

BFEAOL BFDA0O Event MSB 

BFEBOL BEDBOO No connect 

BFECOL BFDCOO = SDR Serial data register 

BFEDOL BFDDOO ICR Interrupt control register 

BFEEOL BFDEOO CRA Control register A 

BFEFOL BFDFOO CRB Control register B 


joao Amiga Custom Chips--------——— 

;The custom chips must be addressed starting at $DFFO00, and no other address. 
;All registers are Write-only or Read-only; violating this restriction in any 
pway will cause subtle problems. Unused registers must not be accessed 
;Custom chip registers must be addressed as words or longs, never bytes. 


Key: 

register used by DMA only 

register used by DMA usually, processor sometimes 
register pair — always write as one 32 bit write 
Not writable by the Copper 

Not writable unless the Copper danger bit is set. 
Agnus, Denise or Paula 

Write-Only, Read-Only or DMA-related Early Read 
Strobe, writing 0's to the address causes an effect 


Ht AM 


i 
i 
i 
i 
i 
i 
; 
i 
i 
i 


fib deo eoo 


NAME ADD R/W CHIP FUNCTION 
BLTDDAT & *000 ER A 
DMACONR *002 R A P 
VPOSR *004 =R A 


Blitter destination early read (dummy address) 
DMA control (and Blitter status) read 
Read vert most significant bit (and frame flop) 


Oct 5 22:42 1988 Chip Register_Map Page 2 


Read vert and horiz. position of beam 
Disk data early read (dummy address) 
Joystick-mouse 0 data (vert ,horiz) 
Joystick-mouse 1 data (vert ,horiz) 
Collision data register (read and clear) 
Audio, disk control register read 
Pot counter pair 0 data (vert,horiz) 
Pot counter pair 1 data (vert,horiz) 
Pot port data read (was POTGOR)(see potgo.resource) 
Serial port data and status read 
Disk data byte and status read 
Interrupt enable bits read 
Interrupt request bits read 
Disk pointer (register pair) 
Disk length 
Disk DMA data write 
Refresh pointer 
Write vert most significant bit (and frame flop) 
Write vert and horiz position of beam 
Coprocessor control register (CDANG) 
Serial port data and stop bits write 
Serial port period and control 
Pot port data write and start 
Write to all four joystick-mouse counters at once 
Strobe for horiz sync with VB and EQU 
Strobe for horiz syne with VB (vert. blank) 
Strobe for horiz sync 
Strobe for identification of long horiz. 
Blitter control register 0 
Blitter control register 1 
Blitter first word mask for source A 
Blitter last word mask for source A 
Blitter pointer to source C (register pair) 
Blitter pointer to source B (register pair) 
Blitter pointer to source A (register pair) 
Blitter pointer to destination D (register pair)) 
Blitter start and size (window width, height) 
Blitter modulo for source C 
Blitter modulo for source B 
Blitter modulo for source A 
Blitter modulo for destination D 
Blitter source C data register 
Blitter source B data register 
Blitter source A data register 
Disk syne pattern register for disk read 
Coprocessor first location register (pair) 
Coprocessor second location register (pair) 
Coprocessor restart at first location 
Coprocessor restart at second location 
Coprocessor instruction fetch identify 
Display window start (upper left 

vert-horiz position) 
Display window stop (lower right 

vert.-horiz. position) 
Display bit plane data fetch start 

(horiz. position) 
Display bit plane data fetch stop 

(horiz. position) 
DMA control write (clear or set) 
Collision control 
Interrupt enable bits (clear or set bits) 
Interrupt request bits (clear or set bits) 
Audio, disk, UART control 


*006 
*008 
*00A 
*00C 
*00E 
*Q010 
*012 
*014 
*016 
*018 
*O1A 
*O01lC 
*O1E 
*020 
*024 
*026 
*028 
*02A 
*02C 
*02E 
*030 
*032 
*034 
*036 
*038 
*03A 
*03C 
*03E 
“040 
“042 
“044 
“046 
“048 
“O04C 
“050 
“054 
“058 
“060 
“062 
“064 
“066 
“070 
“072 
“074 
“O7E 

080 

084 

088 

O8A 

08c 

O8E 


rd 
~ 


OoOYy 


vu ceUyMVUVUUY 


line. 


090 
092 
094 


> FP FP YP PPP PPP PP PP PPP PPP PS PP 


096 
098 
O9A 
09C 


Audio channel 0 location (pair) 
Audio channel 0 length 

Audio channel 0 period 

Audio channel 0 volume 

Audio channel 0 data 





SZLZAR BABAST SB SB A HBAWNNAAATAAADAAALAAALZAAALDNNNUNAZAZADTABABAADAADADABAVWA am 


OS —H 


Oct 5 22:42 1988 Chip Register_Map Page 3 


Oct 5 22:42 1988 Chip _Register_Map 


OAC SPR2DATA % 154 W D 
OAE SPR2DATB. % 156 W D 
AUDLLC + OBO W A Audio channel 1 location (pair) SPR3POS % 158 W D 
AUDILEN OB4 W P Audio channel 1 length SPR3CTL % 15A W D 
AUDIPER OB6 W P Audio channel 1 period SPR3DATA % 15C W D 
AUD1VOL OB8 W P Audio channel 1 volume SPR3DATB % I15E W D 
AUDIDAT & OBA W P.. Audio channel ] data SPR4POS % 160 W D 
OBC SPR4CTL $ 162 W D 
OBE SPR4DATA % 164 W D 
AUD2LC + 0cO W A Audio channel 2 location (pair) SPR4DATB % 166 W D 
AUD2LEN 0c4 W P Audio channel 2 length SPR5POS % 168 W D 
AUD2PER oc6 WwW P Audio channel 2 period SPR5CTL % l16A W D 
AUD2VOL oc8 W P Audio channel 2 volume SPR5DATA % 16C W D 
AUD2DAT & OCA W P ~ Audio channel 2 data SPR5DATB % I16E W D 
occ SPR6POS % 170 W D 
OCE SPR6CTL $ 172 W D 
AUD3LC + Opo0 W A Audio channel 3 location (pair) SPR6DATA % 174 W D 
AUD3LEN op4 WwW P Audio channel 3 length SPR6DATB % 176 W D 
AUD3PER Oop6 W P Audio channel 3 period SPR7POS % 178 W D 
AUD3VOL OD8 W P. Audio channel 3 volume SPR7CTL % I17A W D 
AUD3DAT & ODA W P Audio channel 3 data SPR7DATA % 17C W D 
opc SPR7DATB % I17E W Dd 
ODE 
COLORO00 180 W D 
BPL1PT + OFO W A Bit plane 1 pointer (register pair) Lee 
BPL2PT + OEF4 W A Bit plane 2 pointer (register pair) COLOR31 1BE W D 
BPL3PT + OE8 W A Bit plane 3 pointer (register pair) RESERVED 1110X 
BPL4PT + OFC W A Bit plane 4 pointer (register pair) RESERVED 1111x 
BPLSPT + OFO W A Bit plane 5 pointer (register pair) NO-OP(NULL) 1FE 
BPL6PT + OF4 W A Bit plane 6 pointer (register pair) 
OF8 
OFA 
OFC 
OFE 
BPLCONO 100 W AD Bit plane control register (misc. control bits) 
BPLCONL 102 W D Bit plane control reg. (scroll value PF1, PF2) 
BPLCON2 104 W D Bit plane control reg. (priority control) 
106 
BPLIMOD 108 W A Bit plane modulo (odd planes) 
BPL2MOD 10A W A Bit Plane modulo (even planes) 
10c 
10E 
BPLIDAT & 110 W D Bit plane 1 data (parallel-to-serial convert) 
BPL2DAT & 112 W D ‘Bit plane 2 data (parallel-to-serial convert) 
BPL3DAT & 114 W D Bit plane 3 data (parallel—-to-serial convert) 
BPL4DAT & 116 W D Bit plane 4 data (parallel-to-serial convert) 
BPLSDAT & 118 W D Bit plane 5 data (parallel-to-serial convert) 
BPL6DAT & llA W D Bit plane 6 data (parallel-to-serial convert) 
lic 
1lE 
SPROPT + 120 W A Sprite 0 pointer (register pair) 
SPRIPT + 124 W A Sprite 1 pointer (register pair) 
SPR2PT + 128 W A Sprite 2 pointer (register pair) 
SPR3PT + 12C W A Sprite 3 pointer (register pair) 
SPR4PT + 130 W A Sprite 4 pointer (register pair) 
SPROPT + 134 W A Sprite 5 pointer (register pair) 
SPR6PT + 138 W A Sprite 6 pointer (register pair) 
SPR7PT + 13C W A Sprite 7 pointer (register pair) 
SPROPOS % 140 W AD Sprite 0 vert-horiz start position data 
SPROCTL % 142 W AD Sprite 0 vert stop position and control data 
SPRODATA % 144° W D Sprite 0 image data register A 
SPRODATB % 146 W D Sprite 0 image data register B 
SPRIPOS % 148 W AD Sprite 1 vert-horiz start position data 
SPRICTL % 14A W AD Sprite 1 vert stop position and control data 
SPRIDATA % 14C W D Sprite 1 image data register A 
SPRIDATB % 14E W D Sprite 1 image data register B 
SPR2POS % 150 W AD Sprite 2 vert-horiz start position data 
SPR2CTL % 152 W AD Sprite 2 vert stop position and control data 





Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 
Sprite 


Page 4 


NWSI NADHNUUU EP SSW WWWNDd 


image data register A 

image data register B 

vert-horiz start position data 

vert stop position and control data 
image data register A 

image data register B 

vert-horiz start position data 

vert stop position and control data 
image data register A 

image data register B 

vert-horiz start position data 
vert stop position and control data 
image data register A 

image data register B 

vert-horiz start position data 
vert stop position and control data 
image data register A 

image data register B 

vert-horiz start position data 
vert stop position and control data 
image data register A 

image data register B 


Color table 00 


Color table 31 


TS - H 





Dec 8 02:04 1988 Structure Reference Page 1 
Struct.doc by Kodiak $0020 32 
SSS SS $0000 0 
$0002 2 
AnimComp $0006 6 
$0026 38 sizeof (AnimComp) $000a 10 
$0000 0 Flags $000e 14 
$0002 2 Timer $0012 18 
$0004 4 TimeSet $0016 22 
$0006 6 NextComp $o0la 26 
$000a 10 PrevComp $00le 30 
$000e 14 NextSeq BoolInfo: 
$0012 18 PrevSeq $000a 10 
$0016 22 AnimCRoutine $0000 0 
$00la 26 YTrans $0002 2 
$001c 28 XTrans $0006 6 
$00le 30 Headcob BootBlock: 
$0022 34 AnimBob $000c 12 
AnimOb: $0000 0 
$002a 42 sizeof(AnimOb) $0004 4 
$0000 0 NextOob $0008 8 
$0004 4 PrevOb BootNode: 
$0008 8 Clock $0014 20 
$000c 12 AnOldy $0000 0 
$000e 14 Anoldx $000e 14 
$0010 16 AnY $0010 16 
$0012 18 Anx Border: 
$0014 20 YVel - $0010 16 
$0016 22 XvVel $0000 0 
$0018 24 YAccel $0002 2 
$00la 26 XAccel $0004 4 
$001lc 28 RingYTrans $0005 5 
$00le 30 RingXTrans $0006 6 
$0020 32 AnimORoutine $0007 7 
$0024 36 HeadComp $0008 8 
$0028 40 AUserExt $000c 12 
AreaInfo CIA: 
$0018 24 sizeof (AreaInfo) $0f02 3842 
$0000 0 VetrTbl $0000 0 
$0004 4 VetrPtr $0001 1 
$0008 8 FlagTbl $0100 256 
$000c 12 FlagPtr $0101 257 
$0010 16 Count $0200 512 
$0012 18 MaxCount $0201 513 
$0014 20 Firstx $0300 768 
$0016 22. FirstY $0301 769 
AudChannel: $0400 1024 
$0010 16 sizeof (AudChannel) $0401 1025 
$0000 0 ac_ptr $0500 1280 
$0004 4 ac_len $0501 1281 
$0006 6 ac_per $0600 1536 
$0008 8 ac_vol $0601 1537 
$000a 10 ac_dat $0700 1792 
$000c 12 ac_pad[0] $0701 1793 
AvailFonts: $0800 2048 
$000a 10 sizeof (AvailFonts) $0801 2049 
$0000 0 af_Type $0900 2304 
$0002 2 af_Attr $0901 2305 
AvailFontsHeader: $0a00 2560 
$0002 sizeof (AvailFontsHeader) $0a01 2561 
$0000 0 afh_NumEntries $Ob00 2816 
BitMap: $0b01 2817 
$0028 40 sizeof (BitMap) $0c00 3072 
$0000 0 BytesPerRow $0c0l 3073 
§0002 2 Rows $0a00 3328 
$0004 4 Flags $0d01 3329 
$0005 5 Depth $0e00 3584 
$0006 6 pad $0e01 3585 
$0008 8 Planes[0] $0f00 3840 
Bob: ClipRect: 


sizeof (Bob) 
Flags 
SaveBuf fer 
ImageShadow 
Before 
After 
BobvSprite 
BobComp 
DBuf fer 
BUserExt 


sizeof (BooliInfo) 
Flags 

Mask 

Reserved 


sizeof (BootBlock) 
bb_id[0] 

bb chksum 
bb_dosblock 


sizeof (BootNode) 
bn_Node 
bn_Flags 
bn_DeviceNode 


sizeof (Border) 
LeftEdge 
TopEdge 
FrontPen 
BackPen 
DrawMode 
Count 

xY 

Next Border 


sizeof (CIA) 
ciapra 
pad0[0] 
ciaprb 
pad1 [0] 
ciaddra 
pad2 [0] 
ciaddrb 
pad3[0] 
ciatalo 
pad4 [0] 
ciatahi 
pad5 [0] 
ciatblo 
pad6 [0] 
clatbhi 
pad? [0] 
ciatodlow 
pad8 [0] 
ciatodmid 
pad9 [0] 
ciatodhi. 
pad10[0] 
unusedreg 
pad11[0] 
ciasdr 
pad12[0] 
ciaicr 
pad13[0] 
ciacra 
padi4[0] 
ciacrb 
































































Dec 8 02:04 1988 Structure Reference Page 2 


$0024 36 sizeof(ClipRect) $oOlile 284 
$0000 O Next $Olle 286 
$0004 4 prev $0120 288 
$0008 8 lobs $0122 290 
$000c 12 BitMap $0125 293 
$0010 16 bounds ConfigDev: 
$0018 24 _pl $0044 68 
$001lc 28 _p2 $0000 0 
$0020 32 reserved $000e 14 
ClipboardUnitPartial: $oo0t 15 
$0012 18 sizeof(ClipboardUnitPartial $0010 16 
$0000 0 cu_Node $0020 32 
$000e 14 cu_UnitNum $0024 36 
ColorMap $0028 40 
$0008 8 sizeof (ColorMap) $002a 42 
$0000 0 Flags $002c 44 
$0001 1 Type $0030 48 
$0002 2 Count $0034 52 
$0004 4 Colorfable CopiIns: 
CommandLineInterface: $0006 6 
$0040 64 sizeof(CommandLineInterface $0000 0 
$0000 0 cli_Result2 $0002 2 
$0004 4 cli_SetName $0002 2 
$0008 8 cli_CommandDir $0002 2 
$000c 12 cli_ReturnCode $0002 2 
$0010 16 cli_CommandName $0002 2 
$0014 20 cli_Faillevel $0002 2 
$0018 24 cli_Prompt $0004 4 
$00lc 28 cli _StandardInput $0004 4 
$0020 32 cli_CurrentInput $0004 4 
$0024 36 cli_CommandFile CopList: 
$0028 40 cli Interactive $0022 34 
$002c 44 cli_Background $0000 0 
$0030 48 cli_Currentoutput $0004 4 
$0034 52. cli_DefaultStack $0008 8 
$0038 56 cli _Standardoutput $000c 12 
$003c 60 cli Module $0010 16 
ConUnit: $0014 20 
$0128 296 sizeof (ConUnit) $0018 24 
$0000 0 cu_MP $00lc 28 
$0022 34 cu_Window $00le 30 
$0026 38 cu_XCP $0020 32 
$0028 40 cu_YCP CurrentBinding: 
$002a 42 cu_xXMax $0010 16 
$002c 44 cu_YMax $0000 0 
$002e 46 cu_XRSize $0004 4 
$0030 48 cu_YRSize $0008 8 
$0032 50 cu_XROrigin $000c 12 
$0034 52 cu_YROrigin Custom: 
$0036 54 cu_XRExtant $01c0 448 
$0038 56 cu_YRExtant $0000 0 
$003a 58 cu_XMinShrink $0002 2 
$003c 60 cu_YMinShrink $0004 4 
$003e 62 cu_XCCP $0006 6 
$0040 64 cu_YCCP $0008 8 
$0042 66 cu_KeyMapStruct $000a 10 
$0062 98 cu_TabStops[0] $000c 12 
$0102 258 cu_Mask $000e 14 
$0103 259 cu_FgPen $0010 16 
$0104 260 cu_BgPen $0012 18 
$0105 261 cu_AOLPen $0014 20 
$0106 262 cu_DrawMode $0016 22 
$OlL07 263 cu_AreaPtsSz $0018 24 
$0108 264 cu_AreaPtrn $oola 26 
$010c 268 cu_Minterms[0] $00lc 28 
$0114 276 cu_Font $00le 30 
$0118 280 cu_AlgoStyle $0020 32 
$0119 cu_TxFlags $0024 36 
solla cu_TxHeight $0026 38 






cu_TxWidth 
cu_TxBaseline 
cu_TxSpacing 
cu_Modes [0] 
cu_RawEvents [0] 


sizeof (ConfigDev) 
cd_Node 
ed_Flags 
cd_Pad 
cd_Rom 
cd_BoardAddr 
cd_Boardsize 
cd_SlotAddr 
cd_Slotsize 
cd_Driver 
cd_NextcD 
cd_Unused [0] 


sizeof (CopIns) 
od 


u3.u4.ul 
u3.u4.ul.VWaitPos 
u3.u4.ul.DestAddr 
u3.u4.u2 
u3.u4.u2.HWaitPos 
u3.u4.u2.DestData 


sizeof (CopList) 
Next 
_CopList 
_ViewPort 
CopiIns 
CopPtr 
CopLStart 
CopsSStart 
Count 
MaxCount 
DyOffset 


sizeof (CurrentBinding) 
cb _ConfigDev 
cb_FileName 

eb Productstring 

cb _ToolTypes 


sizeof (Custom) 
bltddat 
dmaconr 
vposr 
vhposr 
dskdatr 
joy0dat 
joyidat 
elxdat 
adkconr 
potddat 
potidat 
potinp 
serdatr 
dskbytr 
intenar 
intreqr 
dskpt 
dsklen 
dskdat. 








cS - H 





$0028 
$002a 
$002c 
$002e 
$0030 
$0032 
$0034 
$0036 
$0038 
$003a 
$003¢ 
$003e 
$0040 
$0042 
$0044 
$0046 
$0048 
$004c 
$0050 
$0054 
$0058 
$005a 
$0060 
$0062 
$0064 
$0066 
$0068 
$0070 
$0072 
$0074 
$0076 
$007e 
$0080 
$0084 
$0088 
$008a 
$008c 
$008e 
$0090 
$0092 
$0094 
$0096 
$0098 
$009a 
$009c 
$009e 
$00a0 
$00a0 
$00a4 
$00a6 
$00a8 
$00aa 
$00ac 
$00e0 
$oofs 
$0100 
$0102 
$0104 
$0106 
$0108 
$010a 
$010c 
$0110 
$Olle 
$0120 
$0140 
$0140 
$0142 
$0144 





Dec 8 02:04 1988 Structure Reference Page 3 


refptr 
vposw 
vhposw 
copcon 
serdat 
serper 
potgo 
joytest 

strequ 

strvbl 

strhor 

strlong 

bltcon0 

bltconl 

bltafwn 

bltalwn 

bltept 

bitbpt 

bltapt 

bltdpt 

bltsize 

pad2d [0] 
bltcmod 

bltbmod 

bitamod 

bitdmod 

pad34 [0] 
bltcdat 

bltbdat. 

bltadat 
pad3b[0] 
dsksync 

coplle 

cop21c 

copjmpl 

copjmp2 

copins 

diwstrt 

diwstop 

ddfstrt 

ddfstop 

dmacon 

clxcon 

intena 

intreq 

adkcon 

aud [0] 
aud[0].ac_ptr 
aud [0] .ac_len 
aud [0] .ac_per 
aud[0] .ac_vol 
aud[0].ac_dat 
aud[0].ac_pad[0] 
bplpt [0] 
pad7c[0] 
bplcon0 
bplconl 
bplcon2 
pad83 
bpllmod 
bp12mod 
pad86 [0] 
bpldat [0] 
pad8e[0] 
sprpt 0] 

spr [0] 

spr [0] .pos 
spr[0].ctl 
spr[0] .dataa 








$0146 
$0180 


326 
384 


DBufPacket: 


$000c 
$0000 
$0002 
$0004 
$0008 


DateStamp: 


$000c 
$0000 
$0004 
$0008 
Devinfo: 
$002c 
$0000 
$0004 
$0008 
$000c 
$0010 
$0014 
$0018 
$00ic 
$0020 
$0024 
$0028 
Device: 
$0022 
$0000 


12 
0 
2 


DeviceData: 


$0034 
$0000 
$0022 
$0026 
$002a 
$002e 
$0032 


DeviceList: 


$002c 
$0000 
$0004 
$0008 
$000c 
$0010 
$00lc 
$0020 
$0024 
$0028 


DeviceNode: 


$002c 
$0000 
$0004 
$0008 
$000c 
$0010 
$0014 
$0018 
$00lc 
$0020 
$0024 
$0028 
DiagArea: 
$000e 
$0000 
$0001 
$0002 
$0004 
$0006 
$0008 













spr[0].datab 
color [0] 


sizeof (DBufPacket) 
BufY 

BufX 

BufPath 

BufBuffer 


sizeof (DateStamp) 
ds_Days 
ds_Minute 
ds_Tick 


sizeof (DevInfo) 
dvi_Next 
dvi_' 
dvi_Task 
davi_Lock 
dvi_Handler 
davi_StackSize 
dvi_Priority 
dvi_Startup 
dvi_SegList 
dvi_GlobVec 
dvi_Name 


sizeof (Device) 
dd_Library 


sizeof (DeviceData) 
dd_Device 
dd_Segment 
dd_ExecBase 
dd_Cmdvectors 
dd_CmdBytes 
dd_NumCommands 


sizeof (DeviceList) 
dl Next 

dl_ Type 

dl_Task 

al_Lock 
dal_VolumeDate 
@l_LockList 
dl_DiskType 
dl_unused 

dl_Name 


sizeof (DeviceNode) 
dn_Next 
dn_Type 
dn_Task 
dn_Lock 
dn_Handler 
dn_StackSize 
dn_Priority 
dn_Startup 
dn_SegList 
dn_GlobalVec 
dn_Name 


sizeof (DiagArea) 
da_Config 
da_Flags 
da_Size 
da_DiagPoint 
da_BootPoint 
da_Name 

























































Dec 8 02:04 1988 Structure Reference Page 4 


$000a 10 da_Reserved01 $0036 54 sizeof (DosLibrary) 
$000c 12 da_Reserved02 $0000 0 dl_lib 
DiscResource: $0022 34 di_Root 
$0090 144 sizeof (DiscResource) $0026 38 .di_GV 
$0000 0 dr_Library $002a 42 dl_A2 
$0022 34 dr Current $002e 46 dl_A5 
$0026 38 dr_Flags $0032 50 dl_A6 
$0027 39 dr_pad DosList: 
$0028 40 dr SysLib $002c 44 sizeof(DosList) 
$002c 44 dr CiaResource $0000 0 dol_Next 
$0030 48 dr _UnitID[0] $0004 4 dol! 
$0040 64 dr Waiting $0008 8 dol_Task 
$004e 78 dr _DiscBlock $000c 12 dol_Lock 
$0064 100 dr DiscSync $0010 16 dol_misc 
$007a 122 dr_Index $0010 16 dol_misc.dol_handler 
DiscResourceUnit: $0010 16 dol_misc.dol_handler.dol_Ha| 
$0056 86 sizeof (DiscResourceUnit) $0014 20 dol_misc.dol_handler.dol_ St 
$0000 0 dru_Message $0018 24 dol_misc.dol_handler.dol_P 
$0014 20 dru_DiscBlock $001c 28 dol_misc.dol_handler.dol_St 
$002a 42 dru_DiscSyne $0020 32 dol_misc.dol_handler.dol_Se| 
$0040 64 dru_Index $0024 36 dol_misc.dol_handler.dol_Gl 
DiskFontHeader: $0010 16 dol_misc.dol_volume 
$006a 106 sizeof (DiskFontHeader) $0010 16 dol_misc.dol_volume.dol_Vol 
$0000 0 dfh_DF $001lc 28 dol_misc.dol_volume.dol_Loc 
$000e 14 dfh_FileID $0020 32 dol_misc.dol_volume.dol_Dis| 
$0010 16 dfh_ Revision $0028 40 dol_Name 
$0012 18 dfh_Segment DosPacket: 
$0016 22 dfh_Name[0] $0030 48 sizeof (DosPacket) 
$0036 54 dfh_TF $0000 0 dp Link 
DiskObject: $0004 4 dp Port 
$004e 78 sizeof (Diskobject) $0008 8 dp Type 
$0000 0 do Magic $000c 12 dp_Resl 
$0002 2 do_Version $0010 16 dp_Res2 
$0004 4 do_Gadget $0014 20 dp_Argl 
$0030 48 do! $0018 24 dp _Arg2 
$0032 50 do_DefaultTool $00lc 28 dp Arg3 
$0036 54 do_ToolTypes $0020 32 dp_Arg4 
$003a 58 do_CurrentXx $0024 36. dp_ArgS 
$003e 62 do_CurrentYy $0028 40 dp Arg6 
$0042 66 do_DrawerData $002c 44 dp Arg7 
$0046 70 do_ToolWindow DrawerData: 
$004a 74 do_StackSize $0038 56 sizeof (DrawerData) 
DosEnvec: $0000 0 dd_NewWindow 
$0044 68 sizeof(DosEnvec) $0030 48 dd_Currentx 
$0000 0 de_TableSize $0034 52 dd_CurrentY 
$0004 4 de_SizeBlock ExecBase: 
$0008 8 de SecOrg $024c 588 sizeof (ExecBase) 
$000c 12 de_Surfaces $0000 0 LibNode 
$0010 16 de_SectorPerBlock $0022 34 SoftVer 
$0014 20 de BlocksPerTrack $0024 36 LowMemChkSum 
$0018 24 de Reserved $0026 38 ChkBase 
$00lc 28 de PreAlloc $002a 42 ColdCapture 
$0020 32 de_Interleave $002e 46 CoolCapture 
$0024 36 de_LowCyl $0032 50 WarmCapture 
$0028 40 de HighCyl $0036 54 SysStkUpper 
$002c 44 de_NumBuffers $003a 58 SysStkLower 
$0030 48 de_BufMemType $003e 62 MaxLocMem 
$0034 52 de MaxTransfer $0042 66 DebugEntry 
$0038 56 de_Mask $0046 70 DebugData 
$003c 60 de_BootPri $004a 74 AlertData 
$0040 64 de _DosType $004e 78 MaxExtMem 
DosInfo $0052 82 ChkSum 
$0014 20 sizeof (DosInfo) $0054 84 IntVects[0] 
$0000 0 di_McName $0114 276 ThisTask 
$0004 4 di _DeviInfo $0118 280 IdleCount 
$0008 8 di_Devices $Olle 284 DispCount 
$000c 12 di_Handlers $0120 288 Quantum 
$0010 16 di_NetHand $0122 290 Elapsed 
DosLibrary: $0124 292 SysFlags 











€S - H 


Dec 8 02:04 1988 Structure Reference Page 5 


$0126 294 IDNestCnt 

$0127. 295 TDNestCnt 

$0128 296 AttnFlags 

$0l2a 298 AttnResched 

$012c 300 ResModules 

$0130 304 TaskTrapCode 

$0134 308 TaskExceptCode 

$0138 312 TaskExitCode 

$013c 316 TaskSigAlloc 

$0140 320 TaskTrapAlloc 

$0142 322 MemList 

$0150 336 ResourceList 

$015e 350 Devicehist 

$0l6c 364 IntrList 

$0l7a 378 LibbList 

$0188 392 PortList 

$0196 406 TaskReady 

$0la4 420 TaskWait 

$0lb2 434 SoftInts[0] 

$0202 514 LastAlert[0} 

$0212 530 VBlankFrequency 

$0213 531 PowerSupplyFrequency 

$0214 532 SemaphoreList 

$0222 546 KickMemPtr 

$0226 550 KickTagPtr 

$022a 554 KickCheckSum 

$022e 558 ExecBaseReserved [0] 

$0238 568 ExecBaseNewReserved [0] 
ExpansionBase: 

$01c8 456 sizeof (ExpansionBase) 

$0000 0 LibNode 

$0022 34 Flags 

$0023 35 pad 

$0024 36 ExecBase 

$0028 40 SegList 

$002c 44 CurrentBinding 

$003c 60 BoardList 

$004a 74 MountList 

$0058 88 AllocTable[0] 

$0158 344 BindSemaphore 

$0186 390 Int2List 

$019c 412 IntéList 

$01b2 434 Int7List 
ExpansionControl: 

$0010 16 sizeof(ExpansionControl) 

$0000 0 ec_Interrupt 

$0001 1 ec _Reservedl1l 

$0002 2 ec_BaseAddress 

$0003 3. ec_Shutup 

$0004 4 ec_Reservedl4 

$0005 5 ec_Reserved15 

$0006 6 ec_Reserved16 

$0007 7 ec _Reservedl7 

$0008 8 ec_Reserved18 

$0009 9 ec_Reservedl9 

$000a 10 ec _Reservedla 

$000b 1l ec_Reservedlb 

$000c 12 ec_Reservedlc 

$000d 13 ec _Reservedid 

$000e 14 ec_Reservedle 

$oo00f 15 ec _Reservedlf 
ExpansionInt: 

$0006 6 sizeof(ExpansionInt) 

$0000 QO IntMask 

$0002 2 ArrayMax 

$0004 4 ArraySize 
ExpansionRom: 

$0010 16 sizeof (ExpansionRom) 


$0000 0 


er! 





Dec 8 02:04 1988 Structure Reference Page 6 


Flags 
Activation 
GadgetType 
GadgetRender 
SelectRender 
GadgetText 
MutualExclude 
Specialinfo 
Gadget ID 
UserData 


GamePortTrigger: 


$0001 1 er Product $000c 
$0002 2 er_Flags $000e 
$0003 3 er Reserved03 $0010 
$0004 4 er Manufacturer $0012 
$0006 6 er SerialNumber $0016 
$000a 10 er_InitDiagVvec $00la 
$000c 12 er_Reserved0c $00le 
$000d 13 er_Reserved0d $0022 
$000e 14 er_Reserved0e $0026 
soooft 15 er_ReservedOf $0028 
FileHandle: 
$002c 44 sizeof (FileHandle) $0008 
$0000 0 fh_Link $0000 
$0004 4 fh_Port $0002 
$0008 8 fh’ $0004 
$000c 12 fh_Buf 
$0010 16 -fh_Pos 
$0014 20 fh_End 
$0018 24 fh_Funcs 
$o00lc 28 fh_Func2 
$0020 32 fh_Func3 
$0024 36 fh_Args 
$0028 40 fh Arg2 
FileInfoBlock: 
$0104 260 sizeof(FileInfoBlock) 
$0000 0 fib_DiskKey 
$0004 4 fib _DirEntryType 
$0008 8 fib_FileName[0} 
$0074 116 fib Protection 
$0078 120 fib EntryType 
$007ec 124 fib_Size 
$0080 128 fib_NumBlocks 
$0084 132 fib Date 
$0090 144 fib _Comment [0} 
$00e0 224 fib_Reserved[0] 
Filebock: 
$0014 20 sizeof (FileLock) 
$0000 0 fl_Link 
$0004 4 fl_Key 
$0008 8 f1 Access 
$000c 12 £1_Task 
$0010 16 £1_Volume 
FileSysStartupMsg: 
$0010 16 sizeof (FileSysStartupMsg) 
$0000 0 fssm_Unit 
$0004 4 fssm_Device 
$0008 8 fssm_Environ 
$000c 12 fssm_Flags 
FontContents: 
$0104 260 sizeof(FontContents) 
$0000 0 fc_FileName[0] 
$0100 256 fc_YSize 
$0102 258 fc_Style 
$0103 259 fc_Flags 
FontContentsHeader: 
$0004 4 sizeof(FontContentsHeader) 
$0000 0 fch_FileID 
$0002 2  fch_NumEntries 
FreeList: 
$0010 16 sizeof(FreeList) 
$0000 0 £1 _NumFree 
$0002 2 £1 MemList 
Gadget: 
$002¢ 44 sizeof(Gadget) 
$0000 0 NextGadget 
$0004 4 LeftEdge 
$0006 6 TopEdge 
$0008 8 Width 
$000a 10 Height 


sizeof (GamePortTrigger ) 
gpt_Keys 

gpt_Timeout 

gpt_XDelta 

gpt_YDelta 


sizeof (GelsInfo) 
sprRsrvd 
Flags 
gelHead 
gelTail 
nextLine 
lastColor 
collHandler 
leftmost 
rightmost 
topmost 

bot tommost 
firstBlissObj 
lastBlissobj 


sizeof (GfxBase) 
LibNode 
Actiview 
copinit 

cia 

blitter 
LOFlist 
SHFlist 

blthd 

blttl 

bsblthd 
bsblttl 

vbsrv 

timsrv 

bltsrv 
TextFonts 
DefaultFont 
Modes 

VBlank 

Debug 

BeamSync 
system_bplcon0 
SpriteReserved 
bytereserved 
Flags 

BlitLock 
BlitNest 
BlitwWaitQ 
BlitOwner 

TOF _Waito 
DisplayFlags 
SimpleSprites 
MaxDisplayRow 
MaxDisplayColumn 
NormalDisplayRows 
NormalDisplayColumns 
Norma 1DPMX 


$00de 
$00e0 
$00e4 
$00e8 
$00ea 
$00ec 
IOAudio: 
$0044 
$0000 
$0020 
$0022 
$0026 
$002a 
$002c 
$002e 
$0030 
IOC1lipReq: 
$0034 
$0000 
$0014 
$0018 
$00lc 
$00le 
$oolft 
$0020 
$0024 
$0028 
$002c 
$0030 
JODRPReq : 
$003e 
$0000 
$0014 
$0018 
$001c 
$00le 
$o0lf 
$0020 
$0024 
$0028 
$002c 
$002e 
$0030 
$0032 
$0034 
$0038 
$003c 
IOEXxtPar: 
$003e 
$0000 
$0030 
$0034 
$0035 
$0036 
IOExtSer: 
$0052 
$0000 
$0030 
$0034 
$0038 
$003c 
$0040 
$0044 
$004c 
$004d 
$004e 
$oo4t 
$0050 
IOEXtTD: 


Norma 1DPMY 
LastChanceMemory 
LCMptr 
MicrosPerLine 
MinDisplayColumn 
reserved [0] 


sizeof (IOAudio) 
ioa_Request 
ioa_Allockey 
ioa_Data 
ioa_Length 
ioa_Period 
ioa_Volume 
ioa_Cycles 
ioa_WriteMsg 


sizeof (IOClipReq) 
io_ Message 
io_Device 
io_Unit 
io_Command 
io Flags 
io_Error 
io Actual 
io_Length 
io_Data 
io_Offset 
io_ClipID 


sizeof ( IODRPReq) 
io_Message 
jio_Device 
io_Unit 
io_Command 
io_Flags 
jio_Error 
io_RastPort 
io_ColorMap 
io_Modes 
io_Srcx 
io_SrcY 
io_SrceWidth 
io_SrcHeight 
io_DestCols 
io_DestRows 
io_Special 


sizeof (IOExtPar) 
IoPar 
io_PExtFlags 
io_Status 
io_ParFlags 
io_PTermArray 


sizeof ( IOExtSer) 
IOSer 
io_Ctlchar 
io_RBufLen 
io_ExtFlags 
io_Baud 
io_BrkTime 
io_TermArray 
io_ReadLen 
io_WriteLen 
io_StopBits 
io_SerFlags 
io_Status 












Dec 8 02:04 1988 Structure Reference Page 8 





Dec 8 02:04 1988 Structure Reference Page 7 




















































































































































































































$0038 56 sizeof(IOExtTD) $0000 0 ie _NextEvent $0010 16 km_HikeyMapTypes $0004 4 lh Tail 
$0000 0 iotd_Reg $0004 4 ie Class $0014 20 km_HikeyMap $0008 8 lh_TailPred 
$0030 48 iotd Count $0005 5. ie_SubClass $0018 24 km _HiCapsable $000c 12) Lh! 
$0034 52 iotd_SecLabel $0006 6 ie Code $001c 28 km_HiRepeatable $000d 13 l_pad 
IOPArray: $0008 8 ie Qualifier KeyMapNode: MathIEEEBase: 
$0008 8 sizeof (IOPArray) $000a 10 ie position $002e 46 sizeof (KeyMapNode) $003c 60 sizeof (MathIEEEBase) 
$0000 0 PTermArray0 $000a 10 ie _position.ie xy $0000 0 kn_Node $0000 0 MathIEEEBase_LibNode 
$0004 4 PTermArrayl $000a 10 ie_position.ie_xy.ie_x $000e 14 kn_KeyMap $0022 34 MathIEEEBase_Flags 
roPprtCcmdReq $000c 12 ie _position.ie xy.ie_y KeyMapResource: $0023 35 MathIEEEBase_reservedl 
$0026 sizeof (IOPrtcmdReg) $000a 10 ie_position.ie_addr $00ic 28 sizeof (KeyMapResource) $0024 36 MathIEEEBase_68881 
$0000 0 io Message $000e 14 ie _TimeStamp $0000 0 kr_Node $0028 40 MathIEEEBase_SysLib 
$0014 20 io_Device IntVector: $000e 14 kr_List $002c 44 MathIEEEBase_SegList 
$0018 24 io Unit $000c 12 sizeof(IntVector) Layer: $0030 48 MathIEEEBase_Resource 
$001¢ 28 io Command $0000 0 iv_Data $00a0 160 sizeof (Layer) $0034 52 MathIEEEBase_TaskOpenLib 
$00le 30 io Flags $0004 4 iv Code $0000 Q front $0038 56 MathIEEEBase_TaskCloseLib 
SOO1E 31 io_Error $0008 8 iv_Node $0004 4 back MathIEEEResource: 
$0020 32 io_PrtCommand Interrupt: $0008 8 ClipRect $002c 44 sizeof (MathIEEEResource) 
$0022 34 io_Parm0 $0016 22 sizeof(Interrupt) $000c 12. rp $0000 0 MathIEEEResource_Node 
$0023 35 io _Parml $0000 0 is_Node $0010 16 bounds $000e 14 MathIEEEResource_Flags 
$0024 36 io _Parm2 $000e 14 is_Data $0018 24 reserved[0] $0010 16 MathIEEEResource_BaseAddr 
$0025 37 io _Parm3 $0012 18 is_Code $00lc 28 priority $0014 20 MathIEEEResource_Dbl1BasInit 
TORequest IntuiMessage: $00le 30 Flags $0018 24 MathIEEEResource_DblTransIn 
$0020 32 sizeof (IORequest) $0034 52 sizeof (IntuiMessage) $0020 32 SuperBitMap $001lc 28 MathIEEEResource_SglBasInit 
$0000 0 io Message $0000 0 ExecMessage $0024 36 SuperClipRect $0020 32 MathIEEEResource_SglTransIn 
$0014 20 io Device $0014 20 Class $0028 40 Window $0024 36 MathIEEEResource_ExtBasInit 
$0018 24 io Unit $0018 24 Code $002c 44 Scroll_x $0028 40 MathIEEEResource_ExtTransInj 
$00l¢ 28 io Command $o00la 26 Qualifier $002e 46 Scroll_y MemChunk : 
$00le 30 io Flags $00le 28 IAddress $0030 48 cr $0008 8 sizeof (MemChunk) 
$oolf 31 io Error $0020 32 Mousex $0034 52 cr2 $0000 0 mc_Next 
IostdReq $0022 34 Mousey $0038 56 crnew $0004 4 mc_Bytes 
$0030 48 sizeof (IOStdReq) $0024 36 Seconds $003c 60 SuperSaveClipRects MemEntry: 
$0000 0 io_Message $0028 40 Micros $0040 64 _cliprects $0008 8 sizeof (MemEntry) 
™! $0014 20 io Device $002c 44 IDCMPWindow $0044 68 lLayerInfo $0000 0 me_Un 
| $0018 24 io_Unit $0030 48 SpecialLink $0048 72 Lock $0000 0 me_Un.meu_Reqs 
uw} $001¢ 28 io_Command Intuifext: $0076 118 reserved3([0] $0000 0 me_Un.meu_Addr 
=! $00le 30 io Flags $0014 20 sizeof(IntuiText) $007e 126 ClipRegion $0004 4 me_Length 
$oolf 31 io_Error $0000 0 FrontPen $0082 130 saveClipRects MemHeader : 
$0020 32 io_Actual $0001 1 BackPen $0086 134 reserved2(0] $0020 32 sizeof (MemHeader) 
$0024 36 io_Length $0002 2 DrawMode $009c 156 DamageList $0000 0 mh_Node 
$0028 40 io Data $0004 4 lLeftEdge Layer Info: $000e 14 mh_Attributes 
$002c 44 io Offset $0006 6 TopEdge 0066 102 sizeof(Layer_Info) $0010 16 mh_First 
IOTArray $0008 8 ITextFont $0000 0 top_layer $0014 20 mh_Lower 
$0008 8 sizeof(10TArray) $000c 12 Text $0004 4 check_lp $0018 24 mh_Upper 
$0000 0 TermArray0 $0010 16 . NextText $0008 8 obs $00lc 28 mh_Free 
$0004 4 TermArrayl IntuitionBase: $000c 12 FreeClipRects MemList: 
Image: $0050 80 sizeof(IntuitionBase) $0018 24 Lock $0018 24 sizeof(MembList) 
$0014 20 sizeof (Image) $0000 0 LibNode $0046 70 gs_Head $0000 0 ml_Node 
$0000 0 LeftEdge $0022 34. ViewLord $0054 84 longreserved $000e 14 mi_NumEntries 
$0002 2 TopEdge $0034 52 ActiveWindow $0058 88 Flags $0010 16 mi_ME[0] 
$0004 4 Width $0038 56 ActiveScreen $005a 90 fatten_count Menu: 
$0006 6 Height $003c 60 FirstScreen $005b 91 LockLayersCount $00le 30 sizeof (Menu) 
$0008 8 Depth $0040 64 Flags $005c 92 lLayerInfo_extra_size $0000 0 NextMenu 
$000a 10 ImageData $0044 68 MouseY $005e 94 blitbuff $0004 4 lLeftEdge 
$000e 14 PlanePick $0046 70 MouseX $0062 98 LayerInfo_extra $0006 6 TopEdge 
$000f 15 Planeonoff $0048 72 Seconds Library $0008 8 Width 
$0010 16 NextImage $004c 76 Micros $0022 34 sizeof(Library) $000a 10 Height 
InfoData Isrvstr: $0000 0 lib Node $000c 12 Flags 
$0024 36 sizeof(InfoData) $00le 30. sizeof(Isrvstr) $000e 14 lib_Flags $000e 14 MenuName 
$0000 0 id_NumSoftErrors $0000 0 is_Node $ooof 15 lib pad $0012 18 FirstItem 
$0004 4 id_UnitNumber $000e 14 Iptr $0010 16 lib _NegSize $0016 22 Jaz2zx 
$0008 8 id _DiskState $0012 18 code $0012 18 lib PosSize $0018 24 Jazzy 
$000c 12 id_NumBlocks $0016 22 ccode $0014 20 lib Version $00la 26 BeatX 
$0010 16 id _NumBlocksUsed $00la 26 Carg $0016 22 lib Revision $001c 28 Beaty 
$0014 20 id _BytesPerBlock KeyMap: $0018 24 lib IdString MenuiItem: 
$0018 24 id _DiskType $0020 32 sizeof (KeyMap) $00lc 28 lib Sum $0022 34 sizeof (MenuItem) 
$00lc 28 id _VolumeNode $0000 0 km_LoKeyMapTypes $0020 32 lib _Opencnt $0000 0 NextItem 
$0020 32 id_InUse $0004 4 km_LoKeyMap List: $0004 4 LeftEdge 
InputEvent: $0008 8 km_LoCapsable $000e 14 sizeof(List) $0006 6 TopEdge 
$0016 22 sizeof(InputEvent) $000c 12 km _LoRepeatable 0 1h Head $0008 8 Width 





GG - H 








Dec 8 02:04 1988 Structure Reference Page 9 Dec 8 02:04 1988 Structure Reference Page 10 











$000a 10 Height $000e 14 sizeof (Node) $0068 104 pd_PBothReady $0004 4 VertPot 

$000c 12 Flags $0000 0 1n_Succ $006c 108 pd_iord $0006 6 HorizBody 

$000e 14 MutualExclude $0004 4 ln Pred $006c 108 pd_ior0.pd_p0 $0008 8 VertBody 

$0012 18 ItemPFill $0008 8 I1n_Type $006c 108 pd_ior0.pd_s0 $000a 10 CWidth 

$0016 22 SelectFill $0009 9 In_Pri $00be 190 | iorl $000c 12 CHeight 

$00la 26 Command $000a 10 1n_Name $00be 190 pd_iorl.pd_pl $000e 14 HPotRes 

$001lc 28 SubItem Preferences: $00be 190 pd_iorl.pd_sl $0010 16 VPotRes 

$0020 32 NextSelect $00e8 232 sizeof(Preferences) $0110 272 pd_TIOR $0012 18 LeftBorder 
Message: $0000 0 .FontHeight $0138 312 pd_IORPort $0014 20 TopBorder 

$0014 20 sizeof (Message) $0001 1 PrinterPort $015a 346 pd_TC PrtInfo: 

$0000 0 mn_Node $0002 2 BaudRate $01b6 438 pd_stk[0] $0072 114 sizeof(PrtInfo) 

$000e 14. mn_ReplyPort $0004 4 KeyRptSpeed $09b6 2486 pd_Flags $0000 0 pi_render 

$0012 18 mn_Length $000c 12 KeyRptDelay $09b7 2487 pd_pad $0004 4 pi_rp 
MinList: $0014 20 DoubleClick $09b8 2488 pd_Preferences $0008 8 pi_temprp 

$000c 12 sizeof(MinList) $001ic 28 PointerMatrix[0] $0aa0 2720 pd_PWaitEnabled $000c 12 pi_RowBuf 

$0000 0 mlh_Head $0064 100 xOffset PrinterExtendedData: $0010 16 pi_HamBuf 

$0004 4 mlh_Tail $0065 101 Yoffset $0042 66 sizeof(PrinterExtendedData) $0014 20 pi_ColorMap 

$0008 8 mlh_TailPred $0066 102 colorl7 $0000 0 ped_PrinterName $0018 24 pi_Colorint 
MinNode: $0068 104 colorl8 $0004 4 ped_Init $00lc 28 pi_HamInt 

$0008 8 sizeof (MinNode) $006a 106 colorl9 $0008 8 ped_Expunge $0020 32 pi_DestlInt 

$0000 0 mln_Succ $006c 108 PointerTicks $000c 12 | Open $0024 36 pi_Dest2Int 

$0004 4 min Pred $006e 110 colord $0010 16 ped_Close $0028 40 pi_Scalex 
MiscResource: $0070 112 colorl $0014 20 ped_PrinterClass $002c 44 pi_ScaleXAlt 

$0032 50 sizeof (MiscResource) $0072 114 color2 $0015 21 ped_ColorClass $0030 48 pi_dmatrix 

$0000 O mr_Library $0074 116 color3 $0016 22 | MaxColumns $0034 52 pi_TopBuf 

$0022 34 mr_Allocarray[0} $0076 118 Viewxoffset $0017 23 ped _NumCharSets $0038 56 pi_BotBuf 
MsgPort: $0077. 119 ViewYOffset $0018 24 ped_NumRows $003c 60 pi RowBufSize 

$0022 34 sizeof (MsgPort) $0078 120 ViewInitx $00la 26 ped_MaxXDots $003e 62 pi_HamBufSize 

$0000 0 mp_Node $007a 122 ViewInitY $00le 30 ped_MaxYDots $0040 64 pi_ColorMapSize 

$000e 14 mp_Flags $007c 124 EnableCLI $0022 34 ped_xXDotsInch $0042 66 pi_ColorintSize 

SO00£ 15 mp SigBit $007e 126 PrinterType $0024 36 ped_YDotsInch $0044 68 pi_HamIntSize 

$0010 16 mp_SigTask $0080 128 PrinterFilename[0] $0026 38 ped_Commands $0046 70 pi_DestlintSize 

$0014 20 mp_MsgList $009e 158 PrintPitch $002a 42 ped_DoSpecial $0048 72 pi _Dest2IntSize 
NewScreen: $00a0 160 PrintQuality $002e 46 ped_Render $004a 74 pi_ScalexsSize 

$0020 32 sizeof (NewScreen) $00a2 162 PrintSpacing $0032 50 ped_TimeoutSecs $004c 76 pi_ScaleXAltSize 

$0000 0 lLeftEdge $00a4 164 PrintLeftMargin $0036 54 ped_8BitChars $004e 78 pi_PrefsFlags 

$0002 2 TopEdge $00a6 166 PrintRightMargin $003a 58 ped _PrintMode $0050 80 pi_special 

$0004 4 Width $00a8 168 PrintImage $003e 62 ped_ConvFunc $0054 84 pi_xstart 

$0006 6 Height $00aa 170 PrintAspect PrinterSegment : $0056 86 pi_ystart 

$0008 8 Depth $00ac 172 PrintShade $004e 78 sizeof (PrinterSegment) $0058 88 pi_width 

$000a 10 DetailPen $00ae 174 PrintThreshold $0000 0 ps _NextSegment $005a 90 pi_height 

$000b 11 BlockPen $00b0 176 PaperSize $0004 4 ps_runAlert $005¢ 92 pi_pe 

$000c 12 ViewModes $00b2 178 PaperLength $0008 8 ps_Version $0060 96 pi_pr 

$000e 14 Type $00b4 180 PaperType $000a 10 ps_Revision $0064 100 pi_ymult 

$0010 16 Font $00b6 182 SerRWBits $000c 12 ps_PED $0066 102 pi_ymod 

$0014 20 DefaultTitle $00b7. 183 SerStopBuf Process: $0068 104 pi_ety 

$0018 24 Gadgets $00b8 184 SerParShk $00bc 188 sizeof(Process) $006a 106 pi_xpos 

$001lc 28 CustomBitMap $00b9 185 LaceWB $0000 0 pr_Task $006c 108 pi_threshold 
NewWindow: $00ba 186 WorkName[0] $005c 92 pr _MsgPort $006e 110 pi_tempwidth 

$0030 48 sizeof (NewWindow) $00d8 216 RowSizeChange $007e 126 pr_Pad $0070 112 pi_flags 

$0000 0 LeftEdge $00d9 217 + ColumnsSizeChange $0080 128 pr_SegList RasInfo: 

$0002 2 Topkdge $00da 218 PrintFlags $0084 132 pr_StackSize $000c 12 sizeof (RasInfo) 

$0004 4 Width $00dc 220 PrintMaxWidth $0088 136 pr_GlobVec $0000 0 Next 

$0006 6. Height $00de 222 PrintMaxHeight $008c 140 pr_TaskNum $0004 4. BitMap 

$0008 8 DetailPen $00e0 224 PrintDensity $0090 144 pr _StackBase $0008 8 RxOffset 

$0009 9 BlockPen $00e1 225 Printxoffset $0094 148 pr _Result2 $000a 10 RyOffset 

$000a 10 IDCMPFlags $00e2 226 wh_Width $0098 152 pr_CurrentDir RastPort: 

$000e 14 Flags $00e4 228 wb _Height $009c 156 pr_CcIS $0064 . 100 sizeof (RastPort) 

$0012 18 FirstGadget $00e6. 230 whb_Depth $00a0 160 pr_cos $0000 0 Layer 

$0016 22 CheckMark $00e7 231 ext_size $00a4 164 pr _ConsoleTask $0004 4 BitMap 

sodla 26 Title PrinterData: $00a8 168 pr_FileSystemTask $0008 8 AreaPtrn 

$00le 30 Screen $Qaa2 2722 sizeof(PrinterData) $00ac 172 pr_CLI $000c 12 TmpRas 

$0022 34 BitMap $0000 0 pd_Device $00b0 176 pr_ReturnAddr $0010 16 AreaInfo 

$0026 38 MinWidth $0034 52 pd_Unit $00b4 180 pr_PktWait $0014 20 GelsInfo 

$0028 40 MinHeight $0056 86 | PrinterSegment $00b8 184 pr _WindowPtr $0018 24 Mask 

$002a 42 MaxWidth $005a 90 pd_PrinterType PropInfo: $0019 25 FgPen 

$002c 44 MaxHeight $005c 92 | SegmentData $0016 22 sizeof(Propinfo) $00la 26 BgPen 

$002e 46 Type $0060 96 pd _PrintBuf $0000 0 Flags $001b 27 aAOlPen 










Node: $0064 100 pd_PWrite $0002 2 HorizPot $001l¢c 28 DrawMode 








Dec 8 02:04 1988 Structure Reference Page 11 


$001d 29 AreaPtSz 
$00le 30 linpatent 
$OO1E 3] dummy 
$0020 32 Flags 
$0022 34 LinePtrn 
$0024 36 cp_x 
$0026 38 cp_y 
$0028 40 minterms[0] 
$0030 48 PenWidth 
$0032 50 PenHeight 
$0034 52 Font 
$0038 56 AlgoStyle 
$0039 57 TxPlags 
$003a 58 TxHeight 
$003c 60 TxWidth 
$003e 62 TxBaseline 
$0040 64 TxSpacing 
$0042 66 RP User 
$0046 70 longreserved [0] 
$004e 78 wordreserved [0] 
$005c 92 reserved[0] 
Rectangle: 
$0008 8 sizeof (Rectangle) 
$0000 O Minx 
$0002 2 Miny 
$0004 4 MaxX 
$0006 6 MaxY 
Region: 
$000c 12 sizeof (Region) 
$0000 0 bounds 
$0008 8 RegionRectangle 
RegionRectangle: 
=! $0010 16 sizeof (RegionRectangle) 
| $0000 O Next 
ul $0004 4 Prev 
a $0008 8 bounds 
Remember : 
$000c 12 sizeof (Remember) 
$0000 0 NextRemember 
$0004 4 RememberSize 
$0008 8 Memory 
Requester: 
$0070 112 sizeof(Requester) 
$0000 0 OlderRequest 
$0004 4 LeftEdge 
$0006 6 TopEdge 
$0008 8 Width 
$000a 10 Height 
$000c 12 RelLeft 
$000e 14 RelTop 
$0010 16 ReqGadget 
$0014 20 ReqBorder 
$0018 24 ReqText 
$00lc 28 Flags 
$00le 30 BackFill 
$0020 32 ReqLayer 
$0024 36 RegPad1[0] 
$0044 68 ImageBMap 
$0048 72  RWindow 
$004c 76 RegPad2[0] 
Resident: 
$00la 26 sizeof (Resident) 
$0000 0 rt_MatchWord 
$0002 2 xrt_MatchTag 
$0006 6 rt _EndSkip 
$000a 10 xrt_Flags 
$000b 11 rt_Version 
$000c 12 rt_Type 
$000a 130 rt_Pri 


$000e 14 rt_Name 

$0012 18 rt_IdString 

$0016 22 rt_Iinit 
RomBootBase: 

$0044 68 sizeof (RomBootBase) 

$0000 0 lLibNode 

$0022 34 ExecBase 

$0026 38 BootList 

$0034 52 Reserved[0] 
RootNode: 

$0020 32 sizeof (RootNode) 

$0000 0 xrn_TaskArray 

$0004 4 xn_ConsoleSegment 

$0008 8 xrn_Time 

$0014 20 «xn_RestartSeg 

$0018 24 xrn_Info 

$001c 28 4xn_FileHandlerSegment 
SatisfyMsg: 

$00la 26 sizeof (SatisfyMsg) 

$0000 0 sm Msg 

$0014 20 sm_Unit 

$0016 22 sm_ClipID 
Screen: 

$015a 346 sizeof(Screen) 

$0000 0 NextScreen 

$0004 4 FirstWindow 

$0008 8 lLeftEdge 

$000a 10 TopEdge 

$000c 12 Width 

$000e 14 Height 

$0010 16 Mousey 

$0012 18 MouseX 

$0014 20 Flags 

$0016 22: Title 

$00la 26 DefaultTitle 

$00le 30 BarHeight 

$oolt 31 BarVBorder 

$0020 32 BarHBorder 

$0021 33 MenuVBorder 

$0022 34 MenuHBorder 

$0023 35 WBorTop 

$0024 36 WBorleft 

$0025 37 WBorRight 

$0026 38 WBorBottom 

$0028 40 Font 

$002c 44 ViewPort 

$0054 84 RastPort 

$00b8 184 BitMap 

$0060 224 LayerInfo 

$0146 326 FirstGadget 

$Ol4a 330 DetailPen 

$014b 331 BlockPen 

$0l4c 332 SaveColor0 

$0l4e 334 BarLayer 

$0152 338 ExtData 

$0156 342 UserData 
Semaphore: 

$0024 36 sizeof (Semaphore) 

$0000 QO sm _MsgPort 

$0022 34 sm_Bids 
SemaphoreRequest : 

$000c 12 sizeof (SemaphoreRequest) 

$0000 0 sr_Link 

$0008 8 sr_Waiter 
SignalSemaphore: 

$002e 46 sizeof (SignalSemaphore) 

$0000 0 ss_Link 

$000e 14 ss_NestCount 

$0010 16 ss_WaitQueue 


Dec 8 02:04 1988 Structure Reference Page 12 


$001ic 28 
$0028 40 
$002c 44 
SimpleSprite: 
$000c 12 
$0000 0 
$0004 4 
$0006 6 
$0008 8 
$000a 10 
SoftIntList: 
$0010 16 
$0000 0 
$000e 14 
SpriteDef : 
$0008 8 
$0000 0 
$0002 2 
$0004 4 
$0006 6 
StandardPacket: 
$0044 68 
$0000 0 
$0014 20 
StringInfo: 
$0024 36 
$0000 0 
$0004 4 
$0008 8 
$000a 10 
$000c 12 
$000e 14 
$0010 16 
$0012 18 
$0014 20 
$0016 22 
$0018 24 
$001lc 28 
$0020 32 
TDU_PublicUnit: 
$0036 54 
$0000 0 
$0026 38 
$0028 40 
$002a 42 
$002c 44 
$0030 48 
$0034 52 
Task: 
$005c 92 
$0000 0 
$000e 14 
$O00£ 15 
$0010 16 
$0011 17 
$0012 18 
$0016 22 
$00la 26 
$00le 30 
$0022 34 
$0024 36 
$0026 38 
$002a 42 
$002e 46 
$0032 50 
$0036 54 
$003a 58 
$003e 62 
$0042 66 


ss_MultipleLink 
ss_Owner 
ss_QueueCount 


sizeof (SimpleSprite) 
posctidata 

height 

x 


y 
num 


sizeof (SoftIntList) 
sh_List 
sh_Pad 


sizeof (SpriteDef) 
pos 

etl 

dataa 

datab 


sizeof (StandardPacket) 
sp_Msg 
sp_ Pkt 


sizeof (StringInfo) 
Buffer 
UndoBuf fer 
Buf ferPos 
MaxChars 
DispPos 
UndoPos 
NumChars 
DispCount 
Cleft 

CTop 
LayerPtr 
Longint 
AltKeyMap 


sizeof (TDU_PublicUnit) 
tdu_Unit 
tdu_Comp01Track 
tdu_Comp10Track 
tdu_Comp11Track 
tdu_StepDelay 
tdu_SettleDelay 
tdu_RetryCnt 


sizeof (Task) 
te_Node 
tc_Flags 
tc_State 
tc_IDNestCnt 
te_TDNestCnt 
te_SigAlloc 
te_SigwWait 
te_SigRecvd 
tc_SigExcept 
tc_TrapAlloc 
tc_TrapAble 
tc_ExceptData 
tc_ExceptCode 
tc_TrapData 
te_TrapCode 
te_SPReg 
tc_SPLower 
tc_SPUpper 
tc_Switch 








$0046 
$004a 
$0058 
TextAttr: 
$0008 
$0000 
$0004 
$0006 
$0007 
TextFont: 
$0034 
$0000 
$0014 
$0016 
$0017 
$0018 
$00la 
$00lc 
$00le 
$0020 
$0021 
$0022 
$0026 
$0028 
$002c 
$0030 
TmpRas: 
$0008 
$0000 
$0004 
UCopList: 
$000c 
$0000 
$0004 
$0008 
Unit: 
$0026 
$0000 
$0022 
$0023 
$0024 
vSprite: 
$003c 
$0000 
$0004 
$0008 
$000c 
$0010 
$0012 
$0014 
$0016 
$0018 
$00la 
$00lc 
$00le 
$0020 
$0022 
$0024 
$0028 
$002c 
$0030 
$0034 
$0038 
$0039 
$003a 
View: 
$0012 
$0000 
$0004 


te_Launch 
te_MemEntry 
te_UserData 


sizeof (TextAttr) 
ta_Name 
ta_yYSize 
ta_Style 
ta_Flags 


sizeof (TextFont) 
tf_Message 
tf_YSize 
tf£_Style 
tf_Flags 
tf_xSize 
tf_Baseline 
tf_BoldSmear 
tf_Accessors 
tf£_Lochar 
tf_HiChar 
tf£_CharData 
tf£_Modulo 
tf£_CharLoc 
tf£_CharSpace 
tf£_CharKern 


sizeof (TmpRas) 
RasPtr 
Size 


sizeof (UCopList) 
Next. 
FirstCopList 
CophList 


sizeof (Unit) 
unit_MsgPort. 
unit_flags 
unit _pad 
unit_OpencCnt 


sizeof (VSprite) 
NextVSprite 
PrevvVSprite 
DrawPath 
ClearPath 

Olay 

o1dx 

Flags 

YX 


Xx 

Height 
Width 
Depth 
MeMask 
HitMask 
ImageData 
BorderLine 
CollMask 
SprColors 
VSBob 
PlanePick 
Pianeonoff 
VUserExt. 


sizeof (View) 
ViewPort 
LOFCprList 


[Dec 8 02:04 1988 Structure Reference Page 13 Dee 8 02:04 1988 Structure Reference Page 14 


$0008 SHFCprList $005e MessageKey $0004 sizeof (colorEntry) 
$000c DyOffset $0062 DetailPen $0000 colorLong 
$000e DxOffset $0063 BlockPen $0000 colorByte[0} 
Modes $0064 CheckMark $0000 colorsByte[0] 
$0068 ScreenTitle 
sizeof (ViewPort) $006c GZ2ZMouseX 
Next $006e GZ2ZMouseY 
ColorMap $0070 GZzZWidth 
DspIns $0072 G22ZHeight 
SpriIns $0074 ExtData 
Clrins $0078 UserData 
UCopIns $007c WLayer 
DWidth $0080 IFont 
DHeight bltnode: 
DxOffset $0012 sizeof (bltnode) 
DyOffset $0000 n 
Modes $0004 function 
SpritePriorities $0008 stat 
reserved $000a blitsize 
RasInfo $000c beamsynec 
$000e cleanup 
sizeof (WBArg) collTable: 
wa_Lock $0040 sizeof (coliTfable) 
wa_Name $0000 collPtrs [0] 
copinit: 
sizeof (WBStartup) $005c sizeof (copinit) 
sm_Message $0000 diagstrt [0] 
sm_Process $0008 sprstrtup [0] 
sm_Segment $0058 sprstop [0] 
sm_NumArgs eprlist: 
sm_Too]lWindow $000a sizeof (cprlist) 
sm_Arglist $0000 Next 
$0004 start 
sizeof (Window) $0008 MaxCount 
NextWindow mouth_rb: 
LeftEdge $004a 74 sizeof (mouth_rb) 
TopEdge $0000 0 voice 
Width $0046 70 width 
Height $0047 71 height 
MouseY $0048 72 shape 
MouseX $0049 73 pad 
MinWidth narrator_rb: . 
MinHeight. $0046 0 sizeof(narrator_rb) 
MaxWidth $0000 message 
MaxHeight $0030 rate 
Flags $0032 pitch 
MenuStrip $0034 mode 
Title $0036 sex 
FirstRequest $0038 ch_masks 
DMRequest $003c nm_masks 
ReqCount $003e volume 
WScreen $0040 sampfreq 
RPort $0042 mouths 
BorderLeft $0043 chanmask 
BorderTop $0044 numchan 
BorderRight $0045 pad 
BorderBottom tPoint: 
BorderRPort $0004 sizeof (tPoint) 
FirstGadget timerequest: 
Parent $0028 4 sizeof (timerequest) 
Descendant. $0000 tr_node 
Pointer $0020 tr_time 
PtrHeight timeval: 
PtrwWidth $0008 sizeof (timeval) 
xoffset $0000 tv_secs 
yoffset $0004 tv_micro 
IDCMPFlags tPoint: 
UserPort $0004 sizeof (tPoint) 
WindowPort colorEntry: 





Section I 


IFF - Interchange File Format 


This section contains the specification for the Interchange File Format. JFF is a stan- 
dard for creating data files specifically designed for easy transfer between programs and 
machines. The text of these documents and the standard itself are in the public domain. 


One of the Amiga’s assets is the wide acceptance of several IFF specifications. Most not- 
able is the ease with which IFF graphic files (of form “ILBM”’) can be transferred among 
dozens of paint, animation, and special effects packages. The user can pick and choose 
among the strengths of several programs, rather than fighting the restrictions of just 
one. Developers can market specialized applications that are good at a certain limited 
set of operations, and with help of the multitasking operating system, create the effect of 
a large integrated system. 


We encourage all developers who wish to write out data files to adopt or expand an 
existing IFF specification. Or, if no current IFF form is suitable, to contact other 
developers and users with similar goals and work out a new specification. To prevent 
conflicts, new FORM identifications must be registered with Commodore before use. No 
additional restrictions are placed on the design of IFF FORMs, aside from the general 
IFF syntax rules. 


Contents of the IFF Section 


EA IFF 85 - General IFF Format Specifications 
Quick Introduction to TPF o......ccccccccceseccscses sess essssessscccececceceeseveueecucneeeners 
HA TPP 85 ooo ceeccccccceseeeeeceeeeeesssseseeececcsssseeeesesessssssececesnssrssteseeertennass 


Form Specifications from the Original EA Document 

ILBM - Interleaved Bitmap oo... ccccceecessesseesseessessesstenstsassnsssateneeeeess 
FTXT - Formatted Text .oocciccccccccccscsseceesssceecessssessessseccssseescesesssavensraeevens 
SMUS - Simple Musical Score oo... eccecssscecceecccssseeseeeceesessstsseeeevennnnsatas 
SSVX - 8-bit Sampled Voice oo... cece cecesseesecsssceeseseeeeessssesceesssecentrasesees 


Additional IFF Documents 
IFF News 10/88 - Notes and Registration Information ........c.cccccsceeeeees 
Registry 10/88 - New FORM & CHUNK registry, 

information & change Notes ooo. cccccessscceccceesessseeeesessestseeeescesecsssaneeees 
About ILBM - Introduction to ILBM and Amiga ViewModes .............000 
Background.doc - Design theory of the IFF code from Electronic Arts ..... 
Code.doc - Descriptions of the EA IFF sources from Electronic Arts ........ 


Third Party Public Registered FORM and Chunk Specifications 
8SVX.SMUS.CHAN and SMUS.PAN - Stereo SMUS (Gold Disk) ............. 
ACBM - Amiga Contiguous Bitmap (for AmigaBASIO) «0.00.0... 
ANBM - Animated Bitmap (EA) .0....c ccc ceeccceeeceeseeeeeeseeesesssseesececsesesseenies 
ANIM - Cel Animation (Aegis/Sparta) ..0...ccecccecceesecsecsseeseecseeescesseneessees 
HEAD - Idea processor (New Horizons) ........cccccececceseesceseseeeeseectseseeneeees 
ILBM.DPPV - DPaint ILBM Perspective chunk (EA) ...0... cc eeeeeeeeeeeenees 
PGTB - Program Traceback (Lattice) 00... ccc ecceeseeseeseeseesestssnettsseetneeees 
WORD - Word Processor (New Horizons) oo... cccccccccssesecssecsseceseeseeseensessees 


EA IFF Source Code 


Additional IFF Examples 

Display - Display ILBMs with print,cycle,and timer options .........00..cee 
PGTB - Replacement Lattice startup code with PGTB catcher ........0.0... 
ScreenSave - Save ILBM example with icon creation ...cc...cc cc ccceeeesceeenseeees 
cycvb.c - example cycle interrupt code ........cccccccecccceessececesseccceseetsseeeetenees 
apack.asm - assembler packer replacement ..........cccccccccccccccccccecesscececeeeceececs 


A Quick Introduction to JFF 


Jerry Morrison, Electronic Arts 
10-17-88 


IFF is the Amiga-standard “Interchange File Format", designed to work across many machines. 


Why IFF? 
Did you ever have this happen to your picture file? 


You can't load it into another paint program. 

You need a.converter to adopt to "ZooPaint" release 2.0 or a new hardware feature. 
You must “export” and “import” to use it in a page layout program. 

You can't move it to another brand of computer. 


What about interchanging musical scores, digitized audio, and other data? It seems the only thing that does 
interchange well is plain ASCII text files. 


It's inexcusable. And yet this is "normal" in MS-DOS. 


What is TIFF? 


IFF, the "Interchange File Format" standard, encourages multimedia interchange between different programs and 
different computers. It supports long-lived, extensible data. It's great for composite files like a page layout file that 
includes photos, an animation file that includes music, and a library of sound effects. 


IFF is a 2-level standard. The first layer is the "wrapper" or “envelope” structure for all IFF files. Technically, it's the 
syntax. The second layer defines particular IFF file types such as ILBM (standard raster pictures), ANIM (animation), 
SMUS (simple musical score), and 8SVX (8-bit sampled audio voice). 


IFF is also a design idea: 

programs should use interchange formats for their everyday storage 
This way, users rarely need converters and import/export commands to change software releases, application 
programs, or hardware. 


What's the trick? 


File compatibility is easy to achieve if programmers let go of one notion—dumping internal data structures to disk. 
A program's internal data structures should really be suited to what the program does and how it works. What's "best" 
changes as the program evolves new functions and methods. But a disk format should be suited to storage and 
interchange. 


Once we design internal formats and disk formats for their own separate purposes, the rest is easy. Reading and 
writing become behind-the-scenes conversions. But two conversions hidden in each program is much better than a pile 
of conversion programs. 

Does this seem strange? It's what ASCII text programs do! Text editors use line tables, piece tables, gaps, and other 
structures for fast editing and searching. Text generators and consumers construct and parse files. That's why the 
ASCII standard works so well. 


Also, every file must be self-sufficient. E.g. a picture file has to include its size and number of bits/pixel. 


I-1 


What's an IFF file look like? 


IFF is based on data blocks called "chunks". Here's an example color map chunk: 


0, 0, 0, 255, 
255, 255 ... 





char typelD[4] in an ILBM file, CMAP means "color map" 







unsigned long dataSize 48 data bytes 


char data] 16 3-byte color values: black, white, ... 





A chunk is made of a 4-character type identifier, a 32 bit data byte count, and the data bytes. It's like a Macintosh 
"resource" with a 32-bit size. 


Fine points: 

Every 16- and 32-bit number is stored in 68000 byte order—highest byte first. 

An Intel CPU must reverse the 2- or 4-byte sequence of each number. This applies to chunk dataSize fields 
and to numbers inside chunk data. It does not affect character strings and byte data because you can't reverse a 
1-byte sequence. But it does affect the 32-bit math used in IFF's MakeID macro. The standard does allow CPU 
specific byte ordering hidden within a chunk itself, but the practice is discouraged. 

Every 16- and 32-bit number is stored on an even address. 

Every odd-length chunk must be followed by a 0 pad byte. This pad byte is not counted in dataSize. 

An ID is made of 4 ASCII characters in the range “ ” (space, hex 20) through “~” (tilde, hex 7E). Leading 
spaces are not permitted. 

IDs are compared using a quick 32-bit equality test. Case matters. 


A chunk typically holds a C structure, Pascal record, or an array. For example, an 'ILBM' picture has a ‘BMHD' 
bitmap header chunk (a structure) and a 'BODY' raster body chunk (an array). 


To construct an IFF file, just put a file type ID (like 'ILBM’) into a wrapper chunk called a 'FORM' (Think "FILE”). 
Inside that wrapper place chunks one after another (with pad bytes as needed) . The chunk size always tells you how 
many more bytes you need to skip over to get to the next chunk. 

FORM is a special chunk ID 

24070 data bytes 

FORM type is ILBM 


a BMHD bitmap header chunk 
(20 data bytes) 


a CMAP color map chunk 
(21 data bytes +1 pad) 


a pad byte 


a BODY raster body chunk 
(24000 data bytes) 





A FORM always contains one 4-character FORM type ID (a file type, in this case LBM’) followed by any number 
of data chunks. In this example, the FORM type is 'ILBM’, which stands for "InterLeaved BitMap". (LBM is an IFF 
standard for bitplane raster pictures.) This example has 3 chunks. Note the pad byte after the odd length chunk. 


Within FORMs ILBM, 'BMHD' identifies a bitmap header chunk, ‘CMAP’ a color map, and ‘BODY’ a raster body. In 
general, the chunk IDs in a FORM are local to the FORM type ID. The exceptions are the 4 global chunk IDs 
FORM’, LIST’, 'CAT ', and ‘PROP’. (A FORM may contain other FORM chunks. E.g. an animation FORM might 
contain picture FORMs and sound FORMs.) 


How to read an IFF file? 
Given the C subroutine "GetChunkHeader(Q)": 


/* Skip any remaining bytes of the current chunk, skip any pad byte, and 
read the next chunk header. Returns the chunk ID or END MARK. */ 
ID GetChunkHeader (); 


we read the chunks in a FORM ILBM with a loop like this: 


do 

switch (id = GetChunkHeader()) 
{ 
case 'CMAP': ProcessCMAP(); break; 
case 'BMHD': ProcessBMHD(); break; 
case 'BODY': ProcessBODY(); break; 
/* default: just ignore the chunk */ 
} 

until (id == END_MARK); 


This loop processes each chunk by dispatching to a routine that reads the specific type of chunk data. We don't 
assume a particular order of chunks. This is a simple parser. Note that even if you have fully processed a chunk, you 
should respect it's chunk size, even if the size is larger than you expected. 


This sample ignores important details like I/O errors. There are also higher-level errors to check, e.g. if we hit 
END_MARK without reading a BODY, we didn't get a picture. 


Every IFF file is a ‘FORM’, ‘LIST’, or ‘CAT ' chunk. You can recognize an IFF file by those first 4 bytes. (FORM' 
is far and away the most common. We'll get to LIST and CAT below.) If the file contains a FORM, dispatch on the 
FORM type ID to a chunk-reader loop like the one above. 


File extensibility 


IFF files are extensible and forward/backward compatible: 


Chunk contents should be designed for compatibility across environments and for longevity. Every chunk 
should have a path for future expansion; at minimum this will be an unused bit or two. 

The standards team for a FORM type can extend one of the chunks that contains a structure by appending new, 
optional structure fields. 

Anyone can define new FORM types as well as new chunk types within a FORM type. Storing private chunks 
within a FORM is ok, but be sure to register your activities with Commodore-Amiga Technical Support. 

A chunk can be superseded by a new chunk type, e.g. to store more bits per RGB color register. New programs 
can output the old chunk (for backward compatibility) along with the new chunk. 

If you must change data in an incompatible way, change the chunk ID or the FORM type ID. 


I-3 


Advanced Topics: CAT, LIST, and PROP (not all that important) 


Sometimes you want to put several "files" into one, such as a picture library. This is what CAT is for. It 
“concatenates" FORM and LIST chunks. 


concatenation 
48160 data bytes 
hint: contains FORMs ILBM 


a FORM ILBM 


another FORM ILBM 





This example CAT holds two ILBMs. It can be shown outline-style: 


CAT ILBM 
..FORM ILBM 
....BMHD 
....CMAP 
....BODY 
..FORM ILBM 
....BMHD 
....CMAP 
....BODY 


a complete FORM ILBM picture 


~~ a 


Sometimes you want to share the same color map across many pictures. LIST and PROP do this: 


LIST ILBM 

..PROP ILBM default properties for FORMs ILBM 

... CMAP an ILBM CMAP chunk (there could be a BMHD chunk here, too) 
..FORM ILBM 

....BMHD (there could be a CMAP here to override the default) 

...-BODY 

..FORM ILBM 

....BMHD (there could be a CMAP here to override the default) 

....BODY 


A LIST holds PROPs and FORMs (and occasionally LISTs and CATs). A PROP ILBM contains default data (in the 
above example, just one CMAP chunk) for all FORMs ILBM in the LIST, Any FORM may override the 
PROP-defined default with its own CMAP. All PROPs must appear at the beginning of a LIST. Each FORM type 
standardizes (among other things) which of its chunks are "property chunks” (may appear in PROPs) and which are 
“data chunks” (may not appear in PROPs). 


“EA TIFF 85" Standard for Interchange Format Files 


Document Date: January 14, 1985 (Re-typeset Oct, 1988 Commodore-Amiga, Inc.) 
From: Jerry Morrison, Electronic Arts 
Status of Standard: Released to the public domain, and in use 


1. Introduction 
Standards are Good for Software Developers 


As home computer hardware evolves into better and better media machines, the demand increases for higher quality, 
more detailed data. Data development gets more expensive, requires more expertise and better tools, and has to be 
. Shared across projects. Think about several ports of a product on one CD-ROM with 500M Bytes of common data! 


Development tools need standard interchange file formats. Imagine scanning in images of "player" shapes, 
transferring them to an image enhancement package, moving them to a paint program for touch up, then 
incorporating them into a game. Or writing a theme song with a Macintosh score editor and incorporating it into an 
Amiga game. The data must at times be transformed, clipped, filled out, and moved across machine kinds. Media 
projects will depend on data transfer from graphic, music, sound effect, animation, and script tools, 


Standards are Good for Software Users 


Customers should be able to move their own data between independently developed software products. And they 
should be able to buy data libraries usable across many such products. The types of data objects to exchange are 
open-ended and include plain and formatted text, raster and structured graphics, fonts, music, sound effects, musical 
instrument descriptions, and animation. 


The problem with expedient file formats—typically memory dumps—is that they're too provincial. By designing 
data for one particular use (such as a screen snapshot), they preclude future expansion (would you like a full page 
picture? a multi-page document?). In neglecting the possibility that other programs might read their data, they fail to 
save contextual information (how many bit planes? what resolution?). Ignoring that other programs might create 
such files, they're intolerant of extra data (a different picture editor may want to save a texture palette with the image), 
missing data (such as no color map), or minor variations (perhaps a smaller image). In practice, a filed representation 
should rarely mirror an in-memory representation. The former should be designed for longevity; the latter to optimize 
the manipulations of a particular program. The same filed data will be read into different memory formats by different 
programs, 


The IFF philosophy: "A little behind-the-scenes conversion when programs read and write files is far better than NxM 
explicit conversion utilities for highly specialized formats”. 


So we need some standardization for data interchange among development tools and products. The more developers 
that adopt a standard, the better for all of us and our customers. 

Here is "EA IFF 1985" 
Here is our offering: Electronic Arts' IFF standard for Interchange File Format. The full name is "EA IFF 1985", 


Altematives and justifications are included for certain choices. Public domain subroutine packages and utility 
programs are available to make it easy to write and use IFF-compatible programs. 


I- 5 


EA IFF 85 
Part 1 introduces the standard. Part 2 presents its requirements and background. Parts 3, 4, and 5 define the primitive 
data types, FORMs, and LISTs, respectively, and how to define new high level types. Part 6 specifies the top level 
file structure. Section 7 lists names of the group responsible for this standard. Appendix A is included for quick 
reference and Appendix B. 


References 


American National Standard Additional Control Codes for Use with ASCII, ANSI standard 3.64-1979 for an 8-bit 
character set. See also ISO standard 2022 and ISO/DIS standard 6429.2. 


The C Programming Language, Brian W. Kernighan and Dennis M. Ritchie, Bell Laboratories. Prentice-Hall, 
Englewood Cliffs, NJ, 1978. 


C, A Reference Manual, Samuel P. Harbison and Guy L. Steele Jr., Tartan Laboratories. Prentice-Hall, Englewood 
Cliffs, NJ, 1984. 


Compiler Construction, An Advanced Course, edited by F. L. Bauer and J. Eickel (Springer-Verlag, 1976). This 
book is one of many sources for information on recursive descent parsing. 


DIF Technical Specification © 1981 by Software Arts, Inc. DIF™ is the format for spreadsheet data interchange 
developed by Software Arts, Inc. DIF™ is a trademark of Software Arts, Inc. 


"FTXT" IFF Formatted Text, from Electronic Arts. IFF supplement document for a text format. 
"ILBM" IFF Interleaved Bitmap, from Electronic Arts. IFF supplement document for a raster image format. 


M68000 16/32-Bit Microprocessor Programmer's Reference Manual © 1984, 1982, 1980, 1979 by Motorola, Inc. 





PostScript Language Manual © 1984 Adobe Systems Incorporated. 
PostScript™ is a trademark of Adobe Systems, Inc. 
Times and Helvetica® are registered trademarks of Allied Corporation. 


Inside Macintosh © 1982, 1983, 1984, 1985 Apple Computer, Inc., a programmer's reference manual. 
Apple® is a trademark of Apple Computer, Inc. 


MacPaint™ is a trademark of Apple Computer, Inc. 
Macintosh™ is a trademark licensed to Apple Computer, Inc. 


InterScript: A Proposal for a Standard for the Interchange of Editable Documents © 1984 Xerox Corporation. 
Introduction to InterScript © 1985 Xerox Corporation. 


Amiga® is a registered trademark of Commodore-Amiga, Inc. 


Electronics Arts™ is a trademark of Electronic Arts. 


EA IFF 85 


2. Background for Designers 


Part 2 is about the background, requirements, and goals for the standard. It's geared for people who want to design 
new types of IFF objects. People just interested in using the standard may wish to quickly scan this section. 


What Do We Need? 


A standard should be long on prescription and short on overhead. It should give lots of rules for designing programs 
and data files for synergy. But neither the programs nor the files should cost too much more than the expedient 
variety. Although we are looking to a future with CD-ROMs and perpendicular recording, the standard must work 
well on floppy disks. 


For program portability, simplicity, and efficiency, formats should be designed with more than one implementation 
style in mind. It ought to be possible to read one of many objects in a file without scanning all the preceding data. 
(In practice, pure stream I/O is adequate although random access makes it easier to write files.) Some programs need 
to read and play out their data in real time, so we need good compromises between generality and efficiency. 


As much as we need standards, they can't hold up product schedules. So we also need a kind of decentralized 
extensibility where any software developer can define and refine new object types without some "standards authority" 
in the loop. Developers must be able to extend existing formats in a forward- and backward-compatible way. A 
central repository for design information and example programs can help us take full advantage of the standard. 


For convenience, data formats should heed the restrictions of various processors and environments. For example, 
word-alignment greatly helps 68000 access at insignificant cost to 8088 programs. 


Other goals include the ability to share common elements over a list of objects and the ability to construct composite 
objects. 


And finally, "Simple things should be simple and complex things should be possible" —Alan Kay. 


Think Ahead 


Let's think ahead and build programs that read and write files for each other and for programs yet to be designed. Build 
data formats to last for future computers so long as the overhead is acceptable. This extends the usefulness and life of 
today's programs and data. 


To maximize interconnectivity, the standard file structure and the specific object formats must all be general and 
extensible. Think ahead when designing an object. File formats should serve many purposes and allow many 
programs to store and read back all the information they need; even squeeze in custom data. Then a programmer can 
store the available data and is encouraged to include fixed contextual details. Recipient programs can read the needed 
parts, skip unrecognized stuff, default missing data, and use the stored context to help transform the data as needed. 


Scope 


IFF addresses these needs by defining a standard file structure, some initial data object types, ways to define new 
types, and rules for accessing these files. We can accomplish a great deal by writing programs according to this 
standard, but do not expect direct compatibility with existing software. We'll need conversion programs to bridge the 
gap from the old world. 


IFF is geared for computers that readily process information in 8-bit bytes. It assumes a "physical layer" of data 


storage and transmission that reliably maintains "files" as sequences of 8-bit bytes. The standard treats a "file" as a 
container of data bytes and is independent of how to find a file and whether it has a byte count. 


1-7 


EA IFF 85 - 


This standard does not by itself implement a clipboard for cutting and pasting data between programs. A clipboard 
needs software to mediate access, and provide a notification mechanism so updates and requests for data can be 
detected. 


Data Abstraction 


The basic problem is how to represent information in a way that's program-independent, compiler- independent, 
machine-independent, and device-independent. 


The computer science approach is "data abstraction", also known as "objects", “actors”, and “abstract data types". A 
data abstraction has a “concrete representation" (its storage format), an "abstract representation" (its capabilities and 
uses), and access procedures that isolate all the calling software from the concrete representation. Only the access 
procedures touch the data storage. Hiding mutable details behind an interface is called "information hiding". What is 
hidden are the non-portable details of implementing the object, namely the selected storage representation and 
algorithms for manipulating it. 


The power of this approach is modularity. By adjusting the access procedures we can extend and restructure the data 
without impacting the interface or its callers. Conversely, we can extend and restructure the interface and callers 
without making existing data obsolete. It's great for interchange! 


But we seem to need the opposite: fixed file formats for all programs to access. Actually, we could file data 
abstractions ("filed objects") by storing the data and access procedures together. We'd have to encode the access 
procedures in a standard machine-independent programming language 4 la PostScript. Even with this, the interface 
can't evolve freely since we can't update all copies of the access procedures. So we'll have to design our abstract 
representations for limited evolution and occasional revolution (conversion). 


In any case, today's microcomputers can't practically store true data abstractions. They can do the next best thing: 
store arbitrary types of data in "data chunks", each with a type identifier and a length count. The type identifier is a 
reference by name to the access procedures (any local implementation). The length count enables storage-level object 
operations like "copy" and "skip to next” independent of object type or contents. 


Chunk writing is straightforward. Chunk reading requires a trivial parser to scan each chunk and dispatch to the 
proper access/conversion procedure. Reading chunks nested inside other chunks may require recursion, but no look 
ahead or backup. 


That's the main idea of IFF. There are, of course, a few other details... 


Previous Work 
Where our needs are similar, we borrow from existing standards. 


Our basic need to move data between independently developed programs is similar to that addressed by the Apple 
Macintosh desk scrap or "clipboard" [Inside Macintosh chapter "Scrap Manager"]. The Scrap Manager works closely 
with the Resource Manager, a handy filer and swapper for data objects (text strings, dialog window templates, 
pictures, fonts...) including types yet to be designed {Inside Macintosh chapter "Resource Manager"]. The Resource 
Manager is akin to Smalltalk's object swapper. 


We will probably write a Macintosh desk accessory that converts IFF files to and from the Macintosh clipboard for 
quick and easy interchange with programs like MacPaint and Resource Mover. 


Macintosh uses a simple and elegant scheme of four-character "identifiers" to identify resource types, clipboard format 
types, file types, and file creator programs. Alternatives are unique ID numbers assigned by a central authority or by 


I-8 


EA IFF 85 


hierarchical authorities, unique ID numbers generated by algorithm, other fixed length character Strings, and variable 
length strings. Character string identifiers double as readable signposts in data files and programs. The choice of 4 
characters is a good tradeoff between storage space, fetch/compare/store time, and name space size. We'll honor 
Apple's designers by adopting this scheme. 


"PICT" is a good example of a standard structured graphics format (including raster images) and its many uses [Inside 
Macintosh chapter "QuickDraw"]. Macintosh provides QuickDraw routines in ROM to create, manipulate, and 
display PICTs. Any application can create a PICT by simply asking QuickDraw to record a sequence of drawing 
commands. Since it's just as easy to ask QuickDraw to render a PICT to a screen or a printer, it's very effective to 
pass them between programs, say from an illustrator to a word processor. An important feature is the ability to store 
"comments" in a PICT which QuickDraw will ignore. (Actually, it passes them to your optional custom "comment 
handler”.) 


PostScript, Adobe System's print file standard, is a more general way to represent any print image (which is a 
specification for putting marks on paper) [PostScript Language Manual]. In fact, PostScript is a full-fledged 
programming language. To interpret a PostScript program is to render a document oma raster output device. The 
language is defined in layers: a lexical layer of identifiers, constants, and operators; a layer of reverse polish semantics 
including scope rules and a way to define new subroutines; and a printing-specific layer of built-in identifiers and 
operators for rendering graphic images. It is clearly a powerful (Turing equivalent) image definition language. PICT 
and a subset of PostScript are candidates for structured graphics standards. 


A PostScript document can be printed on any raster output device (including a display) but cannot generally be edited. 
That's because the original flexibility and constraints have been discarded. Besides, a PostScript program may use 
arbitrary computation to supply parameters like placement and size to each operator. A QuickDraw PICT, in 
comparison, is a more restricted format of graphic primitives parameterized by constants. So a PICT can be edited at 
the level of the primitives, e.g. move or thicken a line. It cannot be edited at the higher level of, say, the bar chart 
data which generated the picture. 


PostScript has another limitation: Not all kinds of data amount to marks on paper. A musical instrument description 
is one example. PostScript is just not geared for such uses. 


"DIF" is another example of data being stored in a general format usable by future programs [DIF Technical 
Specification]. DIF is a format for spreadsheet data interchange. DIF and PostScript are both expressed in plain 
ASCII text files. This is very handy for printing, debugging, experimenting, and transmitting across modems. It can 
have substantial cost in compaction and read/write work, depending on use. We won't store IFF files this way but we 
could define an ASCII alternate representation with a converter program. 


InterScript is Xerox’ standard for interchange of editable documents [Introduction to InterScript]. It approaches a 
harder problem: How to represent editable word processor documents that may contain formatted text, pictures, 
cross-references like figure numbers, and even highly specialized objects like mathematical equations? InterScript aims 
to define one standard representation for each kind of information. Each InterScript-compatible editor is supposed to 
preserve the objects it doesn't understand and even maintain nested cross-references. So a simple word processor 
would let you edit the text of a fancy document without discarding the equations or disrupting the equation numbers. 


Our task is similarly to store high level information and preserve as much content as practical while moving it 
between programs. But we need to span a larger universe of data types and cannot expect to centrally define them all. 
Fortunately, we don't need to make programs preserve information that they don't understand. And for better or 
worse, we don't have to tackle general-purpose cross-references yet. 


EA IFF 85 
3. Primitive Data Types 


Atomic components such as integers and characters that are interpretable directly by the CPU are specified in one 
format for all processors. We chose a format that's the same as used by the Motorola MC68000 processor [M68000 
16/32-Bit Microprocessor Programmer's Reference Manual]. The high byte and high word of a number are stored 
first. 


N.B.: Part 3 dictates the format for "primitive" data types where—and only where—used in the overall file structure. 
The number of such occurrences of dictated formats will be small enough that the costs of conversion, storage, and 
management of processor-specific files would far exceed the costs of conversion during I/O by “foreign” programs. A 
particular data chunk may be specified with a different format for its internal primitive types or with processor or 
environment specific variants if necessary to optimize local usage. Since that hurts data interchange, it's not 
recommended. (Cf. Designing New Data Sections, in Part 4.). 


Alignment 


All data objects larger than a byte are aligned on even byte addresses relative to the start of the file. This may require 
padding. Pad bytes are to be written as zeros, but don't count on that when reading. 


This means that every odd-length "chunk" must be padded so that the next one will fall on an even boundary. Also, 
designers of structures to be stored in chunks should include pad fields where needed to align every field larger than a 
byte. For best efficiency, long word data should be arranged on long word (4 byte) boundaries. Zeros should be 
stored in all the pad bytes. 


Justification: Even-alignment causes a little extra work for files that are used only on certain processors but allows 
68000 programs to construct and scan the data in memory and do block I/O. Any 16 bit or greater CPU will have 
faster access to aligned data. You just add an occasional pad field to data structures that you're going to block 
read/write or else stream read/write an extra byte. And the same source code works on all processors. Unspecified 
alignment, on the other hand, would force 68000 programs to (dis)assemble word and long word data one byte at a 
time. Pretty cumbersome in a high level language. And if you don't conditionally compile that step out for other 
processors, you won't gain anything. 


Numbers 


Numeric types supported are two's complement binary integers in the format used by the MC68000 processor—high 
byte first, high word first—the reverse of 8088 and 6502 format. 


UBYTE 8 bits. unsigned 
WORD 16 bits signed 
UWORD 16 bits unsigned 
LONG 32 bits signed 


The actual type definitions depend on the CPU and the compiler. In this document, we'll express data type definitions 
in the C programming language. [See C, A Reference Manual.] In 68000 Lattice C: 


typedef unsigned char UBYTE; /* 8 bits unsigned */ 
typedef short WORD; /* 16 bits signed * / 
typedef unsigned short UWORD; /* 16 bits unsigned */ 
typedef long LONG; /* 32 bits signed */ 


EA IFF 85 


Characters 


The following character set is assumed wherever characters are used, e.g. in text strings, IDs, and TEXT chunks (see 
below). Characters are encoded in 8-bit ASCII. Characters in the range NUL (hex 0) through DEL (hex 7F) are well 
defined by the 7-bit ASCII standard. IFF uses the graphic group “” (SP, hex 20) through “~” (hex 7E). 


Most of the control character group hex 01 through hex 1F have no standard meaning in IFF. The control character 
LF (hex OA) is defined as a “newline” character. It denotes an intentional line break, that is, a paragraph or line 
terminator. (There is no way to store an automatic line break. That is strictly a function of the margins in the 
environment the text is placed.) The control character ESC (hex.1B) is a reserved escape character under the rules of 
ANSI standard 3.64-1979 American National Standard Additional Control Codes for Use with ASCH, ISO standard 
2022, and ISO/DIS standard 6429.2. 














Characters in the range hex 7F through hex FF are not globally defined in IFF. They are best left reserved for future 
standardization. (Note that the FORM type FTXT (formatted text) defines the meaning of these characters within 
FTXT forms.) In particular, character values hex 7F through hex 9F are control codes while characters hex AO 
through hex FF are extended graphic characters like A, as per the ISO and ANSI standards cited above. [See the 
supplementary document "ETXT" IFF Formatted Text.] 





Dates 


A "creation date" is defined as the date and time a stream of data bytes was created. (Some systems call this a "last 
modified date".) Editing some data changes its creation date. Moving the data between volumes or machines does not. 


The IFF standard date format will be one of those used in MS-DOS, Macintosh, or AmigaDOS (probably a 32-bit 
unsigned number of seconds since a reference point). Issue: Investigate these three. 


Type IDs 


A "type ID", "property name", "FORM type”, or any other IFF identifier is a 32-bit value: the concatenation of four 
ASCII characters in the range “” (SP, hex 20) through “~” (hex 7E). Spaces (hex 20) should not precede printing 
characters; trailing spaces are ok. Control characters are forbidden. 


typedef CHAR ID[4]; 


IDs are compared using a simple 32-bit case-dependent equality test. FORM type IDs are restricted. Since they may 
be stored in filename extensions lower case letters and punctuation marks are forbidden. Trailing spaces are ok. 


Carefully choose those four characters when you pick a new ID. Make them mnemonic so programmers can look at 
an interchange format file and figure out what kind of data it contains. The name space makes it possible for 
developers scattered around the globe to generate ID values with minimal collisions so long as they choose specific 
names like "MUS4" instead of general ones like "TYPE" and "FILE". 


Commodore-Amiga Technical Support has undertaken the task of maintaining the registry of FORM type IDs and 
format descriptions. See the IFF registry document for more information. 


Sometimes it's necessary to make data format changes that aren't backward compatible. As much as we work for 
compatibility, unintended interactions can develop. Since IDs are used to denote data formats in IFF, new IDs are 
chosen to denote revised formats. Since programs won't read chunks whose IDs they don't recognize (see Chunks, 
below), the new IDs keep old programs from stumbling over new data. The conventional way to chose a "revision" 


I- il 


EA IFF 85 


ID is to increment the last character if it's a digit or else change the last character to a digit. E.g. first and second 
revisions of the ID "XY" would be "XY1" and "XY2". Revisions of "CMAP" would be "CMA1" and "CMA2". 


Chunks 
Chunks are the building blocks in the IFF structure. The form expressed as a C typedef is: 


typedef struct { 


ID ckID; /* 4 character ID */ 
LONG ckSize; /* sizeof(ckData) */ 
UBYTE ckData[/* ckSize */]; 

}. Chunk; 


We can diagram an example chunk—a "CMAP" chunk containing 12 data bytes—like this: 











ckData: 0, 0, 0, 32 20 


12 


, 


That's 4 bytes of ck ID, 4 bytes of ckSize and 12 data bytes. The total space used is 20 bytes. 


0, 0, 64, 90 
0, 0, 64, 0 


The ckID identifies the format and purpose of the chunk. As a rule, a program must recognize ck ID to interpret 
ckData. It should skip over all unrecognized chunks. The ck ID also serves as a format version number as long as 
we pick new IDs to identify new formats of ckData (see above). 


The following ck IDs are universally reserved to identify chunks with particular IFF meanings: "LIST", "FORM", 
"PROP", "CAT ",and" ". The specialID" "(4 spaces) is a ck ID for "filler" chunks, that is, chunks that fill 
space but have no meaningful contents. The IDs "LIS1" through "LIS9", "FOR1" through "FOR9", and "CAT" 
through "CAT9" are reserved for future "version number" variations. All IFF-compatible software must account for 
these chunk IDs. 


The ckSize is a logical block size—how many data bytes are in ckData. If ckData is an odd number of bytes long, 
a 0 pad byte follows which is not included in ckSize. (Cf. Alignment.) A chunk’s total physical size is ckSize 
rounded up to an even number plus the size of the header. So the smallest chunk is 8 bytes long with ckSize = 

0. For the sake of following chunks, programs must respect every chunk's ckSize as a virtual end-of-file for reading 
its ckData even if that data is malformed, e.g. if nested contents are truncated. 


We can describe the syntax of a chunk as a regular expression with "#" representing the ckSize, the length of the 
following {braced} bytes. The "[0]" represents a sometimes needed pad byte. (The regular expressions in this 
document are collected in Appendix A along with an explanation of notation.) 


Chunk ::= ID #{ UBYTE* } [0] 
One chunk output technique is to stream write a chunk header, stream write the chunk contents, then random access 


back to the header to fill-in the size. Another technique is to make a preliminary pass over the data to compute the 
size, then write it out all at once. 


EA IFF 85 


Strings, String Chunks, and String Properties 


In a string of ASCII text, linefeed (Ox0A) denotes a forced line break (paragraph or line terminator), Other control 
characters are not used. (Cf. Characters.) For maximum compatibility with line editors, two linefeed characters are 
often used to indicate a paragraph boundary. 


The ckID for a chunk that contains a string of plain, unformatted text is "TEXT". As a practical matter, a text 
string should probably not be longer than 32767 bytes. The standard allows up to 23! - 1 bytes. The ckID "TEXT" 
is globally reserved for this use. 


When used as a data property (see below), a text string chunk may be 0 to 255 characters long. Such a string is 
readily converted to a C string or a Pascal STRING[255]. The ckID of a property must have a unique property 
name, not "TEXT". 


When used as a part of a chunk or data property, restricted C string format is normally used. That means 0 to 255 
characters followed by a NULL byte (ASCII value 0). 


Data Properties (advanced topic) 


Data properties specify attributes for following (non-property) chunks. A data property essentially says “identifier = 
value”, for example "XY = (10, 200)", telling something about following chunks. Properties may only appear inside 
data sections ("FORM" chunks, cf. Data Sections) and property sections ("PROP" chunks, cf. Group PROP). 


The form of a data property is a type of Chunk. The ckID is a property name as well as a property type. The 
ckSize should be small since data properties are intended to be accumulated in RAM when reading a file. (256 
bytes is a reasonable upper bound.) Syntactically: 


Property ::= Chunk 


When designing a data object, use properties to describe context information like the size of an image, even if they 
don't vary in your program. Other programs will need this information. 


Think of property settings as assignments to variables in a programming language. Multiple assignments are 
redundant and local assignments temporarily override global assignments. The order of assignments doesn't matter as 
long as they precede the affected chunks. (Cf. LISTs, CATs, and Shared Properties.) 


Each object type (FORM type) is a local name space for property IDs. Think of a "CMAP" property in a "FORM 
ILBM" as the qualified ID "ILBM.CMAP". A "CMAP" inside some other type of FORM may not have the same 
meaning. Property IDs specified when an object type is designed (and therefore known to all clients) are called 
“standard” while specialized ones added later are “nonstandard”. 


Links 


Issue: A standard mechanism for “links” or "cross references" is very desirable for things like combining images and 
sounds into animations. Perhaps we'll define "link" chunks within FORMs that refer to other FORMs or to specific 
chunks within the same and other FORMs. This needs further work. EA IFF 1985 has no standard link mechanism. 


For now, it may suffice to read. a list of, say, musical instruments, and then just refer to them within a musical score 
by sequence number. , 


EA IFF 85 


File References 


Issue: We may need a standard form for references to other files. A "file ref" could name a directory and a file in the 
same type of operating system as the reference's originator. Following the reference would expect the file to be on 
some mounted volume, or perhaps the same directory as the file that made the reference. In a network environment, a 
file reference could name a server, too. 


Issue: How can we express operating-system independent file references? 
Issue: What about a means to reference a portion of another file? Would this be a "file ref" plus a reference to a “link” 
within the target file? 


EA IFF 85 
4. Data Sections 


The first thing we need of a file is to check: Does it contain IFF data and, if so, does it contain the kind of data we're 
looking for? So we come to the notion of a "data section". 


A "data section" or IFF "FORM" is one self-contained "data object" that might be stored in a file by itself. It is one 
high level data object such as a picture or a sound effect, and generally contains a grouping of chunks. The IFF 
structure "FORM" makes it self- identifying. It could be a composite object like a musical score with nested musical 
instrument descriptions. 


Group FORM 


A data section is a chunk with ck ID "FORM" and this arrangement: 


FORM : "FORM" #{ FormType (LocalChunk | FORM | LIST | CAT)* } 
FormType ::= ID 
LocalChunk ::= Property | Chunk 


The ID "FORM" is a syntactic keyword like "struct" in C. Think of a "struct ILBM" containing a field "CMAP". If 
you see "FORM" you will know to expect a FORM type ID (the structure name, "ILBM" in this example) and a 
particular contents arrangement or "syntax" (local chunks, FORMs, LISTs, and CATs). A "FORM ILBM", in 
particular, might contain a local chunk "CMAP", an "ILBM.CMAP" (to use a qualified name). 


So the chunk ID "FORM" indicates a data section. It implies that the chunk contains an ID and some number of 
nested chunks. In reading a FORM, like any other chunk, programs must respect its ckSize asa virtual end-of-file 
for reading its contents, even if they're truncated. 


The FORM type is a restricted ID that may not contain lower case letters or punctuation characters. (Cf. Type IDs. 
Cf. Single Purpose Files.) 


The type-specific information in a FORM is composed of its “local chunks": data properties and other chunks. Each 
FORM type is a local name space for local chunk IDs. So "CMAP" local chunks in other FORM types may be 
unrelated to "ILBM.CMAP”. More than that, each FORM type defines semantic scope. If you know what a FORM 
ILBM is, you will know what an ILBM.CMAP is. 


Local chunks defined when the FORM type is designed (and therefore known to all clients of this type) are called 
“standard” while specialized ones added later are "nonstandard”. 


Among the local chunks, property chunks give settings for various details like text font while the other chunks 
supply the essential information. This distinction is not clear cut. A property setting can be cancelled by a later 
setting of the same property. E.g. in the sequence: 


propl = x (Data A) propl = z propl = y (Data B) 
propl is = x for Data A, and y for Data B. The setting prop1 = z has noeffect. 
For clarity, the universally reserved chunk IDs "LIST", "FORM", "PROP", "CAT ","  ", "LIS1" through 


"LIS9”, "FOR1" through "FOR9", and "CAT1" through "CAT9" may not be FORM type IDs. 


Part 5, below, talks about grouping FORMs into LISTs and CATs. They let you group a bunch of FORMs but 
don't impose any particular meaning or constraints on the grouping. Read on. 


EA IFF 85 


Composite FORMs 


A FORM chunk inside a FORM is a full-fledged data section. This means you can build a composite object such as 
a multi-frame animation sequence by nesting available picture FORMs and sound effect FORMs. You can insert 
additional chunks with information like frame rate and frame count. 


Using composite FORMs, you leverage on existing programs that create and edit the component FORMs. Those 
editors may even look into your composite object to copy out its type of component. Such editors are not allowed to 
replace their component objects within your composite object. That's because the IFF standard lets you specify 
consistency requirements for the composite FORM such as maintaining a count or a directory of the components. 
Only programs that are written to uphold the rules of your FORM type may create or modify such FORMs. 


Therefore, in designing a program that creates composite objects, you are strongly requested to provide a facility for 
your users to import and export the nested FORMs. Import and export could move the data through a clipboard or a 
file. 


Here are several existing FORM types and rules for defining new ones: 


FTXT 


An FTXT data section contains text with character formatting information like fonts and faces. It has no paragraph or 
document formatting information like margins and page headers. FORM FTXT is well matched to the text 
representation in Amiga's Intuition environment. See the supplemental document "FTXT" IFF Formatted Text. 


ILBM 


"ILBM" is an InterLeaved BitMap image with color map; a machine-independent format for raster images. FORM 
ILBM is the standard image file format for the Commodore-Amiga computer and is useful in other environments, too. 
See the supplemental document "“ILBM" IFF Interleaved Bitmap. 





PICS 


The data chunk inside a "PICS" data section has ID "PICT" and holds a QuickDraw picture. Issue: Allow more than 
one PICT in a PICS? See Inside Macintosh chapter "QuickDraw" for details on PICTs and how to create and display 
them on the Macintosh computer. 





The only standard property for PICS is "XY", an optional property that indicates the position of the PICT relative to 
“the big picture". The contents of an XY is a QuickDraw Point. 


Note: PICT may be limited to Macintosh use, in which case there'll be another format for structured graphics in other 
environments, 


Other Macintosh Resource Types 


Some other Macintosh resource types could be adopted for use within IFF files; perhaps MWRT, ICN, ICN#, and 
STR#. 


Issue: Consider the candidates and reserve some more IDs. 


EA IFF 85 
Designing New Data Sections 


Supplemental documents will define additional object types. A supplement needs to specify the object's purpose, its 
FORM type ID, the IDs and formats of standard local chunks, and rules for generating and interpreting the data. It's a 
good idea to supply typedefs and an example source program that accesses the new object. See "ILBM" IFF 


Interleaved Bitmap for such an example. 


Anyone can pick a new FORM type ID but should reserve it with Commodore-Amiga Technical Support (CATS) at 
their earliest convenience. While decentralized format definitions and extensions are possible in IFF, our preference is 
to get design consensus by committee, implement a program to read and write it, perhaps tune the format before it 
becomes locked in stone, and then publish the format with example code. Some organization should remain in charge 
of answering questions and coordinating extensions to the format. 


If it becomes necessary to incompatibly revise the design of some data section, its FORM type ID will serve as a 
version number (Cf. Type IDs). E.g. a revised "VDEO" data section could be called "VDE1". But try to get by with 
compatible revisions within the existing FORM type. 


In anew FORM type, the rules for primitive data types and word-alignment (Cf. Primitive Data Types) may be 
overridden for the contents of its local chunks—but not for the chunk structure itself—if your documentation spells 
out the deviations. If machine-specific type variants are needed, e.g. to store vast numbers of integers in reverse bit 
order, then outline the conversion algorithm and indicate the variant inside each file, perhaps via different FORM 
types. Needless to say, variations should be minimized. 


In designing a FORM type, encapsulate all the data that other programs will need to interpret your files. E.g. a raster 
graphics image should specify the image size even if your program always uses 320 x 200 pixels x 3 bitplanes. 
Receiving programs are then empowered to append or clip the image rectangle, to add or drop bitplanes, etc. This 
enables a lot more compatibility. 


Separate the central data (like musical notes) from more specialized information (like note beams) so simpler 
programs can extract the central parts during read-in. Leave room for expansion so other programs can squeeze in new 
kinds of information (like lyrics). And remember to keep the property chunks manageably short—let's say < 256 
bytes. 


When designing a data object, try to strike a good tradeoff between a super-general format and a highly-specialized 
one. Fit the details to at least one particular need, for example a raster image might as well store pixels in the current 
machine's scan order. But add the kind of generality that makes the format usable with foresceable hardware and 
software. E.g. use a whole byte for each red, green, and blue color value even if this year's computer has only 4-bit 
video DACs. Think ahead and help other programs so long as the overhead is acceptable. E.g. run compress a raster 
by scan line rather than as a unit so future programs can swap images by scan line to and from secondary storage. 


Try to design a general purpose "least common multiple" format that encompasses the needs of many programs 
without getting too complicated. Be sure to leave provisions for future expansion. Let's coalesce our uses around a 
few such formats widely separated in the vast design space. Two factors make this flexibility and simplicity practical. 
First, file storage space is getting very plentiful, so compaction is not always a priority. Second, nearly any 
locally-performed data conversion work during file reading and writing will be cheap compared to the I/O time. 


It must be ok to copy a LIST or FORM or CAT intact, e.g. to incorporate it into a composite FORM. So any kind 
of internal references within a FORM must be relative references. They could be relative to the start of the containing 


FORM, relative from the referencing chunk, or a sequence number into a collection, 


With composite FORMs, you leverage on existing programs that create and edit the components. If you write a 
program that creates composite objects, please provide a facility for users to import and export the nested FORMs. 


Finally, don't forget to specify all implied rules in detail. 


EA IFF 85 
5. LISTs, CATs, and Shared Properties (Advanced topics) 


Data often needs to be grouped together, for example, consider a list of icons. Sometimes a trick like arranging little 
images into a big raster works, but generally they'll need to be structured as a first class group. The objects "LIST" 
and "CAT" are IFF-universal mechanisms for this purpose. Note: LIST and CAT are advanced topics the first time 
reader will want to skip. 


Property settings sometimes need to be shared over a list of similar objects. E.g. a list of icons may share one color 
map. LIST provides a means called "PROP" to do this. One purpose of a LIST is to define the scope of a PROP. A 
"CAT", on the other hand, is simply a concatenation of objects. 

Simpler programs may skip LISTs and PROPs altogether and just handle FORMs and CATs. All 


"fully-conforming" IFF programs also know about "CAT ", "LIST", and "PROP". Any program that reads a FORM 
inside a LIST must process shared PROPs to correctly interpret that FORM. 


Group CAT 
A CAT is just an untyped group of data objects. 


Structurally, a CAT is a chunk with chunk ID "CAT " containing a "contents type" ID followed by the nested 
objects. The ckSize of each contained chunk is essentially a relative pointer to the next one. 


CAT : “CAT " #{ ContentsType (FORM | LIST | CAT)* } 
ContentsType ::= ID -- a hint or an "abstract data type" ID 


In reading a CAT, like any other chunk, programs must respect it's ckSize as a virtual end-of-file for reading the 
nested objects even if they're malformed or truncated. 


The "contents type" following the CAT's ckSize indicates what kind of FORMs are inside. So a CAT of ILBMs 
would store "ILBM" there. It's just a hint. It may be used to store an "abstract data type". A CAT could just have 
blank contents ID ("._") if it contains more than one kind of FORM. 


CAT defines only the format of the group. The group's meaning is open to interpretation. This is like a list in 
LISP: the structure of cells is predefined but the meaning of the contents as, say, an association list depends on use. 
If you need a group with an enforced meaning (an “abstract data type" or Smalltalk “subclass"), some consistency 
constraints, or additional data chunks, use a composite FORM instead (Cf. Composite FORMs). 


Since a CAT just means a concatenation of objects, CATs are rarely nested. Programs should really merge CATs 
rather than nest them. 
Group LIST 


A LIST defines a group very much like CAT but it also gives a scope for PROPs (see below). And unlike CATs, 
LISTs should not be merged without understanding their contents. 


Structurally, a LIST is a chunk with ck ID "LIST" containing a “contents type” ID, optional shared properties, and 
the nested contents (FORMs, LISTs, and CATs), in that order. The ckSize of each contained chunk is a relative 
pointer to the next one. A LIST is not an arbitrary linked list—the cells are simply concatenated. 


LIST ::= "LIST" #{ ContentsType PROP* (FORM | LIST | CAT)* } 
ContentsType ::= ID 


EA IFF 85 


Group PROP 


PROP chunks may appear in LISTs (not in FORMs or CATs). They supply shared properties for the FORMs in 

that LIST. This ability to elevate some property settings to shared status for a list of forms is useful for both 
indirection and compaction. E.g. a list of images with the same size and colors can share one "size" property and one 
"color map" property. Individual FORMs can override the shared settings. 


The contents of a PROP is like a FORM with no data chunks: 
PROP ::= "PROP" #{ FormType Property* } 
It means, “Here are the shared properties for FORM type <FormType>". 


A LIST may have at most one PROP of a FORM type, and all the PROPs must appear before any of the FORMs or 
nested LISTs and CATs. You can have subsequences of FORMs sharing properties by making each subsequence a 
LIST. 


Scoping: Think of property settings as variable bindings in nested blocks of a programming language. In C this 
would look like: 


#define Roman 0 
#define Helvetica 1 


void main() 

{ 

int font=Roman; /* The global default */ 
{ 
printf ("The font number is %d\n",font); 
} 
{ 
int font=Helvetica; /* local setting */ 
printf ("The font number is %d\n", font) ; 
} 
{ 
printf ("The font number is %d\n", font); 
} 

} 


{* 
* Sample output: The font number is 0 
* The font number is 1 
* The font number is 0 
* f/f 


EA IFF 85 
An IFF file could contain: 


LIST { 
PROP TEXT { 
FONT {TimesRoman} /* shared setting xf 


} 


FORM TEXT { 
FONT {Helvetica} /* local setting * 
CHRS {Hello } /* uses font Helvetica x / 


} 


FORM TEXT { 
CHRS {there.} /* uses font TimesRoman *x/ 


} 


The shared property assignments selectively override the reader's global defaults, but only for FORMs within the 
group. A FORM's own property assignments selectively override the global and group-supplied values. So when 
reading an IFF file, keep property settings on a stack. They are designed to be small enough to hold in main 
memory. 


Shared properties are semantically equivalent to copying those properties into each of the nested FORMs right after 
their FORM type IDs. 


Properties for LIST 


Optional "properties for LIST” store the origin of the list's contents in a PROP chunk for the pseudo FORM type 
"LIST". They are the properties originating program "OPGM", processor family "OCPU", computer type "OCMP", 
computer serial number or network address "OSN ", and user name "UNAM". In our imperfect world, these could be 
called upon to distinguish between unintended variations of a data format or to work around bugs in particular 
originating/receiving program pairs. Issue: Specify the format of these properties. 


A creation date could also be stored in a property, but let's ask that file creating, editing, and transporting programs 
maintain the correct date in the local file system. Programs that move files between machine types are expected to 
copy across the creation dates. 


EA IFF 85 
6. Standard File Structure 
File Structure Overview 


An IFF file is just a single chunk of type FORM, LIST, or CAT. Therefore an IFF file can be recognized by its first 
4 bytes: "FORM", "LIST", or "CAT ". Any file contents after the chunk's end are to be ignored. (Some 

file transfer programs add garbage to the end of transferred files. This specification protects against such common 
damage). 


The simplest IFF file would be one that does no more than encapsulate some binary data (perhaps even an 
old-fashioned single-purpose binary file). Here is a binary dump of such a minimal IFF example: 


0000: 464F524D 0000001A 53464150 43524143 FORM. ...SNAPCRAC 
0010: 0000000D 68656C6C 6F2C776F 726C6421 ....-hello, world! 
0020: OA0O oe 


The first 4 bytes indicate this is a "FORM"; the most common IFF top level structure. The following 4 bytes 
indicate that the contents totals 26 bytes. The form type is listed as "SNAP". 


Our form "SNAP" contains only one chunk at the moment; a chunk of type "CRAC". From the size (SO00Q000D) 
the amount of data must be 13 bytes. In this case, the data happens to correspond to the ASCII string "hello, 
world!<if>". Since the number 13 is odd, a zero pad byte is added to the file. At any time new chunks could be 
added to form SNAP without affecting any other aspect of the file (other than the form size). It's that simple. 


Since an IFF file can be a group of objects, programs that read/write single objects can communicate to an extent 
with programs that read/write groups. You're encouraged to write programs that handle all the objects in a LIST or 
CAT. A graphics editor, for example, could process a list of pictures as a multiple page document, one page at a 
time. 


Programs should enforce IFF's syntactic rules when reading and writing files. Users should be told when a file is 
corrupt. This ensures robust data transfer. For minor damage, you may wish to give the user the option of using the 
suspect data, or cancelling, Presumably a user could read in a damaged file, then save whatever was salvaged to a 
valid file. The public domain IFF reader/writer subroutine package does some syntatic checks for you. A utility 
program "IFFCheck" is available that scans an IFF file and checks it for conformance to IFF's syntactic rules. 
IFFCheck also prints an outline of the chunks in the file, showing the ck ID and ckSize of each. This is quite 
handy when building IFF programs. Example programs are also available to show details of reading and writing IFF 
files. 


A merge program "IFFJoin" will be available that logically appends IFF files into a single CAT group. It "unwraps" 
each input file that is a CAT so that the combined file isn't nested CATs. 


If we need to revise the IFF standard, the three anchoring IDs will be used as "version numbers". That's why IDs 
"FOR1" through "FOR9", "LIS1" through "LIS9", and "CAT1" through "CAT9" are reserved. 


IFF formats are designed for reasonable performance with floppy disks. We achieve considerable simplicity in the 
formats and programs by relying on the host file system rather than defining universal grouping structures like 
directories for LIST contents. On huge storage systems, IFF files could be leaf nodes in a file structure like a B-tree. 
Let's hope the host file system implements that for us! 


There are two kinds of IFF files: single purpose files and scrap files. They differ in the interpretation of multiple data 
objects and in the file's external type. 


EA IFF 85 
Single Purpose Files 


A single purpose IFF file is for normal "document" and "archive" storage. This is in contrast with "scrap files" (see 
below) and temporary backing storage (non-interchange files). 


The external file type (or filename extension, depending on the host file system) indicates the file's contents. It's 
generally the FORM type of the data contained, hence the restrictions on FORM type IDs. 


Programmers and users may pick an "intended use" type as the filename extension to make it easy to filter for the 
relevant files in a filename requester. This is actually a "subclass" or "subtype" that conveniently separates files of 
the same FORM type that have different uses. Programs cannot demand conformity to its expected subtypes without 
overly restricting data interchange since they cannot know about the subtypes to be used by future programs that users 
will want to exchange data with. 


Issue: How to generate 3-letter MS-DOS extensions from 4-letter FORM type IDs? 


Most single purpose files will be a single FORM (perhaps a composite FORM like a musical score containing nested 
FORMS like musical instrument descriptions). If it's a LIST or a CAT, programs should skip over unrecognized 
objects to read the recognized ones or the first recognized one. Then a program that can read a single purpose file can 
read something out of a “scrap file”, too. 


Scrap Files (not currently used) 


A "scrap file" is for maximum interconnectivity in getting data between programs; the core of a clipboard function. 
Scrap files may have type "IFF " or filename extension ".IFF". 


A scrap file is typically a CAT containing alternate representations of the same basic information. Include as many 
alternatives as you can readily generate. This redundancy improves interconnectivity in situations where we can't 
make all programs read and write super-general formats. [Inside Macintosh chapter "Scrap Manager”.] E.g. a 
graphically-annotated musical score might be supplemented by a stripped down 4-voice melody and by a text (the 
lyrics). 


The originating program should write the alternate representations in order of "preference": most preferred (most 
comprehensive) type to least preferred (least comprehensive) type. A receiving program should either use the first 
appearing type that it understands or search for its own "preferred" type. 


A scrap file should have at most one alternative of any type. (A LIST of same type objects is ok as one of the 
alternatives.) But don't count on this when reading; ignore extra sections of a type. Then a program that reads scrap 
files can read something out of single purpose files. 


EA IFF 85 
Rules for Reader Programs 


Here are some notes on building programs that read IFF files. If you use the standard IFF reader module "IFFR.C", 
many of these rules and details will be automatically handled. (See "Support Software" in Appendix A.) We 
recommend that you start from the example program "ShowILBM.C". For LIST and PROP work, you should also 
read up on recursive descent parsers. [See, for example, Compiler Construction, An Advanced Course.] 


* The standard is very flexible so many programs can exchange data. This implies a program has to scan the file and 
react to what's actually there in whatever order it appears. An IFF reader program is a parser. 


* For interchange to really work, programs must be willing to do some conversion during read-in. If the data isn't 
exactly what you expect, say, the raster is smaller than those created by your program, then adjust it. Similarly, 
your program could crop a large picture, add or drop bitplanes, or create/discard a mask plane. The program should 
give up gracefully on data that it can't convert. 


* If it doesn't start with "FORM", "LIST", or "CAT ", it’s not an IFF-85 file. 
* For any chunk you encounter, you must recognize its type ID to understand its contents. 


* For any FORM chunk you encounter, you must recognize its FORM type ID to understand the contained "local 
chunks". Even if you don't recognize the FORM type, you can still scan it for nested FORMs, LISTs, and CATs 
of interest. 


* Don't forget to skip the implied pad byte after every odd-length chunk, this is not included in the chunk count! 


¢ Chunk types LIST, FORM, PROP, and CAT are generic groups. They always contain a subtype ID followed by 
chunks. 


* Readers ought to handle a CAT of FORMs in a file. You may treat the FORMs like document pages to sequence 
through, or just use the first FORM. 


* Many IFF readers completely skip LISTs. "Fully IFF-conforming" readers are those that handle LISTs, even if 
just to read the first FORM from a file. If you do look into a LIST, you must process shared properties (in PROP 
chunks) properly. The idea is to get the correct data or none at all. 


* The nicest readers are willing to look into unrecognized FORMs for nested FORM types that they do recognize. 
For example, a musical score may contain nested instrument descriptions and and animation or desktop publishing 
files may contain still pictures. This extra step is highly recommended. 


Note to programmers: Processing PROP chunks is not simple! You'll need some background in interpreters with 
stack frames. If this is foreign to you, build programs that read/write only one FORM per file. For the more intrepid 
programmers, the next paragraph summarizes how to process LISTs and PROPs. See the general IFF reader module 
"IFFR.C" and the example program "ShowILBM.C" for details. 


Allocate a stack frame for every LIST and FORM you encounter and initialize it by copying the stack frame of the 
parent LIST or FORM. At the top level, you'll need a stack frame initialized to your program's global defaults. 
While reading each LIST or FORM, store all encountered properties into the current stack frame. In the example 
ShowILBM, each stack frame has a place for a bitmap header property ILBM.BMHD and a color map property 
ILBM.CMAP., When you finally get to the ILBM's BODY chunk, use the property settings accumulated in the 
current stack frame. 


An alternate implementation would just remember PROPs encountered, forgetting each on reaching the end of its 
scope (the end of the containing LIST). When a FORM XXXxX is encountered, scan the chunks in all remembered 
PROPs XXXX, in order, as if they appeared before the chunks actually in the FORM XXXX. This gets trickier if 
you read FORMs inside of FORMs. 


EA IFF 85 
Rules for Writer Programs 


Here are some notes on building programs that write IFF files, which is much easier than reading them. If you use 
the standard IFF writer module "IFFW.C", many of these rules and details will automatically be enforced. See the 
example program "Raw2ILBM.C". 


¢ An IFF file is a single FORM, LIST, or CAT chunk. 


° Any IFF-85 file must start with the 4 characters "FORM", "LIST", or "CAT ", followed by a LONG ckSize. 
There should be no data after the chunk end. 


* Chunk types LIST, FORM, PROP, and CAT are generic. They always contain a subtype ID followed by chunks. 
These three IDs are universally reserved, as are "LIS1" through "LIS9", "FOR1" through "FOR9", "CAT1" 
through "CAT9", and " - 


* Don't forget to write a 0 pad byte after each odd-length chunk. 


* Do not try to edit a file that you don't know how to create. Programs may look into a file and copy out nested 
FORMs of types that they recognize, but they should not edit and replace the nested FORMs and not add or 
remove them. Breaking these rules could make the containing structure inconsistent. You may write a new file 
containing items you copied, or copied and modified, but don't copy structural parts you don't understand. 


* You must adhere to the syntax descriptions in Appendix A. E.g. PROPs may only appear inside LISTs. 
There are at least four common techniques for writing an IFF group: 


(1) build the data in a file mapped into virtual memory. 

(2) build the data in memory blocks and use block I/O. 

(3) stream write the data piecemeal and (don't forget!) random access back to set the group (or FORM) 
length count. 

(4) make a preliminary. pass to compute the length count then stream write the data. 


Issue: The standard disallows "blind" chunk copying for consistency reasons. Perhaps we can define-a ckID 
convention for chunks that are ok to replicate without knowledge of the contents. Any such chunks would need to be 
internally consistent, and not be bothered by changed external references. This is a proposal, and has not been 
adopted. 


Issue: Stream-writing an IFF FORM can be inconvenient. With random access files one can write all the chunks 
then go back to fix up the FORM size. With stream access, the FORM size must be calculated before the file is 
written. When compression is involved, this can be slow or inconvenient. Perhaps we can define an "END " chunk. 
The stream writer would use -1 (SFFFFFFFF) as the FORM size. The reader would follow each chunk; when the 
reader reaches an "END ", it would terminate the last -1 sized chunk. Certain new IFF FORMs could require that 
readers understand "END “. This is a proposal, and has not been adopted; current reader software would consider a file 
with an incorrect FORM size to be corrupt. 


7. Standards Committee 


The following people contributed to the design of this IFF standard: 


Bob "Kodiak" Burns, Commodore-Amiga R.J. Mical, Commodore-Amiga 
Jerry Morrison, Electronic Arts Greg Riker, Electronic Arts 
Steve Shaw, Electronic Arts Barry Walsh, Commodore-Amiga 


Oct, 1988 revision by Bryce Nesbitt, and Carolyn Scheppner, Commodore-Amiga 


I- 24 


Appendix A. Reference 


EA IFF 85 


Type Definitions 


The following C typedefs describe standard IFF structures. Declarations to use in practice will vary with the CPU and 
compiler. For example, 68000 Lattice C produces efficient comparison code if we define ID as a"LONG". A macro 
"MakeID" builds these IDs at compile time. 


/* Standard IFF types, expressed in 68000 Lattice C. xf 
typedef unsigned char UBYTE; /* 8 bits unsigned * / 
typedef short WORD; /* 16 bits signed */ 
typedef unsigned short UWORD; /* 16 bits unsigned */ 
typedef long LONG; /* 32 bits signed */ 
typedef char ID[4]; /* 4 chars in ' ' through '~' */ 


typedef struct { 
ID ckID; 
LONG ckSize; 


/* sizeof (ckData) *x/ 


UBYTE ckData[/* ckSize */]; 


} Chunk; 


/* ID typedef and builder for 68000 Lattice C. */ 


typedef LONG ID; 


/* 4 chars in ' ' through '~' */ 


#define MakeID(a,b,c,d) ( (a)<<24 | (b)<<16 | (c)<<8 | (d) ) 


/* Globally reserved IDs. */ 


#define ID_FORM 
#define ID_LIST 
#define ID _PROP 
#define ID_CAT 


MakeID('F', 'O', 'R', 'M') 
MakeID('L', 'I','S', 'T') 
MakeID('P', 'R', 'O', 'P') 
MakeID('C', 'A', 'T',! ') 


#define ID FILLER MakeID(' ',' ',' ',' ") 


Syntax Definitions 


Here's a collection of the syntax definitions in this document. 


Chunk 2:5 
Property 225 
FORM :3= 


FormType 135 
= Property | Chunk 


LocalChunk 


CAT °3= 
ContentsType ::= 


LIST 2:5 
PROP :3= 


ID #{ UBYTE* } [0] 

Chunk 

"FORM" #{ FormType (LocalChunk | FORM | LIST [| CAT)* } 
ID 

"CAT " #{ ContentsType (FORM | LIST | CAT)* } 


ID -- a hint or an "abstract data type" ID 


"LIST" #{ ContentsType PROP* (FORM | LIST | CAT)* } 
"PROP" #{ FormType Property* } 


In this extended regular expression notation, the token-"#" represents a count of the following {braced} data bytes. 
Literal items are shown in "quotes", [square bracketed items] are optional, and "*" means 0 or more instances. A 
sometimes-needed pad byte is shown as "[0]". 


I- 25 


EA IFF 85 
Example Diagrams 
Here's a box diagram for an example IFF file, a raster image FORM ILBM. This FORM contains a bitmap header 
property chunk BMHD, a color map property chunk CMAP, and a raster data chunk BODY. This particular raster is 
320 x 200 pixels x 3 bit planes uncompressed. The "0" after the CMAP chunk represents a zero pad byte; included 


since the CMAP chunk has an odd length. The text to the right of the diagram shows the outline that would be 
printed by the IFFCheck utility program for this particular file. 


FORM 24070 ILBM 


-BMHD 20 


-CMAP 21 


-BODY 24000 





This second diagram shows a LIST of two FORMs ILBM sharing a common BMHD property and a common CMAP 
property. Again, the text on the right is an outline 4 la IFFCheck. 


LIST 48114 AAAA 


‘PROP’ 62 -PROP 62 ILBM 


‘BMHD’ .-BMHD 20 


20 
0, 0, 3, 0, 0, 0... 





~.CMAP 21 


-FORM 24012 ILBM 


.-BODY 24000 


-FORM 24012 ILBM 


..-BODY 24000 





"ILBM" IFF Interleaved Bitma 


Date: January 17, 1986 (CRNG data updated Oct, 1988 by Jerry Morrison) 

(Appendix E added and CAMG data updated Oct, 1988 by Commodore-Amiga, Inc.) 
From: Jerry Morrison, Electronic Arts 
Status: Released and in use 


1. Introduction 


"BA IFF 85” is Electronic Arts’ standard for interchange format files. "ILBM” is a format for a 2 dimensional raster 
graphics image, specifically an InterLeaved bitplane BitMap image with color map. An ILBM is an IFF “data section" 
or "FORM type”, which can be an IFF file.or a part of one. ILBM allows simple, highly portable raster graphic 
storage. 


An ILBM is an archival representation designed for three uses. First, a stand-alone image that specifies exactly how to 
display itself (resolution, size, color map, etc.). Second, an image intended to be merged into a bigger picture which 
has its own depth, color map, and so on. And third, an empty image with a color map selection or "palette" for a 
paint program. ILBM is also intended as a building block for composite IFF FORMs like “animation sequences” and 
"structured graphics”. Some uses of ILBM will be to preserve as much information as possible across disparate 
environments. Other uses will be to store data for a single program or highly cooperative programs while maintaining 
subtle details. So we're trying to accomplish a lot with this one format. 


This memo is the IFF supplement for FORM ILBM. Section 2 defines the purpose and format of property chunks 
bitmap header "BMHD", color map "CMAP", hotspot "GRAB", destination merge data "DEST", sprite information 
“SPRT", and Commodore Amiga viewport mode “CAMG". Section 3 defines the standard data chunk "BODY". These 
are the “standard” chunks. Section 4 defines the nonstandard data chunks. Additional specialized chunks like texture 
pattern can be added later. The ILBM syntax is summarized in Appendix A as a regular expression and in Appendix B 
as a box diagram. Appendix C explains the optional run encoding scheme. Appendix D names the committee 
responsible for this FORM ILBM standard. 


Details of the raster layout are given in part 3,"Standard Data Chunk". Some elements are based on the Commodore 
Amiga hardware but generalized for use on other computers. An alternative to ILBM would be appropriate for 
computers with true color data in each pixel, though the wealth of available ILBM images makes import and export 
important. 


Reference: 


“EA IFF 85" Standard for Interchange Format Files describes the underlying conventions for all IFF files. 
Amiga® is a registered trademark of Commodore-Amiga, Inc. 

Electronic Arts™ is a trademark of Electronic Arts. 

Macintosh™ is a trademark licensed to Apple Computer, Inc. 

MacPaint™ is a trademark of Apple Computer, Inc. 


"ILBM" JFF Interleaved Bitmap 
2. Standard Properties 
ILBM has several defined property chunks that act on the main data chunks. The required property "BMHD" and any 
optional properties must appear before any "BODY" chunk. (Since an ILBM has only one BODY chunk, any 
following properties would be superfluous.) Any of these properties may be shared over a LIST of several IBLMs by 
putting them in a PROP ILBM (See the EA IFF 85 document). 
BMHD 


The required property "BMHD" holds a BitMapHeader as defined in the following documentation. It describes the 
dimensions of the image, the encoding used, and other data necessary to understand the BODY chunk to follow. 


typedef UBYTE Masking; /* Choice of masking technique. */ 

#define mskNone 0 

#define mskHasMask 1 

#define mskHasTransparentColor 2 

#define mskLasso 3 

typedef UBYTE Compression; /* Choice of compression algorithm applied to 


the rows of all source and mask planes. "“cmpByteRunl" is the byte run 
encoding described in Appendix C. Do not compress across rows! */ 
#define cmpNone 0 
#define cmpByteRunl 1 


typedef struct { 


UWORD w, h; /* raster width & height in pixels x] 
WORD x, Yi /* pixel position for this image xf 
UBYTE nPlanes; /* # source bitplanes */ 
Masking masking; 

Compression compression; 

UBYTE padi; /* unused; ignore on read, write as 0 */ 
UWORD transparentColor; /* transparent "color number" (sort of) */ 
UBYTE xAspect, yAspect; /* pixel aspect, a ratio width : height */ 
WORD pageWidth, pageHeight; /* source "page" size in pixels *x/ 
} BitMapHeader; 


Fields are filed in the order shown. The UBYTE fields are byte-packed (the C compiler must not add pad bytes to the 
structure). 


The fields w and h indicate the size of the image rectangle in pixels. Each row of the image is stored in an integral 
number of 16 bit words. The number of words per row is words= ( (w+t15) /16) or Ceiling (w/16). The fields 
x and y indicate the desired position of this image within the destination picture. Some reader programs may ignore x 
and y. A safe default for writing an ILBM is (x, y) = (0, 0). 


The number of source bitplanes in the BODY chunk is stored in nP lanes. An ILBM with a CMAP but no BODY 
and nP lanes = 0 is the recommended way to store a color map. 


Note: Color numbers are color map index values formed by pixels in the destination bitmap, which may be deeper 
than nPlanes if a DEST chunk calls for merging the image into a deeper image. 


The field masking indicates what kind of masking is to be used for this image. The value mskNone designates an 
opaque rectangular image. The value mskHasMask means that a mask plane is interleaved with the bitplanes in the 
BODY chunk (see below). The value mskHasTransparentColor indicates that pixels in the source planes 
matching transparentColor are to be considered "transparent". (Actually, transparentColor isn'ta “color 
number" since it's matched with numbers formed by the source bitmap rather than the possibly deeper destination 


I- 28 


"ILBM" IFF Interleaved Bitmap 


bitmap. Note that having a transparent color implies ignoring one of the color registers. The value mskLasso 
indicates the reader may construct a mask by lassoing the image as in MacPaint™, To do this, put a 1 pixel border of 
transparentColor around the image rectangle. Then do a seed fill from this border. Filled pixels are to be 
transparent. 


Issue: Include in an appendix an algorithm for converting a transparent color to a mask plane, and maybe a lasso 
algorithm. 


A code indicating the kind of data compression used is stored in compression. Beware that using data compression 
makes your data unreadable by programs that don't implement the matching decompression algorithm. So we'll 
employ as few compression encodings as possible. The run encoding byteRun1 is documented in Appendix C. 


The field pad1 is a pad byte reserved for future use. It must be set to 0 for consistency. 


The transparentColor specifies which bit pattern means “transparent”. This only applies if masking is 
mskHasTransparentColor ormskLasso. Otherwise, transparentColor should be 0. (see above) 


The pixel aspect ratio is stored as a ratio in the two fields xAspect and yAspect. This may be used by programs 

to compensate for different aspects or to help interpret the fields w, h, x, y, pageWidth, and pageHeight, which 
are in units of pixels, The fraction xAspect/yAspect represents a pixel’s width/height. It's recommended that your 
programs store proper fractions in the BitMapHeader, but aspect ratios can always be correctly compared with the test: 


xAspect*yDesiredAspect = yAspect*xDesiredAspect 


Typical values for aspect ratio are width : height = 10: 11 for an Amiga 320 x 200 display and 1: 1 fora 
Macintosh™ display. 


The size in pixels of the source "page” (any raster device) is stored in pageWidth and pageHeight, e.g. (320, 
200) for a low resolution Amiga display. This information might be used to scale an image or to automatically set 
the display format to suit the image. Note that the image can be larger than the page. 


CMAP 


The optional! (but encouraged) property "CMAP" stores color map data as triplets of red, green, and blue intensity 
values. The n color map entries ("color registers") are stored in the order 0 through n-1, totaling 3n bytes, Thus n is 
the ckSize/3. Normally, n would equal 29P lanes, 


A CMAP chunk contains a ColorMap array as defined below. Note that these typedefs assume a C compiler that 
implements packed arrays of 3-byte elements. 


typedef struct { 
UBYTE red, green, blue; /* color intensities 0..255 */- 
} ColorRegister; /* size = 3 bytes */ 


typedef ColorRegister ColorMap[{n]; /* size = 3n bytes */ 


The color components red, green, and blue represent fractional intensity values in the range 0 through 255 256ths. 
White is (255, 255, 255) and black is (0, 0, 0). If your machine has less color resolution, use the high order bits. 
Shift each field right on reading (or left on writing) and assign it to (from) a field in a local packed format like 
Color4, below. This achieves automatic conversion of images across environments with different color resolutions. 
On reading an ILBM, use defaults if the color map is absent or has fewer color registers than you need. Ignore any 
extra color registers. (See Appendix E for a better way to write colors) 





"ILBM" IFF Interleaved Bitmap 


The example type Color4 represents the format of a color register in working memory of an Amiga computer, 
which has 4 bit video DACs. (The ": 4" tells smarter C compilers to pack the field into 4 bits.) 


typedef struct { 
unsigned padi :4, red :4, green :4, blue :4; 
} Color4; /* Amiga RAM format. Not filed. */ 
Remember that every chunk must be padded to an even length, so a color map with an odd number of entries would 
be followed by a 0 byte, not included in the ckSize. 


GRAB 


The optional property "GRAB" locates a “handle” or "hotspot" of the image relative to its upper left corner, e.g. when 
used as a mouse cursor or a "paint brush". A GRAB chunk contains a Point2D. 


typedef struct { 
WORD x, y; /* velative coordinates (pixels) */ 
} Point2D; 


DEST 


The optional property "DEST" is a way to say how to scatter zero or more source bitplanes into a deeper destination 
image. Some readers may ignore DEST. 


The contents of a DEST chunk is DestMerge structure: 


typedef struct { 


UBYTE depth; /* # bitplanes in the original source x / 
UBYTE padi; /* unused; for consistency put 0 here * / 
UWORD planePick; /* how to scatter source bitplanes into destination */ 
UWORD planeOnOff; /* default bitplane data for planePick * f 
UWORD planeMask; /* selects which bitplanes to store into x / 


} DestMerge; 
The low order depth number of bits in planePick, planeOnOff, and planeMask correspond one-to-one with 
destination bitplanes. Bit 0 with bitplane 0, etc. (Any higher order bits should be ignored.) "1" bits in planePick 
mean “put the next source bitplane into this bitplane", so the number of "1" bits should equal nP lanes. "0" bits 
mean "put the corresponding bit from planeOnOf f into this bitplane". Bits in planeMask gate writing to the 
destination bitplane: "1" bits mean "write to this bitplane" while "0" bits mean "leave this bitplane alone”. The 
normal case (with no DEST property) is equivalent to planePick = planeMask = 2nPlanes — 1, 
Remember that color numbers are formed by pixels in the destination bitmap (depth planes deep) not in the source 
bitmap (nP lanes planes deep). 

SPRT 


The presence of an "SPRT" chunk indicates that this image is intended as a sprite. It's up to the reader program to 
actually make it a sprite, if even possible, and to use or overrule the sprite precedence data inside the SPRT chunk: 


typedef UWORD SpritePrecedence; /* relative precedence, 0 is the highest */ 


Precedence 0 is the highest, denoting a sprite that is foremost. 


I-30 


“ILBM" IFF Interleaved Bitmap 


Creating a sprite may imply other setup. E.g. a 2 plane Amiga sprite would have transparentColor = 0. Color 
registers 1, 2, and 3 in the CMAP would be stored into the correct hardware color registers for the hardware sprite 
number used, while CMAP color register 0 would be ignored. 


CAMG 


A “CAMG" chunk is specifically for the Commodore Amiga computer, readers on other computers may ignore 
CAMG. All Amiga-based reader and writer software should deal with CAMG. The Amiga supports many different 
video display modes including interlace, extra half-bright, and hold & modify. At this time a CAMG chunk contains 
a single long word (length=4). The high 16 bits are currently reserved by Commodore; they must be written as zeros 
and ignored when read. The low 16 bits of the CAMG will contain a ViewModes word. This value can be used to 
determine the ViewModes information in effect when the ILBM was saved. In the future CAMG may be extended to 
specify other information or video modes. 


Some of the ViewModes flags are not appropriate to use ina CAMG, these should be masked out when writing or 
reading. Here are definitions for the bits to be removed: 


#include <graphics/view.h> 


#define BADFLAGS (SPRITES | VP_HIDE|GENLOCK_AUDIO|GENLOCK_VIDEO) 
#define FLAGMASK (~BADFLAGS) 

#define CAMGMASK (FLAGMASK & QQQOFFFFL) 

camg.ViewModes = myScreen->ViewPort .Modes & CAMGMASK; /* Writing */ 
NewScreen.ViewModes = camg.ViewModes & CAMGMASK; /* Reading */ 


"TLBM" IFF Interleaved Bitmap 


3. Standard "BODY" Data Chunk 
Raster Layout 


Raster scan proceeds left-to-right (increasing X) across scan lines, then top-to-bottom (increasing Y) down columns of 
scan lines. The coordinate system is in units of pixels, where (0,0) is the upper left corner. 


The raster is typically organized as bitplanes in memory. The corresponding bits from each plane, taken together, 
make up an index into the color map which gives a color value for that pixel. The first bitplane, plane 0, is the low 
order bit of these color indexes. 


A scan line is made of one "row" from each bitplane. A row is one planes’ bits for one scan line, but padded out to a 
word (2 byte) boundary (not necessarily the first word boundary). Within each row, successive bytes are displayed in 
order and the most significant bit of each byte is displayed first. 


A "mask" is an optional "plane" of data the same size (w, h) as a bitplane. It tells how to "cut out" part of the image 
when painting it onto another image. "One" bits in the mask mean "copy the corresponding pixel to the destination". 
"Zero" mask bits mean “leave this destination pixel alone". In other words, "zero" bits designate transparent pixels. 


The rows of the different bitplanes and mask are interleaved in the file (see below). This localizes all the information 
pertinent to each scan line. It makes it much easier to transform the data while reading it to adjust the image size or 
depth. It also makes it possible to scroll a big image by swapping rows directly from the file without the need for 
random-access to all the bitplanes. 


BODY 


The source raster is stored ina "BODY" chunk. This one chunk holds all bitplanes and the optional mask, interleaved 
by row. 


The BitMapHeader, in a BMHD property chunk, specifies the raster's dimensions w, h, and nPlanes. It also holds 
the masking field which indicates if there is a mask plane and the compression field which indicates the 
compression algorithm used. This information is needed to interpret the BODY chunk, so the BMHD chunk must 
appear first. While reading an ILBM's BODY, a program may convert the image to another size by filling (with 
transparentColor) or clipping. 


The BODY 's content is a concatenation of scan lines. Each scan line is a concatenation of one row of data from each 
plane in order 0 through nPlanes-1 followed by one row from the mask (ifmasking = hasMask ). If the 
BitMapHeader field compression is cmpNone, all h rows are exactly (w+15) /16 words wide. Otherwise, every 
row is compressed according to the specified algorithm and the stored widths depend on the data compression. 


Reader programs that require fewer bitplanes than appear in a particular ILBM file can combine planes or drop the 
high-order (later) planes. Similarly, they may add bitplanes and/or discard the mask plane. 


Do not compress across rows, and don't forget to compress the mask just like the bitplanes. Remember to pad any 
BODY chunk that contains an odd number of bytes and skip the pad when reading. 


"TLBM"” IFF Interleaved Bitmap 


4, Nonstandard Data Chunks 
The following data chunks were defined after various programs began using FORM ILBM so they are "nonstandard" 
chunks. See the registry document for the latest information on additional nonstandard chunks. 

CRNG 
A "CRNG" chunk contains "color register range” information. It's used by Electronic Arts’ Deluxe Paint program to 
identify a contiguous range of color registers for a "shade range” and color cycling. There can be zero or more CRNG 
chunks in an ILBM, but all should appear before the BODY chunk. Deluxe Paint normally writes 4 CRNG chunks in 


an ILBM when the user asks it to "Save Picture". 


typedef struct { 


WORD padl; /* reserved for future use; store 0 here *x/ 
WORD rate; /* color cycle rate x / 
WORD flags; /* see below x / 
UBYTE low, high; /* lower and upper color registers selected x/ 
} CRange; 


The bits of the £lags word are interpreted as follows: if the low bit is set then the cycle is "active", and if this bit is 
clear it is not active. Normally, color cycling is done so that colors move to the next higher position in the cycle, 
with the color in the high slot moving around to the low slot. If the second bit of the flags word is set, the cycle 
moves in the opposite direction. As usual, the other bits of the flags word are reserved for future expansion. Here are 
the masks to test these bits: 


#define RNG ACTIVE 1 
#define RNG_REVERSE 2 


The fields low and high indicate the range of color registers (color numbers) selected by this CRange. 

The field act ive indicates whether color cycling is on or off. Zero means off. 

The field rate determines the speed at which the colors will step when color cycling is on. The units are such that a 
rate of 60 steps per second is represented as 214 = 16384. Slower rates can be obtained by linear scaling: for 30 
steps/second, rate = 8192; for 1 step/second, rate = 16384/60 = 273. 


CCRT 


Commodore's Graphicraft program uses a similar chunk "CCRT" (for Color Cycling Range and Timing). This chunk 
contains a CycleInfo structure. 


typedef struct { 


WORD direction; /* 0 = don't cycle. 1 = cycle forwards (1, 2, 3). 

* -1 = cycle backwards (3, 2, 1) *x/ 
UBYTE start, end; /* lower and upper color registers. selected */ 
LONG seconds; /* # seconds between changing colors plus... x / 
LONG microseconds; /* # microseconds between changing colors xf 
WORD pad; /* reserved for future use; store 0 here x / 


} CycleInfo; 


This is very similar to a CRNG chunk. A program would probably only use one of these two methods of expressing 
color cycle data, new programs should use CRNG, You could write out both if you want to communicate this 
information to both Deluxe Paint and Graphicraft. 


“TLBM" IFF Interleaved Bitmap 
Appendix A, ILBM Regular Expression 


Here's a regular expression summary of the FORM ILBM syntax. This could be an IFF file or a part of one. 


TLBM ::= "FORM" #{. “ILBM" BMHD [CMAP] [GRAB] [DEST] [SPRT] [CAMG] 
CRNG* CCRT* [BODY] } 

BMHD ::= "BMHD" #{ BitMapHeader } 

CMAP = "CMAP" #{ (red green blue)* } [0] 

GRAB ::= "GRAB" #{ Point2D } 

DEST ::= "DEST" #{ DestMerge } 

SPRT ::= "“SPRT" #{ SpritePrecedence  } 

CAMG ::= "CAMG" #{ LONG } 

CRNG ::= "CRNG" #{ CRange } 

CCRT ::= "CCRT" #{ CycleInfo } 

BODY ::= "BODY" #{ UBYTE* }- [0] 


The token "#" represents a ckSize LONG count of the following {braced} data bytes. E.g. a BMHD's "#" should 
equal sizeof (BitMapHeader) . Literal strings are shown in "quotes", [square bracket items] are optional, and 
"x" means O or more repetitions. A sometimes-needed pad byte is shown as "[0]". 


The property chunks BMHD, CMAP, GRAB, DEST, SPRT, CAMG and any CRNG and CCRT data chunks may 
actually be in any order but all must appear before the BODY chunk since ILBM readers usually stop as soon as they 
read the BODY. If any of the 6 property chunks are missing, default values are inherited from any shared properties (if 
the ILBM appears inside an IFF LIST with PROPs) or from the reader program's defaults. If any property appears 


more than once, the last occurrence before the BODY is the one that counts since that's the one that modifies the 
BODY. 


Appendix B. ILBM Box Diagram 


Here's a box diagram for a simple example: an uncompressed image 320 x 200 pixels x 3 bitplanes. The text to the 
right of the diagram shows the outline that would be printed by the IFFCheck utility program for this particular file. 


FORM 24070 ILBM 


-BMHD 20 


-CMAP 21 









-BODY 24000 


‘BODY’ 24000 


The "0" after the CMAP chunk is a pad byte. 


T- 34 


"ILBM" IFF Interleaved Bitmap 
Appendix C. ByteRun1 Run Encoding 


The run encoding scheme byteRun1 is best described by pseudo code for the decoder Unpacker (called UnPackBits in 
the Macintosh™ toolbox): 


UnPacker: 
LOOP until produced the desired number of bytes 
Read the next source byte into n 
SELECT n FROM 


[0..127] => copy the next n+l bytes literally 
[~1..-127] => replicate the next byte -n+1l times 
-128 => no operation 
ENDCASE; 

ENDLOOP; 


In the inverse routine Packer, it's best to encode a 2 byte repeat run as a replicate run except when preceded and 
followed by a literal run, in which case it's best to merge the three into one literal run. Always encode 3 byte repeats 
as replicate runs. 


Remember that each row of each scan line of a raster is separately packed. 


Appendix D. Standards Committee 
The following people contributed to the design of this FORM ILBM standard: 


Bob "Kodiak" Burns, Commodore-Amiga 
R. J. Mical, Commodore-Amiga 

Jerry Morrison, Electronic Arts 

Greg Riker, Electronic Arts 

Steve Shaw, Electronic Arts 

Dan Silva, Electronic Arts 

Barry Walsh, Commodore-Amiga 


Appendix E. IFF Hints 
Hints on ILBM files from Jerry Morrison, Oct 1988. How to avoid some pitfalls when reading ILBM files: 


* Don't ignore the BitMapHeader.masking field. A bitmap with a mask (such as a partially-transparent DPaint 
brush or a DPaint picture with a stencil) will read as garbage if you don't de-interleave the mask. 

* Don't assume all images are compressed. Narrow images aren't usually run-compressed since that would actually 
make them longer. 

* Don't assume a particular image size. You may encounter overscan pictures and PAL pictures. 


There's a better way to read a BODY than the example IFF code. The GetBODY routine should call a GetScanline 
routine once per scan line, which calls a GetRow routine for each bitplane in the file. This in turn calls a 
GetUnpackedBytes routine, which calls a GetBytes routine as needed and unpacks the result. (If the picture is 
uncompressed, GetRow calls GetBytes directly.) Since the unpacker knows how many packed bytes to read, this 
avoids juggling buffers for a memory-to-memory UnPackBytes routine. 


Caution: If you make many AmigaDOS calls to read or write a few bytes at a time, performance will be mud! 
AmigaDOS has a high overhead per call, even with RAM disk. So use buffered read/write routines. 


I-35 


"ILBM" IFF Interleaved Bitmap 


Different hardware display devices have different color resolutions: 


Device R:G:B bits maxColor 
Mac SE 1 1 
IBM EGA 2:2:2 3 
Atari ST 3:3:3 7 
Amiga 4:4:4 15 
CD-I §:5:5 31 
IBM VGA 6:6:6 63 
Mac It 8:8:8 255 


An ILBM CMAP defines 8 bits of Red, Green and Blue (ie. 8:8:8 bits of R:G:B). When displaying on hardware 
which has less color resolution, just take the high order bits. For example, to convert ILBM's 8-bit Red to the 
Amiga's 4-bit Red, right shift the data by 4 bits (R4 := R8 >> 4). 


To convert hardware colors to ILBM colors, the ILBM specification says just set the high bits (R8 := R4 << 4). But 
you can transmit higher contrast to foreign display devices by scaling the data [0..maxColor] to the full range 
[0..255]. In other words, R8 := (Rn x 255) + maxColor. (Example #1: EGA color 1:2:3 scales to 85:170:255. 
Example #2: Amiga 15:7:0 scales to 255:119:0) This makes a big difference where maxColor is less than 15. In the 
extreme case, Mac SE white (1) should be converted to ILBM white (255), not to ILBM gray (128). 


CGA and EGA subtleties 


IBM EGA colors in 350 scan line mode are 2:2:2 bits of R:G:B, stored in memory as xxR'G'B'RBG. That's 3 
low-order bits followed by 3 high-order bits. 


IBM CGA colors are 4 bits stored in a byte as xxxxIRGB. (EGA colors in 200 scan line modes are the same as CGA 
colors, but stored in memory as xxxIxRGB.) That's 3 high-order bits (one for each of R, G, and B) plus one low-order 
"Intensity" bit for all 3 components R, G, and B. Exception: IBM monitors show IRGB = 0110 as brown, which is 
really the EGA color R:G:B = 2:1:0, not dark yellow 2:2:0. 


"ETXT" TIFF Formatted Text 


Date: November 15, 1985 (Updated Oct, 1988 Commodore-Amiga, Inc.) 
From: Steve Shaw and Jerry Morrison, Electronic Arts and Bob "Kodiak" Burns, Commodore-Amiga 


Status: Adopted 


1. Introduction 


This memo is the IFF supplement for FORM FTXT. An FTXT is an IFF “data section" or "FORM type"—which 
can be an IFF file or a part of one—containing a stream of text plus optional formatting information."EA IFF 85” is 
Electronic Arts' standard for interchange format files, (See the IFF reference.) 


An FYXT is an archival and interchange representation designed for three uses. The simplest use is for a "console 
device" or "glass teletype" (the minimal 2-D text layout means): a stream of "graphic" ("printable") characters plus 
positioning characters "space" ("SP") and line terminator ("LF"). This is not intended for cursor movements on a 
screen although it does not conflict with standard cursor-moving characters. The second use is text that has explicit 
formatting information (or "looks") such as font family and size, typeface, etc. The third use is as the lowest layer of 
a structured document that also has “inherited” styles to implicitly control character looks. For that use, FORMs 
FTXT would be embedded within a future document FORM type. The beauty of FTXT is that these three uses are 
interchangeable, that is, a program written for one purpose can read and write the others’ files. So a word processor 
does not have to write a separate plain text file to communicate with other programs. 


Text is stored in one or more "CHRS" chunks inside an FTXT. Each CHRS contains a stream of 8-bit text 
compatible with ISO and ANSI data interchange standards. FTXT uses just the central character set from the 
ISO/ANSI standards. (These two standards are henceforth called "ISO/ANSI" as in "see the ISO/ANSI reference”) 


Since it's possible to extract just the text portions from future document FORM types, programs can exchange data 
without having to save both plain text and formatted text representations. 


Character looks are stored as embedded control sequences within CHRS chunks. This document specifies which class 
of control sequences to use: the CSI group. This document does not yet specify their meanings, e.g. which one means 
“turn on italic face". Consult ISO/ANSI. 


Section 2 defines the chunk types character stream "CHRS" and font specifier "FONS". These are the "standard" 
chunks, Specialized chunks for private or future needs can be added later. Section 3 outlines an FTXT reader program 
that strips a document down to plain unformatted text. Appendix A is a code table for the 8-bit ISO/ANSI character 
set used here. Appendix B is an example FTXT shown as a box diagram. Appendix C is a racetrack diagram of the 
syntax of ISO/ANSI control sequences. 


Reference: 


Amiga® is a registered trademark of Commodore-Amiga, Inc. 
Electronic Arts™ is a trademark of Electronic Arts. 


IFF: "EA JFF 85" Standard for Interchange Format Files describes the underlying conventions for all IFF files. 
ISO/ANSI: ISO/DIS 6429.2 and ANSI X3.64-1979. International Organization for Standardization (ISO) and 


American National Standards Institute (ANSI) data-interchange standards. The relevant parts of these two standards 
documents are identical. ISO standard 2022 is also relevant. 


"FTXT" IFF Formatted Text 
2. Standard Data and Property Chunks 


The main contents of a FORM FTX is in its character stream “CHRS" chunks. Formatting property chunks may 
also appear. The only formatting property yet defined is "FONS", a font specifier. A FORM FTXT with no CHRS 
represents an empty text stream. A FORM FTXT may contain nested IFF FORMs, LISTs, or CATs, although a 
"stripping" reader (see section 3) will ignore them. 


Character Set 


FORM FTXT uses the core of the 8-bit character set defined by the ISO/ANSI standards cited at the start of this 
document. (See Appendix A for a character code table.) This character set is divided into two "graphic" groups plus 
two "control" groups. Eight of the control characters begin ISO/ANSI standard control sequences. (See "Control 
Sequences", below.) Most control sequences and control characters are reserved for future use and for compatibility 
with ISO/ANSI. Current reader programs should skip them. 


* CO is the group of control characters in the range NUL (hex 0) through hex 1F. Of these, only LF (hex 0A) 
and ESC (hex 1B) are significant. ESC begins a control sequence. LF is the line terminator, meaning “go to 
the first horizontal position of the next line". All other CO characters are not used. In particular, CR (hex OD) 
is not recognized as a line terminator. 

GO is the group of graphic characters in the range hex 20 through hex 7F. SP (hex 20) is the space character. 
DEL (hex 7F) is the delete character which is not used. The rest are the standard ASCII printable characters “!” 
(hex 21) through “~” (hex 7E). 

C1 is the group of extended control characters in the range hex 80 through hex 9F. Some of these begin 
control sequences. The control sequence starting with CSI (hex 9B) is used for FTXT formatting. All other 
control sequences and C1 control characters are unused. 

G1 is the group of extended graphic characters in the range NBSP (hex AO) through “y” (hex FF). It is one of 
the alternate graphic groups proposed for ISO/ANSI standardization. 


Control Sequences 


Eight of the control characters begin ISO/ANSI standard "control sequences" (or “escape sequences”). These sequences 
are described below and diagramed in Appendix C. 


GO ::= (SP through DEL) 

Gl ::= (NBSP through “y”) 

ESC-Seq ::= ESC (SP through “/")* (“0” through ‘~’) 
ShiftToG2 ::= SS2 G0 

ShiftToG3 ::= SS3 G0 

CSI-Seq ::= CSI (SP through “?”)* (“@”% through “~”) 

DCS-Seq ::= (DCS | OSC. | PM | APC) (SP through “~” | G1)* ST 


"ESC-Seq" is the control sequence ESC (hex 1B), followed by zero or more characters in the range SP through “/” 
(hex 20 through hex 2F), followed by a character in the range “O” through “~” (hex 30 through hex 7E). These 
sequences are reserved for future use and should be skipped by current FTXT reader programs. 


SS2 (hex 8E) and SS3 (hex 8F) shift the single following GO character into yet-to-be-defined graphic sets G2 and G3, 
respectively. These sequences should not be used until the character sets G2 and G3 are standardized. A reader may 
simply skip the SS2 or SS3 (taking the following character as a corresponding GO character) or replace the 
two-character sequence with a character like “?” to mean “absent”. 


FTXT uses "CSI-Seq" control sequences to store character formatting (font selection by number, type face, and text 


size) and perhaps layout information (position and rotation). "CSI-Seq” control sequences start with CSI (the "control 
sequence introducer", hex 9B). Syntactically, the sequence includes zero or more characters in the range SP through 


I- 38 


"FTXT" IFF Formatted Text 


“2” (hex 20 through hex 3F) and a concluding character in the range “@” through “‘~” (hex 40 through hex 7E). These 
sequences may be skipped by a minimal FTXT reader, i.e. one that ignores formatting information. 


Note: A future FTXT standardization document will explain the uses of CSI-Seq sequences for setting character face 
(light weight vs. medium vs. bold, italic vs. upright, height, pitch, position, and rotation). For now, consult the 
ISO/ANSI references. 


"DCS -Seq” is the control sequences starting with DCS (hex 90), OSC (hex 9D), PM (hex 9E), or APC (hex 9F), 
followed by zero or more characters each of which is in the range SP through “~” (hex 20 through hex TE) or else a 
G1 character, and terminated by an ST (hex 9C). These sequences are reserved for future use and should be skipped by 
current FTXT reader programs. 


Data Chunk CHRS 


A CHRS chunk contains a sequence of 8-bit characters abiding by the ISO/ANSI standards cited at the start of this 
document. This includes the character set and control sequences as described above and summarized in Appendix A and 
C. 


A FORM FTXT may contain any number of CHRS chunks. Taken together, they represent a single stream of textual 
information. That is, the contents of CHRS chunks are effectively concatenated except that (1) each control sequence 
must be completely within a single CHRS chunk, and (2) any formatting property chunks appearing between two 
CHRS chunks affects the formatting of the latter chunks text. Any formatting settings set by control sequences 
inside a CHRS carry over to the next CHRS in the same FORM FTXT. All formatting properties stop at the end of 
the FORM since IFF specifies that adjacent FORMs are independent of each other (although not independent of any 
properties inherited from an enclosing LIST or FORM). 


Property Chunk FONS 
The optional property "FONS" holds a FontSpecifier as defined in the C declaration below. It assigns a font toa 
numbered “font register” so it can be referenced by number within subsequent CHRS chunks. (This function is not 
provided within the ISO and ANSI standards.) The font specifier gives both a name and a description for the font so 


the recipient program can do font substitution. 


By default, CHRS text uses font 1 until it selects another font. A minimal text reader always uses font 1. If font 1 
hasn't been specified, the reader may use the local system font as font 1. 


typedef struct { 


UBYTE id; /* 0 through 9 is a font id number referenced by an SGR 
control sequence selective parameter of 10 through 19. 
Other values are reserved for future standardization. */ 
UBYTE padl; /* reserved for future use; store 0 here x / 
UBYTE proportional; /* proportional font? 0 = unknown, 1 = no, 2 = yes */ 
UBYTE serif; /* serif font? 0 = unknown, 1 = no, 2 = yes */ 
char name[]; /* A NUL-terminated string naming the preferred font. */ 


} FontSpecifier; 


Fields are filed in the order shown, The UBYTE fields are byte-packed (2 per 16-bit word). The field pad is reserved 
for future standardization. Programs should store 0 there for now. 


The field proportional indicates if the desired font is proportional width as opposed to fixed width. The field 
serif indicates if the desired font is serif as opposed to sans serif. [Issue: Discuss font substitution!] 


“FTXT" IFF Formatted Text 
Future Properties 


New optional property chunks may be defined in the future to store additional formatting information. They will be 
used to represent formatting not encoded in standard ISO/ANSI control sequences and for “inherited" formatting in 
structured documents. Text orientation might be one example. 


Positioning Units 


Unless otherwise specified, position and size units used in FTXT formatting properties and control sequences are in 
decipoints (720 decipoints/inch). This is ANSI/ISO Positioning Unit Mode (PUM) 2. While a metric standard might 
be nice, decipoints allow the existing U.S.A. typographic units to be encoded easily, e.g. "12 points" is "120 
decipoints". 


3. FTXT Stripper 


An FTXT reader program can read the text and ignore all formatting and structural information in a document FORM 
that uses FORMs FTXT for the leaf nodes. This amounts to stripping a document down to a stream of plain text. It 
would do this by skipping over all chunks except FTXT.CHRS (CHRS chunks found inside a FORM FTXT) and 
within the FTXT.CHRS chunks skipping all control characters and control sequences. (Appendix C diagrams this text 
scanner.) It may also read FTXT.FONS chunks to find a description for font 1. 


Here's a Pascal-ish program for an FTXT stripper. Given a FORM (a document of some kind), it scans for all 
FTXT.CHRS chunks. This would likely be applied to the first FORM in an IFF file. 


PROCEDURE ReadFORM4CHRS {); {Read an IFF FORM for FTXT.CHRS chunks. } 
BEGIN 
IF the FORM's subtype = "FTXT" 


THEN ReadFTXT4CHRS () 
ELSE WHILE something left to read in the FORM DO BEGIN 
read the next chunk header; 
CASE the chunk's ID OF 
"LIST", “CAT "; ReadCAT4CHRS (); 
"FORM": ReadFORM4CHRS (); 
OTHERWISE skip the chunk's body; 
END 
END 
END; 


{Read a LIST or CAT for all FTXT.CHRS chunks. } 
PROCEDURE ReadCAT4CHRS (); 
BEGIN 
WHILE something left to read in the LIST or CAT DO BEGIN 
read the next chunk header; 
CASE the chunk's ID OF 


"LIST", "CAT ": ReadCAT4CHRS (); 
"FORM": ReadFORM4CHRS () ; 
"PROP": IF we're reading a LIST AND the PROP's subtype = "FTXT" 


THEN read the PROP for "FONS" chunks; 
OTHERWISE error--malformed IFF file; 
END 
END 
END; 


"FTXT" IFF Formatted Text 


PROCEDURE ReadFTXT4CHRS (); {Read a FORM FTXT for CHRS chunks. } 
BEGIN : 
WHILE something left to read in the FORM FTXT DO BEGIN 
read the next: chunk header; 
CASE the chunk's ID OF 
"“CHRS": ReadCHRS (); 
“FONS": BEGIN 
read the chunk's contents into a FontSpecifier variable; 
IF the font specifier's id = 1 THEN use this font; 


END; 
OTHERWISE skip the chunk's body; 
END 
END 
END; 


{Read an FTXT.CHRS. Skip all control sequences and unused control chars. } 
PROCEDURE ReadCHRS () ; 
BEGIN 
WHILE something left to read in the CHRS chunk DO 
CASE read the next character OF 
LF: start a new output line; 


ESC: SkipControl([' '..'/'], ['0O'..'~')); 

IN [* *..'~'], IN [NBSP..'y']: output the character; 

SS2, SS3: ; {Just handle the following GO character directly, 
ignoring the shift to G2 or G3.} 

CSI: SkipControl({' '..'?'], ['@t..'~"]); 

DCS, OSC, PM, APC: SkipControl([' '..'~'] + [NBSP..'y¥'], [ST]}); 

END 


END; 


{Skip a control sequence of the format (rSet)* (tSet), i.e. any number of 
characters in the set rSet followed by a character in the set tSet.} 
PROCEDURE SkipControl(rSet, tSet); 
VAR c: CHAR; 
BEGIN 
REPEAT c := read the next character 
UNTIL ¢c NCT IN rSet; 
IF c NOT IN tSet 
THEN put character c back into the input stream; 
END 


The following program is an optimized version of the above routines ReadFORM4CHRS and ReadCAT4CHRS for 
the case where you're ignoring fonts as well as formatting. It takes advantage of certain facts of the IFF format to read 
a document FORM and its nested FORMs, LISTs, and CATs without a stack. In other words, it's a hack that ignores 
all fonts and faces to cheaply get to the plain text of the document. 


{Cheap scan of an IFF FORM for FTXT.CHRS chunks. } 
PROCEDURE ScanFORMACHRS () ; 
BEGIN 
IF the document FORM's subtype = "FTXT" 
THEN ReadFTXT4CHRS () 
ELSE WHILE something left to read in the FORM DO BEGIN 
read the next chunk header; 
IF it's a group chunk (LIST, FORM, PROP, or CAT) 


I- 41 


"FTXT" IFF Formatted Text 


THEN read its subtype ID; 
CASE the chunk's ID OF 


"LIST", "CAT “3:7 {NOTE: See explanation below.*} 
"PORM": IF this FORM's subtype = "FTXT" THEN ReaGFTXT4CHRS () 
ELSE; {NOTE: See explanation below.*} 
OTHERWISE skip the chunk's body; 
END 
END 


END; 


*Note: This implementation is subtle. After reading a group header other than FORM FIXT it just continues 
reading. This amounts to reading all the chunks inside that group as if they weren't nested in a group. 


Appendix A: Character Code Table 


This table corresponds to the ISO/DIS 6429.2 and ANSI X3.64-1979 8-bit character set standards. Only the core 


character set of those standards is used in FTXT. 


Two G1 characters aren't defined in the standards and are shown as dark gray entries in this table. Light gray shading 
denotes control characters. (DEL is a control character although it belongs to the graphic group GO.) 


ISO/DIS 6429.2 and ANSI X3.64-1979 Character 


Code Table 





LSN Most Significant Nibble (hex digit) 

\ 0 1 2 3 4 5 6 7 8 9 A BC F 

0 SP Oo;@ | P| p 

1 ! 1/A Qja q 

2 " 2|B R]|b x 

3 # 3 /C S|ic s 

4 $ 41D Thad] t 

5 % 5]E Use u 

of & 6 |F Vif Vv 

7 ' | 7/G | wilg | w 

8h ( H X[h x 

9 ) I Y}ui Vy 

AL x J | 2] 4 z 

BE + K k { 

CH L \]7ol 

Di M ).| m } 

E N “jon 

F o| jot 
Control Graphic group Control Graphic group 
group GO group Gl 

co Cl 


"NBSP" is a “non-breaking space” 
"SHY" is a "soft hyphen" 


"FTXT" IFF Formatted Text 


Appendix B. FTXT Example 


Here's a box diagram for a simple example: "The quick brown fox jumped.Four score and seven", written in a 
proportional serif font named "Roman". 





FONS 
01, 00, 02, 02 
Roman 








86 








CHRS 27 


The quick brown fox jumped. 


CHRS 20 


Four score and seven 


The "0" after the first CHRS chunk is a pad byte. 









Appendix C. ISO/ANSI Control Sequences 


This is a racetrack diagram of the ISO/ANSI characters and control sequences as used in FTXT CHRS chunks. 


line terminator 


printable 
ShiftToG2 (produces a G2 character) 
ShiftToG3 (produces a G3 character) 


DCS-Seq 


DCS, OSC, PM, or APC (72D 
SP through (-) Qe 
G1 
discard 
any other character 


"ETXT" IFF Formatted Text 


Of the various control sequences, only CSI-Seq is used for FTXT character formatting information. The others are 
reserved for future use and for compatibility with ISO/ANSI standards. Certain character sequences are syntactically 
malformed, e.g. CSI followed by a CO, Cl, or G1 character. Writer programs should not generate reserved or 
malformed sequences and reader programs should skip them. 


Consult the ISO/ANSI standards for the meaning of the CSI-Seq control sequences. 


The two character set shifts SS2 and SS3 may be used when the graphic character groups G2 and G3 become 
standardized. 


"SMUS" IFF Simple Musical Score 


Date: February 20, 1987 (SID _Clef and SID_Tempo added Oct, 1988) 
From: Jerry Morrison, Electronic Arts 


Status: Adopted 


1. Introduction 


This is a reference manual for the data interchange format "SMUS", which stands for Simple MUsical Score. "EA 
IFF 85" is Electronic Arts’ standard for interchange format files. A FORM (or "data section") such as FORM SMUS 
can be an IFF file or a part of one. [See “EA IFF 85" Electronic Arts Interchange File Format.] 


SMUS is a practical data format for uses like moving limited scores between programs and storing theme songs for 
game programs. The format should be geared for easy read-in and playback. So FORM SMUS uses the compact time 
encoding of Common Music Notation (half notes, dotted quarter rests, etc.). The SMUS format should also be 
structurally simple. So it has no provisions for fancy notational information needed by graphical score editors or the 
more general timing (overlapping notes, etc.) and continuous data (pitch bends, etc.) needed by performance-oriented 
MIDI recorders and sequencers. Complex music programs may wish to save in a more complete format, but still 
import and export SMUS when requested. 


A SMUS score can say which "instruments" are supposed play which notes. But the score is independent of whatever 
output device and driver software is used to perform the notes. The score can contain device- and driver-dependent 
instrument data, but this is just a cache. As long as a SMUS file stays in one environment, the embedded instrument 
data is very convenient. When you move a SMUS file between programs or hardware configurations, the contents of 
this cache usually become useless. 


Like all IFF formats, SMUS is a filed or "archive" format. It is completely independent of score representations in 
working memory, editing operations, user interface, display graphics, computation hardware, and sound hardware. 
Like all IFF formats, SMUS is extensible. 


SMUS is not an end-all musical score format. Other formats may be more appropriate for certain uses. (We'd like to 
design an general-use IFF score format "GSCR". FORM GSCR would encode fancy notational data and performance 
data. There would be a SMUS to/from GSCR converter.) 


Section 2 gives important background information. Section 3 details the SMUS components by defining the required 
property score header "SHDR", the optional text properties name "NAME", copyright "(c) ", and author "AUTH", 
optional text annotation "ANNO", the optional instrument specifier "INS1", and the track data chunk "TRAK". 
Section 4 defines some chunks for particular programs to store private information. These are "standard" chunks; 
specialized chunks for future needs can be added later. Appendix A is a quick-reference summary. Appendix B is an 
example box diagram. Appendix C names the committee responsible for this standard. 


References: 


“EA IFF 85" Standard for Interchange Format Files describes the underlying conventions for all IFF files. 
"8S VX" IFF 8-Bit Sampled Voice documents a data format for sampled instruments. 

MIDI: Musical Instrument Digital Interface Specification 1,0, International MIDI Association, 1983. 
SSSP: See various articles on Structured Sound Synthesis Project in Foundations of Computer Music. 


Electronic Arts™ is a trademark of Electronic Arts. 
Amiga® is a registered trademark of Commodore-Amiga, Inc. 


"SMUS" IFF Simple Musical Score 
2. Background 
Here's some background information on score representation in general and design choices for SMUS. 


First, we'll borrow some terminology from the Structured Sound Synthesis Project. [See the SSSP reference.] A ° 
"musical note" is one kind of scheduled event. \t's properties include an event duration, an event delay, and a timbre 
object. The event duration tells the scheduler how long the note should last. The event delay tells how long after 
starting this note to wait before starting the next event. The timbre object selects sound driver data for the note; an 
“instrument” or "timbre". A “rest” is a sort of a null event. Its only property is an event delay. 


Classical Event Durations 


SMUS is geared for "classical" scores, not free-form performances. So its event durations are classical (whole note, 
dotted quarter rest, etc.). SMUS can tie notes together to build a "note event" with an unusual event duration. The set 
of useful classical durations is very small. So SMUS needs only a handful of bits to encode an event duration. This is 
very compact. It's also very easy to display in Common Music Notation (CMN). 


Tracks 
The events in a SMUS score are grouped into parallel "tracks". Each track is a linear stream of events. 
Why use tracks? Tracks serve 4 functions: 


1. Tracks make it possible to encode event delays very compactly. A “classical” score has chorded notes and 
sequential notes; no overlapping notes. That is, each event begins either simultaneous with or immediately 
following the previous event in that track. So each event delay is either 0 or the same as the event's duration. 
This binary distinction requires only one bit of storage. 


2. Tracks represent the "voice tracks" in Common Music Notation. CMN organizes a score in parallel staves, 
with one or two “voice tracks” per staff. So one or two SMUS tracks represents a CMN staff. 


3. Tracks are a good match to available sound hardware. We can use "instrument settings” in a track to store the 
timbre assignments for that track's notes. The instrument setting may change over the track. 


Furthermore, tracks can help to allocate notes among available output channels or performance devices or tape 
recorder “tracks”. Tracks can also help to adapt polyphonic data to monophonic output channels. 


4, Tracks are a good match to simple sound software. Each track is a place to hold state settings like "dynamic 
mark pp ", "time signature 3/4", “mute this track", etc., just as it's a context for instrument settings. This is 
a lot like a text stream with running "font" and "face" properties (attributes). Running state is usually more 
compact than, say, storing an instrument setting in every note event. It's also a useful way to organize 
“attributes” of notes. With "running track state" we can define new note attributes in an upward- and 
backward-compatible way. 


Running track state can be expanded (run decoded) while loading a track into memory or while playing the 
track. The runtime track state must be reinitialized every time the score is played. 


Separated vs. interleaved tracks. Multi-track data could be stored either as separate event streams or interleaved into 
one stream. To interleave the streams, each event has to carry a "track number" attribute. 


If we were designing an editable score format, we might interleave the streams so that nearby events are stored nearby. 


This helps when searching the data, especially if you can't fit the entire score into memory at once. But it takes extra 
storage for the track numbers and may take extra work to manipulate the interleaved tracks. 


I- 46 


"SMUS" IFF Simple Musical Score 


The musical score format FORM SMUS is intended for simple loading and playback of small scores that fit entirely 
in main memory. So we chose to store its tracks separately. 


There can be up to 255 tracks ina FORM SMUS. Each track is stored as a TRAK chunk. The count of tracks (the 
number of TRAK chunks) is recorded in the SHDR chunk at the beginning of the FORM SMUS. The TRAK chunks 
appear in numerical order 1, 2, 3, .... This is also priority order, most important track first. A player program that can 
handle up to N parallel tracks should read the first N tracks and ignore any others. 


The different tracks in a score may have different lengths. This is true both of storage length and of playback duration. 


Instrument Registers 


Instrument reference. In SSSP, each note event points to a "timbre object" which supplies the "instrument" (the 
sound driver data) for that note. FORM SMUS stores these pointers as a "current instrument setting" for each track. 
It's just a run encoded version of the same information. SSSP uses a symbol table to hold all the pointers to "timbre 
object". SMUS uses INS1 chunks for the same purpose. They name the score's instruments. 


The actual instrument data to use depends on the playback environment, but we want the score to be independent of 
environment. Different playback environments have different audio output hardware and different sound driver 
software. And there are channel allocation issues like how many output channels there are, which ones are 
polyphonic, and which I/O ports they're connected to. If you use MIDI to control the instruments, you get into issues 
of what kind of device is listening to each MIDI channel and what each of its presets sounds like. If you use 
computer-based instruments, you need driver-specific data like waveform tables and oscillator parameters. 


We just want some orchestration. If the score wants a "piano", we let the playback program find a "piano". 


Instrument reference by name. A reference from a SMUS score to actual instrument data is normally by name. The 
score simply names the instrument, for instance "tubular bells". It's up to the player program to find suitable 
instrument data for its output devices. (More on locating instruments below.) 


Instrument reference by MIDI channel and preset. A SMUS score can also ask for a specific MIDI channel number and 
preset number. MIDI programs may honor these specific requests. But these channel allocations can become obsolete 
or the score may be played without MIDI hardware. In such cases, the player program should fall back to instrument 
reference by name. 


Instrument reference via instrument register. Each reference from a SMUS track to an instrument is via an 
“instrument register". Each track selects an instrument register which in turn points to the specific instrument data. 


Each score has an array of instrument registers. Each track has a "current instrument setting”, which is simply an 
index number into this array. This is like setting a raster image's pixel to a specific color number (a reference to a 
color value through a "color register") or setting a text character to a specific font number (a reference to a font 
through a "font register"). This is diagramed below: 


p‘piano” 


“guitar” 











Track 1 


Note] Note]Note] ... 


(internal guitar data) 


“Spanish guitar” (internal Spanish guitar data) 
_(internal bass drum data) 


Set inst 4 | Note] Note] Note[Note] Note[Note] ... | 













Instrument 
Registers 


Track 2 





"SMUS" IFF Simple Musical Score 


Locating instrument data by name. "INS1" chunks in a SMUS score name the instruments to use for that score. The 
player program uses these names to locate instrument data. 


To locate instrument data, the player performs these steps: 


For each instrument register, check for a suitable instrument with the right name... 
{"Suitable” means usable with an available output device and driver. } 
{Use case independent name comparisons. } 


1. Initialize the instrument register to point to a built-in default instrument. 
{Every player program must have default instruments. Simple programs stop here. For fancier programs, the 
default instruments are a backstop in case the search fails. } 


2. Check any instrument FORMs embedded in the FORM SMUS. (This is an “instrument cache".) 

3. Else check the default instruments. 

4. Else search the local “instrument library". (The library might simply be a disk directory.) 

5. If all else fails, display the desired instrument name and ask the user to pick an available one. 
This algorithm can be implemented to varying degrees of fanciness. It's ok to stop searching after step 1, 2, 3, or 4. If 
exact instrument name matches fail, it's ok to try approximate matches. E.g. search for any kind of "guitar" if you 
can't find a "Spanish guitar". In any case, a player only has to search for instruments while loading a score. 
When the embedded instruments are suitable, they save the program from asking the user to insert the “right” disk in 
a drive and searching that disk for the "right" instrument. But it's just a cache. In practice, we rarely move scores 
between environments so the cache often works. When the score is moved, embedded instruments must be discarded (a 
cache miss) and other instrument data used. 
Be careful to distinguish an instrument's name from its filename—the contents name vs. container name. A musical 
instrument FORM should contain a NAME chunk that says what instrument it really is. Its filename, on the other 


hand, is a handle used to locate the FORM. Filenames are affected by external factors like drives, directories, and 
filename character and length limits. Instrument names are not. 


Issue: Consider instrument naming conventions for consistency. Consider a naming convention that aids approximate 
matches. E.g. we could accept "guitar, bass1" if we didn't find "guitar, bass". Failing that, we could accept "guitar" or 
any name starting with "guitar". 


Set instrument events. If the player implements the set-instrument score event, each track can change instrument 
numbers while playing. That is, it can switch between the loaded instruments. 


Initial instrument settings. Each time a score is played, every track's running state information must be initialized. 
Specifically, each track's instrument number should be initialized to its track number. Track 1 to instrument 1, etc. 
It's as if each track began with a set-instrument event. 

In this way, programs that don't implement the set-instrument event still assign an instrument to each track. The 
INS1 chunks imply these initial instrument settings. 


MIDI Instruments 


As mentioned above, A SMUS score can also ask for MIDI instruments. This is done by putting the MIDI channel 


I- 48 


"SMUS" IFF Simple Musical Score 


and preset numbers in an INS1 chunk with the instrument name. Some programs will honor these requests while 
others will just find instruments by name. 


MIDI Recorder and sequencer programs may simply transcribe the MIDI channel and preset commands in a recording 
session. For this purpose, set-MIDI-channel and set-MIDI-preset events can be embedded in a SMUS score's tracks. 
Most programs should ignore these events. An editor program that wants to exchange scores with such programs 
should recognize these events, It should let the user change them to the more general set-instrument events. 


3. Standard Data and Property Chunks 
A FORM SMUS contains a required property "SHDR" followed by any number of parallel "track" data chunks 
"TRAK". Optional property chunks such as "NAME", copyright "(c) ", and instrument reference "INS1" may also 
appear. Any of the properties may be shared over a LIST of FORMs SMUS by putting them in a PROP SMUS. 
[See the IFF reference.] 

Required Property SHDR 


The required property "SHDR" holds an SScoreHeader as defined in these C declarations and following documentation. 
An SHDR specifies global information for the score. It must appear before the TRAKs in a FORM SMUS. 


#define ID_SMUS MakeID('S', 'M', 'u', 'S*) 
#define ID_SHDR MakeID('S', 'H', 'D', 'R') 


typedef struct { 


UWORD tempo; /* tempo, 128ths quarter note/minute x / 
UBYTE volume; /* overall playback volume 0 through 127 */ 
UBYTE ctTrack; /* count of tracks in the score * f 


} SScoreHeader; 


[Implementation details. In the C struct definitions in this memo, fields are filed in the order shown. A UBYTE field 
is packed into an 8-bit byte. Programs should set all "pad" fields to 0. MakeID is a C macro defined in the main IEF 
document and in the source file IFF.h.] 


The field tempo gives the nominal tempo for all tracks in the score. It is expressed in 128ths of a quarter note per 
minute, i.e. 1 represents 1 quarter note per 128 minutes while 12800 represents 100 quarter notes per minute. You 
may think of this as a fixed point fraction with a 9-bit integer part and a 7-bit fractional part (to the right of the 
point), A coarse-tempoed program may simply shift tempo right by 7 bits to get a whole number of quarter notes 
per minute. The tempo field can store tempi in the range 0 up to 512. The playback program may adjust this tempo, 
perhaps under user control. 


Actually, this global tempo could actually be just an initial tempo if there are any "set tempo” SEvents inside the 
score (see TRAK, below). Or the global tempo could be scaled by "scale tempo" SEvents inside the score. These are 
potential extensions that can safely be ignored by current programs. [See More SEvents To Be Defined, below.] 

The field volume gives an overall nominal playback volume for all tracks in the score. The range of volume values 
0 through 127 is like a MIDI key velocity value. The playback program may adjust this volume, perhaps under 
direction of a user "volume control". 

Actually, this global volume level could be scaled by dynamic-mark SEvents inside the score (see TRAK, below). 
The field ct Track holds the count of tracks, i.e. the number of TRAK chunks in the FORM SMUS (see below). 


This information helps the reader prepare for the following data. 


I- 49 


"SMUS" IFF Simple Musical Score 


A playback program will typically load the score and call a driver routine PlayScore (tracks, tempo, 
volume) , supplying the tempo and volume from the SHDR chunk. 
Optional Text Chunks NAME, (c), AUTH, ANNO 
Several text chunks may be included in a FORM SMUS to keep ancillary information. 
The optional property "NAME" names the musical score, for instance "Fugue in Cc". 


The optional property "(c) ” holds a copyright notice for the score. The chunk ID "(c) " serves the function of the 
copyright characters "© ". E.g. a "(c) " chunk containing "1986 Electronic Arts" means "© 1986 Electronic Arts". 


The optional property "AUTH" holds the name of the score's author. 

The chunk types "NAME", "(c) ", and "AUTH" are property chunks. Putting more than one NAME (or other) 
property in a FORM is redundant. Just the last NAME counts. A property should be shorter than 256 characters. 
Properties can appear in a PROP SMUS to share them over a LIST of FORMs SMUS. 

The optional data chunk "ANNO" holds any text annotations typed in by the author. 

An ANNO chunk is not a property chunk, so you can put more than one ina FORM SMUS. You can make ANNO 
chunks any length up to 231 - 1 characters, but 32767 is a practical limit. Since they're not properties, ANNO 
chunks don't belong in a PROP SMUS. That means they can't be shared over a LIST of FORMs SMUS. 
Syntactically, each of these chunks contains an array of 8-bit ASCII characters in the range “ ” (SP, hex 20) through 
“” (tilde, hex 7F), just like a standard "TEXT" chunk. [See "Strings, String Chunks, and String Properties" in "EA 
IFF 85" Electronic Arts Interchange File Format.] The chunk's ckSize field holds the count of characters. 


#define ID_NAME MakeID('N', 'A', 'M', 'E') 
/* NAME chunk contains a CHAR[], the musical score's name. *x/ 


#define ID_Copyright MakeID('(', ‘c', ')', ' ') 
/* ™(c) ™ chunk contains a CHAR[], the FORM's copyright notice. */ 


#define ID_AUTH MakeID('A', 'U', 'T', "H!) 
/* AUTH chunk contains a CHAR[], the name of the score's author. x / 


#define ID_ANNO MakeID('A', 'N', 'N', 'O"') 
/* ANNO chunk contains a CHAR[], author's text annotations. x / 


Remember to store a 0 pad byte after any odd-length chunk. 


Optional Property INS1 
The "INS1" chunks in a FORM SMUS identify the instruments to use for this score. A program can ignore INS1 
chunks and stick with its built-in default instrument assignments. Or it can use them to locate instrument data. [See 
"Instrument Registers" in section 2, above.] 


#define ID_INS1 MakeID('I', 'N', 'S', '1") 


/* Values for the RefInstrument field "type". */ 
#define INS1 Name 0 /* just use the name; ignore datal, data2 */ 


T- 50 


"SMUS" IFF Simple Musical Score 
#define INS1_MIDI 1 /* <datal, data2> = MIDI <channel, preset> */ 


typedef struct { 


UBYTE register; /* set this instrument register number «ff 
UBYTE type; /* instrument reference type */ 
UBYTE datal, data2; /* depends on the "type" field */ 
CHAR name[]; /* instrument name * / 


} RefInstrument; 


An INS1 chunk names the instrument for instrument register number register. The register field can range 
from 0 through 255. In practice, most scores will need only a few instrument registers. 


The name field gives a text name for the instrument. The string length can be determined from the ckSize of the 
INS1 chunk. The string is simply an array of 8-bit ASCII characters in the range “” (SP, hex 20) through “~” (tilde, 
hex 7F). 


Besides the instrument name, an INS1 chunk has two data numbers to help locate an instrument. The use of these 

. data numbers is controlled by the type field. A value type = INS1_Name means just find an instrument by name. 
In this case, datal and data2 should just be set to 0. A value type = INS1_MIDI means look for an instrument 
on MIDI channel # dat al, preset # dat a2. Programs and computers without MIDI outputs will just ignore the 
MIDI data. They'll always look for the named instrument. Other values of the t ype field are reserved for future 
standardization. 


See section 2, above, for the algorithm for locating instrument data by name. 


Obsolete Property INST 


The chunk type "INST" is obsolete in SMUS. It was revised to form the "INS1" chunk. 


Data Chunk TRAK 


The main contents of a score is stored in one or more TRAK chunks representing parallel "tracks". One TRAK chunk 
per track. 

The contents of a TRAK chunk is an array of 16-bit "events" such as "note", "rest", and "set instrument”. Events are 
really commands to a simple scheduler, stored in time order. The tracks can be polyphonic, that is, they can contain 
chorded "note" events. 


Each event is stored as an "SEvent” record. ("SEvent" means "simple musical event".) Each SEvent has an 8-bit type 
field called an "sID" and 8 bits of type-dependent data. This is like a machine language instruction with an 8-bit 
opcode and an 8-bit operand. 


This format is extensible since new event types can be defined in the future. The "note" and "rest" events are the only 
ones that every program must understand. We will carefully design any new event types so that programs can safely 


skip over unrecognized events in a score. 


Caution: ID codes must be allocated by a central clearinghouse to avoid conflicts. Commodore-Amiga Technical 
Support provides this clearinghouse service. 


Here are the C type definitions for TRAK and SEvent and the currently defined sID values. Afterward are details on 
each SEvent. 


#define ID_TRAK MakeID('T', 'R', 'A', 'K') 


"SMUS" IFF Simple Musical Score 


/* TRAK chunk contains an SEvent[]. x / 
/* SEvent: Simple musical event. xf 
typedef struct { 
UBYTE sID; /* SEvent type code * f 
UBYTE data; /* sID-dependent data x / 
} SEvent; 
/* SEvent type codes "sID". * / 
#define SID_FirstNote 0 
#define SID_LastNote 127 /* sIDs in the range SID_FirstNote through 
x SID LastNote (sign bit = 0) are notes. The 
* sID is the MIDI tone number (pitch). */ 
#define SID_Rest 128 /* a rest (same data format as a note). */ 
#define SID Instrument 129 /* set instrument number for this track. xf 
#define SID_TimeSig 130 /* set time signature for this track. */ 
#define SID_KeySig 131 /* set key signature for this track. xf 
#define SID Dynamic 132 /* set volume for this track. */ 
#define SID _MIDI_Chn1 133 /* set MIDI channel number (sequencers) */ 
#define SID MIDI Preset 134 /* set MIDI preset number (sequencers) « f 
#define SID Clef 135 /* inline clef change. 
* 0=Treble, 1=Bass, 2=Alto, 3=Tenor. (new) */ 
#define SID Tempo 136 /* Inline tempo in beats per minute.(new) */ 
/* SID values 144 through 159: reserved for Instant Music SEvents. * 


/* Remaining sID values up through 254: reserved for future 
* standardization. 


#define SID Mark 


255 


* / 
/* sID reserved for an end-mark in RAM. xf 
Note and Rest SEvents 


The note and rest SEvents SID_FirstNote through SID_Rest have the following structure overlaid onto the 


SEvent structure: 


typedef struct { 


UBYTE 
unsigned 


} SNote; 


tone; 
chord 
tieOut 
nTuplet 


dot 
division 


/* 
{/* 
/* 
/* 


/* 
/* 


MIDI tone number 0 to 127; 128 = rest */ 
1 = a chorded note * f 
1 = tied to the next note or chord « f 
0 = none, 1 = triplet, 2 = quintuplet, 

3 = septuplet */ 


dotted note; multiply duration by 3/2 * f 
basic note duration is 2-division; 09 = whole 
note, 1 = half note, 2 = quarter note, 

7 = 128th note x / 


[Implementation details. Unsigned ":n" fields are packed into n bits in the order shown, most significant bit to least 
significant bit. An SNote fits into 16 bits like any other SEvent. Warning: Some compilers don't implement 
bit-packed fields properly. E.g. Lattice 68000 C pads a group of bit fields out to a LONG, which would make SNote 
take 5-bytes! In that situation, use the bit-field constants defined below.] 


I- 52 


"SMUS" IFF Simple Musical Score 


The SNote structure describes one "note" or "rest" in a track. The field SNote .t one, which is overlaid with the 
SEvent .sID field, indicates the MIDI tone number (pitch) in the range 0 through 127. A value of 128 indicates a 
rest. 


The fields nTuplet, dot, and division together give the duration of the note or rest. The division gives the 
basic duration: whole note, half note, etc. The dot indicates if the note or rest is dotted. A dotted note is 3/2 as long 
as an undotted note. The value nTuplet (0 through 3) tells if this note or rest is part of an N-tuplet of order 1 
(normal), 3, 5, or 7; an N-tuplet of order (2 * nTuplet + 1). A triplet note is 2/3 as long as a normal note, 
while a quintuplet is 4/5 as long and a septuplet is 6/7 as long. 


Putting these three fields together, the duration of the note or rest is 
2-division * {1, 3/2} * {1, 2/3, 4/5, 6/7} 


These three fields are contiguous so you can easily convert to your local duration encoding by using the combined 6 
bits as an index into a mapping table. 


The field chord indicates if the note is chorded with the following note (which is supposed to have the same 
duration). A group of notes may be chorded together by setting the chord bit of all but the last one. (In the 
terminology of SSSP and GSCR, setting the chord bit to 1 makes the "entry delay” 0.) A monophonic-track player 
can simply ignore any SNote event whose chord bit is set, either by discarding it when reading the track or by 
skipping it when playing the track. 


Programs that create polyphonic tracks are expected to store the most important note of each chord last, which is the 
note with the 0 chord bit. This way, monophonic programs will play the most important note of the chord. The 
most important note might be the chord's root note or its melody note. 


If the field t ieOut is set, the note is tied to the following note in the track if the following note has the same pitch. 
A group of tied notes is played as a single note whose duration is the sum of the component durations. Actually, the 
tie mechanism ties a group of one or more chorded notes to another group of one or more chorded notes. Every note 
in a tied chord should have its tieOut bit set. 


Of course, the chord and tieOut fields don't apply to SID_ Rest SEvents. 
Programs should be robust enough to ignore an unresolved tie, i.e. a note whose t ieOut bit is set but isn't followed 
by a note of the same pitch. If that's true, monophonic-track programs can simply ignore chorded notes even in the 


presense of ties. That is, tied chords pose no extra problems. 


The following diagram shows some combinations of notes and chords tied to notes and chords. The text below the 
staff has a column for each SNote SEvent to show the pitch, chord bit, and tieOut bit. 





pitch: DBG DBG DBG G DBG B B DBG 


chord: cc cc cc cc ec 
tieOut: ttt ttt ttt t 


If you read the above track into a monophonic-track program, it'll strip out the chorded notes and ignore unresolved 
ties. You'll end up with: 


I- 53 


"SMUS" IFF Simple Musical Score 


pitch: G G G G G B B G 
chord: 
tieOut: t t (t) (t) 


Arest event (SID = SID_Rest) has the same SEvent . data field as a note. It tells the duration of the rest. The 
chord and tieOut fields of rest events are ignored. 


Within a TRAK chunk, note and rest events appear in time order. 


Instead of the bit-packed structure SNote, it might be easier to assemble data values by or-ing constants and to 
disassemble them by masking and shifting. In that case, use the following definitions. 


#define noteChord (1<<7) /* note is chorded to next note x / 
#define noteTieOut (1<<6) /* tied to next note/chord x / 
#define noteNShift 4 /* shift count for nTuplet field */ 
#define noteN3 (l<<noteNShift) /* note is a triplet x / 
#define noteN5 (2<<noteNShift) /* note is a quintuplet */ 
#define noteN7 (3<<noteNShift) /* note is a septuplet * / 
#define noteNMask noteN7 /* bit mask for the nTuplet field x / 
#define noteDot (1<<3) /* note is dotted */ 
#define noteD1l 0 /* whole note division xf 
#define noteD2 1 /* half note division *x/ 
#define noteD4 2 /* quarter note division xf 
#define noteD8 3 /* eighth note division */ 
#define noteD16 4 /* sixteenth note division */ 
#define noteD32 5 /* thirty-second'th note division x / 
#define noteD64 6 /* sixty-fourth note division */ 
#define noteD128 7 /* 1/128 note division */ 
#define noteDMask noteD128 /* bit mask for the division field xf 
#define noteDurMask 0x3F /* mask for combined duration fields */ 


Note: The remaining SEvent types are optional. A writer program doesn't have to generate them. A reader program 
can safely ignore them. 


Set Instrument SEvent 
One of the running state variables of every track is an instrument number. An instrument number is the array index of 
an "instrument register", which in turn points to an instrument. (See "Instrument Registers", in section 2.) This is 


like a color number in a bitmap; a reference to a color through a “color register". 


The initial setting for each track's instrument number is the track number. Track 1 is set to instrument 1, etc. Each 
time the score is played, every track's instrument number should be reset to the track number. 


The SEvent SID_ Instrument changes the instrument number for a track, that is, which instrument plays the 


following notes. Its SEvent . data field is an instrument register number in the range 0 through 255. If a program 
doesn't implement the SID_ Instrument event, each track is fixed to one instrument. 


I- 54 


"SMUS" IFF Simple Musical Score 


Set Time Signature SEvent 


The SEvent SID_TimeS ig sets the time signature for the track. A "time signature" SEvent has the following 
structure overlaid on the SEvent structure: 


typedef struct { 


UBYTE type; /*x = SID_TimeSig */ 

unsigned timeNSig :5, /* time sig. “numerator" is timeNSig + 1 */ 
timeDSig :3; /* time sig. "denominator" is 2timeDSig; 

* Q = whole note, 1 = half note, 2 = quarter 

* note, .. 7 = 128th note */ 


} STimeSig; 


[Implementation details. Unsigned ":n" fields are packed into n bits in the order shown, most significant bit to least 
significant bit. An STimeSig fits into 16 bits like any other SEvent. Warning: Some compilers don't implement 
bit-packed fields properly. E.g. Lattice C pads a group of bit fields out to a LONG, which would make an STimeSig 
take 5-bytes! In that situation, use the bit-field constants defined below.] 


The field t ype contains the value SID_TimeSig, indicating that this SEvent is a "time signature" event. The field 
timeNSig indicates the time signature "numerator" is timeNSig + 1, that is, 1 through 32 beats per measure. 
The field t imeDS ig indicates the time signature “denominator” is 2timeDSig, that is each "beat" is a 2-timeDSig 
note (see SNote division, above). So 4/4 time is expressed as timeNSig =3, timeDSig = 2. 


The default time signature is 4/4 time. Be aware that the time signature has no effect on the score's playback. Tempo 
is uniformly expressed in quarter notes per minute, independent of time signature. (Quarter notes per minute would 
equal beats per minute only if timeDSig = 2, n/4 time). Nonetheless, any program that has time signatures should 
put them at the beginning of each TRAK when creating a FORM SMUS because music editors need them. 


Instead of the bit-packed structure STimeSig, it might be easier to assemble data values by or-ing constants and to 
disassemble them by masking and shifting. In that case, use the following definitions. 


#define timeNMask O0xF8 /* bit mask for the timeNSig field */ 

#define timeNShift 3 /* shift count for timeNSig field * f 

#define timeDMask 0x07 /* bit mask for the timeDSig field */ 
Key Signature SEvent 


An SEvent SID_KeySig sets the key signature for the track. Its data field isa UBYTE number encoding a major 
key: 


data key music notation data key music notation 
0 C maj 

1 G # 8 F b 

2 D Ht 9 Bb bb 

3 A HH 10 Eb bbb 

4 E HHA 11 Ab bbbb 

5 B HHH 12 Db bbbbb 

6 F# #HHHHH 13 Gb bbbbbb 

7 C# HAHAH 14 Cb bbbbbbb 


A SID_KeySig SEvent changes the key for the following notes in that track. C major is the default key in every 
track before the first SID_KeySig SEvent. 


"SMUS" IFF Simple Musical Score 


Dynamic Mark SEvent 
An SEvent SID_Dynamic represents a dynamic mark like ppp and fff in Common Music Notation. Its data field 
is a MIDI key velocity number 0 through 127. This sets a "volume control" for following notes in the track. This 


“track volume control" is scaled by the overall score volume in the SHDR chunk. The default dynamic level is 127 
(full volume). 


Set MIDI Channel SEvent 


The SEvent SID _MIDI_Chn1 is for recorder programs to record the set-MIDI-channel low level event. The data 
byte contains a MIDI channel number. Other programs should use instrument registers instead. 


Set MIDI Preset SEvent 





The SEvent SID _MIDI_Preset is for recorder programs to record the set-MIDI-preset low level event. The data 
byte contains a MIDI preset number. Other programs should use instrument registers instead. 


Instant Music Private SEvents 


Sixteen SEvents are used for private data for the Instant Music program. SID values 144 through 159 are reserved for 
this purpose. Other programs should skip over these SEvents. 


End-Mark SEvent 


The SEvent type SID_Mark is reserved for an end marker in working memory. This event is never stored in a file. It 
may be useful if you decide to use the filed TRAK format intact in working memory. 





More SEvents can be defined in the future. The sID codes 133 through 143 and 160 through 254 are reserved for 
future needs. Caution: sID codes must be allocated by a central "clearinghouse" to avoid conflicts. 


The following SEvent types are under consideration and should not yet be used. 
Issue: A "change tempo" SEvent changes tempo during a score. Changing the tempo affects all tracks, not just the 
track containing the change tempo event. 


One possibility is a "scale tempo" SEvent SID_ScaleTempo that rescales the global tempo: 
currentTempo := globalTempo * (data + 1) / 128 


This can scale the global tempo (in the SHDR) anywhere from x1/128 to x2 in roughly 1% increments. 


An alternative is two events SID_SetHTempo and SID_Set LTempo. SID_Set HTempo gives the high byte and 
SID_SetLTempo gives the low byte of a new tempo setting, in 128ths quarter note/minute. Set HTempo 
automatically sets the low byte to 0, so the Set LTempo event isn't needed for coarse settings. In this scheme, the 
SHDR's tempo is simply a starting tempo. 


"SMUS" IFF Simple Musical Score 


An advantage of SID_ScaleTempo is that the playback program can just alter the global tempo to adjust the 
overall performance time and still easily implement tempo variations during the score. But the "set tempo" SEvent 
may be simpler to generate. 


Issue: The events SID_BeginRepeat and SID_EndRepeat define a repeat span for one track. The span of 
events between a BeginRepeat and an EndRepeat is played twice. The SEvent . data field in the 
BeginRepeat event could give an iteration count, 1 through 255 times or 0 for “repeat forever". 


Repeat spans can be nested. All repeat spans automatically end at the end of the track. 


An event SID_Ending begins a section like "first ending” or "second ending". The SEvent . data field gives the 
ending number. This SID_ Ending event only applies to the innermost repeat group. (Consider generalizing it.) 


A more general alternative is a "subtrack" or "subscore" event. A “subtrack" event is essentially a "subroutine call" to 
another series of SEvents. This is a nice way to encode all the possible variations of repeats, first endings, codas, and 
such, 


To define a subtrack, we must demark its start and end. One possibility is to define a relative branch-to-subtrack event 
SID_BSR and a return-from-subtrack event SID_RTS. The 8-bit data field in the SID_BSR event can reach as far 
as 512 SEvents. A second possibility is to call a subtrack by index number, with an IFF chunk outside the TRAK 
defining the start and end of all subtracks. This is very general since a portion of one subtrack can be used as another 
subtrack, It also models the tape recording practice of first “laying down a track" and then selecting portions of it to 
play and repeat. To embody the music theory idea of playing a sequence like "ABBA", just compose the "main" track 
entirely of subtrack events. A third possibility is to use a numbered subtrack chunk "STRK" for each subroutine. 


4, Private Chunks [ 

f 
As in any IFF FORM, there can be private chunks ina FORM SMUS that are designed for one particular program to 
store its private information. All IFF reader programs skip over unrecognized chunks, so the presense of private 
chunks can’t hurt. 


Instant Music stores some global score information in a chunk of ID "IRev" and some other information in a chunk 
of ID "BIAS". 


"SMUS" IFF Simple Musical Score 
Appendix A. Quick Reference 
Type Definitions 


Here's a collection of the C type definitions in this memo. In the "struct" type definitions, fields are filed in the order 
shown. A UBYTE field is packed into an 8-bit byte. Programs should set all "pad" fields to 0. 


#define ID_SMUS MakeID('S', ™', UT, 'S') 
#define ID _SHDR MakeID('S', 'H', 'D', 'R‘) 


typedef struct { 


UWORD tempo; /* tempo, 128ths quarter note/minute x / 
UBYTE volume; /* overall playback volume 0 through 127 x/ 
UBYTE ctTrack; /* count of tracks in the score */ 


} SScoreHeader; 


#define ID NAME MakeID('N', ‘A', 'M', ‘E') 


/* NAME chunk contains a CHAR[], the musical score's name. xf 
#define ID_ Copyright MakeID('(', ‘ct, ')', ' ') 
/* "(c) “™ chunk contains a CHAR[], the FORM's copyright notice. */ 


#define ID_AUTH MakeID('A', ‘U', tot, TH!) 
/* AUTH chunk contains a CHAR[], the name of the score's author. */ 


#define ID_ANNO MakeID('A', 'N', 'N', 'O') 
/* ANNO chunk contains a CHAR[], author's text annotations. *x/ 


#define ID_INS1 MakeID('I', TNT, "St, '1') 


/* Values for the RefInstrument field "type". */ 
#define INS1_Name 0 /* just use the name; ignore datal, data2 */ 
#define INS1 MIDI 1 /* <datal, data2> = MIDI <channel, preset> x] 


typedef struct { 


UBYTE register; /* set this instrument register number * f 
UBYTE type; /* instrument reference type * f 
UBYTE datal, data2; /* depends on the "type" field xf 
CHAR name[]; /* instrument name */ 


} RefInstrument; 


#define ID_TRAK MakeID('T', 'R', 'A', 'K') 


/* TRAK chunk contains an SEvent[]. *f 
/* SEvent: Simple musical event. x / 
typedef struct { 
UBYTE sID; /* SEvent type code * / 
UBYTE data; /* sID-dependent data */ 
} SEvent; 


I- 58 


"SMUS" IFF Simple Musical Score 


/* SEvent type codes "sID". 


#define SID FirstNote 0 
#define SID LastNote 127 
#define SID Rest 128 


‘#define SID_Instrument 129 


#define SID_TimeSig 130 
#define SID KeySig 131 
#define SID Dynamic 132 


#define SID _MIDI_Chni 133 
#define SID MIDI Preset 134 
#define SID Clef 135 


#define SID_Tempo 136 


/* SID values 144 through 159: 


x/ 


/* sIDs in the range SID FirstNote through 

* SID LastNote (sign bit = 0) are notes. The 
* sID is the MIDI tone number (pitch). x / 
/* a rest (same data format as a note). xf 
/* set instrument number for this track. xf 
/* set time signature for this track. xf 
/* set key signature for this track. x / 
/* set volume for this track. *x/ 
/* set MIDI channel number (sequencers) */ 
/* set MIDI preset number (sequencers) * / 
/* inline clef change. 

* 0=Treble, 1=Bass, 2=Alto, 3=Tenor. */ 
/* Inline tempo in beats per minute. x / 
reserved for Instant Music SEvents. * f 


/* Remaining sID values up through 254: reserved for future 


* standardization. xf 
#define SID Mark 255 /* sID reserved for an end-mark in RAM. x / 
/* SID FirstNote..SID_LastNote, SID Rest SEvents x / 
typedef struct { 

UBYTE tone; /* MIDI tone number 0 to 127; 128 = rest * / 

unsigned chord 21, /* 1 = a chorded note */ 
tieOut 21, /* 1 = tied to the next note or chord */ 
nTuplet :2, /* 0 = none, 1 = triplet, 2 = quintuplet, 

* 3 = septuplet * 
dot :1, /* dotted note; multiply duration by 3/2 x / 
division :3; /* basic note duration is 2-division: Q = whole 

* note, 1 = half note, 2 = quarter note, 

* 7 = 128th note * / 

} SNote; 
#define noteChord (1<<7) /* note is chorded to next note *x/ 
#define noteTieOut (1<<6) /* tied to next note/chord x / 
#define noteNShift 4 /* shift count for nTuplet field xf 
#define noteN3 (1<<noteNShift) /* note is a triplet * f 
#define noteN5 (2<<noteNShift) /* note is a quintuplet x / 
#define noteN7 (3<<noteNShift) /* note is a septuplet xf 


#define noteNMask noteN7 


#define noteDot (1<<3) 


#define noteDl 
#define noteD2 
#define noteD4 
#define noteD8 


WNHr © 


/* bit mask for the nTuplet field x / 


/* note is dotted * / 
/* whole note division */ 
/* half note division x] 
/* quarter note division */ 
/* eighth note division x / 


I- 59 


"SMUS" IFF Simple Musical Score 


noteD16 


#define 4 
noteD32 5 
6 
7 


#define 
#define 
#define 
#define 


noteD64 
noteD128 
noteDMask noteD128 


#define noteDurMask 0x3F 


/* SID Instrument SEvent 
/* “data” value is an instrument 


/* SID TimeSig SEvent 
typedef struct { 


UBYTE type; /* 
unsigned timeNSig :5, /* 
timeDSig :3; {* 
* 
* 

} STimeSig; 
#define timeNMask OxF8 /* 
#define timeNShift 3 /* 
#define timeDMask 0x07 /* 


/* SID_KeySig SEvent 
/* “data" value 0 = 
* 8 through 14 = 


/* SID Dynamic SEvent 


F,Bb, Eb, Ab, Db, Gb, Cb. 


/* "data" value is a MIDI key velocity 0..127. 


I- 60 


/* sixteenth note division x / 
/* thirty-secondth note division */ 
/* sixty-fourth note. division * / 
/* 1/128 note division x] 
/* bit mask for the division field * f 
/* mask for combined duration fields */ 
*/ 
register number 0 through 255. xf 
x/ 
= SID TimeSig */ 
time sig. "numerator" is timeNSig + 1 * f 

time sig. "denominator" is 2timeDSig; 
0 = whole note, 1 = half note, 2 = quarter 
note, .. 7 = 128th note */ 
bit mask for the timeNSig field */ 
shift count for timeNSig field * f 
bit mask for the timeDSig field */ 
xf 

Cmaj; 1 through 7 = G,D,A,E,B,F#,C#; 

*/ 
x/ 
*/ 


"SMUS" IFF Simple Musical Score 
SMUS Regular Expression 
Here's a regular expression summary of the FORM SMUS syntax. This could be an IFF file or part of one. 


SMUS ::= "FORM" #{ "SMUS" SHDR [NAME] [Copyright] [AUTH] [IRev] 
ANNO* INS1* TRAK* InstrForm* } 


SHDR ::= "SHDR" #{ SScoreHeader } 
NAME ::= "NAME" #{ CHAR* } [0] 
Copyright ::= "(c) ™" #{ CHAR* } [0] 
AUTH :2:= "AUTH" #{ CHAR* } [0] 
TRev ::= "IRev" #{ } 
ANNO ::= "ANNO" #{ CHAR* } [0] 
INS1 ::= “INS1" #{ RefInstrument } [0] 
TRAK i= "TRAK" #{ SEvent* } 
InstrForm ::= "FORM" #{ ... } 


The token "#" represents a ckSize LONG count of the following {braced} data bytes. Literal items are shown in 
"quotes", [square bracket items] are optional, and "*" means 0 or more replications. A sometimes-needed pad byte is 
shown as "[0]". 


Actually, the order of chunks ina FORM SMUS is not as strict as this regular expression indicates. The SHDR, 
NAME, Copyright, AUTH, IRev, ANNO, and INS1 chunks may appear in any order, as long as they precede the 
TRAK chunks. 


The chunk “Inst rForm” represents any kind of instrument data FORM embedded in the FORM SMUS. For 


example, see the document "8S VX" IFF 8-Bit Sampled Voice. Of course, a recipient program will ignore an 
instrument FORM if it doesn't recognize that FORM type. 


I- 61 


"SMUS" IFF Simple Musical Score 
Appendix B. SMUS Example 


Here's a box diagram for a simple example, a SMUS with two instruments and two tracks. Each track contains 1 note 
event and 1 rest event. 







‘SMUS’ 
‘SHDR’ 4 


12800, 127, 2 


1, 0, 0, 0, ‘piano’ 
















2, 0, 0, 0, ‘guitar’ 


60, 16. 128.16 
128, 16, 60,16 


The "0" after the first INS1 chunk is a pad byte. 






Appendix C. Standards Committee 
The following people contributed to the design of this SMUS standard: 


Ralph Bellafatto, Cherry Lane Technologies 
Geoff Brown, Uhuru Sound Software 

Steve Hayes, Electronic Arts 

Jerry Morrison, Electronic Arts 


"8S VX" IFF 8-Bit Sampled Voice 


Date: February 7, 1985 (Re-Typeset Oct, 1988 Commodore-Amiga, Inc.) 
From: — Steve Hayes and Jerry Morrison, Electronic Arts 
Status: Adopted 


1. Introduction 


This is the IFF supplement for FORM "8SVX". An 8SVX is an IFF "data section" or "FORM" (which can be an 

IFF file or a part of one) containing a digitally sampled audio voice consisting of 8-bit samples. A voice can be a 
one-shot sound or—with repetition and pitch scaling—a musical instrument. "EA IFF 85" is Electronic Arts’ standard 
interchange file format. [See "EA IFF 85" Standard for Interchange Format Files.] 





The 8SVX format is designed for playback hardware that uses 8-bit samples attenuated by a volume control for good 
overall signal-to-noise ratio. So a FORM 8SVX stores 8-bit samples and a volume level. 


A similar data format (or two) will be needed for higher resolution samples (typically 12 or 16 bits). Properly 
converting a high resolution sample down to 8 bits requires one pass over the data to find the minimum and 
maximum values and a second pass to scale each sample into the range -128 through 127. So it's reasonable to store 
higher resolution data in a different FORM type and convert between them. 


For instruments, FORM 8SVX can record a repeating waveform optionally preceded by a startup transient waveform. 
These two recorded signals can be pre-synthesized or sampled from an acoustic instrument. For many instruments, 
this representation is compact. FORM 8SVX is less practical for an instrument whose waveform changes from cycle 
to cycle like a plucked string, where a long sample is needed for accurate results. 


FORM 8SVX can store an "envelope" or "amplitude contour" to enrich musical notes. A future voice FORM could 
also store amplitude, frequency, and filter modulations. 


FORM 8SVX is geared for relatively simple musical voices, where one waveform per octave is sufficient, the 
waveforms for the different octaves follow a factor-of-two size rule, and one envelope is adequate for all octaves. You 
could store a more general voice as a LIST containing one or more FORMs 8SVX per octave. A future voice FORM 
could go beyond one "one-shot" waveform and one "repeat" waveform per octave. 


Section 2 defines the required property sound header "VHDR", optional properties name "NAME" , copyright "(c) ", 
and author "AUTH", the optional annotation data chunk "ANNO", the required data chunk "BODY", and optional 
envelope chunks "ATAK" and "RLSE". These are the "standard" chunks. Specialized chunks for private or future 
needs can be added later, e.g. to hold a frequency contour or Fourier series coefficients. The 8S VX syntax is 
summarized in Appendix A as a regular expression and in Appendix B as an example box diagram. Appendix C 
explains the optional Fibonacci-delta compression algorithm. 


Reference: 


“EA IFF 85" Standard for Interchange Format Files describes the underlying conventions for all IFF files. 





Amiga® is a registered trademark of Commodore-Amiga, Inc. 
Electronic Arts™ is a trademark of Electronic Arts. 


"8SVX" IFF 8-Bit Sampled Voice 


2. Standard Data and Property Chunks 


FORM 8SVX stores all the waveform data in one body chunk "BODY". It stores playback parameters in the required 
header chunk "VHDR". "VHDR" and any optional property chunks "NAME", "(c)", and "AUTH" must all appear 
before the BODY chunk. Any of these properties may be shared over a LIST of FORMs 8SVX by putting them in a 
PROP 8SVX. [See "EA IFF 85" Standard for Interchange Format Files.] 


Background 


There are two ways to use FORM 8SVX: as a one-shot sampled sound or as a sampled musical instrument that plays 
"notes". Storing both kinds of sounds in the same kind of FORM makes it easy to play a one-shot sound as an 
instrument or an instrument as a one-note sound. 


A one-shot sound is a series of audio data samples with a nominal playback rate and amplitude. The recipient program 
can optionally adjust or modulate the amplitude and playback data rate. 


For musical instruments, the idea is to store a sampled (or pre-synthesized) waveform that will be parameterized by 
pitch, duration, and amplitude to play each “note”. The creator of the FORM 8SVX can supply a waveform per octave 
over a range of octaves for this purpose. The intent is to perform a pitch by selecting the closest octave's waveform 
and scaling the playback data rate. An optional "one-shot" waveform supplies an arbitrary startup transient, then a 
"repeat" waveform is iterated as long as necessary to sustain the note. 


A FORM 8SVX can also store an envelope to modulate the waveform. Envelopes are mostly useful for 
variable-duration notes but could be used for one-shot sounds, too. 


The FORM 8SVX standard has some restrictions. For example, each octave of data must be twice as long as the next 
higher octave. Most sound driver software and hardware imposes additional restrictions. E.g. the Amiga sound 
hardware requires an even number of samples in each one-shot and repeat waveform. 


Required Property VHDR 
The required property "VHDR" holds a Voice8Header structure as defined in these C declarations and following 
documentation. This structure holds the playback parameters for the sampled waveforms in the BODY chunk. (See 


"Data Chunk BODY", below, for the storage layout of these waveforms.) 


#define ID_8SVX MakeID('8', 'S', 'V', 'X') 
#define ID _VHDR MakeID('V', 'H', 'D', 'R') 


typedef LONG Fixed; /* A fixed-point value, 16 bits to the left of 
the point and 16 to the right. A Fixed is a 
number of 216ths, i.e. 65536ths. */ 

#define Unity 0x10000L /* Unity = Fixed 1.0 = maximum volume * / 


/* sCompression: Choice of compression algorithm applied to the samples. 


x] 
#define sCmpNone 0 /* not compressed */ 
#define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) * 
/* Can be more kinds in the future. * / 
typedef struct { 

ULONG oneShotHiSamples, /* # samples in the high octave 1l-shot part 
x / 

repeatHiSamples, /* # samples in the high octave repeat part 


I- 64 


"8S VX" IFF 8-Bit Sampled Voice 


*/ 
samplesPerHiCycle; /* # samples/cycle in high octave, else 0 */ 
UWORD samplesPerSec; /* data sampling rate x / 
UBYTE ctOctave, /* # octaves of waveforms xf 
sCompression; /* data compression technique used x / 
Fixed volume; /* playback volume from 0 to Unity (full 

* volume). Map this value into the output 

* hardware's dynamic range. * f 


} Voice8Header; 


[Implementation details. Fields are filed in the order shown. The UBYTE fields are byte-packed (2 per 16-bit word). 
MakelID is a C macro defined in the main IFF document and in the source file IFF.h.] 


A FORM 8SVX holds waveform data for one or more octaves, each containing a one-shot part and a repeat part. The 
fields oneShotHiSamples and repeatHiSamples tell the number of audio samples in the two parts of the 
highest frequency octave. Each successive (lower frequency) octave contains twice as many data samples in both its 
one-shot and repeat parts. One of these two parts can be empty across all octaves. 


Note: Most audio output hardware and software has limitations. For example the Amiga computer has sound hardware 
that requires that all one-shot and repeat parts have even numbers of samples. Amiga sound driver software should 
adjust an odd-sized waveform, ignore an odd-sized lowest octave, or ignore odd 8S VX FORMs altogether. Some other 
output devices require all sample sizes to be powers of two. 


The field samplesPerHiCycl1e tells the number of samples/cycle in the highest frequency octave of data, or else 0 
for "unknown". Each successive (lower frequency) octave contains twice as many samples/cycle. The 
samplesPerHiCycle value is needed to compute the data rate for a desired playback pitch. 


Actually, samplesPerHiCycle is an average number of samples/cycle. If the one-shot part contains pitch bends, 
store the samples/cycle of the repeat part in samplesPerHiCycl]e. The division 
repeatHiSamples/samplesPerHiCycle should yield an integer number of cycles. (When the repeat 
waveform is repeated, a partial cycle would come out as a higher-frequency cycle with a "click".) 


More limitations: some Amiga music drivers require samp lesPerHiCycle to be a power of two in order to play 
the FORM 8SVX as a musical instrument in tune. They may even assume samplesPerHiCycle is a particular 
power of two without checking. (If samplesPerHiCycle is different by a factor of two, the instrument will just 
be played an octave too low or high.) 


The field samplesPerSec gives the sound sampling rate. A program may adjust this to achieve frequency shifts or 
vary it dynamically to achieve pitch bends and vibrato. A program that plays a FORM 8SVX as a musical instrument 
would ignore samplesPerSec and select a playback rate for each musical pitch. 


The field ct Octave tells how many octaves of data are stored in the BODY chunk. See "Data Chunk BODY", 
below, for the layout of the octaves. 


The field scompression indicates the compression scheme, if any, that was applied to the entire set of data 
samples stored in the BODY chunk. This field should contain one of the values defined above. Of course, the 
matching decompression algorithm must be applied to the BODY data before the sound can be played. (The 
Fibonacci-delta encoding scheme sCmpFibDelta is described in Appendix C.) Note that the whole series of data 
samples is compressed as a unit. 


The field volume gives an overall playback volume for the waveforms (all octaves). It lets the 8-bit data samples use 
the full range -128 through 127 for good signal-to-noise ratio. The playback program should multiply this value by a 
“volume control" and perhaps by a playback envelope (see ATAK and RLSE, below). 


"8SVX" IFF 8-Bit Sampled Voice 


Recording a one-shot sound. To store a one-shot sound in a FORM 8SVX, set oneShotHiSamples = number of 
samples, repeatHiSamples = 0, samplesPerHiCycle =0, samplesPerSec = sampling rate, and 
ctOctave = 1. Scale the signal amplitude to the full sampling range -128 through 127. Set volume so the sound 
will playback at the desired volume level. If you set the samplesPerHiCycle field properly, the data can also be 
used as a musical instrument. 


Experiment with data compression. If the decompressed signal sounds okay, store the compressed data in the BODY 
chunk and set sCompression to the compression code number. 


Recording a musical instrument. To store a musical instrument in a FORM 8SVX, first record or synthesize as many 
octaves of data as you want to make available for playback. Set ctOctaves to the count of octaves. From the 
recorded data, excerpt an integral number of steady state cycles for the repeat part and set repeatHiSamples and 
samplesPerHiCycle. Either excerpt a startup transient waveform and set oneShotHiSamples, or else set 
oneShotHiSamples to 0. Remember, the one-shot and repeat parts of each octave must be twice as long as those 
of the next higher octave. Scale the signal amplitude to the full sampling range and set volume to adjust the 
instrument playback volume. If you set the samplesPerSec field properly, the data can also be used as a one-shot 
sound. 


A distortion-introducing compressor like sCmpF ibDelta is not recommended for musical instruments, but you 
might try it anyway. 


Typically, creators of FORM 8SVX record an acoustic instrument at just one frequency. Decimate (down- sample 
with filtering) to compute higher octaves. Interpolate to compute lower octaves. 


If you sample an acoustic instrument at different octaves, you may find it hard to make the one-shot and repeat 
waveforms follow the factor-of-two rule for octaves. To compensate, lengthen an octave's one-shot part by appending 
replications of the repeating cycle or prepending zeros. (This will have minimal impact on the sound's start time.) 
You may be able to equalize the ratio of one-shot-samples to repeat-samples across all octaves. 


Note that a “one-shot sound" may be played as a "musical instrument" and vice versa. However, an instrument player 
depends on samplesPerHiCycle, anda one-shot player depends on samplesPerSec. 


Playing a one-shot sound. To play any FORM 8SVX data as a one-shot sound, first select an octave if cLOctave > 
1. (The lowest-frequency octave has the greatest resolution.) Play the one-shot samples then the repeat samples, scaled 
by volume, at a data rate of samplesPerSec. Of course, you may adjust the playback rate and volume. You can 
play out an envelope, too. (See ATAK and RLSE, below.) 


Playing a musical note. To play a musical note using any FORM 8SVX, first select the nearest octave of data from 
those available. Play the one-shot waveform then cycle on the repeat waveform as long as needed to sustain the note. 
Scale the signal by volume, perhaps also by an envelope, and by a desired note volume. Select a playback data rate 
s samples/second to achieve the desired frequency (in Hz): 

frequency = s / samplesPerHiCycle 
for the highest frequency octave. 


The idea is to select an octave and one of 12 sampling rates (assuming a 12-tone scale). If the FORM 8SVX doesn't 
have the right octave, you can decimate or interpolate from the available data. 


When it comes to musical instruments, FORM 8SVX is geared for a simple sound driver. Such a driver usesa single 
table of 12 data rates to reach all notes in all octaves. That's why 8SVX requires each octave of data to have twice as 
many samples as the next higher octave. If you restrict samplesPerHiCycle to a power of two, you can use a 
predetermined table of data rates. 


"8S VX" IFF 8-Bit Sampled Voice 
Optional Text Chunks NAME, (c), AUTH, ANNO 
Several text chunks may be included in a FORM 8SVX to keep ancillary information. 
The optional property "NAME" names the voice, for instance "tubular bells”. 


The optional property "(c) " holds a copyright notice for the voice. The chunk ID "(c) " serves as the copyright 
characters "© ". E.g. a "(c) " chunk containing "1986 Electronic Arts" means "© 1986 Electronic Arts". 


The optional property "AUTH" holds the name of the instrument's "author" or "creator". 


The chunk types "NAME", "(c) ", and "AUTH" are property chunks. Putting more than one NAME (or other) 
property ina FORM is redundant. Just the last NAME counts. A property should be shorter than 256 characters. 
Properties can appear in a PROP 8SVX to share them over a LIST of FORMs 8SVX. 


The optional data chunk "ANNO" holds any text annotations typed in by the author. 


An ANNO chunk is not a property chunk, so you can put more than one in a FORM 8SVX. You can make ANNO 
chunks any length up to 231 - 1 characters, but 32767 is a practical limit. Since they're not properties, ANNO 
chunks don't belong in a PROP 8SVX. That means they can't be shared over a LIST of FORMs 8SVX. 


Syntactically, each of these chunks contains an array of 8-bit ASCII characters in the range “” (SP, hex 20) through 
“~" (tilde, hex 7F), just like a standard "TEXT" chunk. [See "Strings, String Chunks, and String Properties" in "EA 
IFF 85" Electronic Arts Interchange File Format.] The chunk's ck$ize field holds the count of characters. 





#define ID NAME MakeID('N', 'A', 'M', 'E*) 


/* NAME chunk contains a CHAR[], the voice's name. xf 

#define ID Copyright MakeID('(', 'c', yr, hoy 

/* "(c) " chunk contains a CHAR[], the FORM's copyright notice. 
* 


#define ID_AUTH MakeID('A', 'U', 'T', 'H?) 
/* AUTH chunk contains a CHAR[], the author's name. x / 


#define ID_ANNO MakeID('A', 'N', 'N', 'O") 
/* ANNO chunk contains a CHAR[], author's text annotations. x / 


Remember to store a 0 pad byte after any odd-length chunk. 


Optional Data Chunks ATAK and RLSE 
The optional data chunks ATAK and RLSE together give a piecewise-linear “envelope” or "amplitude contour". This 
contour may be used to modulate the sound during playback. It's especially useful for playing musical notes of 
variable durations. Playback programs may ignore the supplied envelope or substitute another. 


#define ID_ATAK MakeID('A', 'T', 'A', 'Kt) 
#define ID_RLSE MakeID('R', 'L', 'S', 'E") 


typedef struct { 


UWORD duration; /* segment duration in milliseconds, > 0 */ 
Fixed dest; /* destination volume factor */ 
} EGPoint; 


"8S VX" IFF 8-Bit Sampled Voice 


/* ATAK and RLSE chunks contain an EGPoint[], piecewise-linear envelope. 
*/ 

/* The envelope defines a function of time returning Fixed values. It's 
* used to scale the nominal volume specified in the Voice8Header. x / 


To explain the meaning of the ATAK and RLSE chunks, we'll overview the envelope generation algorithm. Start at 0 
volume, step through the ATAK contour, then hold at the sustain level (the last ATAK EGPoint's dest), and then 
step through the RLSE contour. Begin the release at the desired note stop time minus the total duration of the release 


contour (the sum of the RLSE EGPoints' durat ions). The attack contour should be cut short if the note is shorter 
than the release contour. 


The envelope is a piecewise-linear function. The envelope generator interpolates between the EGPoints. 
Remember to multiply the envelope function by the nominal voice header volume and by any desired note volume. 
Figure 1 shows an example envelope. The attack period is described by 4 EGPoints in an ATAK chunk. The release 


period is described by 4 EGPoints in a RLSE chunk. The sustain period in the middle just holds the final ATAK level 
until it's time for the release. 


ATAK sustain RLSE 
Figure 1. Amplitude contour. 


Note: The number of EGPoints in an ATAK or RLSE chunk is its ckSize / sizeof (EGPoint).InRAM, 
the playback program may terminate the array with a0 duration EGPoint. 


Issue: Synthesizers also provide frequency contour (pitch bend), filtering contour (wah-wah), amplitude oscillation 
(tremolo), frequency oscillation (vibrato), and filtering oscillation (leslie). In the future, we may define optional 
chunks to encode these modulations. The contours can be encoded in linear segments. The oscillations can be stored 
as segments with rate and depth parameters. 
Data Chunk BODY 

The BODY chunk contains the audio data samples. 

#define ID BODY MakeID('B', 'O', ‘D', '¥") 

typedef character BYTE; /* 8 bit signed number, -128 through 127. * f 

/* BODY chunk contains a BYTE[], array of audio data samples. */ 
The BODY contains data samples grouped by octave. Within each octave are one-shot and repeat portions. Figure 2 
depicts this arrangement of samples for an 8SVX where oneShotHiSamples = 24, repeatHiSamples = 16, 
samplesPerHiCycle = 8, and ctOctave = 3. The major divisions are octaves, the intermediate divisions 


separate the one-shot and repeat portions, and the minor divisions are cycles. 


I- 68 


"8SVX" IFF 8-Bit Sampled Voice 


Oo |r [| one-shot one-shot repeat 
hi octave mid octave low octave 
Figure 2. BODY subdivisions. 





In general, the BODY has ct Octave octaves of data. The highest frequency octave comes first, comprising the 
fewest samples: oneShotHiSamples + repeatHiSamples. Each successive octave contains twice as many 
samples as the next higher octave but the same number of cycles. The lowest frequency octave comes last with the 
most samples: 2ctOctave-1 * (oneShotHiSamples + repeatHiSamples). 


The number of samples in the BODY chunk is 
(20 + ... + 2ctOctave-1) * (oneShotHiSamples + repeatHiSamples) 


Figure 3, below, looks closer at an example waveform within one octave of a different BODY chunk. In this 
example, oneShotHiSamples / samplesPerHiCycle =2 cycles and repeatHiSamples / 
samplesPerHiCycle = 1 cycle. 


oneShot repeat 





Figure 3. Example waveform. 


To avoid playback "clicks" the one-shot part should begin with a small sample value, and flow smoothly into the 
repeat part. The end of the repeat part should flow smoothly into the beginning of the next repeat part. 


If the VHDR field scompression # sCmpNone, the BODY chunk is just an array of data bytes to feed through 
the specified decompresser function. All this stuff about sample sizes, octaves, and repeat parts applies to the 
decompressed data. 


Be sure to follow an odd-length BODY chunk with a 0 pad byte. 


Other Chunks 


Issue: In the future, we may define an optional chunk containing Fourier series coefficients for a repeating waveform. 
An editor for this kind of synthesized voice could modify the coefficients and regenerate the waveform. 


See the registry document for the latest information. 


"8SVX" IFEF 8-Bit Sampled Voice 
Appendix A. Quick Reference 
Type Definitions 


#define ID_8SVX MakeID('8', 'S', 'V', 'X"') 
#define ID _VHDR MakeID('V', '‘H', 'p', 'R') 


typedef LONG Fixed; /* BA fixed-point value, 16 bits to the left of 
the point and 16 to the right. A Fixed is a 
number of 21¢ths, i.e. 65536ths. * / 
#define Unity 0x10000L /* Unity = Fixed 1.0 = maximum volume «/ 
/* sCompression: Choice of compression algorithm. *x/ 
#define sCmpNone Q /* not compressed xf 
#define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) */ 
/* Can be more kinds in the future. * / 


typedef struct { 


ULONG oneShotHiSamples, /* # samples in the high octave l-shot part 
*/ 

repeatHiSamples, /* # samples in the high octave repeat part 
*/ 
samplesPerHiCycle; /* # samples/cycle in high octave, else 0 */ 
UWORD samplesPerSec; /* data sampling rate *x/ 
UBYTE ctOctave, /* # octaves of waveforms xf 
sCompression; /* data compression technique used xf 

Fixed volume; /* playback volume from 0 to Unity (full 

* yolume). Map this value into the output 

* hardware's dynamic range. «/ 


} Voice8Header; 


#define ID NAME MakeID('N', 'A't, '', 'E') 


/* NAME chunk contains a CHAR[], the voice's name. x/ 
#define ID Copyright MakeID('(', ‘et, ")', ' ') 

/* "(c) “ chunk contains a CHAR[], the FORM's copyright notice. */ 
#define ID AUTH MakeID('A', 'U', 'T', 'H") 

/* AUTH chunk contains a CHAR[], the author's name. */ 
#define ID_ANNO MakeID('A', ‘Nt, 'N', 'O") 

/* ANNO chunk contains a CHAR[], author's text annotations. x/ 


#define ID_ATAK MakeID('A', 'T', 'A', 'K") 
#define ID _RLSE MakeID('R', 'L', 'S', 'E') 


typedef struct { 


UWORD duration; /* segment duration in milliseconds, > 0 */ 
Fixed dest; /* destination volume factor xf 
} EGPoint; 


/* ATAK and RLSE chunks contain an EGPoint[],piecewise-linear envelope. * / 
/* The envelope defines a function of time returning Fixed values. It's 
* used to scale the nominal volume specified in the Voice8Header. x / 


#define ID_BODY MakeID('B', 'O', 'D', 'Y¥") 


typedef character BYTE; /* 8 bit signed number, -128 through 127. * f 
/* BODY chunk contains a BYTE[], array of audio data samples. * / 


I- 70 


"8SVX" IFF 8-Bit Sampled Voice 


8SVX Regular Expression 
Here's a regular expression summary of the FORM 8SVX syntax. This could be an IFF file or part of one. 


8SVX ::= "FORM" #{ "8SVX" VHDR [NAME] [Copyright] [AUTH] ANNo* 
[ATAK] [RLSE] BODY } 


VHDR ::= "VHDR" #{ Voice8Header } 
NAME ::= "NAME" #{ CHAR* } [0] 
Copyright ::= "(c) ™ #{ CHAR* } [0] 
AUTH 2: "AUTH" #{ CHAR* } [0] 
ANNO ::= "ANNO" #{ CHAR* } [0] 
ATAK ::= “"ATAK" #{ EGPoint* } 
RLSE ::= “"RLSE" #{ EGPoint* } 
BODY ::= "FORM" #{ BYTE* } [0] 


The token "#" represents a ckSize LONG count of the following {braced} data bytes. E.g.a VHDR's "#” should 
equal sizeof (Voice8Header). Literal items are shown in "quotes", [square bracket items] are optional, and "*" 
means 0 or more replications. A sometimes-needed pad byte is shown as "[0]". 


Actually, the order of chunks in a FORM 8SVX is not as strict as this regular expression indicates. The property 
chunks VHDR, NAME, Copyright, and AUTH may actually appear in any order as long as they all precede the 
BODY chunk. The optional data chunks ANNO, ATAK, and RLSE don't have to precede the BODY chunk. And of 
course, new kinds of chunks may appear inside a FORM 8SVX in the future. 

Appendix B. 8SVX Example 


Here's a box diagram for a simple example containing the three octave BODY shown earlier in Figure 2. 


VHDR 20 


24, 16, 8, 10000, 3, 0, 1.0 


NAME 11 


(c) 20 


1985 Electronic Arts 





"8S VX" IFF 8-Bit Sampled Voice 
Appendix C. Fibonacci Delta Compression 


This is Steve Hayes’ Fibonacci Delta sound compression technique. It's like the traditional delta encoding but encodes 
each delta in a mere 4 bits. The compressed data is half the size of the original data plus a 2-byte overhead for the 
initial value. This much compression introduces some distortion, so try it out and use it with discretion. 


To achieve a reasonable slew rate, this algorithm looks up each stored 4-bit value in a table of Fibonacci numbers. So 
very small deltas are encoded precisely while larger deltas are approximated. When it has to make approximations, the 
compressor should adjust all the values (forwards and backwards in time) for minimum overall distortion. 


Here is the decompressor written in the C programming language. 
/* Fibonacci delta encoding for sound data. */ 
BYTE codeToDelta[16] = {-34,-21,-13,-8,-5,-3,-2,71,0,1,2,3,5,8,13,21}; 


/* Unpack Fibonacci-delta encoded data from n byte source buffer into 2*n byte 
* dest buffer, given initial data value x. It returns the last data value x 
* so you can call it several times to incrementally decompress the data. */ 
short D1lUnpack(source, n, dest, xX) 
BYTE source[], dest[]; 
LONG n; 
BYTE x; 
{ 
BYTE d; 
LONG i, lim; 


lim =n << 1; 
for (i = 0; i < lim; ++i) 
{ /* Decode a data nybble; high nybble then low nybble. */ 


d = source[i >> 1]; /* get a pair of nybbles */ 
if (i € 1) /* select low or high nybble? */ 
d &= Oxf; /* mask to get the low nybble */ 
else 
d >>= 4; /* shift to get the high nybble */ 
x t= codeToDelta[d]; /* add in the decoded delta */ 
dest [i] = x; /* store a 1l-byte sample */ 


} 


return (x); 


} 


/* Unpack Fibonacci-delta encoded data from n byte source buffer into 2*(n-2) 
* byte dest buffer. Source buffer has a pad byte, an 8-bit initial value, 
x followed by n-2 bytes comprising 2*(n-2) 4-bit encoded samples. * | 
void DUnpack (source, n, dest) 
BYTE source[], dest[]; 
LONG n; 
{ 
D1lUnpack (source + 2, n ~ 2, dest, source[1]); 
} 


Additional IFF Documents 


These documents include the lattest JFF News, FORM and CHUNK registration, an intro- 


duction to ILBM and Amiga ViewModes, design theory of IFF, and descriptions of the EA 
code modules. 


Si-I1 











Nov 10 17:19 1988 additional_docs/1188_IFF_News Page 1 


IFF News 11/88 


Carolyn Scheppner ~ CBM 


FORMS and Chunks not in the original EA IFF specs 


A "Registry" document has been added to the IFF specs. The Registry 

contains lists of all registered chunks and forms, and notes on j 

additions and changes to the specs of the original FA forms and their 
chunks. 


Form specifications for registered public third-party forms will 
appear in the Third-Party section of the IFF manual. However, due 

to the proliferation of application-specific forms, future IFF manuals 
might only contain forms in use by more than one company's products. 





Authors who wish to create new forms or chunks are strongly urged to 


— Collaborate with other software authors and CBM on their design 
~ Choose unique names and reserve them with CBM to avoid conflicts 
— Register all new forms and chunks with CBM 


Authors should remember special-purpose chunks are usually lost when 
an IFF FORM is loaded into another application and saved back out. 
The IFF spec states that IFF writers must not write back chunks that 
they don't understand because inconsistencies could be created in 
the FORM. 


The current CBM contact for registration of IFF FORMs and chunks is: 


Carolyn Scheppner — CATS/IFF 

CBM 

1200 Wilson Drive 

West Chester, PA. 19380 U.S.A. 


UUCP: {allegra |rutgers | uunet} !cbmvax! carolyn 
BIX: cscheppner (proposals may be posted/discussed in amiga.dev/iff) 


3. The embedded ILBM forms in an ANIM do not adhere to the ILBM spec 
and technically should have had a different chunk ID. They do 
not contain the required ILBM property BMHD, and instead contain 
an ANHD and delta information for changing the previous image. 
This inconsistency occurred because the original ANIM concept of 
sequential ILBMs was slowly modified, for speed and compactness, 
into a single ILBM followed by frames containing encoded animation 
changes. After much discussion with the authors and third parties 
supporting the ANIM form, it was decided that this inconsistency 
must remain for now to avoid breaking existing products. 


ILBM Problem Areas 


Thanks to John Bittner of the Zuma Group for organizing much of this 
information in our amiga.dev/iff conference on BIX. 


1. PageWidth and PageHeight - Overscan or Not ? 


There are two sets of variables in an ILBM which describe the size 
of the picture. The image dimensions are stored in wand h. The 
other two variables, pageWidth and pageHeight, have been interpreted 
in different ways by the various applications which create ILBMs. 











. How many colors should a CMAP contain ? 











Nov 10 17:19 1988 additional_docs/1188_IFF News Page 2 | 


The ILBM spec describes them as follows: 


"The size in pixels of the source "page" (any raster device) is stored 
in pageWidth and pageHeight, e.g. (320,200) for a low resolution Amiga 
display. This information might be used to scale an image or to 
automatically set the display format to suit the image. (The image can 
be larger than the page.)" 


DPaintII stores the normal Amiga screen size in pageWidth and pageHeight, 
and the image size (which may be larger) in w and h. Up until now, 

we have maintained that this is the correct use of these variables 
because it preserves the normal screen dimensions for programs which 
wish to clip or scroll larger images in a normal size display. 

In addition, storage of the normal screen size makes it.possible for 

the correct ViewModes to be determined in the absence of an Amiga 
ViewModes CAMG chunk. 


However, a number of other applications which save overscan images 
store the full size of their display ViewPort in the pageWidth and 
pageHeight variables, and there seems to be a growing consensus 
that this is the correct use of these variables. This approach is 
non-Amiga-specific and preserves the artist's intent of the size 
raster in which the image was meant to be displayed. 


For now, flexible ILBM readers should be prepared to deal with 
with either alternative, and must parse CAMG chunks for the 
correct Amiga ViewModes. If a CAMG chunk is not present, ViewModes 
must be guessed based on the pageWidth and pageHeight. For 1.3 
viewmodes, width greater than or equal to 640 can be assumed HIRES, 
and height greater than or equal to 400 assumed LACE. These 
assumptions may be incorrect for future viewmodes. 


The Use and Misuse of the CAMG chunk 


The "optional" ILBM chunk CAMG holds the Amiga ViewModes for displaying 
the image contained in an ILBM. 


With the current variety of overscan storage methods, and the introduction 
of HAM and HALFBRITE paint packages, it is extremely important that 

all Amiga ILBM readers and writers save and parse this chunk. I have 
actually seen HALFBRITE ILBMs with NO CAMG chunk! I guess the reader 
programs are supposed to see that it's 6 bitplanes and toss a coin to 
decide if it's HAM or HALFBRITE. Please store CAMG chunks in all 

ILBMs and parse them when reading ILBMs. 


When saving and parsing the CAMG chunk, you should be aware that certain 
ViewMode bits can cause problems for display programs which use the 
CAMG contents directly for Screen or View modes. The following 

Amiga Viewmode bits should be masked out when reading or writing 

a CAMG chunk: SPRITES, VP_HIDE, GENLOCK_AUDIO, and GENLOCK_VIDEO. 

The reserved high word of the CAMG must currently be written as 

zero but not assumed to be zero when read. 





. CRNG Color Cycling chunks ~ Active or Not ? 


DPaintII, by default, usually saves CRNG chunks which contain cycle 
ranges and are marked as active, regardless of whether a picture is 
meant to be cycled. This makes it impossible for a cycling display 
program to reliably identify ILBMs which should not be cycled. 
Internally, DPaintII interprets a cycle rate <= 36 (RNG_NORATEB) 

to mark a cycle range as non-active. 








There seems to be a great deal of variation in the size of the CMAP 


94-1 





Mh 


Nov 10 17:19 1988 additional_docs/1188_IFF_News Page 3 


stored in HAM ILBMs by various applications. Some store only the 
number of absolute colors used in that particular HAM ILBM. Programs 
that do this must be really careful about following the IFF spec 
rules regarding the padding between odd-sized chunks. Some store the 
maximum number of absolute colors in a HAM display (16). Some store 
a full palette of 32, and many may store a palette of 64 because the 
supplied IFF example code generically uses 1<<bitmap~>depth when 
calculating the size CMAP to write. ILBM display programs must be 
careful to not blindly accept and set the number of color registers 
provided in a CMAP. 


A Word about Compatibility 


There have been several incidences of new ILBM graphic products 
going to market and then being found incompatible with major existing 
ILBM graphic software. Before releasing any product which saves IFF 
files of any type, please test the compatibility of your files by 
loading them into the major existing software products which read 
and write files of the same type, and try loading the files created by 
other applications. If you do not have access to a large number of 
these other products, try to find people who do and arrange file exchanges 
and compatibility tests. If your product adapts to PAL screen sizes 
or clock rate (important in audio period calculations), arrange for 
your product to also be tested on a PAL system. 


Be especially careful if you are not using the EA supplied IFF reading, 
writing, and compression routines. This can sometimes lead to the creation 
of subtly out-of-spec IFF files which are rejected by products which use 
the LFF code supplied by EA. Some examples would be odd length chunks 
not followed by a pad byte or a reader not designed to handle pad bytes. 
Another would be a badly compressed ILBM. The EA compresser is smart and 
does not encode a scan line if encoding would result in more bytes. The EA 
decompressor expects a smartly compressed file, and will return an error if 
handed an encoded line more than one control byte larger than destination 
scan line. If you are not using the EA IFF code, please make sure that your 
code follows all of the rules. 


Future IFF 


We hope to see a shared run-time iff.library sometime this year, through 
a coordinated effort between CBM and third-parties. Core IFF reading and 
writing routines will probably be in an IFF.library, with form-specific 
routines in separate modules or libraries. An IFF.library would take a 
lot of the code burden off of applications and would be especially useful 
for programmers using languages other than C. 





ZL -1 


Nov 10 17:19 1988 additional_docs/1188_Registry Page 1 Nov 10 17:19 1988 additional_docs/1188_Registry Page 2 










#include <graphics/view.h> 

#define BADFLAGS (SPRITES|VP_HIDE|GENLOCK_AUDIO|GENLOCK_VIDEO) 
#define FLAGMASK (~BADFLAGS) 

#define CAMGMASK (FLAGMASK & Ox0000FFFFL) 






IFF Registry 10/88 






( Note ~ If anyone notices any omissions, please let me know. camg.ViewModes = viewport—>Modes & CAMGMASK; 
If anyone is writing unregistered FORMs or chunks, please 


register them. C. Scheppner CBM ) 













3. ILBMs in ANIM are non-standard 


The embedded ILBM forms in an ANIM do not adhere to the ILBM spec 
SS SSS SSS SSE and technically should have had a different chunk ID. They do 
not contain the required ILBM property BMHD, and instead contain 
an ANHD and delta information for changing the previous image. 
This inconsistency occurred because the original ANIM concept of 
sequential ILBMs was slowly modified, for speed and compactness, 
into a single ILBM followed by frames containing encoded animation 
changes. After much discussion with the authors and third parties 
supporting the ANIM form, it was decided that this inconsistency 
must remain for now to avoid breaking existing products. 












Filetypes: FORM,PROP,LIST,CAT 






Chunks found in more than one type of FORM: 










AUTH, CHRS, (c), ANNO, NAME, TEXT 
- Described in EBA spec, may be found in some ILBMs 
and other forms. 


AUTH and (c) should be preserved by read/writers 











a FONS ~ Font specification 
CHRS — Ascii characters and ISO/ANSII standard control sequences 





BMHD —- Bitmap header 

CMAP — rgb color map 

GRAB — Hot spot 

DEST — Planepick 

SPRT - Sprite info 

CAMG — Amiga Viewmodes 

CCRT ~ Cycle info (Graphicraft) 
CRNG — Cycle info (DPaint) 

BODY — Interleaved bitplane data 






also AUTH, (c), CHRS, etc. 
















SHDR - Score header 

NAME — Name of score 

INS1 — Instrument 

TRAK ~ Data chunk for one track 










DPaintII Perspective chunk (see Third Party Specs) 
DGVW —- DigiView private chunk in 21-bit SaveRGB ILBMs 
BHSM ~ Photon Paint private (see their manual) (appears first in ILBM) 
BHCP — Photon Paint private (see their manual) (in full images) 

BHBA — Photon Paint private (see their manual) (in brushes) 






also AUTH, (c), NAME, ANNO, CHRS, etc. 







ADDENDA 






EA has reserved two new sEvents for SMUS since the IPF release which 


AUTH, 
appears in the Addison-Wesley manuals: 





(c), CHRS, etc. 







ADDENDA 






SID Value 






#define SID Clef 135 O=treble, l=bass, 2=alto, 3=tenor 


1. CRNG bit 1 defined as Reverse cycling flag 
#define SID_Tempo 136 beats per second (0-255) 






In DPaintII, Dan Silva has defined bit 1 (next to lowest bit) of 
the CRNG cycling chunk “active" variable as a flag for reverse 
color cycling. If this bit is set, cycle direction is reversed. 
Unfortunately, DPaintII internally uses rate <= RNG_NORATE (36) 

to mean that a cycle range is inactive, and is not too careful 
about the value saved in the CRNG.active variable. This makes 

it impossible to determine programatically whether or not a DPaint 
pic should be cycled. 














VHDR ~ Voice header 

ATAK — Attack info 

RLSE — Release info 

BODY - Data samples grouped by octave (may be Fibonacci-delta encoded) 







. CAMG bits require masking 






CHAN — Stereo channel chunk (Gold Disk -— see third party specs) 


Under certain circumstances, unwanted application-specific ViewMode 
PAN — Stereo pan chunk (Gold Disk — see third party specs) 


bits are saved to or loaded from a CAMG chunk. The SPRITES, VP_HIDE, 
GENLOCK_AUDIO, and GENLOCK_VIDEO flags should be masked out of the 
camg.ViewModes when saving or loading a CAMG chunk. The UWORD 

of masked Amiga viewmodes is stored in the low word of CAMG.Viewmodes. 
The high word of CAMG.Viewnmodes is reserved by Commodore and must 
currently be written as zeros, but not assumed to be zeros when read. 







also AUTH, (c), NAME, ANNO, etc. 








Public Registered Third Party FORMS 









BSL -1I 





Nov 10 17:19 1988 additional_docs/1188_Registry Page 3 





Amiga Contiguous Bitmap (used in AmigaBasic Demos) 
Contains normal ILBM chunks except: 


ABIT replaces BODY (ABIT is uncompressed contiguous bitplane data) 


Apple Audio IFF Form for ] to 32-bit audio samples. By Steve Milne, Apple 
I posted a general description in BIX amiga.dev/iff. 
I don't plan to add it to our Amiga IJFF manual. 


Animated bitmap FORM, used in Deluxe Video by Posehn & Case for EA 
Should appear. in 1988 IFF manual. 


Cel Animation FORM used by Videoscape-3D (Aegis) 


ANHD 
DLTA 


ANIM contains embedded "ILBM"'s, all but first not true ILBM's but rather 
containing ANHD (Anim header) and DLTA (changes to create next cell). 


Latest ANIM spec is in the May/June 88 AmigaMail, and is also posted on 
BIX in amiga.dev/docs. Spec in August 87 IFF manual is outdated. 
The new spec will appear in 1988 IFF manual. 


FORM BANK 


SoundQuest Editor/Librarian format for MIDI system-exclusive data dump. 
Form spec has not yet been provided. 





Idea processor FORM used by Flow (New Horizons Software) 
Described in current IFF manual. 


NEST 
TEXT 
FSCC 


Expecting spec soon — watch BIX amiga.dev/iff 
Circum Design 


ProGram TraceBack diagnostic dump image - John Toebes, S.A.S. 
Presented at Devcon. Should appear in 1988 IFF manual. 





SoundQuest Master Librarian format for MIDI system-exclusive driver. 

















Nov 10 17:19 1988 additional_docs/1188_Registry Page 4 


Form spec has not yet been provided. 


Word processing FORM used by Prowrite (New Horizons Software) 
See spec in current IFF manual. 


FONT 
COLR 


Cloanto Italia (private word processing form) 
Chunks C1C0, C1KO, C1LFO, C1U0, C1K1L 
clcO and C1KO used in C100 forms 
C1FO and ClU0 used in C100 and FTXT forms 
Also SGR9 SGR29 (label start and end) 





FORM RGB4 


For 4 bit R G B pixel information 


COMP (chunk containing compression table for the FORM) 


The RGB4 FORM contains a BMHD which will specify 2 as its Compression. 
BMHD compression value 2 has been reserved for this algorithm 
which is a modified Huffman encoding. 


Used by Shakespeare, Infinity Software (private) 
Contains embedded ILBMs 


64-1 






Nov 10 17:19 1988 additional_docs/1188_Registry Page 5 














Sound sample FORM proposed by "dissidents" (BIX: jfiore) 
Will be posted there if I. get author's permission. 
Designed to work cohesively with the MIDI standard. 









For ray-tracing program Turbo Silver by Impulse 
Will probably be posted on BIX when finalized. 





Unregistered Third Party FORMs 


Sculpt-3D 














Other IDs reserved in original EA IFF 85 spec: 


TEXT — a chunk containing plain unformatted ASCII text 
FNTR ~ raster font 
ENIV -— vector font 
GSCR — general-use musical score 
Macintosh picture 
PLBM — obsolete 
USCR — Uhuru Sound Software musical score 
- UVOX ~ Uhuru Sound Software Macintosh voice 
Property IDs: OPGM, OCPU, OCMP, OSN, UNAM 


CONNOR WNE 
0 
ml 
OQ 
an 
I 


Temporarily reserved by CBM or third parties: 


- CAT. CLIP — to hold various representations of data clipped to clipboard 
- FORM ARC - possible archiving form discussed on Usenet a while back 

. ATXT, PTXT — temporarily reserved 

ILBM chunks 3DCM, 3DPA - temporarily reserved 

RGBX, CDAT — temporarily reserved 

FORM MSMP, chunks MSHD, SSHD, SSLP — temporarily reserved 

FORM FIGR — temporarily reserved 

LIST MOVI ~ reserved 

Chunk name END - reserved by CBM for future stream end indication 


WMATA UN PWD 








i) 


os -iI 


Nov 10 17:25 1988 additional_docs/AboutILBM Page 1 


Intro to IFF Amiga ILBM Files and Amiga Viewmodes 


The IFF (Interchange File Format) for graphic images on the Amiga 
is called FORM ILBM (Interleaved BitMap).. It follows a standard 
parsable IFF format. 


Sample hex dump of beginning of an ILBM: 


Important note! You can NOT ever depend on any particular ILBM chunk 
being at any particular offset into the file! IFF files are composed, 
in their simplest form, of chunks within a FORM. Each chunk starts 
starts with a 4-letter chunkID, followed by a 32-bit length of the 
rest of the chunk. You PARSE IFF files, skipping past unneeded or 
unknown chunks by seeking their length (+1 if odd length) to the 

next 4-letter chunkID. 


0000: 464F524D 00016418 494C424D 424D4844 FORM. .d. ILBMBMHD 
0010: 00000014 01400190 00000000 06000100... .@.......... 


0020: OOOOOAOB 01400190 43414D47 00000004 iw... ..CAMG.... 

0030: 00000804 434D4150 00000030 001000E0 ...-CMAP...0.... 

0040: EOEO0000 20000050 30303050 50500030 .... ..PQOOPPP.0 
0050: 90805040 70707010 60E02060 E06080D0 .-P@ppp.”. 7.7... 

0060: AOAOAOAO 90EOCOCO CODOAOEO 424F4459 ... wee eee BODY 
0070: 000163AC F8000F80 148A5544 2ABDEFFF w-Cle eee uUD*... etc. 
Interpretation: 


'FORM' length ‘I L BM''B MH D‘'<-start of BitMapHeader chunk 
0000: 464F524D 00016418 494C424D 424D4844 FORM. .d. ILBMBMHD 
length’ WideHigh XorgYorg PIMkCoPd <- Planes Mask Compression Pad 


0010: 00000014 01400190 00000000 06000100 iw... Cn 
TranAspt PagwPagh 'C AMG' length <- start of C-AMiGa View modes chunk 


0020: OOOOOAOB 01400190 43414D47 00000004 iw... @. .CAMG.... 
Viewmode 'C MA P!' length R gb R <- Viewmode 800=HAM | 4=LACE 
0030: 00000804 434D4150 00000030 001000E0 ...-CMAP...0.... 
: gbRg bRgb RGbR gGbRg <- Rob's are for regO thru regn 

0040: EOE00000 20000050 30303050 50500030 .... .-POOOPPP.0 

bRgb RgbR gGbhRGQG DRGgb 
0050: 90805040 70707010 60E02060 E06080D0 .-P@ppp.”. 7.7... 

RgbR gbRg bRgb 'BOD Y' 
0060: AOAOAOAO 90E0COCO CODOA000 424F4459 www we ee BODY 

length start of body data <- Compacted (Compression=l1 above) 
0070: 000163AC F8000F80 148A5544 2ABDEFFF fr on UD*... 
0080: FFBFF800 OF7FF7FC FFO4F85A 77ADSDFE  ......-.... gw.J. ete. 


Notes on CAMG Viewmodes: HIRES=0x8000 LACE=0x4 HAM=0x800 HALFBRITE=0x80 


Interpreting ILBMs 


ILBM is a fairly simple IFF FORM. All you really need to deal with 
to extract the image are the following chunks: 


(Note — Also watch for AUTH Author chunks and (c) Copyright chunks 
and preserve any copyright information if you rewrite the ILBM) 


BMHD — info about the size, depth, compaction method 
(See interpreted hex dump above) 








Nov 10 17:25 1988 additional_docs/AboutILBM Page 2 


CAMG - optional Amiga viewmodes chunk 
Most HAM and HALFBRITE ILBMs should have this chunk. If no 
CAMG chunk is present, and image is 6 planes deep, assume 
HAM and you'll probably be right. Some Amiga viewmodes 
flags are HIRES=0x8000, LACE=0x4, HAM=0x800, HALFBRITE=0x80. 


CMAP — RGB values for color registers 0 ton 
(each component left justified in a byte) 


BODY - The pixel data, stored in an interleaved fashion as follows: 
(each line individually compacted if BMHD Compression = 1) 

plane 0 scan line 

plane 1 scan line 

plane 2 scan line 


plane n scan line 
plane 0 scan line 
plane 1 scan line 
etc. 


BPReEOoO O9CoO 





The BODY contains pixel data for the image. Width, Height, and depth 
(Planes) is specified in the BMHD. 


If the BMHD Compression byte is 0, then the scan line data is not compressed. 
If Compression=1, then each scan line is individually compressed as follows: 


More than 2 bytes the same stored as BYTE code value n from ~-1 to -127 
followed by byte to be repeated (-n) + 1 times. 

Varied bytes stored as BYTE code n from 0 to 127 followed by ntl bytes 
of data. 

The byte code -128 is a NOP. 


If the ILBM is not HAM or HALFBRITE, then after parsing and uncompacting 
if necessary, you will have N planes of pixel data. Color register 

used for each pixel is specified by looking at each pixel thru the planes. 
IE ~ if you have 5 planes, and the bit for a particular pixel is set in 
planes 0 and 3: 


PLANE 43210 
PIXEL o1l001 
then that pixel uses color register binary 01001 = 9 


The RGB value for each color register is stored in the CMAP chunk of the 
ILBM, starting with register 0, with each register's RGB value stored as 
one byte of R, one byte G, and one byte of B, with each component left 
justified in the byte. (ie. Amiga R, G, and B components are each stored 
in the high nibble of a byte) 


BUT — if the picture is HAM or HALFBRITE, it is interpreted differently. 


Hopefully, if the picture is HAM or HALFBRITE, the package that saved 
it properly saved a CAMG chunk (look at a hex dump of your file with 
ascii interpretation — you will see the chunks — they all start with 
a 4-ascii-char chunk ID). If the picture is 6 planes deep and has no 
CAMG chunk, it is probably HAM. If you see a CAMG chunk, the "CAMG" is 
followed by the 32-bit chunk length, and then the 32-bit Amiga Viewmode 
flags. 





T8 -— I 











Nov 10 17:25 1988 additional_docs/AboutILBM Page 3 


HAM pics will have the 0x800 bit set in CAMG chunk ViewModes. 
HALBRITE pics will have the 0x80 bit set. 


To transport a HAM or HALFBRITE picture to another machine, you must 
understand how HAM and HALFBRITE work on the Amiga. 


How Amiga HAM mode works: 


Amiga HAM (Hold and Modify) mode lets the Amiga display all 4096 RGB 
values. In HAM mode, the bits in the two last planes describe an R G or 
B modification to the color of the previous pixel on the line to create 
the color of the current pixel. So a 6-plane HAM picture has 4 planes 
for specifying absolute color pixels giving up to 16 absolute colors 
which would be specified in the ILBM CMAP chunk. The bits in the last 
two planes are color modification bits which cause the Amiga, in HAM mode, 
to take the RGB value of the previous pixel (Hold and), substitute the 4 
bits in planes 0-3 for the previous color's R G or B component (Modify) 
and display the result for the current pixel. If the first pixel of 
a scan line is a modification pixel, it modifies the RGB value of the 
border color (register 0). The color modification bits in the last two 
planes (planes 4 and 5) are interpreted as follows: 


00 - no modification. Use planes 0-3 as normal color register index 
10 - hold previous, replacing Blue component with bits from planes 0-3 
01 - hold previous, replacing Red component with bits from planes 0-3 
1l - hold previous. replacing Green component with bits from planes 0-3 


How Amiga HALFBRITE mode works: 


This one is simpler. In HALFBRITE mode, the Amiga interprets the 
bit in the last plane as HALFBRITE modification. The bits in the other 
planes are treated as normal color register numbers (RGB values for each 
color register is specified in the CMAP chunk). If the bit in the last 
plane is set (1), then that pixel is displayed at half brightness. 

This can provide up to 64 absolute colors. 


Other Notes: 


Amiga ILBMs images must be a even number of bytes wide. Smaller 
images (such as brushes) are padded to an even byte width. 


ILBMs created with Electronic Arts IBM and Amiga "DPaintII" packages 
are compatible (though you may have to use a '.lbm' filename extension 
on-an IBM). The ILBM graphic files may be transferred between the 
machines (or between the Amiga and IBM sides your Amiga if you have 
a CBM Bridgeboard card installed) and loaded into either package. 





Nov 10 17:19 1988 additional _docs/BackGrnd.doc Page 1 


BACKGROUND ON THE EXAMPLE IFF SOURCE CODE 
Jerry Morrison, 1/30/86 


The example IFF code is written using a programming style and techniques 
that may be unfamiliar to you. So here's a tutorial on "call-back 
procedures","enumerators", "interfaces", and "sub-classed structures". I 
recommend these programming practices independently of IFF software. 


DEFINITIONS: "CLIENT" VS. "USER" 


First, some definitions. The word “user” is reserved for a human user of a 
software package. That's you and me. 


A "client" of a software package, on the other hand, is a piece of software 
that uses that software package. A program that calls operating system 
routines such as "OpenFile" is a client of that operating system. 


CALL-BACK PROCEDURES 


Consider an operating system subroutine "ListDir" that lists the files-in a 
disk directory. It might allow you to list just the filenames matching a 
pattern like "a*.text". Maybe you can ask it to list just the files created 
since yesterday ... or those longer than 2000 bytes. ListDir is a fancy, 
general-purpose directory subroutine that lets you pass in a number of 
arguments to filter the listing. 


A C definition might look like: 


void ListDir(directory, namePattern, minSize, maxSize, minDate ...); 
for (each file in the directory) 
if ( PatternMatch(namePattern, filename) 
&& fileSize >= minSize 
&& fileSize <= maxSize 
&& fileDate >= minDate 


&& ... ) 
printf("%s\n", filename); /* probably fancier than this... */ 


and your call to it: 
ListDir(myDir, "a*.text", 0, maxFileSize, datel_1_1900, ...); 


When you think about it, these filtering arguments make up a 
special-purpose "file filtering language". The person who designed this 
subroutine “ListDir" might be pretty pleased with his accomplishment. But 
in practice he can never put in enough features into this special-purpose 
language to satisfy everyone. (You say you need to list just the files 
currently open?) And he may have provided a lot of functionality that is 
rarely needed. Is this filtering language what he should spending his time 
designing, writing, and debugging? 


A much better technique is to use a "call-back procedure". The concept is 
simple: instead of all those filter arguments to ListDir, you pass it a 
pointer to a "filter procedure". ListDir simply calls your procedure (via the 
pointer) to do the filtering, once per file. It passes each filename to your 
"filter proc", which returns "TRUE" to include that file in the listing or 
"PALSE" to skip it. 


typedef BOOL FilterProc(); /* FilterProc: a BOOL procedure */ 


void ListDir(directory, filterProc) ; 
Directory directory; FilterProc *filterProc; { 
for (each file in the directory) 
if ( (*filterProc)(filename) ) printf("%s\n", filename) ; 





7e8- I 





Nov 10 17:19 1988 additional_docs/BackGrnd.doc Page 


and your code: 


BOOL MyFilterProc(filename) STRING filename; [ 
return(PatternMatch("a*.text", filename) ); 


ListDix(myDir, MyFilterProc) ; 


This technique has many advantages. It gives unlimited flexibility to 
ListProc. It means you can use a general-purpose programming language 
instead of learning a special-purpose filtering language. It's more 
efficient to call a compiled subroutine than to "interpret" the filtering 
parameters. And it means you can do anything you want in a filter proc, 
from selecting files on the basis of numerology to copying files to backup 


tape. 





In practice, ListDir would have data about each file readily available. So it 
should pass this data to the filter proc to save time. 


As Alan Kay once said, “Simple things should be simple and complex things 
should be possible." 


STANDARD CALL-BACK PROCEDURE 


I could extend ListDir to accept a NULL FilterProc pointer to mean “list all 
files". More likely, I'd supply a standard call-back procedure ''FilterTRUE" 
that always returns TRUE. Then ListDir(directory, FilterTRUE) will list all 
files with no special test for filterProc == NULL. 


BOOL FilterTRUE( filename) 
return( TRUE) ; 


STRING filename; {f{ 


ENUMERATORS 


Let's take our ListDir example one step further. Rather than have. ListDir 
print the selected filenames, have it JUST call your custom proc for every 
file. Let your custom proc print the filenames, maybe in your own personal 
format. Or maybe have it quietly backup new files, or ask the user which 
ones to delete, or ... 


typedef CallBackProc(/* filename */); 


void ListDir(directory, callBackProc) ; 
Directory directory; CallBackProc *callBackProc; { 
for (each file in the directory) 
(*callBackProc) (filename) ; 
7} . 


and your code: 


void MyProc(filename) STRING filename; [ 
if ( PatternMatch("a*.text", filename) ) 
printf("%s\n", filename) ; 


Listbir(myDir, MyProc) ; 


Now we're talking about a full-blown "enumerator". The procedure “ListDir" 
is said to "enumerate" all the files in a directory. It "applies" your 
call-back procedure to each file. The enumerator scans the directory and 
your call-back procedure processes the files. It deals with the internal 
directory details and you deal with the printout. A nice separation of 
concerns. 











Nov 10 17:19 1988 additional_docs/BackGrnd.doc Page 3 











ListDir should come with a standard call-back procedure "PrintFilename" 
that lists the filename. By simply passing PrintFilename to ListDir, you 
can print a directory. By writing a call-back procedure that selectively 
calls the PrintFilename, you can filter the listing. 

void PrintFilename(filename) STRING filename; { 
printf£("%s\n", filename) ; 


ENUMERATION CONTROL 


A simple enhancement is to empower the call-back procedure to stop the 
enumeration early. That's easy. Have it return "TRUE" to stop. This is very 
handy, for example, to quit when you find what you're looking for. Let's 
expand this boolean "continue/stop" result into an integer error code. 


#define OKAY 0 
#define DONE —-1 
typedef int CallBackProc(/* filename */); 


int ListDir(directory, callBackProc) ; 
Directory directory; CallBackProc *callBackProc; { 
int result = OKAY; 
for (each file in the directory) while (result == OKAY) 
result = (*caliBackProc) (filename) ; 
return(result) ; 


IFF FILE ENUMERATOR 


Now we'll relate these techniques to the example IFF code. I'm assuming 
that you've read "EA IFF 85" Standard for Interchange Format Files. That 
memo is available from Commodore as part of their Amiga documentation. 
Also ask Commodore for "ILBM" IFF Interleaved Bitmap and the example IFF 
source code. 


Two things make IFF files very flexible for lots of interchange between 
programs. First, file formats are independent of RAM formats. That means 
you have to do some conversion when you read and write IFF files. Second, 
the contents are stored in chunks according to global rules. That means you 
have to parse the file, i.e. scan it and react to what's actually there. 


In the example IFF files IFF.H and IFFR.C, the routines ReadIFF, ReadIList, & 
ReadICat are enumeration procedures. ReadIFF scans an IFF file, 

enumerating all the "FORM", "LIST", "pROP", and "CAT" chunks encountered. 
ReadIList & ReadICat enumerate all the chunks in a LIST and CAT, 
respectively. 


A ClientFrame record is a bundle of pointers to 4 "call-back procedures" 
getList, getProp, getForm, and getCat. These 4 procedures are called by 
ReadIFF, ReadIList, and ReadICat when the 4 kinds of IFF "groups" are 
encountered: "LIST", "PROP", “FORM", or "CAT". 





These 3 enumerator procedures and 4 client procedures together make up a 
reader for IFF files--a very simple recursive descent parser. If you want 
to learn more about parsing, a real good place to look is the new edition 
"@ragon book" by Aho, Ullman, and Sethi. 


The procedure "SkipGroup" is just a default call—back procedure. 


The “IFFP" values IFF_OKAY through BAD_IFF are the error codes used by 
the IFF enumerators. We use the type "IFFP" to declare variables (and 
procedure results) that hold such values. The code “IFF_OKAY" means "AOK; 
keep enumerating". The other values mean "stop" for one reason or other. 
“TIFF DONE" means “we're all done", while "END MARK" means "we hit the 


€8 -1 











Nov 10 17:19 1988 additional_docs/BackGrnd.doc Page 4 
end at this nesting level". 


CALL-BACK PROCEDURE STATE 


ListDir is an enumerator with some internal state--it internally 

remembers its place in the directory. It loops over the directory, calling 

the client proc once per file. That's fine for some cases and less 
convenient for others. Consider this example that just lists the first 10 
iles: 


int count; 
int PrintFirstl0(filename) STRING filename; { 
if (++count > 10) return(DONE); 


printf("Ss\n", filename) ; 
return (OKAY) ; 
} 


void DoIt(); ‘{ 


count = 0; 
ListDir(myDir, PrintFirst10); 
} 


Inherently, the client's code has to be split into code that calls the 
enumerator and a call~back procedure. Thus any communication between 

the two must be via global variables. In this trivial example, the global 
"count'' saves state data between calls to PrintFirstl0. Often, it's much 
more complex. But globals won't work if you need reenterent or recursive 
code. We really want "count" to be a local variable of DolIt. 


Fixing this in Pascal is easy: Define PrintFirstl0 as a nested procedure 
within DoIt so it can access DoIt's local variables. The manual analog in ¢ 
is to redefine the enumerator to pass a raw "client data pointer" straight 
through to the call-back procedure. The two client procedures then 
communicate through the "client data pointer". DoIt would call 
ListDir(myDir, PrintFirstl0, s&count) which calls PrintFirst10(filename, 
&count.). 


#define OKAY. 0 
#define DONE ~1 
typedef int CallBackProc(/* filename, clientData */); 


int ListDir(directory, callBackProc, clientData); 


Directory directory; CallBackProc *callBackProc; BYTE *clientData; [{ 


int result = OKAY; 

for (each file in the directory) while (result == OKAY) 
result = (*callBackProc)(filename, clientData) ; 

return(result); 


In general, an enumerator is sometimes inconvenient because it takes over 
control. Think about this: How could you enumerate two directories in 
parallel and copy the newer files from one directory to the other? 


STATELESS ENUMERATOR 

An alternate form without this disadvantage is the "stateless enumerator". 
In a stateless enumerator, it's up to the client to keep its place in the 
enumeration. Call a procedure like GetNextFilename each time around the 
loop. 


STRING curFilename = NULL; 
int count = 0; 


Nov 10 17:19 1988 additional_docs/BackGrnd.doc Page 5 


do { 
if (++count > 10) break; /* stop after 10 files */ 
curFilename = GetNextFilename(directory, curFilename) ; 
if (curFilename == NULL) break; /* stop at end of directory */ 
printf("%s\n", filename); 


The stateless enumerator is sometimes better because it puts the client 

in control. The above example shows how easy it is to keep state 
information between iterations and to stop the enumeration easy. It's also 
easy to do things like list two directories in parallel. 


IFF CHUNK ENUMERATOR 


The following IFFR.C routines make up a stateless IFF chunk enumerator: 
OpenRIFF, OpenRGroup, GetChunkHdr and CloseRGroup. Together with 
IFFReadBytes, we have a complete layer of "chunk reader" subroutines. 
These subroutines are built upon the file stream package in the local 
system library. 


GetChunkHdr is the "get next" procedure you call to get the next IFF chunk. 
(GetFChunkHdr, GetFlChunkHdr, and GetPChunkHdr are subroutines that call 
GetChunkHdr and do a little extra work.) OpenRIFF and OpenRGroup do the 
initialization needed before you can call GetChunkHdr. CloseRGroup does 
the cleanup work. 


You supply a “GroupContext" pointer each time you call one of these "chunk 
reader" procedures. The enumeration state is kept in a GroupContext record 
which the *client* must allocate but the *enumerator* routines initialize 
and maintain. (The client may peek into a GroupContext but should never 
modify it directly.) The two procedures OpenRIFF and OpenRGroup initialize 
the GroupContext record. This “opens a context" for reading chunks. The 
procedure CloseRGroup cleans up when you're done with a GroupContext. 


Here's the essense of an IFF scanner program. It handles whatever it finds, 
unlike inflexible file readers that demand conformance to a rigid file 
format. [Note: This code doesn't check for errors or end-of-context. ] 


OpenRGroup(..., context); /* initialize */ 
do 


id = GetChunkHdr(context); /* get the next chunk's ID */ 
switch (id) f 

case AAAA: {read in an AAAA chunk; break}; 

case BBBB: {read in a BBBB chunk; break}; 


default: {}; /* just ignore unrecognized chunks */ 
J 
CloseRGroup(context); /* cleanup */ 


GetChunkHdr reads the next chunk header and returns its chunk ID. You then 
dispatch on the chunk ID, that is, switch to a different piece of code for 
each type of chunk. If you don't recognize the chunk ID, just keep looping. 


In each “case:" statement, call IFFReadBytes one or more times to read the 
chunk's contents. The readin work you do here depends on the chunk type 
and what you need in RAM. Since GetChunkHdr automatically skips to the 
start of the next chunk, it doesn't matter if you don't read all the data 
bytes. 


GetChunkHdr does some other things for you automatically. When it reads a 
"group" chunk header (a chunk of type "FORM", "LIST", "CAT ", or "PROP") it 
automatically reads the subtype ID. That makes it very convenient to just 
open the contents of the group chunk as a group context and read the 
nested chunks. See the example source program ShowILBM for more about 

the relationship between a "GroupContext" and a "ClientFrame". 


Like all the example IFF code, GetChunkHdr checks for errors. To handle 
GetChunkHdr errors, we just add cases to the switch statment. To stop at 


ya - 1 





Nov 10 17:19 1988 additional_docs/BackGrnd.doc Page 6 


end-of-context or an error in a switch case, we add a "while" clause at the 
end of the "do" statement. 


CLIENTS, INTERFACES, AND IMPLEMENTORS 


In the ListDir example, you can see that a lot of flexibility comes from 
decoupling the task of tracing through the directory's data structures from 
the task of filtering files and printing filenames. This is called 
modularity, or simply, dividing a program into parts. 


Choosing good module boundaries is an art. It has a big impact on a 
programmer's ability to coope with lrge programs. Good modularity makes 
programs much easier to understand and modify. But this topic would be 
another whole tutorial in itself. 


Just be aware that the example IFF program is divided into various 
"modules", each of which implements a different part of the bigger picture. 
One such module is the low level IFF reader/writer. It's split into two 
files IFFR.C and IFFW.C. Other such modules are the run encoder/decoder 
Packer.C and UnPacker.C, and ILBM read/write subroutines ILBMR.C and 
ILBMW.C. 


You'll notice that all three of these "modules" are split into a pair of files. 


That's because most linkers aren't fancy enough to automatically eliminate 
unused subroutines, e.g. for a program like ShowILBM that reads but doesn't 
need the writer code. Also, a program like DeluxePaint wants read and 
write code in separate overlays. So think of each pair as a single module. 


What I want to point out is the basic structure. Each "module" has an 
"interface" file (a .H file) that separates the "implementor" .C file(s) from 
the "client" programs. This interface is very important, in fact, more 
important than the code details inside the .C files. The interfaces for the 
above-mentioned modules are called IFF.H, Packer.H, and ILBM.H. 


Everything about a layer of software that the clients need to know belongs 
in its interface: constant and type definitions, extern declarations for the 
procedures, and comments. The comments detail the purpose of the module 

and each procedure, the procedure arguments, side effects, results, and 
error codes, etc. Nothing the clients don't need to know belongs in its 
interface: internal implementation details that might change. 


Thus, the modularization and other important design information is 
collected and documented in these interface files. So if you want to 
understand what a module does and how to use it, READ ITS INTERFACE. 
Don't dive headfirst into the implementation. 


Two of the original articles on modular programming are 
D.L. Parnas, "On the Criteria To Be Used in Decomposing Systems into 
Modules". Communications of the ACM 15, 12 (Dec. ‘'72), pp 1053-1058. 


B. Liskov and S. Zilles, ."Programming with Abstract.Data Types". 
Proceedings ACM SIGPLAN Conference on Very High-Level Languages. 
SIGPLAN Notices 9, 4 (April '74), pp 50-59. 


SUBCLASSED STRUCTURES 


One more technique. In programming, a general-purpose module may define 

a structure like ClientFrame. Along comes a more special-purpose program 
that needs a structure like it but with specialized fields added on. The 
answer is to build a larger structure whose first field is the earlier 
structure. This is called "subclassing" a structure, a term that comes from 
subclassing in Smalltalk. 


In the Macintosh(tm) toolbox, the record GrafPort is subclassed to produce 
the record WindowRecord, which is subclassed again to produce a 
DialogWindow record. 


IL 





Nov 10 17:19 1988 additional _docs/BackGrnd.doc Page 7 


Similarly in the example IFF program ShowILBM, the structure ClientFrame 
is subclassed to produce the more specialized structure ILBMFrame. 


typedef struct { 
ClientFrame clientFrame; 
UBYTE foundBMHD; 


} ILBMFrame; 


Since the first field of an ILBMFrame is a ClientFrame, the ShowILBM 
procedure ReadPicture can coerce a *ClientFrame pointer to an 
*ILBMFrame pointer to pass it to ReadIFF (which knows nothing about 
ILBMFrame). When ReadIFF calls back ShowILBM's getForm procedure, we 
can coerce it back to an *ILBMFrame pointer. Take a look at ShowILBM to 
see how this works. 














Ss - I 


Nov 10 17:19 1988 additional_docs/Code.doc Page 1 


Overview of EA IFF example source files 
This source code is distributed as public domain software. Use it to help 
write robust IFF-compatible programs. 
Caveat: Electronic Arts developed this code, and is releasing it to promote 
the success of the Amiga. EA does not have the resources to supply support 
for this code. For support, Amiga software developers contact Commodore 
directly. 


1. Description of the EA-provided sources and include files 


COMPILER .H Portability file to isolate compiler idiosyncrasies. 

INTUALL .H A super-include file for Amiga include files. 

REMALLOC .H Header for RemAlloc subroutines. 

REMALLOC.C Memory ALLOCators which REMember the size allocated, 
for simpler freeing. 

GIO .H Header file for Generic 1/0 speed up package. 

GIO .c Generic I/O speed up routines (a disk cache). 

GIOCALL .C Outline of example GIO client. 
To turn on the GIO package, change a switch in GIO.H, 
add GIO.O to the linker control file, and recompile. 

IFF -H Header file for general IFF read/write support. 

IFFR Cc IFF reader support routines. 

IFFW .c IFF writer support routines. 
These routines do a lot of the work for reading and 
writing IFF files robustly. The reader and writer are 
separate since some programs don't need both. 

IFFCHECK.C IFF checker utility source (very handy for debugging). 
The IFF checker scans an IFF file, checks it for 
syntax errors, and prints an outline of its contents. 

PACKER .H Header for byte run encoder (compressor) subroutines. 

PACKER .C Run encoder subroutines. 

UNPACKER .C Run decoder subroutines. This run encoder/decoder is 
used for ILBM raster images. 

ILBM -H Header for ILBM (raster image file) subroutines. 

ILBMR Cc ILBM reader support routines. Uses IFFR. 

TLBMW Cc ILBM writer support routines. Uses IFFW. 

READPICT.H Header for ReadPicture subroutines. 

READPICT.C ReadPicture subroutines read an ILBM file into an 
Amiga BitMap in RAM. Uses ILBMR and IFFR. 

SHOWILBM .C Example program that reads and displays an ILBM file. 

PUTPICT .H Header for PutPict subroutines. 

PUTPICT .C PutPict subroutines write an Amiga BitMap from RAM 
to an ILBM file. Uses ILBMW and IFFW. 

RAW21LBM.C Example program that reads a "raw" raster image file 
and writes the image as an ILBM file. 

ILBM2Raw.C Example program that reads an image as an ILBM file 
and writes the image as.a "raw" raster image file. 

BMPrintc.c Subroutine that actually does the text dump. 

ILBMDump . C Example program that reads an image as an ILBM file 


and writes the image as a text file containing C data 
initialization statements for either a BOB or a 
Sprite. 


Nov 10 17:19 1988 additional_docs/Code.doc Page 2 


2. Compiler idiosyncracies. 


This source code was built for the Lattice 68000 Amiga C cross-compiler, and 
the Metacomco ALink linker. Some of the IFF source code assumes that the 
compiler will support function protyping: the ability to typecheck procedure 
arguments (templates). Believe me, typechecking is useful! The more bugs I 
find at compile time, the less I have to find at run time. 


The programmer asks for this typechecking via an "extern" statement like 
this: 

extern IFFP Seek(BPTR, LONG, LONG); 

typedef IFFP ClientProc(struct _GroupContext *); 


Unfortunately, this chokes some C compilers. If you have such a compiler, you 
have to comment out the stuff in parentheses. The above two examples become: 


extern IFFP Seek(/* BPTR, LONG, LONG */); 
typedef IFFP ClientProc(/* struct _GroupContext * */); 


Don't remove the parentheses! 


The header file COMPILER.H defines macros to isolate the compiler 
dependencies. The macro FDwAT ("function definitions with argument types") 
switches on/off the argument type declarations in the header files in this 
directory. 


3. RemAlloc subroutines. 


The "REMembering ALLOCator" is a useful little subroutine package included 
here. It saves you from having to remember the size of each node you 
allocate. (Why doesn't the Amiga allocator do this?) 


4. Optional buffered file I/O package GIO. 


Amiga file I/O can be greatly sped up by use of a RAM buffer. So we now have 
a layer of software that provides optional buffering. Some compilers may also 
have such a layer, in which case ignore this one. The "option" is controlled 
by changing a "#define" inside the header file GIO.H, adding GIO.O to your 
link file, recompiling, and recompiling. When turned off, this layer becomes 
just a layer of macro calls between the IFFR and IFFW modules and the 
AmigaDbOS routines they call. 


This RAM buffer speeds things up when you're doing numerous small Writes 
and/or Seeks while writing. The general IFF writer IFFW.C tends to do this. 
It should be extended to optimize reading, too. If you are not using IFF, and 
already Write in chunks of 256 bytes or more, don't bother using GIO. 











Third Party Public Registered FORM 
and Chunk Specifications 


This section contains the specifications of many public registered third party IFF FORMs 
and Chunks currently used in Amiga software products. As noted in the Registry, there are 
additional forms for which final specs are not yet available, most notably the SAMP, SYTH, 
and BANK midi-related formats. Check for availability of these form specs in the CATS 
IFF topic on BIX (amiga.dev /iff). 


68 -— I 





Nov 10 17:18 1988 TP_specs/8SVX.CHANandPAN Page 1 


SMUS.CHAN and SMUS.PAN Chunks 
Stereo imaging in the "8SVX" IFF 8-bit Sample Voice 


Registered by David Jones, Gold Disk Inc. 


There are two ways to create stereo imaging when playing back a digitized 
sound. The first relies on the original sound being created with a stereo 
sampler: two different samples are digitized simultaneously, using right and 
left inputs. To play back this type of sample while maintaining the 

stereo imaging, both channels must be set to the same volume. The second type 
of stereo sound plays the identical information on two different channels at 
different volumes. This gives the sample an absolute position in the stereo 
field. Unfortunately, there are currently a number of methods for doing this 
currently implemented on the Amiga, none truly adhering to any type of 
standard. What I have tried to to is provide a way of doing this 
consistently, while retaining compatibility with existing (non-standard) 
systems. Introduced below are two optional data chunks, CHAN and PAN. CHAN 
deals with sounds sampled in stereo, and PAN with samples given stereo 
characteristics after the fact. 


Optional Data Chunk CHAN 


This chunk is already written by the software for a popular stereo sampler. To 
maintain the ability read these samples, its implementation here is 
therefore limited to maintain compatability. 


The optional data chunk CHAN gives the information neccessary to play a 

sample on a specified channel, or combination of channels. This chunk 

would be useful for programs employing stereo recording or playback of sampled 
sounds. 


#define RIGHT 4L 
#define LEFT 2L 
#define STEREO 6L 


#define ID_CHAN MakeID('C','H','A','N’) 
typedef sampletype LONG; 


If "sampletype" is RIGHT, the program reading the sample knows that it was 
originally intended to play on a channel routed to the right speaker, 
(channels 1 and 2 on the Amiga). If “sampletype" is LEFT, the left speaker 
was intended (Amiga channels 0 and 3). It is left to the discretion of the 
programmer to decide whether or not to play a sample when a channel on the 
side designated by "sampletype" cannot be allocated. 


If "sampletype" is STEREO, then the sample requires a pair of channels routed 
to both speakers (Amiga pairs [0,1] and [2,3]). The BODY chunk for stereo 
pairs contains both left and right information. To adhere to existing 
conventions, sampling software should write first the LEFT information, 
followed by the RIGHT. The LEFT and RIGHT information should be equal in 
length. 


Again, it is left to the programmer to decide what to do if a channel for 
a stereo pair can't be allocated; wether to play the available channel only, 
or to allocate another channels routed to the wrong speaker. 


Optional Data Chunk PAN 


The optional data chunk PAN provides the neccessary information to create a 
stereo sound using a single array of data. It is neccessary to replay the 
sample simultaneously on two channels, at different volumes. 


Nov 10 17:18 1988 TP_specs/8SVX.CHANandPAN Page 2 


#define ID_PAN MakeID('P','A','N',' ') 


typedef sposition Fixed; /* 0 <= sposition <= Unity */ 
/* Unity is elsewhere #defi 
* refers to the maximum po 


*/ 


/* Please note that 'Fixed' (elsewhere #defined as LONG) is used to 
* allow for compatabilty between audio hardware of different resolutions. 


*/ 
The 'sposition’ variable describes a position in the stereo field. The 


numbers of discrete stereo positions available is equal to 1/2 the number of 
discrete volumes for a single channel. 


The sample must be played on both the right and left channels. The overall 
volume of the sample is determined by the "volume" field in the Voice8Header 
structure in the VHDR chunk. 


overall volume / (Unity / sposition). 
overall volume ~ left channel volume. 


The left channel volume 
at right uw iT 


toa 


For example: 
If sposition 
If sposition 
If sposition 


Unity, the sample is panned all the way to the left. 
0, the sample is panned all the way to the right. 
Unity/2, the sample is centered in the stereo field. 


hoa 


06-1 


Nov 10 17:18 1988 TP_specs/ACBM Page 1 


IFF FORM / CHUNK DESCRIPTION 


Form/Chunk ID: FORM ACBM (Amiga Contiguous BitMap) 


Chunk ABIT (Amiga BITplanes) 


Date Submitted: 05/29/86 
Submitted by: Carolyn Scheppner CBM 


FORM ID: ACBM (Amiga Contiguous BitMap) 
FORM Description: 


FORM ACBM has the same format as FORM ILBM except the normal BODY 


chunk (Interleaved BitMap) is replaced by an ABIT chunk (Amiga BITplanes). 


FORM Purpose: 


To enable faster loading/saving of screens, especially from Basic, 
while retaining the flexibility and portability of IFF format files. 


CHUNKS 


Chunk ID: ABIT (Amiga BiTplanes) 
Chunk Description: 


The ABIT chunk contains contiguous bitplane data. The chunk contains 
sequential data for bitplane 0 through bitplane n. 


Chunk Purpose: 


To enable loading/storing of bitmaps with one DOS Read/Write per 
bitplane. Significant speed increases are realized when loading/saving 
screens from Basic. 


SUPPORTING SOFTWARE 


(Public Domain, available soon via Fish PD disk, various networks) 


LoadILBM~SaveACBM (AmigaBasic) 
Loads and displays an IFF ILBM pic file (Graphicraft, DPaint, Images). 
Optionally saves the screen in ACBM format. 


LoadACBM (AmigaBasic) 
Loads and display an ACBM format pic file. 


SaveILBM (AmigaBasic) 
Saves a demo screen as an ILBM pic file which can be loaded into 
Graphicraft, DPaint, Images. 


Nov 10 17:18 1988 TP_specs/ANBM Page 1 


TITLE: Form ANBM (animated bitmap form used by Framer, Deluxe Video) 
(note from the author) 


The format was designed for simplicity at a time when the IFF 
standard was very new and strange to us all. It was not designed 
to be a general purpose animation format. It was intended to be 
a private format for use by DVideo, with the hope that a more 
powerful format would emerge as the Amiga became more popular. 


I hope you will publish this format sc that other formats will 
not inadvertantly conflict with it. 


PURPOSE: To define simple animated bitmaps for use in DeluxeVideo. 


In Deluxe Video objects appear and move in the foreground 
with a picture in the background. Objects are "small" bitmaps 
usually saved as brushes from DeluxePaint and pictures are large 
full screen bitmaps saved as files from DeluxePaint. 


Two new chunk headers are defined: ANBM and FSON. 


An animated bitmap (ANBM) is a series of bitmaps of the same 
size and‘depth. Each bitmap in the series is called a frame and 
is labeled by a character, 'abc ...' in the order they 
appear in the file. 


The frame sequence chunk (FSQN) specifies the playback 
sequence of the individual bitmaps to achieve animation. 
FSQN_CYCLE and FSQN_TOFRO specify two algorithmic sequences. If 
neither of these bits is set, an arbitrary sequence can be used 
instead. 


ANBM - identifies this file as an animated bitmap 

. FSQN — playback sequence information 

.LIST ILBM - LIST allows following ILBMs to share properties 
..PROP ILBM -— properties follow 

.. .BMHD ~ bitmap header defines common size and depth 

. . CMAP - colormap defines common colors 

..FORM ILBM - first frame follows 


. -BODY ~ the first frame 
: — FORM ILBM and BODY for each remaining frame 


Chunk Description: 
The ANBM chunk identifes this file as an animated bitmap 
Chunk Spec: 
#define ANBM MakeID('A','N','B','M') 
Disk record: 
none 
Chunk Description: 
The FSQN chunk specifies the frame playback sequence 
Chunk Spec: 
#define FSQN MakeID('F','S','Q','N') 
/* Flags */ 


#define FSQN_CYCLE 0x0001. /* Ignore sequence, cycle a,b,..y,z,a,b,.. */ 
#define FSON_TOFRO 0x0002 /* Ignore sequence, cycle a,b,..y,2,y,-.a,b, */ 








Nov 10 17:18 1988 TP_specs/ANBM Page 2 Nov 10 17:18 1988 TP_specs/ANIM Page 1 


/* Disk record */ TITLE: New ANIM spec (with typos corrected) 
typedef struct { 
WORD numframes; /7* Number of frames in the sequence */ ANIM 
LONG dat; /* Nominal time between frames in jiffies */ An IFF Format For CEL Animations 
WORDBITS flags; /* Bits modify behavior of the animation */ 
UBYTE sequence[80]; /* string of ‘a'..'z' specifying sequence */ Revision date: 4 May 1988 
} FrameSeqn; 
prepared by: 
SPARTA Inc. 
Supporting Software: 23041 de la Carlota 
Laguna Hills, Calif 92653 
DeluxeVideo by Mike Posehn and Tom Case for Electronic Arts (714) 768-8161 
contact: Gary Bonham 
Thanks, also by: 
Mike Posehn Aegis Development Co. 


2115 Pico Blvd. 
Santa Monica, Calif 90405 
213) 392-9972 


1.0 Introduction 


The ANIM IFF format was developed at Sparta originally for the 
production of animated video sequences on the Amiga computer. The 
intent was to be able to store, and play back, sequences of frames 
and to minimize both the storage space on disk (through compression) 
and playback time (through efficient de-compression algorithms) . 

It was desired to maintain maximum compatibility with existing 

IFF formats and to be able to display the initial frame as a normal 
still IFF picture. 


Several compression schemes have been introduced in the ANIM format. 
Most of these are strictly of historical interest as the only one 
currently being placed in new code is the vertical run length 
encoded byte encoding developed by Jim Kent. 


Té6 - I 


1.1 ANIM Format Overview 


The general philosophy of ANIMs is to present the initial frame 
as a normal, run-~length-encoded, IFF picture. Subsequent 
frames are then ‘described by listing only their differences 
from a previous frame. Normally, the "previous" frame is two 
frames back as that is the frame remaining in the hidden 

screen buffer when double-buffering is used. To better 
understand this, suppose one has two screens, called A and B, 
and the ability to instantly switch the display from one to 

the other. The normal playback mode is to load the initial 
frame into A and duplicate it into B. Then frame A is displayed 
on the screen. Then the differences for frame 2 are used to 
alter screen B and it is displayed. Then the differences for 
frame 3 are used to alter screen A and it is displayed, and so 
on. Note that frame 2 is stored as differences from frame 1, 
but all other frames are stored as differences from two frames 
back. 


ANIM is an IFF FORM and its basic format is as follows (this 
assumes the reader has a basic understanding of IFF format 


files): 

FORM ANIM 

. FORM ILBM first frame 
. BMHD normal type IFF data 
. ANHD optional animation header 

chunk for timing of lst frame. 

. CMAP 

- »« BODY 

. FORM ILBM frame 2 
. ANHD animation header chunk 


. DLTA delta mode data 


c6 ~ 1 






Nov 10 17:18 1988 TP_specs/ANIM Page 2 


. FORM ILBM frame 3 
. ANHD 
. DLTA 


The initial FORM ILBM can contain all the normal ILBM chunks, 
such as CRNG, etc. The BODY will normally be a standard 
run-length-encoded data chunk (but may be any other legal 
compression mode as indicated by the BMHD). If desired, an ANHD 
chunk can appear here to provide timing data for the first 
frame. If it is here, the operation field should be =0. 


The subsequent FORMs ILBM contain an ANHD, instead of a BMHD, 
which duplicates some of BMHD and has additional parameters 
pertaining to the animation frame. The DLTA chunk contains 

the data for the delta compression modes. If 

the older XOR compression mode is used, then a BODY chunk 

will be here. In addition, other chunks may be placed in each 
of these as deemed necessary (and as code is placed in player 
programs to utilize them). A good example would be CMAP chunks 
to alter the color palette. A basic assumption in ANIMs is 
that the size of the bitmap, and the display mode (e.g. HAM) 
will not change through the animation. Take care when playing 
an ANIM that if a CMAP occurs with a frame, then the change must 
be applied to both buffers. 


Note that the DLTA chunks are not interleaved bitmap representations, 
thus the use of the ILBM form is inappropriate for these frames. 
However, this inconsistency was not noted until there were a number 
of commercial products either released or close to release which 
generated/played this format. Therefore, this is probably an 
inconsistency which will have to stay with us. 


1.2 Recording ANIMs 


To record an ANIM will require three bitmaps - one for 
creation of the next frame, and two more for a "history" of the 
previous two frames for performing the compression calculations 
(e.g. the delta mode calculations). 


There are five frame-to-frame compression methods currently 
defined. The first three are mainly for historical interest. 

The product Aegis VideoScape 3D utilizes the third method in 
version 1.0, but switched to method 5 on 2.0. This is 

the only instance known of a commercial product generating 

ANIMs of any of the first three methods. The fourth method 

isa general short or long word compression scheme which has 
several options including whether the compression is horizontal 
or vertical, and whether or not it is XOR format. This offers 

a choice to the user for the optimization of file size and/or 
playback speed. The fifth method is the byte vertical run length 
encoding as designed by Jim Kent. Do not confuse 

this with Jim's RIFF file format which is different than ANIM. 
Here we utilized his compression/decompression routines within the 
ANIM file structure. 


The following paragraphs give a general outline of each of the 
methods of compression currently included in this spec. 


1.2.1 XOR mode 


This mode is the original and is included here for historical 
interest. In general, the delta modes are far superior. 

The creation of XOR mode is quite simple. One simply 
performs an exclusive-or (XOR) between all corresponding 
bytes of the new frame and two frames back. This results 

in a new bitmap with 0 bits wherever the two frames were 
identical, and 1 bits where they are different. Then this 
new bitmap is saved using run-length-encoding. A major 

















Nov 10 17:18 1988 TP_specs/ANIM Page 3 


obstacle of this mode is in the time consumed in performing 
the XOR upon reconstructing the image. 


1.2.2 Long Delta mode 


This mode stores the actual new frame long-words which are 
different, along with the offset in the bitmap. The 

exact format is shown and discussed in section 2 below. 
Each plane is handled separately, with no data being saved 
if no changes take place in a given plane. Strings of 

2 or more long-words in a row which change can be run 
together so offsets do not have to be saved for each one. 


Constructing this data chunk usually consists of having 
a buffer to hold the data, and calculating the data as 
one compares the new frame, long-word by long-word, with 
two frames back. 


1.2.3 Short Delta mode 


This mode is identical to the Long Delta mode except that 
short-words are saved instead of long-words. In most 
instances, this mode results in a smaller DLTA chunk. 

The Long Delta mode is mainly of interest in improving 

the playback speed when used on a 32-bit 68020 Turbo Amiga. 


1.2.4 General Delta mode 


The above two delta compression modes were hastily put together. 
This mode was an attempt to provide a well-thought-out delta 
compression scheme. Options provide for both short and long 
word compression, either vertical or horizontal compression, 
XOR mode (which permits reverse playback), etc. About the time 
this was being finalized, the fifth mode, below, was developed 
by Jim Kent. “In practice the short-vertical—-run—length—encoded 
deltas in this mode play back faster than the fifth mode (which 
is in essence a byte-vertical-run-length-encoded delta mode) but 
does not compress as well - especially for very noisy data such 
as digitized images. In most cases, playback speed not being 
terrifically slower, the better compression (sometimes 2x) is 
preferable due to limited storage media in most machines. 


Details on this method are contained in section 2.2.2 below. 
1.2.5 Byte Vertical Compression 


This method does not offer the many options that method 4 offers, 
but is very successful at producing decent compression even for 
very noisy data such as digitized images. The method was devised 
by Jim Kent and is utilized in his RIFF file format which is 
different than the ANIM format. The description of this method 
in this document is taken from Jim's writings. Further, he has 
released both compression and decompression code to public domain. 


Details on this method are contained in section 2.2.3 below. 


1.3 Playing ANIMs 


Playback of ANIMs will usually require two buffers, as mentioned 
above, and double-buffering between them. The frame data from 
the ANIM file is used to modify the hidden frame to the next 
frame to be shown. When using the XOR mode, the usual run— 
length-decoding routine can be easily modified to do the 
exclusive-or operation required. Note that runs of zero bytes, 
which will be very common, can be ignored, as an exclusive or 
of any byte value to a byte of zero will not alter the original 
byte value. 


The general procedure, for all compression techniques, is to first 








€6 -I1 


Nov 10 17:18 1988 TP_specs/ANIM Page 4 


decode the initial ILBM picture into the hidden buffer and double- 
buffer it into view. Then this picture is copied to the other (now 
hidden) buffer. At this point each frame is displayed with the 
same procedure. The next frame is formed in the hidden buffer by 
applying the DLTA data (or the XOR data from the BODY chunk in the 
case of the first XOR method) and the new frame is double-buffered 
into view. This process continues to the end of the file. 


A master colormap should be kept for the entire ANIM which would 
be initially set from the CMAP chunk in the initial ILBM. This 
colormap should be used for each frame. If a CMAP chunk appears 
in one of the frames, then this master colormap is updated and the 
new colormap applies to all frames until the occurrance of another 
CMAP chunk. 


Looping ANIMS may be constructed by simply making the last two frames 
identical to the first two. Since the first two frames are special 
cases (the first being a normal ILBM and the second being a delta from 
the first) one can continually loop the anim by repeating from frame 
three. In this case the delta for creating frame three will modify 
the next to the. last frame which is in the hidden buffer (which is 
identical to the first frame), and the delta for creating frame four 
will modify the last frame which is identical to the second frame. 


Multi-File ANIMs are also supported so long as the first two frames 
of a subsequent file are identical to the last two frames of the 
preceeding file. Upon reading subsequent files, the ILBMs for the 
first two frames are simply ignored, and the remaining frames are 
simply appended to the preceeding frames. This permits splitting 
ANIMs across multiple floppies and also permits playing each section 
independently and/or editing it independent of the rest of the ANIM. 


Timing of ANIM playback is easily achieved using the vertical blank 
interrupt of the Amiga. There is an example of setting up such 

a timer in the ROM Kernel Manual. Be sure to remember the timer 
value when a frame is flipped up, so the next frame can be flipped 

up relative to that time. This will make the playback independent 

of how long it takes to decompress a frame (so long as there is enough 
time between frames to accomplish this decompression). 


2.0 Chunk Formats 


2.1 ANHD Chunk 
The ANHD chunk consists of the following data structure: 


UBYTE operation The compression method: 

=0 set directly (normal ILBM BODY), 

=1 XOR ILBM mode, 

=2 Long Delta mode, 

=3 Short Delta mode, 

=4 Generalized short/long Delta mode, 

=5 Byte Vertical Delta mode 

=74 (ascii ‘'J') reserved for Eric Graham's 
compression technique (details to be 
released later). 


UBYTE mask (XOR mode only — plane mask where each 
bit is set =l if there is data and =0 
if not.) 

UWORD w,h (XOR mode only - width and height of the 


area represented by the BODY to eliminate 
unnecessary un-changed data) 


WORD X,Y (XOR mode only — position of rectangular 
area representd by the BODY) 
ULONG abstime (currently unused - timing for a frame 


relative to the time the first frame 
was displayed - in jiffies (1/60 sec)) 

ULONG reltime {timing for frame relative to time 
previous frame was displayed - in 
jiffies (1/60 sec)) 





Nov 10 17:18 1988 TP_specs/ANIM Page 5 


UBYTE interleave (unused so far - indicates how may frames 
back this data is to modify. =0 defaults 
to indicate two frames back (for double 
buffering). =n indicates n frames back. 
The main intent here is to allow values 
of =1 for special applications where 
frame data would modify the immediately 
previous frame) 

UBYTE pad0d Pad byte, not used at present. 

ULONG bits 32 option bits used by options=4 and 5. 
At present only 6 are identified, but the 
rest are set =0 so they can be used to 
implement future ideas. These are defined 
for option 4 only at this point. It is 
recommended that all bits be set =0 for 
option 5 and that any bit settings 
used in the future (such as for XOR mode) 
be compatible with the option 4 
bit settings. Player code should check 
undefined bits in options 4 and 5 to assure 
they are zero. 


The six bits for current use are: 


bit # set =0 set =l 
0 short data long data 
1 set XOR 
2 separate info one info list 
for each plane for all planes 
3 not RLC RLC (run length coded) 
4 horizontal vertical 
5 short info offsets long info offsets 


UBYTE pad[16] This is a pad for future use for future 
compression modes. 


2.2 DLTA Chunk 


This chunk is the basic data chunk used to hold delta compression 
data. The format of the data will be dependent upon the exact 
compression format selected. At present there are two basic 
formats for the overall structure of this chunk. 


2.2.1 Format for methods 2 & 3 


This chunk is a basic data chunk used to hold the delta 
compression data. . The minimum size of this chunk is 32 bytes 
as the first 8 long-words are byte pointers into the chunk for 
the data for each of up to 8 bitplanes. The pointer for the 
plane data starting immediately following these 8 pointers will 
have a value of 32 as the data starts in the 33-rd byte of the 
chunk (index value of 32 due to zero-base indexing). 


The data for a given plane consists of groups of data words. In 
Long Delta mode, these groups consist of both short and long 
words — short words for offsets and numbers, and long words for 
the actual data. In Short Delta mode, the groups are identical 
except data words are also shorts so all data is short words. 
Each group consists of a starting word which is an offset. If 
the offset is positive then it indicates the increment in long 
or short words (whichever is appropriate) through the bitplane. 
In other words, if you were reconstructing the plane, you would 
start a pointer (to shorts or longs depending on the mode) to 
point to the first word of the bitplane. Then the offset would 
be added to it and the following data word would be placed at 
that position. Then the next offset would be added to the 
pointer and the following data word would be placed at that 
position. And so on... The data terminates with an offset 


v6 - 1 











Nov 10 17:18 1988 TP_specs/ANIM Page 6 


equal to OxFFFF. 


A second interpretation is given if the offset is negative. In 
that. case, the absolute value is the offset+2,. Then the 
following short-word indicates the number of data words that 
follow. Following that is the indicated number of contiguous 
data words (longs or shorts depending on mode) which are to 

be placed in contiguous locations of the bitplane. 


If there are no changed words in a given plane, then the pointer 
in the first 32 bytes of the chunk is =0. 


2.2.2 Format for method 4 


The DLTA chunk is modified slightly to have 16 long pointers at 

the start. The first 8 are as before ~ pointers to the start of 
the data for each of the bitplanes (up to a theoretical max of 8 
planes). The next 8 are pointers to the start of the offset/numbers 
data list. If there is only one list of offset/numbers for all 
planes, then the pointer to that list is repeated in all positions 
so the playback code need not even be aware of it. In fact, one 
could get fancy and have some bitplanes share lists while others 
have different lists, or no lists (the problems in these schemes 

lie in the generation, not in the playback). 


The best way to show the use of this format is. in a sample playback 
routine. 


SetDLTAshort (bm,deltaword) 
struct BitMap *bm; 
WORD *deltaword; 
{ 
int i; 
LONG *deltadata; 
WORD *ptr,*planeptr; 
register int s,size,nw; 
register WORD *data,*dest; 


deltadata = (LONG *)deltaword; 
nw = bm->BytesPerRow >>1; 


for (i=0;i<bm->Depth;it+) { 
planeptr = (WORD *)(bm->Planes{i]); 
data = deltaword + deltadata[i]; 
ptr = deltaword + deltadata[i+8] ; 
while (*ptr != OxFFFF) [{ 
dest = planeptr + *ptr++; 
size = *ptrtt+; 
if (size ¢< 0) [{ 
for (s=size;s<0;st+) { 
xdest = *data; 
dest += nw; 


} 
datat+; 


else { 
for (s=0;s<size;st+) [{ 
*dest = *datatt+; 
dest += nw; 


} 


return(0); 


} 


The above routine is for short word vertical compression with 
run length compression. The most efficient way to support 
the various options is to replicate this routine and make 








Nov 10 17:18 1988 TP_specs/ANIM Page 7 


alterations for, say, long word or XOR. The variable nw 
indicates the number of words to skip to go down the vertical 
column. This one routine could easily handle horizontal 
compression by simply setting nw=l. For ultimate playback 
speed, the core, at least, of this routine should be coded in 
assembly language. 


2.2.2 Format for method 5 


In this method the same 16 pointers are used as in option 4. 
The first 8 are pointers to the data for up to 8 planes. 

The second set of 8 are not used but were retained for several 
reasons. First to be somewhat compatible with code for option 
4 (although this has not proven to be of any benefit) and 
second, to allow extending the format for more bitplanes (code 
has been written for up to 12 planes). 


Compression/decompression is performed on a plane-by-plane basis. 
For each plane, compression can be handled by the skip.c code 
(provided Public Domain by Jim Kent) and decompression can be 
handled by unvscomp.asm (also provided Public Domain by Jim Kent). 


Compression/decompression is performed on a plane—by—plane basis. 
The following description of the method is taken directly from 
Jim Kent's code with minor re-wording. Please refer to Jim's 
code (skip.c and unvscomp.asm) for more details: 


Each. column of the bitplane is compressed separately. 

A 320x200 bitplane would have 40 columns of 200 bytes each. 
Each column starts with an op-count followed by. a number 
of ops. If the op-count is zero, that's ok, it just means 
there's no change in this column from the last frame. 

The ops are of three classes, and followed by a varying 
amount of data depending on which class: 

1. Skip ops - this is a byte with the hi bit clear that 
says how many rows to move the “dest" pointer forward, 
ie to skip. It is non-zero. 

2. Unig ops ~ this is a byte with the hi bit set. The hi 
bit is masked down and the remainder is a count of the 
number of bytes of data to copy literally. It's of 
course followed by the data to copy. 

3. Same ops ~ this is a 0 byte followed by a count byte, 
followed by a byte value to repeat count times. 

Do bear in mind that the data is compressed vertically rather 
than horizontally, so to get to the next byte in the destination 
we add the number of bytes per row instead of one! 








G6 -1I 





Nov 10 17:18 1988 TP_specs/HEAD Page 1 


TITLE: HEAD (FORM used by Flow ~ New Horizons Software, Inc.) 


IFF FORM / CHUNK DESCRIPTION 


Form/Chunk ID: FORM HEAD, Chunks NEST, TEXT, FSCC 


Date Submitted: 03/87 
Submitted by: James Bayless — New Horizons Software, Inc. 


FORM 


FORM ID: HEAD 
FORM Description: 


FORM HEAD is the file storage format of the Flow idea processor 
by New Horizons Software, Inc. Currently only the TEXT and NEST 
chunks are used. ‘There are plans to incorporate FSCC and some 
additional chunks for headers and footers. 


CHUNKS 


CHUNK ID: NEST 


This chunk consists of only of a word (two byte) value that gives 
the new current nesting level of the outline. The initial nesting level 
(outermost level) is zero. It is necessary to include a NEST chunk only 
When the nesting level changes. Valid changes to the nesting level are 
either to decrease the current value by any amount (with a minimum of 0) 
or to increase it by one (and not more than one). 


CHUNK ID: TEXT 


This chunk is the actual text of a heading. Each heading has a TEXT 
chunk (even if empty)... The text is not NULL terminated —- the chunk 
size gives the length of the heading text. 


CHUNK ID: FSCC 


This chunk gives the Font/Style/Color changes in the heading from the 
most recent TEXT chunk. It should occur immediately after the TEXT chunk 
it modifies. The format is identical to the FSCC chunk for the IFF 
form type 'WORD' (for compatibility), except that only the 'Location' 
and 'Style' values are used (i.e., there can be currently only be style 
changes in an outline heading). The structure definition is: 


typedef struct { 
UWORD = Location; 7* Char location of change */ 
UBYTE  FontNum; /* Ignored */ 
UBYTE Style; /* Amiga style bits */ 
UBYTE MiscStyle; /* Ignored */ 
UBYTE Color; /* Ignored */ 
UWORD. pad; /* Ignored */ 
} FSCChange; 





The actual chunk consists of an array of these structures, one entry 
for each Style change in the heading text. 








Nov 10 17:18 1988 TP_specs/ILBM.DPPV Page 1 


IFF FORM / CHUNK DESCRIPTION 


Form/Chunk ID: Chunk DPPV (DPaint II ILBM perspective chunk) 
Date Submitted: 12/86 
Submitted by: Dan Silva 


Chunk Description: 
The DPPV chunk describes the perspective state in a DPaintII ILBM. 
Chunk Spec: 


/* The chunk identifier DPPV */ 
#tdefine ID _DPPV MakeID('D','P', 'P','V') 


typedef LONG LongFrac; 
typedef struct ( LongFrac x,y,z; ) LFPoint; 
typedef LongFrac APoint{[3]; 


typedef union [ 
LFPoint 1; 
APoint a; 
} UPoint; 


/* values taken by variable rotType */ 
#define ROT_EULER 0 
#tdefine ROT_INCR 1 


/7* Disk record describing Perspective state */ 


typedef struct { 
WORD rotType; /* rotation type */ 
WORD iA, 1B, iC; /* rotation angles (in degrees) */ 
LongFrac Depth; * perspective depth */ 
WORD uCenter, vCenter; /* coords of center perspective, 
* relative to backing bitmap, 
* in Virtual coords 


WORD fixCoord; /* which coordinate is fixed */ 

WORD angleStep; /* large angle stepping amount */ 
UPoint grid; /* gridding spacing in X,Y,Z */ 
UPoint gridReset; /* where the grid goes on Reset */ 
UPoint gridBrCenter; /7* Brush center when grid was last on, 


* as reference point 
* 
/7* Brush center the last time the mouse 
* button was clicked, a rotation performed, 
* or motion along "fixed" axis 
* 


/* rotation matrix */ 


UPoint permBrCenter; 


LongFrac rot[3] [3]; 
} PerspState; 


SUPPORTING SOFTWARE 





DPaint II by Dan Silva for Electronic Arts 














96 - I 


Nov 10 17:18 1988 TP_specs/PGTB Page 1 


Nov 10 17:18 1988 TP_specs/PGTB Page 2 


Stack ~ dump of stack from current to current + 4k 
FORM PGTB 
In other words, we will dump a maximum of 8k of stack data. This 
Proposal: does NOT mean the stack must be less than 8k in size to dump the 
New IFF chunk type, to be named PGTB, meaning ProGram TraceBack. entire stack, just that the amount of stack USED be less than 8k. 
Format: 'UDAT' — Optional User DATa chunk. If the user assigns 
a function pointer to the label "_ONGURU", the 
'PGTB! - chunk identifier catcher will call this routine prior to closing 
length - longword for length of chunk the SnapShot file, passing one parameter on the 
stack — an AmigaDOS file pointer to the SnapShot 
'PAIL' - subfield giving environment at time of crash file. Spec for the _ONGURU routine: 
length — longword length of subfield . . 
NameLen - length of program name in longwords (BSTR) void <function name> (fp) 
Name ~ program name packed in longwords long fp; 
Environment. - copy of AttnFlags field from ExecBase, . 
gives type of processor, and existence of In other words, your routine must be of type 'void' 
math chip and must take one parameter, an AmigaDOS file 
vBlankFreq - copy of VBlankFrequency field from ExecBase handle (which AmigaDOS wants to see as a LONG). 
PowerSupFreq ~ copy of PowerSupplyFrequency field from ExecBase length ~ length of the UserDATa chunk, calculated after the 
above fields may be used to determine whether user routine terminates. 
machine was PAL or NTSC 
Starter - non-zero = CLI, zero = WorkBench 
GURUNum - exception number. of crash 
SegCount — number of segments for program 
SegList - copy of seglist for program 
(Includes all seglist pointers, paired with 
sizes of the segments) 
‘REGS ' ~— register dump subfield 
length - length of subfield in longwords 
GURUAddr -— PC at time of crash 
Flags — copy of Condition Code Register 
DDump - dump of data registers 
ADump - dump of address registers 
'VERS ' - revision of program which created this file 
length - length of subfield in longwords 
version — main version of writing program 
revision ~ minor revision level of writing program 
TBNameLen — length of name of writing program 
TBName - name of writing program packed in longwords (BSTR) 
'STAK! - stack dump subfield 
length — length of subfield in longwords 
(type) - tells type of stack subfield, which can be any of 
the following: 
Info — value 0 
StackTop ~ address of top of stack 
StackPtr - stack pointer at time of crash 
StackLen ~ number of longwords on stack 
Whole stack —- value l 


only used if total stack to be dumped is 8k 
or less in size 
Stack ~ dump of stack from current to top 


Top 4k — value 2 
if stack used larger than 8k, this part 
is a dump of the top 4k 

Stack — dump of stack from top ~ 4k to top 


Bottom 4k ~ value 3 
if stack used larger than 8k, this part 
is.a dump of the bottom 4k 


46-1 








Nov 10 17:18 1988 TP_specs/WORD Page 1 


TITLE: WORD (word processing FORM used by ProWrite) 


IFF FORM / CHUNK DESCRIPTION 


Form/Chunk IDs: 
FORM WORD 
Chunks FONT, COLR , DOC ,HEAD, FOOT, PCTS , PARA, TABS , PAGE, TEXT , FSCC,, PINF 


Date Submitted: 03/87 
Submitted by: James Bayless - New Horizons Software, Inc. 


FORM ID: WORD 
FORM Purpose: Document storage (supports color, fonts, pictures) 
FORM Description: 


This include file describes FORM WORD and its Chunks 


/* 
* IFF Form WORD structures and defines 
* Copyright (c) 1987 New Horizons Software, Inc. 
* 
* Permission is hereby granted to use this file in any and all 
* applications. Modifying the structures or defines included 
* in this file is not permitted without written consent of 
* New Horizons Software, Inc. 
*/ 


#include ":IFF/ILBM.h" /* Makes use of ILBM defines */ 


#define ID_WORD MakeID('W','O','R','D') /* Form type */ 


#define ID_FONT /* Chunks */ 
#define ID_COLR 
#define ID_Doc 

#tdefine ID_HEAD 
#define ID_FOOT 
#define ID PCTS 
#define ID_PARA 
#define ID_TABS 
#define ID_PAGE 
#define ID_TEXT 
#tdefine ID_FSCC 
#define ID_PINF 


/* 


* Special text characters for page number, date, and time 


MakeID('F','O','N','T') 
MakeID('C','O', 'L','R'} 
MakeID('D','0','C',' '} 
MakeID('H','E','A','D') 
MakeID('F','0",'0', 'T') 
MakeID('P','C','T','S!') 
MakeID('P','A','R',‘A') 
MakeID('T','A','B','S') 
MakeID('P','A','G!,'E') 
MakeID('T','E','X','T') 
MakeID('F','S','C','C!) 
MakeID('P','I','N','F') 


* Note: ProWrite currently supports only PAGENUM_CHAR, and only in 
* headers and footers 

*/ 

#define PAGENUM_CHAR 0x80 

#define DATE_CHAR 0x81 

#define TIME_CHAR 0x82 


* 
* Chunk structures follow 
*/ 
/* 
* FONT ~ Font name/number table 


x There are one of these for each font/size combination 
* These chunks should appear at the top of the file (before document data) 


Nov 10 17:18 1988 TP_specs/WORD Page 2 


*/ 
typedef struct [{ 
UBYTE Num; f/* 0... 255 */ 
UWORD Size; 
/* UBYTE Name [] ; xf /7* NULL terminated, without ".font" */ 
} FontID; 
/* 


* COLR — Color translation table 

* Translates from color numbers used in file to ISO color numbers 

* Should be at top of file (before document data) 

* Note: Currently ProWrite only checks these values to be its current map, 
* it does no translation as it does for FONT chunks 


typedef struct [ 
UBYTE Isocolors [8]; 
} Isocolors; 


/* 
*  poc ~ Begin document section 
* All text and paragraph formatting following this chunk and up to a 
* HEAD, FOOT, or PICT chunk belong to the document section 


*/ 


#define PAGESTYLE_1 
#tdefine PAGESTYLE I 
#define PAGESTYLE_i 
#define PAGESTYLE_A 
#define PAGESTYLE_a 


/* 1, 2, 3 */ 
7* T, I, IIL */ 
i, ii, iii */ 
/* A, B, C */ 
/* a, b, c */ 


Pm WNE © 
~ 
* 


typedef struct [ 


UWORD StartPage; 7* Starting page number */ 
UBYTE  PageNumStyle; 7* From defines above */ 
UBYTE padl; 
LONG pad2; 

} DocHdr; 


* HEAD/FOOT - Begin header/footer section 

* All text and paragraph formatting following this chunk and up to a 

*  p~oC, HEAD, FOOT, or PICT chunk belong to this header/footer 

* Note: This format supports multiple headers and footers, but currently 
* ProWrite only allows a single header and footer per document 


define PAGES_NONE 0 
#define PAGES LEFT 1 
#define PAGES RIGHT 2 
#define PAGES _BOTH 3 


typedef struct { 


UBYTE PageType; /* From defines above */ 
UBYTE FirstPage; 7/* 0 = Not on first page */ 
LONG pad; 

} HeadHdr; 


* 
* pcTs — Begin picture section 


x Note: ProWrite currently requires NPlanes to be three (3) 
*/ 
typedef struct { 
UBYTE NPlanes; /* Number of planes used in picture bitmaps */ 
UBYTE pad; 
} PiectHdr; 
Jt 


86-1 








Nov 10 17:18 1988 TP_specs/WORD Page 3 


* PARA — New paragraph format 
x his chunk should be inserted first when a new section is started (DOC, 
* HEAD, or FOOT), and again whenever the paragraph format changes 


*/ 


#define SPACE_SINGLE 0 
#define SPACE_DOUBLE 0x10 


#define JUSTIFY _LEFT 0 
#define JUSTIFY_CENTER 1 
#define JUSTIFY RIGHT 2 
#define JUSTIFY FULL 3 


#define MISCSTYLE_NONE 0 
#define MISCSTYLE_SUPER 1 
#define MISCSTYLE_SUB 2 


/* Superscript */ 
/* Subscript .*/ 


typedef struct [ 
UWORD 


LeftIndent ; /* In decipoints (720 dpi) */ 
UWORD LeftMargin; 
UWORD RightMargin; 
UBYTE Spacing; /* From defines above */ 
UBYTE Justify; /* From defines above */ 
UBYTE FontNum; /* FontNum, Style, etc. for first char in para*/ 
UBYTE Style; /* Standard Amiga style bits */ 
UBYTE MiscStyle; /* From defines above */ 
UBYTE Color; /* Internal number, use COLR to translate */ 
LONG pad; 
} ParaFormat; 


* TABS - New tab stop types/locations 

* Use an array of values in each chunk 

* like the PARA chunk, this should be inserted whenever the tab settings 
* for a paragraph change 

* Note: ProWrite currently does not support TAB_CENTER 


#define TAB_LEFT 
#define TAB_CENTER 
#define. TAB_RIGHT 
#define TAB_DECIMAL 


WR O 


typedef struct [{ 
UWORD Position; 
UBYTE Type; 
UBYTE pad; 

} TabStop; 


/* In decipoints */ 


* PAGE - Page break 
* Just a marker ~- this chunk has no data 


x TEXT — Paragraph text (one block per paragraph) 

* Block is actual text, no need for separate structure 

* If the paragraph is empty, this is an empty. chunk —~ there MUST be 

* a TEXT block for every paragraph 

* Note: The only ctrl characters ProWrite can currently handle in TEXT 
* chunks are Tab and PAGENUM_CHAR, ie no Return's, etc. 


x FSCC — Font/Style/Color changes in previous TEXT block 

* Use an array of values in each chunk 

* Only include this chunk if the previous TEXT block did not have 
x the same Font/Style/Color for all its characters 











Nov 10 17:18 1988 TP_specs/WORD Page 4 


typedef struct [{ 


UWORD. Location; /* Character location in TEXT chunk of change x/ 
UBYTE FontNum; 
UBYTE Style; 
UBYTE MiscStyle; 
UBYTE Color; 
UWORD pad; 
} FSCChange; 
/* 
x  PINF — Picture info 
* This chunk must only be in a PCTS section 
* Must be followed by ILBM BODY chunk 
* Pictures are treated independently of the document text (like a 
* page-layout. system), this chunk includes information about what 
* page and location on the page the picture is at 
* Note: ProWrite currently only supports mskTransparentColor and 
* mskHasMask masking 
*/ 


typedef struct { 


UWORD Width, Height; /* In pixels */ 
UWORD Page; /* Which page picture is on (0..max) */ 
UWORD XPos, YPos; /* Location on page in decipoints */ 
Masking Masking; /* Like ILBM format */ 
Compression Compression; /* Like ILBM format */ 
UBYTE TransparentColor; /* Like ILBM format */ 
UBYTE pad; 
} PictInfo; 
/* end */ 








EA IFF Source Code Listings 


This section contains source code listings of the EA IFF include files, reader and writer 
modules, and the IFF examples provided by EA. 


Nov 10 17:19 1988 Nov 10 17:19 1988 IFF_include/8svx.h Page 2 





IFF_include/8svx.h Page 1 








[*--—--— an ee — ee nnn * 


<= } EGPoint; 
* 8SVX.H Definitions for 8-bit sampled voice (VOX). 2/10/86 






/7* ATAK and RLSE chunks contain an EGPoint[], piecewise-linear envelope. */ 





By Jerry Morrison and Steve Hayes, Electronic Arts. 


This software is in the public domain. /* The envelope defines a function of time returning Fixed values. 


* It's used to scale the nominal volume specified in the VoiceSHeader. 
*/ 
8 BODY nn ty 


/* BODY chunk contains a BYTE[], array of audio data samples. */ 
/* (8-bit signed numbers, -128 through 127.) */ 





This version for the Commodore-Amiga computer. 
#ifndef EIGHTSVX_H 
ine EIGHTSVX_H 





———— nrc 

















COMPILER_H 
#include "iff/compiler.h" 
#endif 






[Roe 8SVX Reader Support Routines —-~------~---~------———------= */ 





/* Just call this macro to read a VHDR chunk. */ 
#define GetVHDR(context, vHdr) 
IFFReadBytes(context, (BYTE *)vHdr, sizeof (Voice8Header) ) 






#include "iff/iff.h" 









ID_85VX MakeID('8', 'S', 
#define ID_VHDR MakeID('V', 'H', 'D', 'R') 
tdefine ID_NAME MakeID('N', 'A', 'M', 'B') 
#define ID_Copyright MakeID('(', 'e', ')', ' ') 






Rs 8SVX Writer Support Routines -----—------------—----~~----- */ 























/7* Just call this macro to write a VHDR chunk. */ 
#define PutVHDR(context, vHdr) 
PutCk(context, ID_VHDR, sizeof(Voice8Header), (BYTE *)vHdr) 


ID_AUTH 
#define ID_ANNO 


MakeID('A', 
MakeID('A', 


‘uy! , 
tn? , 


im 
'Nt, 










ID_BODY MakeID('B', 'O', 'D', 





#tendif 











#define ID_ATAK MakeID('A', 'T', 'A', 'K') 
#define ID_RLSE MakeID('R', 















ne Voice8Header —~—-— rr rf 
typedef LONG Fixed; /* A fixed-point value, 16 bits to the left of 

* the point and 16 to the right. A Fixed is a 

* number of 2**l6ths, i.e. 65536ths. */ 
#define Unity 0xl0000L /* Unity = Fixed 1.0 = maximum volume */ 









TOT - I 





/* sCompression: Choice of compression algorithm applied to the samples. */ 

#define sCmpNone 0 * not compressed */ 

#define sCmpFibDelta 1 /* Fibonacci-delta encoding (Appendix C) */ 
/* Could be more kinds in the future. */ 











typedef struct [{ 










ULONG oneShotHiSamples, /* # samples in the high octave 1l-shot part */ 
repeatHiSamples, /* # samples in the high octave repeat part */ 
samplesPerHiCycle; /7* # samples/cycie in high octave, else 0 */ 

UWORD samplesPerSec; /* Gata sampling rate */ 

UBYTE ctOctave, /* # of octaves of waveforms */ 
sCompression ; /* data compression technique used */ 

Fixed volume; /* playback nominal volume from 0 to Unity 






* (full volume). Map this value into 
* the output hardware's dynamic range. 







} Voice8Header; 












Sorrceres NAME wenn --- Su EEneemtee A 
NAME chunk contains a CHAR[], the voice's name. */ 






Som COPY LAG NG or 
"(c) “ chunk contains a CHAR[], the FORM's copyright notice. */ 







NUT rr */ 
AUTH chunk contains a CHAR[], the author's name. */ 






ANNO 
ANNO chunk contains a CHAR[], the author's text annotations. */ 









fi aol Envelope ATAK & RLSE ----------------~--—------—---------—— */ 
typedef struct [ 

UWORD duration; /* segment duration in milliseconds, > 0 */ 

Fixed dest; /* destination volume factor */ 










cot — I 








Nov 10 17:19 1988 IFF_include/compiler.h Page 1 


#ifndef COMPILER_H 

#define COMPILER_H 

[eRe compiler .h FOO OO IOI IIR IOI IOI RII IO TA TAIT RIA II IO IAAI AAI IIR / 

/* Steve Shaw 1/29/86 */ 

/* Portability file to handle compiler idiosyncrasies. * 

Mn Version: Lattice 3.03 cross-compiler for the Amiga from the IBM PC. */ 
* */ 


/* This software is in the public domain. «/ 
* 


FOE III III I IIIT ITO TOTTI I TI RI TOIOIO ICT TT IA II AAA IAI AIA IIA III AAAI III IOI. 


#ifndef EXEC_TYPES _H 
#include "exec/types.h" 
#endif 


7* NOTE —- NOTE -—- NOTE — NOTE ~— NOTE 
* Some C compilers can handle Function Declarations with Argument Types 
* (FDWAT) like this: 
* extern LONG Seek(BPTR, LONG, LONG) 
* while others choke unless you just say 
* extern LONG Seek() 
*x 
* 


Comment out the #define FDwAT if you have a compiler that chokes. */ 


/* #define FDwAT COMMENTED OUT BECAUSE GREENHILLS CANT TAKE IT */ 


#endif COMPILER_H 











Nov 10 17:19 1988 IFF_include/gio.h Page 1 


#ifndef GIO_H 
#define GIO_H 
7* GIO.H defs for Generic I/O Speed Up Package. 


1/23/86 */ 
/* See GIOCall.c for an example of usage. */ 


/7* Read not speeded-up yet. Only one Write file buffered at a time. */ 
/* */ 
/* Note: The speed-up provided is ONLY significant for code such as IFF */ 
/* which does numerous small Writes and Seeks. */ 
ye */ 


/* WARNING: If gio reports an error to you and you care what specific */ 
/7* Dos error was, you must call JoErr() BEFORE calling any other gio */ 





7* functions. x/ 
7 */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
7* This software is in the public domain. */ 
y* */ 
/* This version for the Commodore-Amiga computer. */ 
yx */ 
a ee a A a */ 


/* Use this file interface in place of ALL Open ,Close,Read,Write,Seek DOS 
calls for an optional i/o speed-up via buffering. You must use ONLY 
these G routines for a file that is being buffered; e.g., call GClose 
to Close the file, etc. 

It is harmless though not necessary to use G routines for a file that 
is not being buffered; e.g., GClose and Close are equivalent in that 
case. 

This Version only buffers one file at_a time, and only for writing. 
If you call GWriteDeclare for a second file before the first file 

is GClosed, the first file becomes unbuffered. This is harmless, no 
data is lost, the first file is simply no longer speeded-up. 


a 


*/ 


Before compiling any modules that make G calls, or compiling gio.c, 
you must set the GIO_ACTIVE flag below. 


~ 
* 


To omit the speed-up code, 
#define GIO_ACTIVE 0 


‘o make the speed-up happen: 

#define GIO_ACTIVE 1 

link gio.o into your progrm 

GWriteDeclare(file, buffer, size) 

after GOpening the file and before doing 

any writing. 

. ONLY use GRead, GWrite, GSeek, GClose -~- do not use the DOS i/o 
routines directly. 

5. When done, do GClose. Or to stop buffering without closing the 

file, do GWriteUndeclare( file). 


WN a 


= 


4 eH OE HH HH HH OK 


* 
#define GIO_ACTIVE 0 


#ifndef COMPILER_H 
#include "iff/compiler.h" 
#endif 


#ifndef LIBRARIES_DOS_H 
#include "Libraries/dos.h" 
#tendif 


#ifndef OFFSET_BEGINNING 
#tdefine OFFSET BEGINNING OFFSET_BEGINING 
tendif 


#if GIO_ACTIVE 


#ifdef FDwAT /* Compiler handles Function Declaration with Argument Types */ 





Nov 10 17:19 1988 IPFF_include/gio.h Page 2 


Present for completeness in the interface. 

“openmode"' is either MODE_OLDFILE to read/write an existing file, or 

MODE_NEWFILE to write a new file. 

RETURNS a "file" pointer to a system-supplied structure that describes 

the open file. This pointer is passed in to the other routines below.*/ 
extern BPTR GOpen(char * /*filename*/, LONG /*openmode*/) ; 





7* NOTE: Flushes & Frees the write buffer. 
* Returns -1 on error from Write.*/ 
extern LONG GClose(BPTR /*file*/) ; 


/* Read not speeded-up yet. 
* GOpen the file, then do GReads to get successive chunks of data in 
* the file. Assumes the system can handle any number of bytes in each 
* call, regardless of any block~structure of the device being read from. 
* When done, GClose to free any system resources associated with an 
* open file.*/ 

extern LONG GRead(BPTR /*file*/, BYTE * /*buffer*/, LONG /*nBytes*/) ; 


/7* Writes out any data in write buffer for file. 
* NOTE WHEN have Seeked into middle of buffer: 
* GWriteFlush causes current position to be the end of the data written. 
* —l1 on error from Write.*/ 

extern LONG GWriteFlush(BPTR /*file*/); 


7* Sets up variables to describe a write buffer for the file.*/ 
/* If the buffer already has data in it from an outstanding GWriteDeclare, 
* then that buffer must first be flushed. 
* RETURN —l1 on error from Write for that previous buffer flush. 
* See also "GWriteUndeclare".*/ 
extern LONG GWriteDeclare(BPTR /*file*/, BYTE * /*buffer*/, LONG /*nBytes*/) ; 


/7* ANY PROGRAM WHICH USES "GWrite" MUST USE "GSeek" rather than "Seek" 
* TO SEEK ON A FILE BEING WRITTEN WITH "GWrite". 
* "Write" with Generic speed-up. 
* ~l1 on error from Write. else returns # bytes written to disk. 
* Call GOpen, then do successive GWrites with GSeeks if required, 
* then GClose when done. (IFF does require GSeek.)*/ 
extern LONG GWrite(BPTR /*file*/, BYTE * /*buffer*/, LONG /*nBytes*/); 


cot - 1 


/* "Seek" with Generic speed-up, for a file being written with GWrite.*/ 

/* Returns what Seek returns, which appears to be the position BEFORE 

seeking, though the documentation says it returns the NEW position. 

In fact, the code now explicitly returns the OLD position when 

seeking within the buffer. 

Eventually, will support two independent files, one being read, the 

other being written. Or could support even more. Designed so is safe 
* to call even for files which aren't being buffered.*/ 

extern LONG GSeek(BPTR /*file*/, LONG /*position*/, LONG /*mode*/) ; 


+ 4 eH OH 


#else /*not FDwAT*/ 


extern BPTR GOpen(); 

extern LONG GClose(); 
extern LONG GRead(); 

extern LONG GWriteFlush(); 
extern LONG GWriteDeclare(); 
extern LONG GWrite(); 
extern LONG GSeek(); 


#endif FDwAT 

#else /* not GIO_ACTIVE */ 
#define GOpen( filename, openmode) Open(filename, openmode) 
#define GClose(file) Close( file) 

#define GRead(file, buffer, nBytes) Read(file, buffer, nBytes) 


#define GWriteFlush( file) (0) 
#define GWriteDeclare(file, buffer, nBytes) (0) 








Nov 10 17:19 1988 IFF_include/gio.h Page 3 


#tdefine GWrite(file, buffer, nBytes) 
#tdefine GSeek(file, position, mode) 


Write(file, buffer, nBytes) 
Seek(file, position, mode) 


#endif GIO_ACTIVE 





/* Release the buffer for that file, flushing it to disk if it has any 
* contents. GWriteUndeclare(NULL) to release ALL buffers. 
* Currently, only one file can be buffered at a time anyway.*/ 
#define GWriteUndeclare(file) GWriteDeclare(file, NULL, 0) 


#endif 
















































Nov 10 17:19 1988 IFF_include/iff.h Page 1 


#ifndef IFF_H 
#define IFF_H 
J 
/* IFF.H defs for IFF-85 Interchange Format Files. 1/22/86 */ 
x/ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. *f 
/7* This software is in the public domain. */ 


[OR xf 


#ifndef COMPILER_H 
#include “iff/compiler.h" 
#endif 


#ifndef LIBRARIES DOS_H 
#include "libraries/dos.h" 
#tendif 


#ifndef OFFSET_BEGINNING 
#tdefine OFFSET BEGINNING OFFSET BEGINING 
#endif 


typedef LONG IFFP; /* Status code result from an IFF procedure */ 
/* LONG, because must be type compatable with ID for GetChunkHdr.*/ 
7* Note that the error codes below are not legal IDs.*/ 
#define IFF_OKAY OL /* Keep going...*/ 
#define END MARK -lL /* As if there was a chunk at end of group. */ 
#define IFF_DONRE -2L /* clientProc returns this when it has READ enough. 
* It means return thru all levels. File is Okay.*/ 
#tdefine DOS_ERROR —3L 
#define NOTLIFF -4L /* not an IFF file.*/ 
#define NO FILE -5L /* Tried to open file, DoS didn't find it.*/ 
¥define CLIENT _BRROR -6L /* Client made invalid request, for instance, write 
* a negative size chunk. */ 
#define BAD FORM -7L /* A client read proc complains about FORM semantics; 
* e.g. valid IFF, but missing a required chunk.*/ 
#define SHORT CHUNK ~8L /* Client asked to IFFReadBytes more bytes than left 
* in the chunk. Could be client bug or bad form.*/ 
#define BAD_IFF -9L /* mal-formed IFF file. [TBD] Expand this into a 
* range of error codes.*/ 
#define LAST_ERROR BAD_IFF 


yor. - I 


/* This MACRO is used to RETURN immediately when a termination condition is 
* found. This is a pretty weird macro. It requires the caller to declare a 
* local "IFFP iffp" and assign it. This wouldn't work as a subroutine since 
* it returns for it's caller. */ 

#define CheckIFFP() { if (iffp != IFF_OKAY) return(iffp); } 





typedef LONG ID; /* An ID is four printable ASCII chars but 


* stored as a LONG for efficient copy & compare.*/ 


/* Four-character IDentifier builder.*/ 
#define MakeID(a,b,c,d) ( (LONG)(a)<¢24L | (LONG)(b)<<16L | (c)<<B | (d) ) 


/* Standard group IDs. A chunk with one of these IDs contains a 
SubTypeID followed by zero or more chunks.*/ 

#define FORM MakeID('F','0O','R','M') 

#define PROP MakeID('P','R',‘'O','P') 

#define LIST MakeID('L','I','S','T') 

#define CAT MakeID('c','A','T',' ') 

#define FILLER MakeID(' ',' ',' ',' ') 

/* The IDs "FORL". "FORO", "LISL'. ."LIS9", & "CATL".."CAT9" are reserved 

* for future standardization. */ 





/* Pseudo-ID used internally by chunk reader and writer.*/ 
#define NULL_CHUNK OL /* No current chunk. */ 


“Nov 10 17:19 1988 IFF_include/iff.h Page 2 


/* All chunks start with a type ID and a count of the data bytes that 
follow--the chunk's “logicl size" or "data size". If that number is odd, 
a 0 pad byte is written, too. */ 
typedef struct [ 
ID ckID; 
LONG ckSize; 
} ChunkHeader; 


typedef struct [ 
ID ckID; 
LONG ckSize; 
UBYTE ckData[ 1 /*REALLY: ckSize*/ J]; 
} Chunk; 


/* Pass ckSize = szNotYetKnown to the writer to mean “compute the size". */ 
#define szNotYetKnown 0x80000001L 


/* Need to know whether a value is odd so can word-align.*/ 
#define IS_ODD(a) ((a) & 1) 


/* This macro rounds up to an even number. */ 
#define WordAlign(size) ((sizet1l)&™1) 


/* ALL CHUNKS MUST BE PADDED TO EVEN NUMBER OF BYTES. 
* ChunkPSize computes the total "physical size" of a padded chunk from 
* its "data size" or "logical size". */ 

#define ChunkPSize(dataSize) (WordAlign(dataSize) + sizeof (ChunkHeader) ) 


/* The Grouping chunks (LIST, FORM, PROP, & CAT) contain concatenations of 
* chunks after a subtype ID that identifies the content chunks. 
* "FORM type XXXX", “LIST of FORM type XXXX", "PROPerties associated 
* with FORM type XXXX", or “concATenation of XXXX".*/ 
typedef struct [{ 
ID ckID; 





LONG ckSize; /* this ckSize includes "grpSubID".*/ 
ID gxrpSubID; 


}. GroupHeader ; 


typedef struct [ 
ID ckID; 
LONG ckSize; 
ID grpSubID; 
UBYTE grpData[ 1 /*REALLY: ckSize-sizeof(grpSubID)*/ ]; 
} GroupChunk ; 


fe kf 


/* ———-----—- IFF Reader —--—-----——— > 
/kxexeeke Routines to support a stream-oriented IFF file reader ******* 
* 


These routines handle lots of details like error checking and skipping 
over padding. They're also careful not to read past any containing context. 


These routines ASSUME they're the only ones reading from the file. 
Client should check IFFP error codes. Don't press on after an error! 
These routines try to have no side effects in the error case, except 
partial I/O is sometimes unavoidable. 


All of these routines may return DOS_FRROR. In that case, ask DOS for the 
specific error code. 


The overall scheme for the low level chunk reader is to open a "group read 
context" with OpenRIFF or OpenRGroup, read the chunks with GetChunkHdr 
(and its kin) and IFFReadBytes, and close the context with CloseRGroup. 


4 4 FH HH HH OE OH OE 


The overall scheme for reading an IFF file is to use ReadIFF, ReadIList, 





SOT - I 























Nov 10 17:19 1988 IFF_include/iff.h Page 3 


* and ReadICat to scan the file. See those procedures, ClientProc (below), 
* and the skeleton IFF reader. */ 


/7* Client passes ptrs to procedures of this type to ReadIFF which call them 
back to handle LISTs, FORMs, CATs, and PROPs. 


* 
* 
* Use the GroupContext ptr when calling reader routines like GetChunkHdr. 
* Look inside the GroupContext ptr for your ClientFrame ptr. You'll 
* want to type cast it into a ptr to your containing struct to get your 
* private contextual data (stacked property settings). See below. */ 
#ifdef FDwAT 
typedef IFFP ClientProc(struct _GroupContext *); 
#else 
typedef IFFP ClientProc(); 
#endif 


/* Client's context for reading an IFF file or a group. 
Client should actually make this the first component of a larger struct 
{it's personal stack "frame") that has a field to store each "interesting" 
property encountered. 
Either initialize each such field to a global default or keep a boolean 
indicating if you've read a property chunk into that field. 
Your getList and getForm procs should allocate a new "frame" and copy the 
parent frame's contents. The getProp procedure should store into the frame 

* allocated by getList for the containing LIST. */ 
typedef struct _ClientFrame { 

ClientProc *getList, *getProp, *getForm, *getCat; 
/* client's own data follows; place to stack property settings */ 
} ClientFrame; 


+ + HF HF HH HH 


/* Our context for reading a group chunk. */ 

typedef struct _GroupContext [ 
struct. GroupContext *parent; /* Containing group; NULL => whole file. */ 
ClientFrame *clientFrame; /7* Reader data & client's context state. */ 


BPTR file; /* Byte-stream file handle. */ 
LONG position; /* The context's logical file position. */ 
LONG bound; /7* File-absolute context bound 

* or szNotYetKnown (writer only). */ 


ChunkHeader ckHdr; /* Current chunk header. ckHdr.ckSize = szNotYetKnown 


* means we need to go back and set the size (writer only). 


* See also Pseudo-IDs, above. */ 
ID subtype; /7* Group's subtype ID when reading. */ 
LONG bytesSoFar; /* # bytes read/written of current chunk's data. */ 
} GroupContext ; 


/* Computes the number of bytes not yet read from the current chunk, given 
* a group read context ge. * 
#define ChunkMoreBytes(gc) ((gc)—>ckHdr.ckSize — (gc)—>bytesSoFar) 


/x*x** Low Level IFF Chunk Reader *****/ 
#ifdef FDwAT 


/* Given an open file, open a read context spanning the whole file. 
This is normally only called by ReadIFF. 
This sets new->clientFrame = clientFrame. 
ASSUME context allocated by caller but not initialized. 
ASSUME caller doesn't deallocate the context before calling CloseRGroup. 
* NOT_IFF ERROR if the file is too short for even a chunk header.*/ 
extern IFFP OpenRIFF(BPTR, GroupContext *, ClientFrame *); 
/* file, new, clientFrame */ 


* 
* 
* 
* 


/* Open the remainder of the current chunk as a group read context. 

This will be called just after the group's subtype ID has been read 
(automatically by GetChunkHdr for LIST, FORM, PROP, and CAT) so the 
remainder is a sequence of chunks. 

This sets new->clientFrame = parent—>clientFrame. The caller should repoint 
it at_a new clientFrame if opening a LIST context so it'll have a "stack 


e+ + * HF 


Nov 10 17:19 1988 IFF_include/iff.h Page 4 


frame" to store PROPs for the LIST. (It's usually convenient to also 
allocate a new Frame when you encounter FORM of the right type.) 


ASSUME new context allocated by caller but not initialized. 

ASSUME caller doesn't deallocate the context or access the parent context 
before calling CloseRGroup. 

BAD_IFF ERROR if context end is odd or extends past parent. */ 

extern IFFP OpenRGroup(GroupContext *, GroupContext *); 

/* parent, new */ 


+ + + He 


/7* Close a group read context, updating its parent context. 
* After calling this, the old context may be deallocated and the parent 
* context can be accessed again. It's okay to call this particular procedure 
* after an error has occurred reading the group. 
* This always returns IFF_OKAY. */ 
extern IFFP CloseRGroup(GroupContext *); 
/* old */ 


Skip any remaining bytes of the previous chunk and any padding, then 
read the next chunk header into context.ckHdr. 

If the ckID is LIST, FORM, CAT, or PROP, this automatically reads the 
subtype ID into context—>subtype. 

Caller should dispatch on ckID (and subtype) to an appropriate handler. 


~~ 
* 


RETURNS context.ckHdr.ckID (the ID of the new chunk header); END MARK 

if there are no more chunks in this context; or NOT_IFF if the top level 
file chunk isn't a FORM, LIST, or CAT; or BAD_IFF if malformed chunk, e.g. 
ckSize is negative or too big for containing context, ckID isn't positive, 
or we hit end-of-file. 


4 FF HO He Oe 


* See also GetFChunkHdr, GetFlChunkHdr, and GetPChunkHdr, below.*/ 
extern ID GetChunkHdr(GroupContext *); 
/* context.ckHdr.ckID context */ 


/* Read nBytes number of data bytes of current chunk. (Use OpenGroup, etc. 
instead to read the contents of a group chunk.) You can call this several 
times to read the data piecemeal. 
CLIENT _ERROR if nBytes < 0. SHORT_CHUNK if nBytes > ChunkMoreBytes(context) 
which could be due to a client bug or a chunk that's shorter than it 
ought to be (bad form). (on either CLIENT_ERROR- or SHORT_CHUNK, 

* IFFReadBytes won't read any bytes.) */ 
extern IFFP IFFReadBytes(GroupContext *, BYTE *, LONG); 

/* context, buffer, nBytes */ 


+t +t ee OE 


/*xeee TPF Pile Reader *****/ 


/* This is a noop ClientProc that you can use for a getList, getForm, getProp, 
* or getCat procedure that just skips the group. A simple reader might just 
x implement getForm, store ReadICat in the getCat field of clientFrame, and 
* use SkipGroup for the getList and getProp procs.*/ 

extern IFFP SkipGroup(GroupContext *); 


IFF file reader. 

Given an open file, allocate a group context and use it to read the FORM, 
LIST, or CAT and it's contents. The idea is to parse the file's contents, 
and for each FORM, LIST, CAT, or PROP encountered, call the getForm, 
getList, getCat, or getProp procedure in clientFrame, passing the 
GroupContext ptr. 

This is achieved with the aid of ReadIList (which your getList should 
call) and ReadICat (which your getCat should call, if you don't just use 
ReadICat for your getCat). If you want to handle FORMs, LISTs, and CATs 
nested within FORMs, the getForm procedure must dispatch to getFomn, 
getList, and getCat (it can use GetFlChunkHdr to make this easy). 


~~ 
* 


Normal return is IFF_OKAY (if whole file scanned) or IFF_DONE (if a client 
proc said "done" first). 

* See the skeletal getList, getForm, getCat, and getProp procedures. */ 
extern IFFP ReadIFF(BPTR, ClientFrame *); 


+ £ 4 t 4 4 HH HH 4 HH 














90T - I 


Nov 10 17:19 1988 IFF_include/iff.h Page 5 


/* file, clientFrame */ 


/* IFF LIST reader. 
Your “getList" procedure should allocate a ClientFrame, copy the parent's 
ClientFrame, and then call this procedure to do all the work. 


Normal return is IFF_OKAY (if whole LIST scanned) or IFF_DONE (if a client 
proc said “done" first). 
* BAD_IFF ERROR if a PROP appears after a non-PROP. */ 
extern IFFP ReadIList(GroupContext *, ClientFrame *); 
/*® parent, clientFrame */ 


+ + 4 


/* IFF CAT reader. 

Most. clients can simply use this to read their CATs. If you must do extra 
setup work, put a ptr to your getCat procedure in the clientFrame, and 
have that procedure call ReadICat to do the detail work. 


Normal return is IFF_OKAY (if whole CAT scanned) or IFF_DONE (if a client 
proc said "done" first). 
* BAD IFF ERROR if a PROP appears in the CAT. */ 
extern IFPFP ReadICat(GroupContext *); 
/* parent */ 


4 + + eH OF 


/* Call GetFChunkHdr instead of GetChunkHdr to read each chunk inside a FORM. 
* It just calls GetChunkHdr and returns. BAD_IFF if it gets a PROP chunk. x/ 
extern ID GetFChunkHdr (GroupContext *); 
/* context.ckHdr.ckID context */ 


/* GetFlChunkHdr is like GetFChunkHdr, but it automatically dispatches to the 
* getForm, getList, and getCat procedure (and returns the result) if it 
* encounters a FORM, LIST, or CAT. */ 

extern ID GetF1lChunkHdr(GroupContext *); 


/* context.ckHdr.ckID context */ 
/* Call GetPChunkHdr instead of GetChunkHdr to read each chunk inside a PROP. 
* It just calls GetChunkHdr and returns BAD_IFF if it gets a group chunk. */ 
extern ID GetPChunkHdr(GroupContext *); : 


/* context.ckHdr.ckID context */ 


#else /* not FDwAT */ 


extern IFFP OpenRIFF(); 
extern IFFP OpenRGroup(); 
extern IFFP CloseRGroup() 
extern ID GetChunkHdr() 
extern IFFP IFFReadBytes( 
extern IFFP SkipGroup(); 
extern IFFP ReadIFF(); 
extern IFFP ReadIList(); 
extern IFFP ReadICat(); 


i 
i 
i 


extern ID GetFChunkHdr() ; 
extern ID GetFiChunkHdr(); 
extern ID  GetPChunkHdr(); 


#endif /* not FDwAT */ 
[8 IEF Writer —--—e nna */ 


/****kk* Routines to support a stream-oriented IFF file writer ******* 

* 
These routines will random access back to set a chunk size value when the 
caller doesn't know it ahead of time. They'll also do things automatically 
like padding and error checking. 


These routines ASSUME they're the only ones writing to the file. 

Client should check IFFP error codes. Don't press on after an error! 
These routines try to have no side effects in the error case, except that 
partial I/O is sometimes unavoidable. 


* 4% 4 Ht HH OF 


Nov 10 17:19 1988 IFF_include/iff.h Page 6 


All of these routines may return DOS_ERROR. In that case, ask DOS for the 
specific error code. 


The overall scheme is to open an output GroupContext via OpenWIFF or 
OpenWGroup, call either PutCk or {PutCkHdr {IFFWriteBytes}* PutCkEnd} for 
each chunk, then use CloseWGroup to close the GroupContext. 


To write a group (LIST, FORM, PROP, or CAT), call StartWcroup, write out 
its chunks, then call EndWGroup. StartWGroup automatically writes the 
group header and opens a nested context for writing the contents. 
EndWGroup closes the nested context and completes the group chunk. */ 


+H He HH HE 


#ifdef FDwAT 


/* Given a file open for output, open a write context. 
The "limit" arg imposes a fence or upper limit on the logical file 
position for writing data in this context. Pass in szNotYetKnown to be 
bounded only by disk capacity. 
ASSUME new context structure allocated by caller but not initialized. 
ASSUME caller doesn't deallocate the context before calling CloseWGroup. 
The caller is only allowed to write out one FORM, LIST, or CAT in this top 
level context (see StartWGroup and PutCkHdr). 
* CLIENT ERROR if limit is odd.*/ 

extern IFFP OpenWIFF(BPTR, GroupContext *, LONG); 

: /* file, new, limit {file position} */ 


+ + HH HO 


Start writing a group (presumably LIST, FORM, PROP, or CAT), opening a 
nested context. The groupSize includes all nested chunks + the subtype ID. 


~~ 
* 


The subtype of a LIST or CAT is a hint at the contents' FORM type(s). Pass 
in FILLER if it's a mixture of different kinds. 


This writes the chunk header via PutCkHdr, writes the subtype ID via 
IFFWriteBytes, and calls OpenWGroup. The caller may then write the nested 
chunks and finish by calling EndWGroup. 

The OpenWGroup call sets new~>clientFrame = parent—>clientFrame. 


ASSUME new context structure allocated by caller but not initialized. 
ASSUME caller doesn't deallocate the context or access the parent context 
before calling CloseWGroup. 

ERROR conditions: See PutCkHdr, IFFWriteBytes, OpenWGroup. */ 

extern IFFP StartWGroup(GroupContext *, ID, LONG, ID, GroupContext *); 

/* parent, groupType, groupSize, subtype, new */ 


e * HHH HH HH HOF OF 


/* Enda group started by StartWGroup. 
* This just calls CloseWGroup and PutCkEnd. 
* ERROR conditions: See CloseWGroup and PutCkEnd. */ 
extern IFFP EndWGroup(GroupContext *); 
{/*® old */ 


Open the remainder of the current chunk as a group write context. 
This is normally only called by StartWGroup. 


~S 
* 


Any fixed limit to this group chunk or a containing context will impose 
a limit on the new context. 
This will be called just after the group's subtype ID has been written 
so the remaining contents will be a sequence of chunks. 

This sets new->clientFrame = parent-—>clientFrame. 

ASSUME new context structure allocated by caller but not initialized. 
ASSUME caller doesn't deallocate the context or access the parent context 
before calling CloseWGroup. 

* CLIENT ERROR if context end is odd or PutCkHdr wasn't called first. */ 
extern IFFP OpenWGroup(GroupContext *, GroupContext *); 
/* parent, new */ 


+ et OF OO Ot 


/* Close a write context and update its parent context. 
* This is normally only called by EndWGroup. 
* 











40T — fi 








Nov 10 17:19 1988 IFF_include/iff.h Page 7 


If this is a top level context (created by OpenWIFF) we'll set the file's 
EOF (end of file) but won't close the file. 

After calling this, the old context may be deallocated and the parent 
context can be accessed again. 


Amiga DOS Note: There's no call to set the EOF. We just position to the 
desired end and return. Caller must Close file at that position. 
* CLIENT ERROR if PutCkEnd wasn't called first. */ 
extern IFFP CloseWGroup(GroupContext *); 
/* old */ 


+ te FE OH OE 


/* Write a whole chunk to a GroupContext. This writes a chunk header, ckSize 
* data bytes, and (if needed) a pad byte. It also updates the GroupContext. 
* CLIENT_ERROR if ckSize == szNotYetKnown. See also PutCkHdr errors. */ 

extern IFFP PutCk(GroupContext *, ID, LONG, BYTE *); 

/* context, ckID, ckSize, *data */ 


Ss 
« 


Write just a chunk header. Follow this will any number of calls to 
IFFWriteBytes and finish with PutcCkEnd. 

If you don't yet know how big the chunk is, pass in ckSize = szNot YetKnown, 
then PutCkEnd will set the ckSize for you later. 

Otherwise, IFFWriteBytes and PutCkEnd will ensure that the specified 
number of bytes get written. 

CLIENT_ERROR if the chunk would overflow the GroupContext.'s bound, if 
PutCkHdr was previously called without a matching PutCkEnd, if ckSize < 0 
(except szNotYetKnown), if you're trying to write something other 

than one FORM, LIST, or CAT in a top level (file level) context, or 

if ckID <= 0 (these illegal ID values are used for error codes). */ 
extern IFFP PutCkHdr(GroupContext *, ID, LONG) ; 

/* context, ckID, ckSize */ 


+ + 4 4 HH HH HOt 


/* Write nBytes number of data bytes for the current chunk and update 
* GroupContext. 
* CLIENT_ERROR if this would overflow the GroupContext's limit or the 
* current chunk's ckSize, or if PutCkHdr wasn't called first, or if 
* nBytes ¢ 0. */ 
extern IFFP IFFWriteBytes(GroupContext *, BYTE *, LONG) ; 
/* context, *data, nBytes */ 


/* Complete the current chunk, write a pad byte if needed, and update 
* GroupContext. : 
* If current chunk's ckSize = szNotYetKnown, this goes back and sets the 
* ckSize in the file. 
* CLIENT_ERROR if PutCkHdr wasn't called first, or if client hasn't 
* written 'ckSize' number of bytes with IFFWriteBytes. */ 
extern IFFP PutCkEnd(GroupContext *); 
/* context */ 


#telse /* not FDwAT */ 


extern IFFP OpenWIFF(); 
extern IFFP StartWGroup(); 
extern IFFP EndWGroup(); 
extern IFFP OpenWGroup(); 
extern IFFP CloseWGroup({ ); 
extern IFFP PutCk(); 

extern IFFP PutCkHdr(); 
extern IFFP IFFWriteBytes(); 
extern IFFP PutCkEnd(); 


#fendif /* not FDwAT */ 


#tendif IFF_H 





Nov 10 17:19 1988 IFF_include/ilbm.h Page 1 


#ifndef ILBM_H 
#define ILBM_H 


x ILBM.H Definitions for InterLeaved BitMap raster image. 1/23/86 
* 09/88 — added CAMG, CCRT, and CRNG typedefs and macros (cs) 

* 

* By Jerry Morrison and Steve Shaw, Electronic Arts. 

* This software is in the public domain. 

* 

* This version for the Commodore~Amiga computer. 











*— ne —-- —*/ 
#ifndef COMPILER_H 
#include "iff/compiler.h" 
fendif 
#ifndef GRAPHICS _GFX_H 
tinclude "graphics/gfx.h" 
ftendif 
#include “iff/iff.h" 
#define ID_ILBM MakeID('I','L','B','M') 
#tdefine ID_BMHD MakeID('B','M','H','D') 
#define ID_CMAP MakeID('C’','M','A','P') 
#define ID_GRAB MakeID('G','R','A','B') 
#define ID_DEST MakeID('D','E','S','T') 
#define ID_SPRT MakeID('S','P','R','T') 
#define ID.CAMG MakeID('C','A','M','G') 
#define ID_CRNG MakeID('C','R','N','G') 
#define ID_CCRT MakeID('c','C','R','T') 
#define ID_BODY MakeID('B','0','D','Y') 
{tT BitMapHeader -----~— rtm _ mn me Kf 
typedef UBYTE Masking; /* Choice of masking technique. */ 
#define mskNone ° 
#define mskHasMask 
#define mskHasTransparentColor 2 
#define mskLasso 3 





typedef UBYTE Compression; /* Choice of compression algorithm applied to 
* each row of the source and mask planes. "cmpByteRunl" is the byte run 
* encoding generated by Mac's PackBits. See Packer.h . */ 

#define cmpNone 0 

#define cmpByteRunl 1 


/* Aspect ratios: The proper fraction xAspect/yAspect represents the pixel 
* aspect ratio pixel _width/pixel_height. 
*x 


* For the 4 Amiga display modes: 
* 320 x 200: 10/11 (these pixels are taller than they are wide) 
* 320 x 400: 20/11 

* 640 x 200: 5/11 

* 640 x 400: 10/11 */ 
#define x320x200Aspect 10 
#define y320x200Aspect 11 
#define x320x400Aspect 20 
#define y320x400Aspect 11 
#tdefine x640x200Aspect 5 
#define y640x200Aspect 11 
tdefine x640x400Aspect 10 
#tdefine y640x400Aspect 11 


/* A BitMapHeader is stored in a BMHD chunk. */ 
typedef struct { 
UWORD w, h; 
WORD X, Yi 


/7* raster width & height in pixels */ 
/* position for this image */ 





























Nov 10 17:19 1988 IFF_include/ilbm.h Page 2 


UBYTE nPlanes; /* # source bitplanes */ 

Masking masking; /* masking technique */ 

Compression compression; /* compression algoithm */ 

UBYTE padl; 7* UNUSED. For consistency, put 0 here.*/ 
UWORD transparentColor; /* transparent "color number" */ 

UBYTE xAspect, yAspect; /* aspect ratio, a rational number x/y */ 
WORD pageWidth, pageHeight; /* source “page" size in pixels */ 

} BitMapHeader ; 


/* RowBytes computes the number of bytes in a row, from the width in pixels.*/ 
#define RowBytes(w) (((w) +15) >> 4 <1) 





[eR COLOLREGL Ste Sm kf 
/* A CMAP chunk is a packed array of ColorRegisters (3 bytes each). xf 
typedef struct [ 
UBYTE red, green, blue; 
} ColorRegister; 


/* MUST be UBYTEs so ">> 4" won't sign extend.*/ 


/* Use this constant instead of sizeof (ColorRegister). */ 
#define sizeofColorRegister 3 


typedef WORD Color4; /* Amiga RAM version of a color-register, 
* with 4 bits each RGB in low 12 bits.*/ 


/* Maximum number of bitplanes in RAM. Current Amiga max w/dual playfield. */ 
#define MaxAmDepth 6 





[* moon an Point 2D —— ea */ 
/7* A Point2D is stored in a GRAB chunk. */ 
typedef struct { 
WORD X, Y; 
} Point2D; 


/* coordinates (pixels) */ 





[RO DestMerge ——-~7>-7-7—77 aa ff 
/* A DestMerge is stored in a DEST chunk. */ 


got - 1 


UBYTE depth; /* # bitplanes in the original source */ 

UBYTE padl; /* UNUSED; for consistency store 0 here */ . . 
UWORD planePick; /* how to scatter source bitplanes into destination */ 
UWORD planeOnOff; /* default bitplane data for planePick */ 

UWORD planeMask; /* selects which bitplanes to store into */ 

} DestMerge; 


[ko wnoa ao SpriitePrecedemce mm */ 
/* A SpritePrecedence is stored in a SPRT chunk. */ 
typedef UWORD SpritePrecedence; 


[hae Camg Amiga Viewport Mode —— tt */ 
/* A Commodore Amiga ViewPort—>Modes is stored in a CAMG chunk. */ 
/* The chunk's content is declared as a LONG. */ 
typedef struct [{ 
ULONG ViewModes ; 





} CamgChunk ; 
[*. --------—— -CRange cycling chunk mo na */f 
/* A CRange is store in a CRNG chunk. */ 
typedef struct [ 
WORD padl; /* reserved for future use; store 0 here */ 
WORD rate; /* 60/sec=16384, 30/sec=8192, 1/sec=16384/60=273 */ 
WORD active; /* bitO set = active, bit 1 set = reverse */ 
UBYTE low, high; /* lower and upper color registers selected */ 
} CRange; 
fe Cert (Graphicraft) cycling chunk er *f 


7* A Cert is stored in a CCRT chunk. *x/ 

typedef struct { 

WORD direction; /* O=don't cycle, l=forward, -l=backwards */ 
UBYTE start; 7* range lower */ 


Nov 10 17:19 1988 IFF_include/ilbm.h Page 3 


UBYTE end; /* range upper */ 

LONG seconds; /* seconds between cycling */ 
LONG microseconds; /* msecs between cycling */ 
WORD pad; /* future exp — store 0 here */ 
} CertChunk; 


/* ~—---—--- ILBM Writer Support Routines RL 


/* Note: Just call PutCk to write a BMHD, GRAB, DEST, SPRT, or CAMG 
x chunk. As below. */ 
#define PutBMHD(context, bmHdr) \ 

PutCk(context, ID_BMHD, sizeof(BitMapHeader), (BYTE * )bmHdr) 
#tdefine PutGRAB(context, point2D) \ 

PutCk(context, ID_GRAB, sizeof(Point2D), (BYTE *)point2D) 
#define PutDEST(context, destMerge) \ 

PutCk(context, ID_DEST, sizeof(DestMerge), (BYTE *)destMerge) 
#define PutSPRT(context, spritePrec) \ 

PutCk(context, ID_SPRT, sizeof (SpritePrecedence) , (BYTE *)spritePrec) 
#define PutCAMG(context, camg) \ 

PutCck(context, ID_CAMG, sizeof (CamgChunk) , (BYTE *)camg) 
#define PutCRNG(context, crng) \ 

PutCk(context, ID _CRNG, sizeof(CRange) , (BYTE *)crng) 
#define PutCCRT(context, ccrt) 

Putck(context, ID_CCRT, sizeof (CcertChunk) , (BYTE *)ccrt) 


#ifdef FDwAT 


Initialize a BitMapHeader record for a full-BitMap ILBM picture. 

This gets w, h, and nPlanes from the BitMap fields BytesPerRow, Rows, and 
Depth. It assumes you want Ww = bitmap->BytesPerRow * 8 . 

CLIENT _ERROR if bitmap->BytesPerRow isn't even, as required by ILBM format. 


~ 
De 


If (pageWidth, pageHeight) is (320, 200), (320, 400), (640, 200), or 
(640, 400) this sets (xAspect, yAspect) based on those 4 Amiga display 





modes. Otherwise, it sets them to (1, 1). 


After calling this, store directly into the BitMapHeader if you want to 
override any settings, e.g. to make nPlanes smaller, to reduce w a little, 
* or to set a position (x, y) other than (0, 0).*/ 

extern IFFP InitBMHdr(BitMapHeader *, struct BitMap *, 

/* bmHdr, bitmap */ : 
int, int, int, WORD, WORD) ; 

/7* masking, compression, transparentColor, pageWidth, pageHeight */ 

/* Masking, Compression, UWORD —— are the desired types, but get 
* compiler warnings if use them. */ 


4 ee 4 HO HH HF OF 


|/* Output a CMAP chunk to an open FORM ILBM write context. */ 





extern IFFP PutCMAP(GroupContext *, WORD *, 
/* context, colorMap, depth */ 


UBYTE) ; 


This procedure outputs a BitMap as an ILBM's BODY chunk with 

bitplane and mask data. Compressed if bmHdr—->compression == cmpByteRunl. 
If the "mask" argument isn't NULL, it merges in the mask plane, too. 

(A fancier routine could write a rectangular portion of an image.) 

This gets Planes (bitplane ptrs) from "bitmap". 


~ 
* 


CLIENT_ERROR if bitmap->Rows != bmHdr—>h, or if 
bitmap—>»BytesPerRow != RowBytes(bmHdr—>w), or if 
pitmap->Depth < bmHdr-—>nPlanes, or if bmHdr—>nPlanes > MaxAmDepth, or if 
bufsize < MaxPackedSize(bitmap->BytesPerRow), or if 
* bmHdr->compression > cmpByteRunl. */ 
extern IFFP PutBODY( 
GroupContext *, struct BitMap *, BYTE *, BitMapHeader *, BYTE *, LONG); 
/* context, bitmap, mask, bmHdr, buffer, bufsize */ 


Ce 


#telse /*not FDwAT*/ 


extern IFFP InitBMHdr(); 








60T — I 





Nov 10 17:19 1988 IFF_include/ilbm.h Page 4 






















extern IFFP PutCMAP(); 
extern IFFP PutBODY(); 


#tendif FDwAT 
[* -— ILBM Reader Support Routines —~~----—-----~~~-------———---*/ 


/* Note: Just call IFFReadBytes to read a BMHD, GRAB, DEST, SPRT, or CAMG 
* chunk. As below. */ 
#define GetBMHD(context, bmHdr) \ 
IFFReadBytes(context, (BYTE *)bmHdr, sizeof (BitMapHeader) ) 


#tdefine GetGRAB(context, point2D) \ 

IFFReadBytes(context, (BYTE *)point2D, sizeof (Point2D) ) 
#define GetDEST(context, destMerge) \ 

IFFReadBytes(context, (BYTE *)destMerge, sizeof (DestMerge) ) 
#define GetSPRT(context, spritePrec) \ 

IFFReadBytes(context, (BYTE *)spritePrec, sizeof (SpritePrecedence) ) 
#define GetCAMG(context, camg) 

IFFReadBytes(context, (BYTE *)camg, sizeof (CamgChunk) ) 
#define GetCRNG(context, crng) 

IFFReadBytes(context, (BYTE *)crng, sizeof (CRange) ) 
#define GetCCRT(context, cert) 

IFFReadBytes (context, (BYTE *)cert, sizeof(CcrtChunk) ) 


/* GetBODY can handle a file with up to 16 planes plus a mask.*/ 
#define MaxSrcPlanes 16+1 


#ifdef FDwAT 


/* Input a CMAP chunk from an open FORM ILBM read context. 
* This converts to an Amiga color map: 4 bits each of red, green, blue packed 
* into a 16 bit color register. 
* pNColorRegs is passed in as a pointer to a UBYTE variable that holds 
* the number of ColorRegisters the caller has space to hold. GetCMAP sets 
* that variable to the number of color registers actually read.*/ 
extern IFFP GetCMAP(GroupContext *, WORD *, UBYTE *); 
/7* context, colorMap, pNColorRegs */ 


GetBODY reads an ILBM's BODY into a client's bitmap, de-interleaving and 
decompressing. 


Ss 
* 


Caller should first compare bmHdr dimensions (rowWords, h, nPlanes) with 
bitmap dimensions, and consider reallocating the bitmap. 

If file has more bitplanes than bitmap, this reads first few planes (low 
order ones). If bitmap has more bitplanes, the last few are untouched. 
This reads the MIN(bmHdr->h, bitmap—>Rows) rows, discarding the bottom 
part of. the source or leaving the bottom part of the bitmap untouched. 


GetBODY returns CLIENT_ERROR if asked to perform a conversion it doesn't 
handle. It only understands compression algorithms cmpNone and cmpByteRun1. 
The filed row width (# words) must agree with bitmap-—>BytesPerRow. 


Caller should use bmHdr.w; GetBODY only uses it to compute the row width 
in words. Pixels to the right of bmHdr.w are not defined. 


[TBD] In the future, GetBODY could clip the stored image horizontally or 
fill (with transparentColor) untouched parts of the destination bitmap. 


GetBODY stores the mask plane, if any, in the buffer pointed to by mask. 
If mask == NULL, GetBODY will skip any mask plane. If 
(bmHdr.masking != mskHasMask) GetBODY just leaves the caller's mask alone. 


GetBODY needs a buffer large enough for two compressed rows. 
It returns CLIENT ERROR if bufsize < 2 * MaxPackedSize(bmHdr.rowWords * 2). 


Get BODY can handle a file with up to MaxSrcPlanes planes. It returns 
CLIENT_ERROR if the file has more. (Could be due to a bum file, though.) 


+ Oe oO OO HOO OO OOOO 











Nov 10 17:19 1988 IFF_include/ilbm.h Page 5 






* If GetBODY fails, itt might've modified the client's bitmap. Sorry.*/ 
extern IFFP GetBODY( 

GroupContext *, struct BitMap *, BYTE *, BitMapHeader *, BYTE *, LONG); 

/* context, bitmap, mask, bmHdar, buffer, bufsize */ 





/7* [TBD] Add routine(s) to create masks when reading ILBMs whose 

* masking != mskHasMask. For mskNone, create a rectangular mask. For 

* mskHasTransparentColor, create a mask from transparentColor. For mskLasso, 
* create an "auto mask" by filling transparent color from the edges. */ 






#telse /*not FDwAT*/ 





extern IFFP GetCMAP(); 
extern IFFP GetBODY({); 


#endif FDwAT 


#endif ILBM_H 

























Nov 10 17:19 1988 IFF_include/intuall.h Page 1 Nov 10 17:19 1988 IFF_include/intuall.h Page 2 

















































/*** intuall.h FORGO ICI III III I IIIA IAAT ITI IIR III K /*#include “hardware/custom.h"*/ 
/7* intuall.h, Include lots of Amiga~provided header files. 1/22/86 */ 
/* Plus the portability file "iff/compiler.h" which should be tailored */ /*#include "libraries/dos.h"*/ 

7* for your compiler. */ /*#tinclude "“libraries/dosextens.h"*/ 


/* By Jerry Morrison and Steve Shaw, Electronic Arts. xf #include "devices/timer.h" 

7* This software is in the public domain. */ finclude "devices/inputevent.h" 

/* xf #include "devices/keymap.h" 

7* This version for the Commodore-Amiga computer. */ 
* xf #include “intuition/intuition.h" 

[AIA IOI III TIO TIT TO TOT TTR I I ITT I TIT IT IIIT IT IT ITI IIIT ATI I IAI DSTI IAI IOI I IIIA 

/*tinclude "intuitionbase.h"*/ 

#include "iff/compiler.h" /* COMPILER-DEPENDENCIES */ /*#include "intuinternal.h"*/ 





/* Dummy definitions because some includes below are commented out. 
* This avoids ‘undefined structure' warnings when compile. 
* This is safe as long as only use POINTERS to these structures. 


*/ 


struct Region { int dummy; }; 
struct VSprite { int dummy; }; 

struct collTable { int dummy; }; 
struct CopList { int dummy; }; 

struct UCopList { int dummy; }; 
struct cprlist { int dummy; } 
struct copinit { int dummy; } 
struct Timevai { int dummy; } 


#include "“exec/types.h" 
#tinclude "exec/nodes.h" 
#include "“exec/lists.h" 
#include "“exec/libraries.h" 
#include "exec/ports.h" 


#include “exec/tasks.h" 
#include "exec/devices.h" 


oIt-TI 


#include "“exec/interrupts.h" 





#include "exec/io.h" 
#include "exec/memory.h" 
#include “exec/alerts.h" 


/* ALWAYS INCLUDE GFX.H before any other amiga includes */ 


#include "graphics/gfx.h" 
/*#tinclude “hardware/blit .h"*/ 





#include "graphics/collide.h" 
#include "graphics/copper.h" 
#include "graphics/display.h" 
#include "“hardware/dmabits.h" 
#include "graphics/gels.h" 
nee / 


#include "graphics/clip.h" 


#tinclude "graphics/rastport.h" 
#include "graphics/view.h" 
#include "graphics/gfxbase.h" 
/*#include "hardware/intbits.h"*/ 
#include."graphics/gfxmacros.h" 


#include "graphics/layers.h" 


#include "graphics/text.h" 


#include "graphics/sprite.h" 





TIt - 1 








Nov 10 17:19 1988 IFF_include/packer.h Page 1 


#ifndef PACKER_H 
#define PACKER H 
PACKER.H typedefs for Data—Compresser. 1/22/86 


This module implements the run compression algorithm "cmpByteRunl"; the 
same encoding generated by Mac's PackBits. 


By Jerry Morrison and Steve Shaw, Electronic Arts. 
This software is in the public domain. 


+ + 4 Ot tM OF 


This version for the Commodore-Amiga computer. 
a —*/ 


ka on —. eee 


#ifndef COMPILER_H 
#include "iff/compiler.h" 
#endif 


/* This macro computes the worst case packed size of a "row" of bytes. */ 
#define MaxPackedSize(rowSize) ( (rowSize) + ( ((rowSize)+127) >> 7) ) 


#ifdef FDwAT /* Compiler handles Function Declaration with Argument Types */ 


/* Given POINTERS to POINTER variables, packs one row, updating the source 
* and destination pointers. Returns the size in bytes of the packed row. 
* ASSUMES destination buffer is large enough for the packed row. 

* See MaxPackedSize. */ 

extern LONG PackRow(BYTE **, BYTE **, LONG); 

7* pSource, pDest, rowSize */ 


/* Given POINTERS to POINTER variables, unpacks one row, updating the source 
* and destination pointers until it produces dstBytes bytes (i.e., the 
* rowSize that went into PackRow). 
* If it would exceed the source's limit srcBytes or if a run would overrun 
* the destination buffer size dstBytes, it stops and returns TRUE. 
* Otherwise, it returns FALSE (no error). */ 
extern BOOL UnPackRow(BYTE **, BYTE **, WORD, WORD) ; 
/* pSource, pDest, srcBytes, dstBytes */ 


#else /* not FDwAT */ 


extern LONG PackRow(); 
extern BOOL UnPackRow(); 


#fendif /* FDwAT */ 
#tendif 





Nov 10 17:19 1988 IFF_include/putpict.h Page 1 


#ifndef PUTPICT_H 


#define PUTPICT_H 
[kk putpict.h KKK KKK KI KKK KKK KEKE KKK KEK KI KK EK KEK KKK EEK EKER KEKE KEKRKEK xf 


7* PutPict(). Given a BitMap and a color map in RAM on the Amiga, xf 
/7* outputs as an ILBM. See /iff/ilbm.h & /iff/ilbnw.c. 23-Jan-86 */ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/* This software is in the public domain. */ 
yk */ 
7* This version for the Commodore-Amiga computer. */ 
* * 


ICO IOGIIIIICIIG ICICI CIO TOO TIO IIR IO IIR IG, 
#ifndef COMPILER_H 

#include "iff/compiler.h" 

#tendif 


#ifndef ILBM_H 
#tinclude "iff/ilbm.h" 
#endif 


#ifdef FDwAT 


[RRKRRER IffErr RARER RAK IEK EEK ARE RARER EK HEE KKK HER IEREK EERIE KHER RIKER ER IKEA R EK / 


/7/* Returns the iff error code and resets it to zero * 
DGC OICI ICICI CITC ICICTOCICC ICCC CIICCTO ITO IIIT I TOR IOI TOTO TIO II | 


extern IFFP IffErr( void); 


[REKRERE PutPict RRR KIRA II KIRK RK KK KKK EK KKK KK ARK HRA RRR KK ERA K ER ERK EK K ERR / 


/7* Put a picture into an IFF file */ 
/* Pass in mask == NULL for no mask. */ 
7* */ 
/* Buffer should be big enough for one packed scan line */ 
/* Buffer used as temporary storage to speed-up writing. */ 
/* A large buffer, say 8KB, is useful for minimizing Write and Seek calls. */ 
/* (See /iff/gio.h & /iff/gio.c). x/ 


[RRR RRR REIKI R ERIK IRR IEK IKK ERK ERK K ERIE RIK EIR IRR IIHR RIKKI IORI IR TTR TIKI I IK / 
extern BOOL PutPict (LONG, struct BitMap *, WORD,WORD, WORD *, BYTE *, LONG); 
pageW,pageH,colorMap, buffer,bufsize */ 


/* file, bm, 
#else /*not FDwAT*/ 


extern IFFP IffErr(); 
extern BOOL PutPict(); 


#endif PDwAT 


#tendif PUTPICT_H 








ett - I 


Nov 10 17:19 1988 


IFF_include/readpict.h Page 1 


#ifndef READPICT_H 


#define READPICT_H 
/** ReadPict.h SOI ISIS IOI ICICI IO IAIIO IOC OIC ASAT ITI ICATIIG 


* * 
hi Read an ILBM raster image file into RAM. 1/23/86. y 
i By Jerry Morrison, Steve Shaw, and Steve Hayes, Electronic Arts. * 
“* This software is in the public domain. % 
/: USE THIS AS AN EXAMPLE PROGRAM FOR AN IFF READER. */ 
te The IFF reader portion is essentially a recursive-descent parser. v, 


[OI ICICI IIIT III ACT OTCT TIO A IIIT RIT RCT TT TR ITT IR TOIT IT TTT TA ITI IIA I TOY. 


/* ILBMFrame. is our "client frame" for reading FORMs ILBM in an IFF file. 
* We allocate one of these on the stack for every LIST or FORM encountered 
* in the file and use it to hold BMHD & CMAP properties. We also allocate 
* an initial one for the whole file. */ 
typedef struct [{ 
ClientFrame clientFrame; 
UBYTE foundBMHD; 
UBYTE nColorRegs; 
BitMapHeader bmHdr; 
Color4 colorMap[32 /*1<<MaxAmDepth*/ J]; 
/* If you want to read any other property chunks, e.g. GRAB or CAMG, add 
* fields to this record to store them. */ 
} ILBMPrame ; 


/** ReadPicture() FOR TOK I RRR IR IO TOR ROR IOI TOI I II IR II IKI AIA IAAI AIA KEI A AIK IKKE KARIERRE 
* 

* Read a picture from an IFF file, given a file handle open for reading. 

* Allocates BitMap RAM by calling (*Allocator) (size). 

* 


GIS IIGIUI IIIS GIOIA IASI IIA IIR IAS AAA ISA IIA AAAI 


typedef UBYTE *UBytePtr; 
#ifdef FDwAT 


typedef UBytePtr Allocator(LONG) ; 


/* Allocator: a memory allocation procedure which only requires a size 
* argument. (No Amiga memory flags argument.) */ 


extern IFFP ReadPicture(LONG, struct BitMap *, ILBMFrame *, Allocator *); 
/* file, bm, iFrame, allocator */ 
/* iFrame is the top level “client frame". */ 
7* allocator is a ptr to your allocation procedure. It must always 
* allocate in Chip memory (for bitmap data). */ 


/7* PS: Notice how we used two "typedef''s above to make allocator's type 


* meaningful to humans. 
* Consider the usual Cc style: UBYTE *(*)(), or is it (UBYTE *)(*()) ? ¥*/ 
#felse /* not FDWAT */ 


typedef UBytePtr Allocator(); 
extern IFFP ReadPicture(); 


#tendif 


ftendif READPICT_H 





Nov 10 17:19 1988 IFF_include/remalloc.h Page 1 





/** RemAlloc.h FAO IICIIIIDIG OCI IO III IOI TOTO IIA IIIA IISA AIK 





/* ChipAlloc(), ExtAlloc(), RemAlloc(), RemFree(). xf 
/* ALLOCators which REMember the size allocated, for simpler freeing. */ 
/* */ 
/* Date Who Changes x/ 
ene pn ne tt xf 
/* 16-Jan-86 sss Created from DPaint/DAlloc.c */ 
/* 22-Jan-86 jhm Include Compiler .h */ 
/* 25-Jan-86 sss Added ChipNoClearAlloc,ExtNoClearAlloc xf 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/* This software is in the public domain. */ 
* */ 
/7* This version for the Commodore-Amiga computer. */ 
* * 


FOR III IIR RIK IIT ARI IA IIA IIA IIIA EIA IB IIR IAAI AAI IKI IIIB HRI SIS AIHA AIR IA / 
#ifndef REM_ALLOC_H 
#define REM_ALLOC_H 


#ifnmdef COMPILER_H 
#include "iff/compiler.h" 
tendif 


/* How these allocators work: 

The allocator procedures get the memory from the system allocator, 
actually allocating 4 extra bytes. We store the length of the node in 
the first 4 bytes then return a ptr to the rest of the storage. The 
deallocator can then find the node size and free it. */ 


+ +H OF 


#ifdef FDwAT 


/* RemAlloc allocates a node with "size" bytes of user data. 
* Example: 
* struct BitMap *bm; 
* bm = (struct BitMap *)RemAlloc( sizeof(struct BitMap), 
* 
extern UBYTE *RemAlloc(LONG, LONG); 
/* size, flags */ 


...flags... ); 


/* ALLOCator that remembers size, allocates in CHIP—accessable memory. 
* Use for all data to be displayed on screen, all sound data, all data to be 
* blitted, disk buffers, or access by any other DMA channel. 
* Does clear memory being allocated.*/ 
extern UBYTE *ChipAlloc( LONG) ; 
/* size */ 


/* ChipAlloc, without clearing memory. Purpose: speed when allocate 
* large area that will be overwritten anyway.*/ 
extern UBYTE *ChipNoClearAlloc( LONG) ; 





/* ALLOCator that remembers size, allocates in extended memory. 
* Does clear memory being allocated. 
* NOTICE: does NOT declare "MEMF FAST". This allows machines 
* lacking extended memory to allocate within chip memory, 
* assuming there is enough memory left.*/ 
extern UBYTE *ExtAlloc( LONG) ; 
/* size */ 


/* ExtAlloc, without clearing memory. Purpose: speed when allocate 
* large area that will be overwritten anyway.*/ 
extern UBYTE *ExtNoClearAlloc(LONG); 


/* FREES either chip or extended memory, if allocated with an allocator 
* which REMembers size allocated. 

* Safe: won't attempt to de-allocate a NULL pointer. 

* Returns NULL so caller can do 





e€TT - 1 





Nov 10 17:19 


1988 IFF_include/remalloc.h Page 2 


* p = RemFree(p); 


* 


extern UBYTE 


#else /* not 


extern UBYTE 
extern UBYTE 
extern UBYTE 
extern UBYTE 


*RemFree(UBYTE *); 
/* p */ 
FDwAT */ 
*RemAlloc(); 
*ChipAlloc({ ); 


*ExtAlloc(); 
*RemFree(); 


#tendif /* FDwAT */ 


#endif REM_ALLOC_H 


Nov 10 17:19 1988 IFF_include/smus.h Page l 





* SMUS.H Definitions for Simple MUSical score. 2/12/86 
* 

* By Jerry Morrison and Steve Hayes, Electronic Arts. 

* This software is in the public domain. 

* 


* This version for the Commodore-Amiga computer. 





#ifndef SMUS_H 
#define SMUS_H 


#ifndef COMPILER_H 
#include "iff/compiler.h" 
#endif 


#include "iff/iff.h" 


ID_SMUS MakeID('S', 'M', 'U', 'S') 
ID_SHDR MakeID('S', 'H', 'D', 'R') 
ID_NAME MakeID('N', 'A*, 'M', 'B') 
ID_Copyright MakeID('(', 'c', ')', ' ' 

ID_ AUTH MakeID('A', 'U', 'T', 'H') 
ID_ANNO MakeID('A', 'N', 'N', 'O') 


ID_INS1 MakeID('I', 'N', 's', '1') 
ID TRAK MakeID('T', ‘R', ‘A’, ‘K') 


[8 moomoo SSCOLEHEADEL Mer rrr rn re HY 
typedef struct { 

UWORD tempo; 7* tempo, 128ths quarter note/minute */ 

UBYTE volume; /* playback volume 0 through 127 */ 

UBYTE ctTrack; 7* count of tracks in the score */ 

} SScoreHeader ; 


MSR NBME HY 


NAME chunk contains a CHAR[], the musical score's name. */ 





Copyright (¢) ------------- _ 
"(c) “ chunk contains a CHAR[], the FORM's copyright notice. 





mene eee INS] monct 
/7* Constants for the RefInstrument' s "type" field. 
#define INS1_Name 0 /* just use the name; ignore datal, data2 */ 
define INS]_MIDI 1 /* <datal, data2> = MIDI <channel, preset> */ 


typedef struct [ 
UBYTE iRegister; /* set this instrument register number */ 
UBYTE type; /* instrument reference type (see above) */ 
UBYTE datal, data2; /* depends on the "type" field */ 
char name[60]; /7* instrument name */ 
} RefInstrument ; 





7* TRAK chunk contains an SEvent[]. */ 


/* SEvent: Simple musical event. */ 

typedef struct { 
UBYTE sID; /* SEvent type code */ 
UBYTE data; /* sID-dependent data */ 
} SEvent; 


/* SEvent type codes "sID". */ 
#define SID_FirstNote 0 





IT - I 











[Nov 10 17:19 1988 IFF_include/smus.h Page 2 


#define SID_LastNote 127 /* sIDs in the range SID_FirstNote through. 


* SID_LastNote (sign bit = 0) are notes. The 


*x sID is the MIDI tone number (pitch). */ 


#define SID_Rest 128 /* a rest; same data format as a note. */ 
#define SID_Instrument 129 /* set instrument number for this track. */ 
#define SID_TimeSig 130 7* set time signature for this track. */ 
#define SID_KeySig 131 /* set key signature for this track. «/ 
#define SID_Dynamic 132 /* set volume for this track. */ 

#define SID_MIDI_Chnl 133 /* set MIDI channel number (sequencers) */ 
#define SID MIDI_Preset 134 /* set MIDI preset number (sequencers) */ 
#define SID_Clef 135 7* inline clef change. 


x 0=Treble, 1l=Bass, 2=Alto, 3=Tenor. */ 


#define SID_Tempo 136 /* Inline tempo change in beats per minute. */ 


/* SID values 144 through 159: reserved for Instant Music SEvents. */ 


/* The remaining sID values up through 254: reserved for future 
* standardization. */ 


#define SID_Mark 255 /* SID reserved for an end-mark in RAM. */ 
* -----—---- SFvent FirstNote..LastNote or Rest sot */ 
typedef struct [{ 
unsigned tone 78, /7* MIDI tone number 0 to 127; 128 = rest */ 
chord sl, /* 1 = a chorded note */ 
tiedut 1, /* 1 = tied to the next note or chord */ 
nTuplet :2, /* Q = none, 1 = triplet, 2 = quintuplet, 
3 = septuplet */ 
dot rl, /* dotted note; multiply duration by 3/2 */ 
division :3; /7* basic note duration is 2**x-division: 
* 0 = whole note, 1 = half note, 2 = quarter 
* note, . 7 = 128th note */ 
} SNote; 


/* Warning: An SNote is supposed to bea 16-bit entity. 
* Some C compilers will not pack bit fields into anything smaller 
* than an int. So avoid the actual use of this type unless you are certain 
* that the compiler packs it into a 16-bit word. 
*/ 


/* You may get better object code by masking, ORing, and shifting using the 
* following definitions rather than the bit-packed fields, above. */ 
#tdefine noteChord (1<<7) /7* note is chorded to next note x/ 


#tdefine noteTieout (1<<6) /* note/chord is tied to next note/chord */ 


#define noteNShift 4 /* shift count for nTuplet field */ 
#define noteN3 (1<<notenshift) /* note is a triplet */ 

#define noteN5 (2<<noteNShift) /7* note is a quintuplet */ 

#define noteN7 (3<<noteNShift) /* note is a septuplet */ 

#define noteNMask  noteN7 /* bit mask for the nTuplet field xf 
#define noteDot (1<<3) /* note is dotted */ 

#define noteDShift 0 /* shift count for division field */ 
#define noteDl (0<<notebDShift) /7* whole note division */ 

#tdefine noteb2 (1<<noteDshift) /* half note division */ 

#define noteb4 (2<<noteDSshi ft) /* quarter note division */ 

#define noteD8 (3<<noteDshift) /* eighth note division */ 

#define noteD16 (4<<noteDShift) /* sixteenth note division */ 
#define noteD32 (5<<noteDshift) /* thirty-secondth note division */ 
#define noteD64 (6<<noteDShift) /* sixty~fourth note division */ 
#define noteD128 (7<<noteDshift ) /* 1/128 note division */ 

#define noteDMask noteD128 /* bit mask for the division field */ 


/7* bit mask for all duration fields 
x division, nTuplet, dot */ 


#define noteDurMask 0x3F 


/* Field access: */ 





Nov 10 17:19 1988 IFF_include/smus.h Page 3 


#tdefine IsChord(snote) (((UWORD)snote) & noteChord) 

#define IsTied(snote) (((UWORD)snote) & noteTieOut) 

#define NTuplet(snote) ((((UWORD)snote) & noteNMask) >> noteNShift) 
#define IsDot(snote) (((UWORD)snote) & noteDot) 

#define Division(snote) ((((UWORD)snote) & noteDMask) >> noteDShift) 


[ma TAMOS Lg SEV */ 
typedef struct [{ 
unsigned type 78, /* = SID_TimeSig */ 
timeNSig :5, /* time signature "numerator" timeNSig + 1 */ 
timeDSig :3; /* time signature "denominator" is 


* 2**timeDSig: 0 = whole note, 1 = half 
* note, 2 = quarter note, 
* 7 = 128th note */ 


} STimeSig; 
#define timeNMask OxF8 /* bit mask for timeNSig field */ 
#define timeNShift 3 /* shift count for timeNSig field */ 
#define timeDMask 0x07 /* bit mask for timeDSig field */ 


/7* Field access: */ 
#tdefine TimeNSig(sTime) ( 


(((UWORD)sTime) & timeNMask) >> timeNShift) 
#define TimeDSig(sTime) (( 


(UWORD)sTime) & timeDMask) 


PR man Key Sg SEV EE */ 
7* “data" value 0 = cmaj; 1 through 7 = G,D,A,E,B,F#,C#; 
* 8 through 14 = F,Bb,&b,Ab,Db,Gb,Cb. */ 
Bee MAL SEV CT mr x/ 


/* "data" value is a MIDI key velocity 0..127. «f/f 


1. SMUS Reader Support Routines eee A 
/* Just call this to read a SHDR chunk. */ 
#define GetSHDR(context, ssHdr) \ 

IFFReadBytes(context, (BYTE *)ssHdr, sizeof (SScoreHeader) ) 
[Rao SMUS Writer Support ROUtLN@S om «/ 
/7* Just call this to write a SHDR chunk. */ 
#define PutSHDR(context, ssHdr) 

PutCk(context, ID_SHDR, sizeof (SScoreHeader), (BYTE *)ssHdr) 


#endif 











sTt - I 


Nov 10 17:18 1988 IFF_source/EA_LinkInfo Page 1 


; iffchecg. ink 

FROM lstartup.o,iffcheck.o,iffr.o,gio.o 
LIBRARY le.lib,amiga.1lib 

To iffcheck 


i; ifficheck. lnk 

FROM Istartup.o,iffcheck.o,iffr.o 
LIBRARY lc. lib,amiga.lib 

TO iffcheck 


; ilbm2raw.1nk 

FROM lstartup.o, ilbm2raw.o, readpict.o, ilbmr.o, unpacker.o, iffr.o* 
remalloc.o 

LIBRARY le.lib, amiga.lib 

TO ilbm2raw 


3; ilbmdump. ink 

FROM lstartup.o, ilbmdump.o, readpict.o, ilbmr.o, unpacker.o, iffr.o* 
remalloc.o, bmprintc.o 

LIBRARY lc. lib, amiga.lib 

TO ilbmdump 


; Yaw2ilbg.1nk 

FROM lstartup.o, raw2ilbm.o, putpict.o, ilbmw.o, packer.o, iffw.o, gio.o 
LIBRARY lc.lib, amiga.lib 

TO raw2ilbm 


raw2ilbm. lnk 
FROM lstartup.o, raw2ilbm.o, putpict.o, ilbmw.o, packer.o, iffw.o 
LIBRARY lc.1lib, amiga.lib 
TO raw2ilbm 


;  showilbg.1nk 

FROM lstartup.o,showilbm.o,readpict.o,ilbmr.o,unpacker.o,iffr.o,remalloc.o* 
gio.o 

LIBRARY lc.lib,amiga.1lib 

To showilbm 


showilbm. Ink 
FROM lstartup.o,showilbm.o,readpict.o,ilbmr.o,unpacker.o,iffr.o,remalloc.o 
To showilbm 
LIBRARY 1c.lib,amiga.lib 


3; read8svx. ink 

FROM LIB:lstartup.obj, Read8svx.o, dUnpack.o, iffr.o 
TO Read8svx 

LIBRARY LIB:ic.lib, LIB:amiga.lib 





Nov 10 17:18 1988 IFF_source/IFFCheck.c Page 1 











I Bo (an ee —— an _— me 
/* IFFCheck.C Print out the structure of an IFF-85 file, 1/23/86 */ 
/* checking for structural errors. */ 
[* xf 
7* DO NOT USE THIS AS A SKELETAL PROGRAM FOR AN IFF READER! xf 
/* See ShowILBM.c for a skeletal example. */ 
/* */ 
7* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/7* This software is in the public domain. */ 
/* */ 
7* This version for the Commodore-Amiga computer. */ 
* * 
jn oY 


#include NifE/ife. h" 


[8 wna BF Che CK ———* 


/* [TBD] More extensive checking could be done on the IDs encountered in the 
* file. Check that the reserved IDs "FORL".."FOR9", "LIS1".."LIS9", and 
* “CATL". "CATO" aren't used. Check that reserved IDs aren't used as Form 
* types. Check that all IDs are made of 4 printable characters (trailing 
* spaces ok). */ 


typedef struct [{ 
ClientFrame clientFrame; 
int levels; /* # groups currently nested within.*/ 


} Frame; 
char MsgOkay[] = { "---—~ (IFF_OKAY) A good IFF file." }; 
char MsgEndMark[] = {"-~—-—— (END_MARK) How did you get this message??" }; 
char MsgDone[] = { "----- (IFF_DONE) How did you get this message??" }; 
char MsgDos[{] = { '---—- (DOS_EBRROR) The DOS gave back an error." }; 
char MsgNot{] = { "---—- (NOT_IFP) not an IFF file." ]; 
char MsgNoFile[] = { "~-——- (NO_FILE) no such file found." }; 
char MsgClientError[] = {"---—— (CLIENT_ERROR) IFF Checker bug."}; 
char MsgForm[] = { "----- (BAD_FORM) How did you get this message??" }; 
char MsgShort[] = { "--——— (SHORT_CHUNK) How did you get this message??" ]; 
char MsgBad[] = { "~---- (BAD_IFF) a mangled IFF file." }; 


/* MUST GET THESE IN RIGHT ORDER! !*/ 

char *IFFPMessages [—(int)LAST_ERROR+1] = { 
/*IFF_OKAY*/ MsgOkay, 
/*END_MARK*/ MsgEndMark, 
/*IFF_DONE*/ .MsgDone, 
/*DOS_ERROR*/ MsgDos, 
/*NOT_IFF*/  MsgNot, 
/*NO_FILE*/  MsgNoFile, 
/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/. MsgForm, 
/*SHORT_CHUNK*/ MsgShort, 
/*BAD_IFF*/ MsgBad 


i 


/* FORWARD REFERENCES */ 
extern IFFP GetList(GroupContext *); 
extern IFFP GetForm(GroupContext *) 
extern IFFP GetProp(GroupContext *); 
extern IFFP GetCat (GroupContext *) 


void IFFCheck(name) char *name; [ 
IFFP iffp; 
BPTR file = Open(name, MODE_OLDFILE); 
Frame frame; 


frame.levels = 0; 


frame.clientFrame.getList = GetList; 
frame.clientFrame.getForm = GetForm; 
frame.clientFrame.getProp = GetProp; 
frame.clientFrame.getCat = GetCat ; 


ll 


a 
| 
b 
be 
a 


Nov 10°-17:18 1988 IFF_source/IFFCheck.c Page 2 


printf("----- Checking file 'ts' —-~—— \n'', name) ; 
if (file == 0) 

iffp = NO FILE; 
else 

iffp = ReadIFF(file, (ClientFrame *)&frame) ; 


Close( file); 
printf("%s\n", IFFPMessages[~iffp]); 
} 


main(arge, argv) int argc; char **argv; [ 
if (arge != 1+1) 
printf("Usage: 'iffcheck filename'\n"); 
exit(0); 


} 
IFFCheck(argv[1]); 
} 











[Rm Put a SS «/ 
PutLevels (count) int count; [{ 
for ( ; count > 0; --count) [ 
printf("."); 
} 
} 
PutID(id) ID id; [ 
printf ("%c%ctc%c", 
(char) ((id>>24L) & Ox7f), 
(char)((id>>16L) & Ox7f), 
(char) ((id>>8) & Ox7f), 
(char) (id & Ox7f) ); 
} 
PutN(n) int n; { 
printf(" %d ", nj; 
J 
/* Put something like "...BMHD 14" or "...LIST 14 PLB " o*/ 
PutHdr(context) GroupContext *context; 
PutLevels( ((Frame *)context->clientFrame)—>levels ); 
PutID(context—>ckHdr.ckID) ; 
PutN(context—>ckHdr.ckSize) ; 
if (context->subtype != NULL_CHUNK) 
PutID(context—>subtype) ; 
printf("\n"); 
} 
[8 eon AtLeaf, —----------- aaa Rant 


/7* At Leaf chunk. That is, a chunk which does NOT contain other chunks. 
* Print "ID size".*/ 
IFFP AtLeaf(context) GroupContext *context; { 


PutHdr (context) ; 

/* A typical reader would read the chunk's contents; using the "Frame" 
* for local data, esp. shared property settings (PROP).*/ 

/* IFFReadBytes(context, ...buffer, context—>ckHdr->ckSize); */ 

return ( IFF_OKAY) ; 

} 


Bm GOED AF 
7* Handle a LIST chunk. Print “LIST size subTypeID". 
* Then dive into it.*/ 
IFFP GetList(parent) GroupContext *parent; { 
Frame newFrame; 














Nov 10 17:18 1988 IFF_source/IFFCheck.c Page 3 


newFrame = *(Frame *)parent—>clientFrame; /* copy parent's frame*/ 
newFrame.levels++; 


PutHdr(parent) ; 


return( ReadIList(parent, (ClientFrame *)é&newFrame) ); 





* Soe GetForm —- oto ee an 
/* Handle a FORM chunk. Print "FORM size subTypeID". 
* Then dive into it.*/ 
IFFP GetForm(parent ) GroupContext *parent; [ 
/*CompilerBug register*/ IFFP iffp; 
GroupContext new; 
Frame newFrame; 


newFrame = *(Frame *)parent->clientFrame; /* copy parent's frame*/ 
newFrame. levelst++; 


PutHdr (parent) ; 


iffp = OpenRGroup(parent, &new); 
CheckIFFP(); 
new.clientFrame = (ClientFrame *) &newFrame; 


/* FORM reader for Checker. */ 
/* LIST, FORM, PROP, CAT already handled by GetFlChunkHdr. */ 
do {if ( (iffp = GetF1lChunkHdr(&new)) > 0 ) 
iffp = AtLeaf(&new); 
} while (iffp >= IFF_OKAY); 


CloseRGroup( &new) ; 


return(iffp == END_MARK ? IFF_OKAY : iffp); 


Bn GetProp ~—--—---"~ 
/7* Handle a PROP chunk. Print “PROP size subTypeID". 
* Then dive into it.*/ 
IFFP GetProp(listContext) GroupContext *listContext; f 
/*CompilerBug register*/ IFFP iffp; 
GroupContext new; 


a nn ne nat 


PutHdr(listContext) ; 


iffp = OpenRGroup(listContext, &new); 
CheckIFFP(); 


7* PROP reader for Checker. */ 
((Frame *)listContext~—>clientFrame)—>levels++; 


do {if ( (iffp = GetPChunkHdr(&new)) > 0 ) 
iffp = AtLeaf(énew) ; 
} while (iffp >= IFF_OKAY); 


((Frame *)listContext->clientFrame)—>levels——; 
CloseRGroup( &new) ; 


return(iffp == END_MARK ? IFF_OKAY : 
J 


iffp); 





ft GetCat -——a rrr a */ 
/* Handle a CAT chunk. Print "CAT size subTypeID". 
* Then dive into it.*/ 
IFFP GetCat(parent) GroupContext *parent; { 
IFFP iffp; 


((Frame *)parent—>clientFrame)~>levelst+; 





LTT - 1 





Nov 10 17:18 1988 IFF_source/IFFCheck.c Page 4 


PutHdr (parent); 
iffp = ReadICat(parent); 


((Frame *)parent—>clientFrame)—->levels—j; 
return(iffp); 
} 








Nov 10 17:18 1988 IFF_source/ILBM2Raw.c Page 1 





















SaveBitMap(name,bm,cols) 
UBYTE *name; 
struct BitMap *bm; 
SHORT *cols; 
{ 


SHORT i; 
LONG nb,plsize; 
LONG file = Open( name, MODE_NEWFILE); 
if( file = ») 
printf(" couldn't open %s \n",name) ; 
return (-1); /* couldnt open a load-file */ 


} 
plsize = bm->BytesPerRow*bm->Rows ; 


[ Br nn Kank 
/* ilbm2raw.c x/ 
/* 2/4/86 x/ 
/* Reads in ILBM, outputs raw format, which is x/ 
/* just the planes of bitmap data followed by the color map */ 
7k */ 
/7* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/* This software is in the public domain. x/ 
/* */ 
/* This version for the Commodore~Amiga computer. */ 
/* */ 
/* Callable from CLI only */ 
[OR */ 
#include "iff/intuall.h" 
#include "libraries/dos.h" 
#include "libraries/dosextens.h" 
#include "iff/ilbm.h" 
#include "iff/readpict.h" 
#include “iff/remalloc.h" 
#undef NULL 
include "lattice/stdio. h* 
nt A x/ 
Ms Iff error messages */ 
[hoo a a */ 
char MsgOkay[] = ({ "----~ (IFF_OKAY) A good IFF file." }; 
char MsgEndMark[] = {"-~-—— (END_MARK) How did you get this message??" }; 
char MsgDone[] = it "—-__ (IFF DONE) How did you get this message??" }; 
char MsgDos[] = "——--— (DOS_ERROR) The DOS gave back an error." }; 
char MsgNot[] = t "____~ (NOT_IFF) not an IFF file." J; 
char MsgNoFile[] = { t---- (NO_FILE) no such file found." }; 
char MsgClientError[] = -~—-— (CLIENT_ERROR) IPF Checker bug."}; 
char MsgForm[] = { "----— (BAD_FORM) How did you get this message??" ]; 
char’ MsgShort[{} = { '~~--~ (SHORT_CHUNK) How did you get this message??" }; 
char MsgBad[] = { "---—- (BAD_IFF) a mangled IFF file." }; 
/* MUST GET THESE IN RIGHT ORDER! !*/ 
char *IFFPMessages [-LAST_ERROR+1] = { 
/*IEF_OKAY*/ MsgOkay, 
/*END_MARK*/ MsgEndMark, 
/*1EF_DONE*/ MsgDone, 
/*DOS_ERROR*/ MsgDos, 
/*NOT_IFF*/ MsgNot, 
/*NO_FILE*/ MsgNoFile, 
/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/ Msg¥Form, 
/*SHORT_CHUNK*/ MsgShort, 
/*BAD_IFF*/ MsgBad 
LONG GfxBase; 
/t-——--- —— pee */ 





8TT - TI 


Nov 10 17:18 1988 IFF_source/ILBM2Raw.c Page 2 Nov 10 17:18 1988 


for (i=0; i<bm->Depth; i++) [ 
nb = Write(file, bm->Planes[i], plsize); 
if (nb<plsize) break; 
} 
Write(file, cols, (1<<bm->Depth)*2); /* save color map */ 
Close(file); 
return(0); 


struct BitMap bitmap = [0}; 
char depthString[] = "0"; /* Replaced with desired digit below. */ 


ILBMFrame ilbmFrame; /* Top level “client frame".*/ 


(** main( } FOI OI III IOI IOI IIIT III IIR IA IITA IAS IS IIS TAI IOS IISA IA IK 


UBYTE defSwitch[] = "“b"; 


void main(arge, argv) int argc; char **argv; { 
LONG iffp, file; 
UBYTE fname [40] ; 
GfxBase = (LONG)OpenLibrary("graphics.library",0); 
if (GfixBase==NULL) exit(0); 


if (argc) { 
/* Invoked via CLI. Make a lock for current directory. */ 
if (arge ¢ 2) [{ 
printf("Usage from CLI: 'ilbm2raw filename 'An"); 
else { 
file = Open(argv[1], MODE_OLDFILE) ; 
if (file) { / 
iffp = ReadPicture(file, &bitmap, &ilbmFrame, ChipAlloc) ; 
Close(file); 
if (iffp != IFF_DONE) { 
printf(" Couldn't read file %s \n", argv[1]); 
printf ("%s\n",IFFPMessages(—-iffp] ); 
J 
else { 
strepy(fname,argv[1] ); 
if (ilbmPrame.bmHdr.pageWidth > 320) { 
if (ilbmFrame.bmHdr.pageHeight > 200) 
streat(fname, ".hi"); 
else strcat(fname, ".me"); 
else streat(fname, ".10"); 


depthString[0] = '0' + bitmap.Depth; 
streat(fname, depthString); 


printf(" Creating file %s \n", fname); 
SaveBitMap(fname, sbitmap, ilbmFrame.colorMap) ; 
} } 
else printf(" Couldn't open file: %s. \n", argv{l]); 
if (bitmap.Planes[0]) RemFree(bitmap.Planes[0]); 


printf ("\n"); 
} 


} 
CloseLibrary (GfxBase) ; 





IFF_source/ILBM2Raw.c Page 3 





exit(0); 
} 





6TT -~ I 





Nov 10 17:18 1988 IFF_source/ILBMDump.c Page 1 





1 ns tt ee en xf 
/* */ 
/* TLBMDump.c: reads in ILBM, prints out ascii representation, */ 
7* for including in C files. */ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
7* This software is in the public domain. */ 
/* */ 
/7* This version for the Commodore-Amiga computer. */ 
/* */ 
/* Callable from CLI ONLY */ 
7* Jan 31, 1986 */ 
OT aaa 





#include "iff/intuall.h" 
#include "libraries/dos.h" 
#include "libraries/dosextens.h" 
#include "iff/ilbm.h" 

#include "iff/readpict.h" 
#include "iff/remalloc.h" 











#undef NULL 

#include_ "lattice/stdio. h" 

[tr One a 
Me iff error messages 
/* a = 
char MsgOkay[] = { "----- (IFF_OKAY) A good IFF file." ]; 

char MsgEndMark[] = {"----- (END_MARK) How did you get this message??" J; 


char MsgDone[] = { '~---— (IFF_DONE) How did you get this message??" }; 





char MsgDos[] = { '---~ (DOS_ERROR) The DOS gave back an error." }; 

char MsgNot[] = { "---—- (NOT_IFF) not an IFF file." }; 

char MsgNoFile[] = { "“---— (NO_FILE) no such file found." }; 

char MsgClientError[] = {"---—— (CLIENT_ERROR) IFF Checker bug."}; 

char MsgForm[] = { "—---- (BAD_FORM) How did you get this message??" J; 
char MsgShort[] = { "----- (SHORT_CHUNK) How did you get this message??" }; 
char MsgBad[{] = { "----- {(BAD_IFF) a mangled IFF file." }; 


/* MUST GET THESE IN RIGHT ORDER! !*/ 

char *IFFPMessages [-LAST_ERROR+1] = [{ 
/*IFF_OKAY*/ MsgOkay, 
/*END_MARK*/ MsgEndMark, 
/*IFF_DONE*/ MsgDone, 
7*DOS_ERROR*/ MsgDos, 
/*NOT_LIFF*/  MsgNot, 
/*NO_FILE*/ MsgNoFile, 
/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/ MsgForm, 
/*SHORT_CHUNK*/ “MsgShort, 
/*BAD_IFF*/ | MsgBad 


yi 
/* this returns a string containing characters after the 
last '/' or ':' * 
GetSuffix(to, fr) UBYTE *to, *fr; { 
int i; 


UBYTE c,*s = fr; 
for (i=0; ;it+) { 
c = *sgtt; 
if (c == 0) break; 
if (c= '/') fr =s; 
else if (c == '':') fr = s; 


j 
strepy(to,fr); 
} 


LONG GfxBase; 


Nov 10 17:18 1988 IFF_source/ILBMDump.c Page 2 


struct BitMap bitmap = [(0}; 
ILBMFrame ilbmFrame; /* Top level “client frame".*/ 


[kk main() HORII RIK IKI RRA KI IK IRR IK IIR ERE REE I IKI RE III ER IEEE ERIRIRERE / 


UBYTE defSwitch{] = "b"; 


void main(arge, argv) int argc; char **argv; f 
UBYTE *sw; 
FILE *fp; 
LONG iffp,file; 
UBYTE name[{40}, fname[40]; 
GfxBase = (LONG)OpenLibrary("graphics. library",0); 
if (GfxBase==NULL) exit(0); 


if (arge) { 

/* Invoked via CLI. Make a lock for current directory. */ 

if (arge < 2) f{ 
printf("Usage from CLI: 'ILBMDump filename switch-string'\n"); 
printf(" where switch-string = \n"); 
printf(" <nothing> : Bob format (Qefault)\n") ; 
printf(" s : Sprite format (with header and trailer words)\n"); 
printf(" sn : Sprite format (No header and trailer words)\n"); 
printf(" a : Attached sprite (with header and trailer)\n"); 
printf(" an : Attached sprite (No header and trailer)\n"); 
printf(" Add 'c' to switch list to output CR's with LF's Xn"); 
} 


else { 
= (arge>2)? argv[2}: defSwitch; 


file = Open(argv[1], MODE_OLDFILE) ; 


if (file) { 
iffp = ReadPicture(file, &bitmap, &ilbmFrame, ChipAlloc) ; 
Close(file); 
if (iffp !+ IFF _DONE') { 
printf(" Couldn't read file %s \n", argv[1]); 
printf('"'%s\n", IFFPMessages{—iffp] ); 


else [{ 
print{(" Creating file %s.c \n",argv[(1]); 
GetSuffix(name,argv[1]); 
strepy(fname,argv[1]); 
streat(fname,".c"); 
fp = fopen(fname,"w"); 
BMPrintCRep( &bitmap, fp,name, sw) ; 
fclose(fp); 
} 


else’ printt(" Couldn't open file: %s. \n", argv{1]); 
if (bitmap.Planes(0]) RemFree(bitmap.Planes[0]); 
printf("\n"); 
} 

Closttibrary(G£xBase) ; 


exit(0); 
} 





o2gT - I 








Nov 10 17:18 1988 IFF_source/Raw2ILBM.c Page 1 


[** raw2ilbm.c FOR IR II IK AKIRA I ABI IK IAA SAD IIIA IAA IK IAA KAKI IERIE RERERREEE 
7* Read in a "raw" bitmap (dump of the bitplanes in a screen). */ 
* 


/* Display it, and write it out as an ILBM file. / 
/* 23-San-86 x/ 
/* xf 
/* Usage from CLI: 'Raw2ILBM source dest fmt (low,med,hi) */ 
/* nplanes' */ 
/7* Supports the three common Amiga screen formats. xf 
/* ‘low! is 320x200, */ 
/* ‘med' is 640x200, */ 
/* ‘hi' is 640x400. */ 
/* ‘nplanes' is the number of bitplanes. */ 
/* The default is low-resolution, 5 bitplanes */ 
/* (32 colors per pixel). */ 
ye */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. «f/f 
/* This software is in the public domain. * 
/* 

/* This version for the Commodore-Amiga computer. *f 
* * 


(IOI II IOI IOI III III TI TOI ATI III TIT IIT ITI IIA ITA IO II IAI ISAS AI ISIS 


#include "iff/intuall.h" 
#include "libraries/dos.h" 
#include "libraries/dosextens.h" 
#include "iff/ilbm.h" 

#include "iff/putpict.h" 


#define MIN(a,b) ((a)<(b)?(a):(b)) 
#define MAX(a,b) ((a)>(b)?(a):(b)) 


/* general. usage pointers */ . 
LONG IconBase; /* Actually, "struct IconBase *" if you've got some ".h" file*/ 
struct GfxBase *GfxBase; 


/* Globals for displaying an image */ 
struct RastPort rP; 

struct Rasinfo rasinfo; 

struct View v = {0}; 

struct ViewPort vp = {0}; 


struct View *oldView = 0; /* so we can restore it */ 


oH * - 
DisplayPic(bm, colorMap) struct BitMap *bm; UWORD *colorMap; [ 
oldView = GfxBase—>ActiView; /* so we can restore it */ 
InitView(&v); 
InitVPort(&vp); 
v.ViewPort = &vp; 
InitRastPort (&rP) ; 
rP.BitMap = bm; 
rasinfo.BitMap = bm; 


/* Always show the upper left~hand corner of this picture. */ 
rasinfo. RxOffset 
rasinfo.RyOffset 


i 


0; 


i] 


vp.DWidth = bm->BytesPerRow*8; /* Physical display WIDTH */ 
vp.DHeight = bm-—>Rows; /* Display height */ 


/* Always display it in upper left corner of screen. */ 


if (vp.DWidth <= 320) vp.Modes = 0; 
else vp.Modes = HIRES; 

if (vp.DHeight > 200) { 
v.Modes |= LACE; 
vp.Modes |= LACE; 











Nov 10 17:18 1988 IFF_source/Raw2ILBM.c Page 2 


} 

vp.RasInfo = érasinfo; 
MakeVPort (&V,&Vp) ; 
MrgCop(&V); 
LoadView(&v) ; 
WaitBlit(); 
WaitTOF(); 

if (colorMap) LoadRGB4(&vp, colorMap,(1 << bm~>Depth) ); 


/* show the picture */ 


UnDispPict() { 
if (oldView) { 
LoadView(oldView) ; 
FreeVPortCopLists ( &vp) ; 
FreeCprList(v.LOFCprList) ; 
} 


/* switch back to old view */ 


} 


PrintS(msg) char *msg; { printf (msg); } 


void GoodBye(msg) char *msg; [{ PrintS(msg) ; Prints("\n"); exit(0); ~ } 


struct BitMap bitmap = {0}; 
SHORT cmap[32]; 


AllocBitMap(bm) struct BitMap *bm; [ 


int 1; 
LONG psz = bm—>BytesPerRow*bm—>Rows; 
UBYTE *p = (UBYTE *)AllocMem(bm->Depth*psz, MEME CHIP |MEMF PUBLIC) ; 


for (i=0; i<bm->Depth; i++) { 
bm->Planes[i] = p; 
p t= ps2; 
} 


} 


FreeBitMap(bm) struct BitMap *bm; { 
if (bitmap.Planes[0]) { 
FreeMem(bitmap.Planes [0], 
bitmap.BytesPerRow * bitmap.Rows * bitmap.Depth); 
J 


} 


BOOL LoadBitMap(file,bm,cols) 
LONG file; 
struct BitMap *bm; 
SHORT *cols; 


{ 
SHORT i; 
LONG nb,plsize; 
plsize = bm->BytesPerRow*bm—>Rows ; 
for (i=0; i<bm->Depth; i++) [{ 
nb = Read(file, bm->Planes[i], plsize); 
if (nb<plsize) BltClear(bm—>Planes[i],plsize,1); 





if (cols) { 
nb = Read(file, cols, (1<<bm->Depth)*2) ; 
return( (BOOL) (nb == (1<<bm->Depth)*2) ); 


/* load color map */ 


} 
return( (BOOL) FALSE); 
} 


/** main() JOISTS GIGI ICI IAITIIG CIO TATOO IOI AIA I IA IO TIAA TAA III IA 
UBYTE defSwitch[] = "“b"; 


#define BUFSIZE 16000 


static SHORT maxDepth[3] = [5,4,4}; 


Nov 10 17:18 1988 IFF_source/Raw2ILBM.c Page 3 Nov 10 17:18 1988 IFF_source/Read8svx.c Page 1 


void main(arge, argv) int arge; char *ekargv; { [** Read8SvVX.c KEKE ERE KKK KKK EKER ERK KKK RA KER ERK KEEKEKEEKE 
SHORT fmt ,depth, pwidth, pheight; * 
UBYTE *buffer; * Read a sound sample from an IFF file. 21Jan85 
BOOL hadCmap; x 
LONG file; * By Steve Hayes, Electronic Arts. 
if( !(GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",0)) ) * This software is in the public domain. 
GoodBye("No graphics. library"); * 
if( !(IconBase = OpenLibrary("icon.library",0)) ) * 
GoodBye("No icon. library"); 
if (arge) [ #include "exec/types.h" 
if (arge <¢ 3) { i "exec/exec.h" 
printf ( i "libraries/dos.h" 
“Usage from CLI: 'Raw2ILBM source dest fmt(low,med,hi) nplanes'\n"); #include "iff/8svx.h" 
goto bailout; 


HARE K RRR RHR KEKE KIKI KER EH IKE KER RIKER RRR ARIK K RIKER ERR ER ERK / 


} /* Message strings for IFFP codes. */ 
fmt = 0; MsgOkay [] "(IFF_ OKAY) No FORM 8SVX in the file." }; 
depth = 5; MsgEndMark [] “(END_MARK) How did you get this message?" }; 
if (argce>3) MsgDone [] “(IPF DONE) All done."]; 
switch(*argv[3]) { team 1 (DOS ERROR) The eer ete yee error." ); 
'l': ; ; SGNo jot an ile 
case int ime 1 break’ MsgNoFile{] "ENO FILE) No such file found." }; 
case 'h': fmt = 2; break; MsgClientError[] "(CLIENT_ERROR) Read8SVX bug or insufficient RAM."}; 
} MsgForm[] "(BAD FORM) A malformed FORM 8SVX." }; 
if (arge>4) depth = *argv{4]}]-'0'; MsgShort [] "(SHORT_CHUNK) A malformed FORM 8SVX." J; 
depth = MAX(1, MIN(maxDepth[fmt] ,depth)); MsgBad [] “(BAD_IFF) A mangled IFF file." }; 
pwidth = fmt? 640: 320; 
pheight = (fmt>1)? 400: 200; 
InitBitMap(&bitmap, depth, pwidth, pheight); 
AllocBitMap( &bitmap) ; 


/* THESE MUST APPEAR IN RIGHT ORDER!!! */ 
char *IFFPMessages[—-LAST_ERROR+1] = [{ 
/*IFF_OKAY*/ MsgOkay, 
/*END_MARK*/ MsgEndMark, 
/*IFF_DONE*/ MsgDone, 
/*DOS_ERROR*/ MsgDos, 
/*NOT_IFF*/  MsgNot, 
/*NO_FILE*/ MsgNoFile, 


file = Open(argv[1], MODE _OLDFILE) ; 
if (file) [{ 


Tet -I 


DisplayPic(&bitmap,NULL) ; 

hadCmap = LoadBitMap(file,&bitmap, cmap); 

if (hadCmap) LoadRGB4(&vp, cmap, 1<<bitmap.Depth) ; 
Close( file); 


/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/ MsgForm, 
/*SHORT_CHUNK*/: MsgShort, 


file = Open(argv[2], MODE_NEWFILE); /*BAD_IFF*/ MsgBad 
buffer = (UBYTE *)AllocMem(BUFSIZE, MEMF . CHIP |MEMF | PUBLIC) ; hi 
PutPict(file, &bitmap, pwidth, pheight, 
hadCmap? cmap: NULL, buffer, BUFSIZE); typedef struct {__ 
Close(file); ClientFrame clientFrame; 
FreeMem(buffer,BUFSIZE) ; ~ UBYTE foundVHDR; 
UBYTE padl; 
Voice8Header sampHdr; 
} SVXFrame; 


} 
else printf(" Couldn't open file 'ts' \n",argv[2]); 
, 


UnDispPict(); . . 

FreeBitMap(&bitmap) ; NOTE: For a simple version of this program, set Fancy to 0. 

That'll compile a program that skips all LISTs and PROPs in the input 

bailout: file. It will look in CATs for FORMs 8SVX. That's suitable for most uses. 
CloseLibrary (GfxBase) ; 
CloseLibrary (IconBase) ; 


exit(0); 


For a fancy version that handles LISTs and PROPs, set Fancy to 1. */ 
#define Fancy 1 


BYTE *buf; 
int szBuf; 


[** DoSomethingWithsSample( ) KEKE KERK KEK KK EKER KEKKREKRKKKEKKERKEKKEEEKEKKKEKK 
* 


* Interface to Amiga sound driver. 
* 


RK IK IK KIKI KK RIK IK KKK IKK RAKE AHHH KKK KERR ERE ERE IKK ER ERIK ERE RE KRERE / 
DoSomethingWithSample(sampHdr) Voice8Header *sampHdr; { 
BYTE *t; 
printf ("\noneShotHiSamples=%1d", sampHdr-—>oneShotHiSamples) ; 
printf ("\nrepeatHiSamples=%1d", sampHdr->repeatHiSamples) ; 





eeT - I 











Nov LO 17:18 1988 IFF_source/Read8svx.c Page 2 


printf ("\nsamplesPerHiCycle=%1d", sampHdr—>samplesPerHicycle) ; 
printf ("\nsamplesPerSec=31d", sampHdr->samplesPerSec) ; 
printf ("\nctoctave=%1d", sampHdr->ctOctave) ; 
printf("\nsCompression=%1d", sampHdr—>sCompression) ; 
printf ("\nvolume=0x%1x", sampHdr—>volume) ; 
/7* Decompress, if needed. */ 
if (sampHdr->sCompression) [ 

t = (BYTE *)AllocMem(szBuf<<1, MEMF_CHIP); 

DUnpack(buf, szBuf, t); 

FreeMem(buf, szBuf); 

buf = t; 

szBuf <<= 1; 


yi 
printf("\nData = %31d %3ld 331d $31d %31d %31d %31d %31d", 
buf [0] ,buf [1] ,buf [2] ,buf [3] ,buf{4],buf [5] ,buf [6] ,buf[7]); 
printf ("\n $31d 331d 31d 331d %31d.$31d %31d %31d ...\n", 
buf [8+0] ,buf[8+1] , buf [8+2] ,buf [8+3] ,buf[8+4] ,buf[8+5], 
buf [8+6] ,buf [8+ 7]); 
} 


[** ReadBODY ( ) FORTH III II IORI II RIOR IIA AOI IKI IIIA IIA II KIA IA IKI RIK IR IARI SIH 
* 


* Read a BODY into RAM. 
* 


GORI GIGI GIGI OI OIC III III III IOI IIIT ATI III ISI IIIA IIIA AIK IAIKIAK | 


IFFP ReadBODY(context) GroupContext *context; { 
IFFP iffp; 


szBuf = ChunkMoreBytes(context); 
buf = (BYTE *)AllocMem(szBuf, MEMF CHIP); 
if (buf == NULL) 
iffp = CLIENT_ERROR; 
else 
iffp = IFFReadBytes(context, (BYTE *)buf, szBuf); 
CheckIFFP(); 
} 


[kk GetFo8SVX{) FRR IR IIR IS IRI TIA II III TAI TAI RIK IAA IARI I IK ER IRR ER EAK 
* 

Called via ReadSample to handle every FORM encountered in an IFF file. 
Reads FORMS 8SVX and skips all others. 

Inside a FORM 8SVX, it reads BODY. It complains if it 

doesn't find an VHDR before the BODY. 


[TBD] We could read and print out any NAME and "(c) chunks. 


+ * + HH HH 


FOCI IOI III OI IAI AI OTT AR IAAI TTI I OAD IIA IT IAA IIIT RII IIIA IIA IAIN | 


IFFP GetFo8SVX(parent) GroupContext *parent; { 
/*compilerBug register*/ IFFP iffp; 
GroupContext formContext; 
SVXFrame smusFrame; /* only used for non-clientFrame fields.*/ 

if (parent—>subtype != ID_8SVX) 
return(IFF_OKAY); /* just continue scaning the file */ 


smusFrame = *(SVXFrame *)parent—>clientFrame; 
iffp =~ OpenRGroup(parent, &formContext) ; 
CheckIFFP ( ); : 


do switch (iffp = GetFChunkHdr( &formContext) ) { 
case ID_VHDR: [{ 
smusFrame.foundVHDR = TRUE; 
iffp = GetVHDR(&formContext, &smusFrame.sampHdr) ; 
break; } 
case ID_BODY: { 
if (!smusFrame.foundVHDR) 
iffp = BAD_FORM; /* Need an VHDR chunk first! */ 
else iffp = ReadBODY(&formContext) ; 
break; } 





Nov 10 17:18 1988 IFF_source/Read8svx.c Page 3 


case END_MARK: { 
if (!smusFrame. foundVHDR ) 
iffp = BAD_FORM; 
else 
iffp = IFF_DONE; 
break; } 
} while (iffp >= IFF_OKAY); /* loop if valid ID of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors).*/ 


‘ 


if (iffp != IFF_DONE) return(iffp); 


/* If we get this far, there were no errors. */ 
CloseRGroup( &formContext) ; 
DoSomethingWithSample(&smusFrame. sampHdr) ; 
FreeMem(buf, szBuf); 

return(iffp); 

} 


/** Notes on extending GetFo8SVX FORO III II IO II IR TIO IR IR IO RIK 
* 


* To read more kinds of chunks, just add clauses to the switch statement. 
* To read more kinds of property chunks (like NAME) add clauses to 


* the switch statement in GetPr8SVX, too. 
* 


GOI IIICI GIGI IOI OI IO IOI I IOI IOI ITO IOI TIO I TA IA III IAI AKA EI IK 


/** GetPr8SVX() FOI IO IOI III IOI TO IOI IIR III OR TO IOI AI I III ITA ISA IIA IK 
* 
* Called via ReadSample to handle every PROP encountered in an IFF file. 
* Reads PROPs 8SVX and skips all others. 
* 


FOI ICO III IIIS III I ARIAT II IAI AS AAI IA AS ASI IK IARI KH IA KIARA EK | 
#if Fancy 
IFFP GetPr8SVX(parent) GroupContext *parent; { 
/*compilerBug register*/ IFFP iffp; 
GroupContext propContext; 
SVXFrame *svxFrame = (SVXFrame *)parent—>clientFrame; /* Subclass xf 


if (parent—>subtype != ID_8SVX) 
return(IFF_OKAY); /* just continue scaning the file */ 


iffp = OpenRGroup(parent, &propContext) ; 
CheckIFFP(); 


do switch (iffp = GetPChunkHdr(&propContext)) [ 
ease ID_VHDR: { 
svxFrame—>foundVHDR = TRUE; 
iffp = GetVHDR(spropContext, &svxFrame~>sampHdr) ; 
break; } 
} while (iffp >= IFF_OKAY); /* loop if valid ID of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors) .*/ 


CloseRGroup( &propContext ) ; 
return(iffp == END_MARK ? IFF_OKAY : 
J 

#endif 


iffp); 


[** GetLi8SVvXx() FFI RII IR III TIT III III IORI IAI IAAI DKA I IAI IARI AA IIHR ISIE 
* 


* Called via ReadSample to handle every LIST encountered in an IFF file. 
* 


III IO ORR TOI IO IT AIA IA RIT IAA IA IAD AI IIA IIIT TI IA AAAI AAAI IK IK | 
#if Fancy 
IFFP GetLi8SVX(parent) GroupContext *parent; [ 

SVXFrame newFrame; /* allocate a new Frame */ 

newFrame = *(SVXFrame *)parent—>clientFrame; /* copy parent frame */ 


return( ReadIList(parent, (ClientFrame *)&newFrame) ); 





eet —- 1 





Nov 10 17:18 1988 IFF_source/Read8svx.c Page 4 


} 
#fendif 


7**® ReadSamp Le ( ) 0G GGG GIGI III IO IIIT II IO II IK IATA 
* 


* Read IFF 8SVX, given a file handle open for reading. 
* 


FRM H RIK RRR KKK RRR HK HII KICK RH RIK IK RIK IK IK RIK IIR IK IK IKK ERK KIRA IKK KHIR KE / 
IFFP ReadSample(file) LONG file; { 

SVXFrame sFrame; /* Top level "client frame". */ 

IFFP iffp = IFF_OKAY; 


#if Fancy 
sFrame.clientFrame.gethList = GetLi8Svx; 
sFrame.clientFrame.getProp = GetPr8SVX; 
#telse 


sFrame.clientFrame.getList = SkipGroup; 

sFrame.clientFrame.getProp = SkipGroup; 
#tendif 

sFrame.clientFrame.getPorm = GetFo8SVX; 

sFrame.clientFrame.getCat = ReadIcat ; 


/* Initialize the top-level client frame's property settings to the 

* program-wide defaults. This example just records that we haven't read 

* any VHDR properties yet. 

x If you want to read another property, init it's fields in sFrame. */ 
sFrame.foundVHDR = FALSE; 
sFrame.padl = 0; 


iffp = ReadIFF(file, (ClientFrame *)&sFrame) ; 


return(iffp); 
} 


7777 TN 0 () RII III ICICI III III III IO III IOI IIIA IRI / 
void main0O(filename) char *filename; [ 

LONG file; 

IFFP iffp = NO_FILE; 

file = Open(filename, MODE_OLDFILE) ; 

if (file) : 

iffp = ReadSample(file); 

Close(file); 

printf(" %s\n", IFFPMessages[~-iffp] ); 

} 


[**® main()} FIR KIRK KIRK RK IR IRR ROR IORI TOI ITT OTR IORI I TITRE IK IK IR ICR K 
void main(arge, argv) int argc; char **argv; { 
printf("Reading file '%s' ...", argv[1l]); 
1f (arge < 2) 
printf("\nfilename required\n") ; 
else 
mainO(argv[1]); 












Nov 10 17:18 1988 IFP_source/ShowILBM.c. Page 1 


778 SHOW] LBM. 0 CAG GCCIIR I RICO TOTO CIC IGT TOIT IIT III IK 
* 
Read an ILBM raster image file and display it. 24-Jan-86 - 


By Jerry Morrison, Steve Shaw, and Steve Hayes, Electronic Arts. 
This software is in the public domain. 


USE THIS AS AN EXAMPLE PROGRAM FOR AN TIFF READER. 


The IFF reader portion is essentially a recursive-descent parser. 
The display portion is specific to the Commodore Amiga computer. 


Usage from CLI: 
showilbm picturel [picture2] 


* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* NOTE: This program displays an image, pauses, then exits. 
* 
* 
* 
* 
* Usage from WorkBench: 

* Click on ShowILBM, hold down shift key, click on each picture to show, 
* Double-click on final picture to complete the selection, release the 
* shift key. 

* 

* 


RR IK RIKI IK IK IIR IR KK IKE IIR KIKI HII KK IRR KIRK ARH ER KER ERK ERIK IKE RIKER KE / 


/* If you are constructing a Makefile, here are the names of the files 
* that you'll need to compile and link with to use showilbm: 


showilbm. 
readpict. 
remalloc. 
ilbmr.c 
iffr.c 
unpacker.c 
gio.c 


aaa 


and you'll have to get movmem() from Ic.lib 


* robp. 
HO KKK KKK KKK KKK IKKE KEKE RIK KK KKK RIK EEK EK KKK KKK KKK KKK IKKE KEKE KEKE KREKRKKKKKK *f 


#include "iff/intuall.h" 
#tinclude "libraries/dos.h" 
#tinclude "libraries/dosextens.h" 
#include "iff/ilbm.h" 

#include "“workbench/workbench.h" 
#include “workbench/startup.h" 
#include "iff/readpict.h" 
f#ineclude "iff/remalloc.h" 


#define LOCAL static 


#define MIN(a,b) ((a)<(b)?(a):(b)) 
#define MAX(a,b) ((a)>(b)?(a):(b)) 


/* general usage pointers */ 
struct GfxBase *GfxBase; 
LONG IconBase; /* Actually, “struct IconBase *" if you've got some ".h" file*/ 


/* For displaying an image */ 
LOCAL struct RastPort xP; 
LOCAL struct BitMap bitmap0; 
LOCAL struct RasInfo rasinfo; 
LOCAL struct View v = (0}; 
LOCAL struct ViewPort vp = [0}; 


LOCAL ILBMFrame iFrame; 


/* Define the size of a temporary buffer used in unscrambling the ILBM rows.*/ 











Nov 10 17:18 1988 IFF_source/ShowILBM.c Page 2 






#define bufSz 512 


/* Message strings for IFFP codes. */ 
LOCAL char MsgOkay[] =.{ 
“(IFF_OKAY) Didn't find a FORM ILBM in the file." ]; 
LOCAL char MsgEndMark[] { "(END MARK) How did you get this message?" }; 
LOCAL char MsgDone[] 
LOCAL char MsgDos[] 
LOCAL char MsgNot [] 
LOCAL char MsgNoFilef] 
LOCAL char MsgClientError[] 
“(CLIENT _ERROR) ShowILBM bug or insufficient RAM."]; 
LOCAL char MsgForm[(] { "(BAD_FORM) A malformed FORM ILBM." J; 
LOCAL char MsgShort[] { "(SHORT_CHUNK) A malformed FORM ILBM." i; 
LOCAL char MsgBad{) { "“(BAD_IFF) A mangled IFF file." }; 


{ "(IFF_DONE) All done."}; 

{ “(DOS ERROR) The DOS returned an error." }; 
{ "(NOT_IFF) Not an IFF file." }; 

{ "(NO_FILE) No such file found." }; 


fol tou th 


on) 


/* THESE MUST APPEAR IN RIGHT ORDER! ! xf 
LOCAL char *IFFPMessages [—(int)LAST_ERROR+1] = [ 
/*IFF_OKAY*/ MsgOkay, 

/*END_MARK*/ MsgEndMark, 
/*IFE_DONE*/ MsgDone, 

/*DOS_ERROR*/ MsgDos, 

/*NOT_IFF*/  MsgNot,, 

/*NO_FILE*/  MsgNoFile, 
/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/ MsgForm, 
/*SHORT_CHUNK*/ MsgShort, 
/*BAD_IFF*/ MsgBad 


[** DisplayPic() HIKARI IRE KAI IIA IIH IK IKI IHR IK KEKE KEKE REE IHKEREKREEEK 
* 


* Interface to Amiga graphics ROM routines. 

* 

be FOR III III IO OO IIIA IO IAT IRI IAI IAD IIB III SOD IIR III IR IR IA IK IKI II IA IAA IIIA 
x DisplayPic(bm, ptilbmFrame) 

struct BitMap *bm; ILBMFrame *ptilbmFrame; { 

int i; 

struct View *oldView = GfxBase->ActiView; /* so we can restore it */ 
InitView( &V); 

InitVPort(&Vvp); 

v.ViewPort = &vp; 

InitRastPort(&rP); 

rP.BitMap = bm; 

rasinfo.BitMap = bm; 


/* Always show the upper left-hand corner of this picture. */ 
rasinfo.Rx0ffset 
rasinfo.RyOffset 


‘ 


0; 


toll 


vp.DWidth = MAX(ptilbmframe—>bmHdr.w, 4*8); 
vp.DHeight = ptilbmFrame—>bmHdr.h; 


#if 0 
/* Specify where on screen to put the ViewPort. */ 


vp.DxOffset = ptilbmFrame~>bmHdr.x; 
vp.DyOffset = ptilbmFrame—>bmHdr.y; 
#else 


* Always display it in upper left. corner of screen.*/ 
#tendif 


if (ptilbmPrame~>bmHdr.pageWidth <= 320) 
vp.Modes = 0; 

else vp.Modes = HIRES; 

if (ptilbmPrame~>bmHdr.pageHeight > 200) { 
v.Modes |= LACE; 
vp.Modes |= LACE; 
} 








Nov 10 17:18 1988 IFF_source/ShowILBM.c Page 3 


vp.RasInfo = &rasinfo; 
MakeVPort(&V,&Vp); 
MrgCop(&V) ; 
LoadView( &V); 
WaitBlit(); 
WaitTOF(); 
LoadRGB4(&vp, ptilbmFrame—>colorMap, ptilbmFrame—>nColorRegs) ; 


7* show the picture */ 


for (i = 0; i ¢ 5*60; ++i) WaitTOF(); /* Delay 5 seconds. */ 


LoadView(olaView); /* switch back to old view */ 


/** stuff for main0() FOI IO TT TOI IITA TOI IDI IA AIA IIH IIA IK IK 
LOCAL struct WBStartup *wbStartup = 0; /* 0 unless started from WorkBench.*/ 


PrintS(msg) char *msg; [ 
if (!wbStartup) printf(msg); 
} 


void GoodBye(msg) char *msg; [ 
Prints (msg) ; Prints("\n"); 
exit(0); 
} 


[tk OpenArg( ) FORK IRR IK IIR III ITI IORI IS IIR IIIS I IAI AISI ITI AAAI ADAIR IR IAA IA RIK KARI IIE 
* 


Given a "workbench argument" (a file reference) and an I/O mode. 
* Jt opens the file. 
FOIA IOI CI GIT IOIGIO ISIC UII ICICI ICI OGIO OOOO IO IO IOS IAIN 
LONG OpenArg(wa, openmode) struct WBArg *wa; int openmode; { 
LONG olddir; 
LONG file; 
if (wa->wa_Lock) olddir = CurrentDir(wa->wa_Lock); 
file = Open({wa—>wa_Name, openmode) ; 
if (wa->wa_Lock) CurrentDir(olddir) ; 
return(file); 


j 


[** main0O() YOGI ICICI IOI ICICI OIG OGIO OO IIIT I III TIAA / 
void mainO{wa) struct WBArg *wa; f 

LONG file; 

IFFP iffp = NO_FILE; 


/* load and display the picture */ 
file = OpenArg(wa, MODE OLDFILE) ; 
if (file) 
iffp = ReadPicture(file, &bitmap0, 4iFrame, ChipAlloc) ; 





/* Allocates BitMap using ChipAlloc().*/ 
Close( file); 
if (iffp == IFF_DONE) 
DisplayPic(ébitmap0, &iFrame) ; 
Prints(" "); PrintS(IFFPMessages [—iffp] ); Prints("\n"); 
/7* cleanup */ 
if (bitmap0.Planes[0]) { 
RemFree(bitmap0.Planes[0]); 
/* ASSUMES allocated all planes via a single ChipAlloc call.*/ 
FreeVPortCopLists( &Vvp) ; 
FreeCprList(v.LOFCprhist) ; 


} 


[** main() FOI GIGI GIGI ISO IOI OCI IO OI AAI AI TAINS IOI TIT TAI IIIA IN 


void main(arge, argv) int argc; char **argv; f{ 
struct WBArg wbArg, *wbArgs; 
LONG olddir; 

/*SSS struct Process *myProcess; */ 








S@T — I 


Nov 10 17:18 1988 IFF_source/ShowILBM.c Page 4 


if( !(GfxBase = (struct GfxBase *)OpenLibrary("“graphies.library",0)) ) 
GoodBye("No graphics. library"); 
if( !(IconBase = OpenLibrary("icon.library",0)) ) 


GoodBye("No icon. library"); 
if (!arge) { 

/* Invoked via workbench */ 

wbStartup = (struct WBStartup *)argv; 

wbArgs = wbStartup~>sm_ArgList; 

arge = wbStartup—>sm_NumArgs; 

while (arge >= 2) 
olddir = CurrentDir(wbArgs[1].wa_Lock) ; 
main0O(&wbArgs[1]); 


arge——; wbhArgs = &wbArgs[1]; 
#if 0 
/7* [TBD] We want to get an error msg to the Workbench user... */ 
if (arge ¢< 2) [ 
Prints ("Usage from workbench:\n"); 
Prints (" Click mouse on Show-ILBM, Then hold 'SHIFT' key\n"); 
GoodBye(" while double-click on file to display."); 
} 
#tendif 
else [{ 
/* Invoked via CLI. Make a lock for current directory. 
* Eventually, scan name, separate out directory reference?*/ 
if (arge < 2) 
GoodBye("Usage from CLI: 'Show-ILBM filename'"); 
/*ssS  myProcess = (struct Process *)PindTask(0); */ 
wbArg.wa_Lock = 0; /*sss myProcess—>pr_CurrentDir; */ 
while (arge >= 2) { 
wbArg.wa_Name = argv[1]; 
PrintS("Showing file "); Prints (wbArg.wa_Name) ; Prints(" ."); 
main0O( &wbArg) ; 
Prints("\n"); 
arge——; argv = sargv[{1]; 


] 

} 
CloseLibrary(GfxBase) : 
CloseLibrary (IconBase) ; 
exit(0); 

} 








Nov 10 17:18 1988 


IFF_source/bmprintc.c Page 1 





aa */ 
7 */ 
/* bmprintc.c xf 
/* */ 
/* print out a C-language representation of data for bitmap */ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. xf 
/* This software is in the public domain. */ 
/* */ 
/7* This version for the Commodore-Amiga computer. *f 
/* Cleaned up and modified a bit by Chuck McManis, Aug 1988 «f/f 
* x 
an " 
#include <iff/intuall .h> 
#undef NULL 
#include <stdio.h> 
#define NO 0 
#define YES 1 


static BOOL docCRLF; 


void 
PrCRLF( fp) 
FILE *fp; 
{ 
if (doCRLF) 
fprintf(fp, "Sctc", OxD, OxA); 
else 
fprintf(fp, "\n"); 
} 
void 


PrintBob(bm, fp, name) 


struct BitMap *bm; 


FILE *fp; 

UBYTE *name; 

register UWORD *wp; /* Pointer to the bitmap data */ 

short. p,i,j,nb; /* temporaries */ 

short nwords = (bm—>BytesPerRow/2)*bm—->Rows; 

fprintf(fp, "/*t-~---- bitmap : w = %ld, h = %ld ----— */", 
bm->BytesPerRow*8, bm->Rows); 

PrCRLF (fp); 


for (p = 0; p < bm->Depth; +tp) [ 
wp = (UWORD *)bm—>Planes[p]; 


/* For each bit plane */ 


fprintf{(fp, "/*-————— plane # %ld: ----——--*/", p); 

PYCRLF( fp); 

fprintf(fp, "UWORD %s%c[%ld] = { ", name, (p?('O'+p):' '), nwords); 

PrCRLF( fp); 

for (j = 0; j < bm->Rows; j++, wp += (bm->BytesPerRow >> 1)) { 
fprintf(fp, " "); 


for (nb = 0; nb < (bm—->BytesPerRow) >> 1; nbt+) 
fprintf(fp, "Ox04x,", *(wptnb)); 
if (bm—->BytesPerRow <= 6) [ 
fprintf(fp, "\t/* "); 
for (nb = 0; nb < (bm->BytesPerRow) >> 1; 
for (i=0, ; i<l6; i++) 
fprintf(fp, "Sc", 
((¢(*(wptnb)>>(15-i))&1) 7? '*! 
fprintf(fp, " */"); 


nb++) 
ty): 


} 
PrCRLF( fp); 


9@T - I 








Nov 10 17:18 1988 IFF_source/bmprintc.c Page 2 


} 
fprintf(fp," yi")e 


PrcRLF (fp); 
} 
static char 


uw .006"; 
void 


PSprite(bm, fp, name, p, dohead) 


sp_colors[4] = 


struct BitMap *bm; 

FILE *fp; 

UBYTE *name; 

int Pp; 

BOOL dohead ; 

{ 

UWORD *wp0, *wpl; /* Pointer temporaries */ 

short i, j, nwords, /7* Counter temporaries */ 
color; /* pixel color */ 

short wplen = bm—->BytesPerRow/2; 

nwords = 2*bm->Rows + (dohead?4:0); 


wp0 = (UWORD *)bm->Planes [p]; 
wpl = 


(UWORD *)bm->Planes[p+1] ; 
fprintf(fp, "UWORD %s[%ld] = {", name, nwords) ; 
PrCRLF (fp); 


if, (dohead) { 
fprintf(fp," 
PrCRLF( fp); 


0x0000, 0x0000, /* VStart, VStop */"); 


} 

for (j=0 ; 3 < bm->Rows; j++) [ 
fprintf(fp, " 0x%04x, 0x304x", *wpO, *wpl); 
if (dohead || (j != bm->Rows~1)) { 


fprintf(fp, ",")i 


} 

fprintf(fp, "\t/* "); 

for (i = 0; i < 16; i++) { 
color = ((*wpl >> (14-i)) & 2) + ((*wp0 >> (15~i)) & 1); 
fprintf(fp, "se", sp_colors[color]); 


J 
fprintf£(fp," 


*/")i 
PrCRLF( fp); 
wpO0 += wplen; 
wpl += wplen; 
} 
if (dohead) . 
fprintf(fp, "  0x0000, 0x0000 }; /* End of Sprite ef"); 
else 
fprintf(fp," 3"); 
PrCRLF(fp); 
PrCRLF(fp) ; 


} 


void 
PrintSprite(bm, fp, name, attach, dohdr) 


struct BitMap *bm; 
FILE *fp; 
UBYTE *name ; 
BOOL attach, 
dohdr; 


fprintf(fp,"/*-—--—— Sprite format: h = 81d ————~ */", bm->Rows) ; 


PrCRLF (fp) ; 


if (bm->Depth > 1) { 
fprintf(fp, 
PYCRLF( fp); 
PSprite(bm, fp, name, 0, dohdr); 


f YG 


“/*x--Sprite containing lower order two planes: 


~ [Nov 10 17:18 1988 


IFF_source/bmprintc.c Page 3 


} 
if (attach && (bm->Depth > 3) ) { 


streat(name, "1"); 
fprintf(fp, "/*--Sprite containing higher order two planes: af"); 
PrCRLF (fp); 
PSprite(bm, fp, name, 2, dohdr); 
} 
} 
#define BOB 0 


#define SPRITE 1 


void 
BMPrintCRep(bm, fp, name, fmt) 


struct BitMap *bm; /* Contains the image data */ 
FILE *fp; /* file we will write to */ 
UBYTE *name; /* name associated with the bitmap */ 
UBYTE *fmt; /* string of characters describing output fmt*/ 
{ 
BOOL attach, doHdr; 
char c; 
SHORT type; 
doCRLF = NO; 
doHdr = YES; 
type = BOB; 
attach = NO; 
while ( (c=*fmtt+) != 0 ) 
switch (c) { 
case 'b': 
type = BOB; 
break; 
case 's': 
type = SPRITE; 
attach = NO; 
break; 
case 'a': 
type = SPRITE; 
attach = YES; 
break; 
case 'n': 
doHdr = NO; 
break; 
case ‘c!': 
doCRLF = YES; 
break; 
} 
switch(type) { 
case BOB: 
PrintBob(bm, fp, name); 
break; 


case SPRITE: 
PrintSprite(bm, fp, name, attach, doHdr); 
break; 











4@T - IT 


Nov 10 17:18 1988 IFF_source/dUnpack.c Page 1 


/7* DUnpack.c -—- Fibonacci Delta decompression by Steve Hayes */ 
#include <exec/types.h> 


/* Fibonacci delta encoding for sound data */ 


BYTE codeToDelta[16] = {-34,-21,-13,-8,-5,-3,-2,-1,0,1,2,3,5,8,13,21}; 


/* Unpack Fibonacci-delta encoded data from n byte source 
* buffer into 2*n byte dest buffer, given initial data 
* value x: It returns the lats data value x so you can 
* call it several times to incrementally decompress the data. 


*/ 


BYTE DlUnpack(source,n,dest,x) 
BYTE source[{], dest[]; 

LONG nj; 

BYTE x; 


( 
BYTE d; 
LONG i, lim; 


lim=n << 1; 
for (i=0; i < lim; ++i) 


u Decode a data nibble, high nibble then low nibble */ 
d = source[i >> 1]; /* get a pair of nibbles */ 


if (i @& 1) /* select low or high nibble */ 
d &= Oxf; /* mask to get the low nibble */ 
else 
d >= 4; 7* shift to get the high nibble */ 
x += codeToDelta [dl /* add in the decoded delta */ 
dest[i] = /7* store a 1 byte sample */ 
return(xX); 


/7* Unpack Fibonacci~delta encoded data from n byte 
* source buffer into 2*(n-2) byte dest buffer. 
* Source buffer has a pad byte, an 8-bit initial 
* value, followed by n-2 bytes comprising. 2*(n-2) 
x 4-bit encoded samples. 
*/ 


void DUnpack(source, n, dest) 
BYTE source[], dest[]; 
LONG n; 


D1Unpack(sourcet2, n-2, dest, source[1]); 








Nov 10 17:18 1988 IFF_source/gio.c Page 1 


/* tm A A AI I AA A A A A * 
/* GIO.C Generic I/O Speed Up Package 1/23/86 */ 
/* See GI0Call.c for an example of usage. */ 
/* Read not speeded-up yet. Only one Write file buffered at a time. */ 
7* Note: The speed-up provided is ONLY significant for code such as IFF */ 
/7* which does numerous small Writes and Seeks. */ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/* This software is in the public domain. */ 
/* */ 
7* This version for the Commodore-Amiga computer. x/ 
/* */ 
Pe ce cn en ee 





#include "iff/gio.h" /* See comments here for explanation.*/ 


#if GIO_ACTIVE 


#define local static 


local BPTR wFile 
local BYTE *wBuffer 
local LONG wNBytes 
local LONG wIndex 
local LONG wWaterline 


NULL; 
NULL; 
0; /* buffer size in bytes.*/ 
0; /* index of next available byte.*/ 
0; /* Count of # bytes to be written. 
* Different than wIndex because of GSeek.*/ 


fond oi ot 





Ween GOR cit 
LONG GOpen(filename, openmode) char *filename; LONG openmode; [ 
return( Open(filename, openmode) ); 





*-—----—--—— GClose ---- mn 


LONG GClose(file) BPTR file; { 
LONG signal = 0, signal2; 
if (file == wFile) 
signal = GWriteUndeclare( file) ; 
signal2 = Close(file); /* Call Close even if trouble with write.*/ 
if (signal2 < 0) 
signal = signal2; 
return( signal ); 





[hoa GREAd —*/ 
LONG GRead(file, buffer, nBytes) BPTR file; BYTE *buffer; LONG nBytes; [ 
LONG signal = 0; 
/* We don't yet read directly from the buffer, so flush it to disk and 
* let the DOS fetch it back. */ 
if (file == wFile) 
signal = GWriteFlush( file) ; 
if (signal >= 0) 
signal = Read(file, buffer, nBytes); 
return( signal ); 


[Ro GWE CEB LUST mm */ 
LONG GWriteFlush(file) BPTR file; [ 
LONG gWrite = 0; 
if (wFile {= NULL && wBuffer != NULL && WwiIndex > 0) 
gWrite = Write(wFile, wBuffer, wWaterline); 
wWaterline = windex = 0; /* No matter what, make sure this happens.*/ 
return( gWrite ); 





GW CODEC) aA i KF 
LONG GWriteDeclare(file, buffer, nBytes) 

BPTR file; BYTE *buffer; LONG nBytes; { 

LONG gWrite = GWriteFlush(wFile); /* Finish any existing usage.*/ 

if ( file=-=NULL || (file==wFile ss buffer==NULL) nBytes<=3) { 


eeT —-I 





Nov 10 17:18 1988 IFF_source/gio.c Page 2 


wFile = NULL; 
else { 

wFile = file; 
return ( gWrite ); 


wBuffer 


i 
"1 


NULL; wNBytes 0; } 


wBuffer = buffer; wNBytes = nBytes; } 


IR SW x/ 
LONG GWrite(file, buffer, nBytes) BPTR file; BYTE *buffer; LONG nBytes; [ 
LONG gWrite = 0; 


if (file == wFile 6& wBuffer != NULL) { 
if (wNBytes >= wIndex + nBytes) [{ 
/* Append to wBuffer.*/ 
movmem(buffer, wBuffertwIndex, nBytes) ; 
wiIndex += nBytes; 
if (wIndex > wWaterline) 
wWaterline = windex; 
nBytes = 0; /* Indicate data has been swallowed.*/ 
} 


else { 
wWaterline » wIndex; /* We are about to overwrite any 
x data above wIndex, up to at least the buffer end.*/ 
gWrite = GWriteFlush(file); /* Write data out in proper order.*/ 
J 


} 
if (nBytes > 0 && gWrite >= 0) 

gWrite += Write(file, buffer, nBytes); 
return( gWrite ); 


[* ~~-------- GSeek -——-~ 
LONG GSeek(file, position, mode) 
BPTR file; LONG position; 
LONG gSeek = —2; 
LONG newWIndex = wIndex + position; 


——. ——% f 
LONG mode; [{ 


if (file == wFile «&& wBuffer != NULL) { 

if (mode == OFFSET_CURRENT && 
newWIndex >= 0 && newWIndex <= wWaterline) { 
gSeek = wiIndex; /* Okay; return *OLD* position */ 
windex = newWIndex; 
J} 

else { . 
/* We don't even try to optimize the other cases.*/ 
gSeek = GWriteFlush(file); 
if (gSeek >= 0) gSeek = -2; /* OK so far */ 
} 


} 
if (gSeek == -2) 

gSeek = Seek(file, position, mode); 
return( gSeek ); 


#else /* not GIO_ACTIVE */ 


void GroDunmy() { } 
#endif GIO_ACTIVE 


/* to keep the compiler happy */ 


$$ 








Nov 10 17:18 1988 IFF_source/giocall.c Page 1 








OR ee cr era */ 
/* GIOCall.c: An example of calling the Generic I/O Speed-up. */ 
/* 1/23/86 x/ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. «/ 
7* This software is in the public domain. x/ 
x */ 
/* This version for the Commodore-Amiga computer. */ 
/* */ 
OR x/ 
main(...) { 
LONG file; 


int success; 


success = (0 != (file = GOpen(...))); 
/* A TmpRas is a good buffer to use for a variety of short-term uses.*/ 
if (success) 
success = PutObject(file, ob, tmpRas.RasPtr, tmpRas.Size); 
success &= (0 <= GClose(file)); 


/*----— PutObject writes a DVCS object out as a disk file.----—--*/ 
BOOL PutObject(file, ob, buffer, bufsize) 
LONG file; struct Object *ob; BYTE *buffer; 
int success = TRUE; 


LONG bufsize; { 


if (bufsize > 2*BODY_BUFSIZE) { 
/* Give buffer to speed-up writing.*/ 
GWriteDeclare(file, buffer+BODY_BUFSIZE, bufsize-BODY_BUFSIZE) ; 
bufsize = BODY BUFSIZE; /* Used by PutObject for other purposes.*/ 


, /* Use GWrite and GSeek instead of Write and Seek.*/ 
success &= (0 <= GWrite(file, address, length)); 


success &= (0 <= GWriteUndeclare(file)); 
/7* Release the speed-up buffer.*/ 
/* This is not necessary if GClose is used to close the file, 
* but it can't hurt.*/ 
return( (BOOL)success ); 








6cT — I 








Nov 10 17:18 1988 IFF_source/iffr.c Page 1 


YOR nt a 


* IFFR.C Support routines for reading IFF~-85 files. 1/23/86 
(IFF is Interchange Format File.) 


By Jerry Morrison and Steve Shaw, Electronic Arts. 
This software is in the public domain. 


This version for the Commodore~Amiga computer. 


Uses "gio". 
in gio.h. 
a rence ff 
#include "iff/gio.h" 

#tinclude "iff/iff.h" 


Either link with gio.c, or set the GIO_ACTIVE flag to 0 


+ + HH OH 


ft - Private subroutine FileLength() —-----------------------------—— */ 
/* Returns the length of the file or else a negative IFFP error code 

* (NO_FILE or DOS_ERROR). AmigaDOS-specific implementation. 

* SIDE EFFECT: Thanks to AmigaDOS, we have to change the file's position 

x to find its length. 

* Now if Amiga DOS maintained fh_End, we'd just do this: 

* fileLength = (FileHandle *)BADDR(file)~>fh_End; */ 
LONG FileLength(file) BPTR file; 

LONG fileLength = NO_FILE; 


if (file > 0) 
GSeek(file, 0, OFFSET_END); /7* Seek to end of file.*/ 
fileLength = GSeek(file, 0, OFFSET CURRENT) ; 
/* Returns position BEFORE the seek, which is #bytes in file. */ 
if (fileLength < 0) 


fileLength = DOS_ERROR; 7* DOS being absurd.*/ 





return (fileLength) ; 

J 
[Ro REAQ —m ar a «/ 
[* soto OpenRIFF ---~~~---—- a 


IFFP OpenRIFF(fileO, new0, clientFrame) 
BPTR filed; GroupContext *new0; 
register BPTR file = file0; 
register GroupContext *new = new0; 
IFFP iffp = IFF_OKAY; 


ClientFrame *clientFrame; { 


new—>ckHdr.ckID 
new~>ckHdr.ckSize 


new->parent = NULL; 7* “whole file" has no parent.*/ 
new—>clientFrame = client¥rame; 

new->file = file; 

new->position = 0; 


new~>subtype NULL_CHUNK; 
new->bytesSoFar 0; 


Hol 


/* Set new->bound and go to the file's beginning. */ 
new—>bound = FileLength( file); 
if (new->bound < 0) 
iffp = new->bound; * File system error! */ 
else if ( new->bound ¢ sizeof(ChunkHeader) ) 
iffp = NOT_IFF; /* Too small for an IFF file. */ 
else 
GSeek(file, 0, OFFSET_BEGINNING); /* Go to file start. */ 
return(iffp); 
} 


L® TTT TTT COP eM RG LOU Wr 
IFFP OpenRGroup(parent0O, new0) GroupContext *parentO, *new0; [ 
register GroupContext *parent = parent0; 
register GroupContext *new = new0; 
IFFP iffp = IFF_OKAY; 














Nov 10 17:18 1988 


IFF_source/iffr.c Page 2 


parent; 


new~>parent . 
parent—>clientFrame; 


new->clientFrame 


new—>file parent—>file;_ 
new-—>position parent—>position; 
new->bound parent—>position + ChunkMoreBytes (parent) ; 


NULL_CHUNK; 
0; 


new—>ckHdr.ckID 
new~>ckHdr.ckSize 


new—>subtype 
new->bytesSoFar 


It et dboadea 


Wii 


if ( new->bound > parent~>bound | | IS_ODD(new->bound) ) 
iffp = BAD_IFF; 


return(iffp); 


, a CLOSERG OUP mr a */ 
IFFP CloseRGroup(context) GroupContext. *context; [ 
register LONG position; 


if (context->parent == NULL) [{ 
} /* Context for whole file.*/ 
else { 
position = context-—>position; ; 
context—>parent—>bytesSoFar += position — context->parent—>position; 
context—>parent—>position = position; 


} 
return (IFF_ OKAY) ; 
} 


{* —OOO SKA PEW mr oe */ 
* Skip over bytes in a context. Won't go backwards. */ 
/* Updates context~>position but not context—>bytesSoFar.*/ 
/7* This implementation is AmigaDOS specific.*/ 
IFFP SkipFwd(context, bytes) GroupContext *context; 
IFFP iffp = IFF_OKAY; 


LONG bytes; { 


if (bytes > 0) f{ 
if (-l == GSeek(context->file, bytes, OFFSET_CURRENT) ) 
iffp = BAD_IFF; 7* Ran out of bytes before chunk complete. */ 
else 
context—>position += bytes; 


} 
return(iffp); 
} 


* oo «~GetChunkHdr -----~ 
ID GetChunkHdr(context0) GroupContext. *contextO; f{ 
register GroupContext *context = context0; 
register IFFP iffp; 
LONG remaining; 


/* Skip remainder of previous chunk & padding. */ 
iffp = SkipFwd(context, 

ChunkMoreBytes (context) + IS_ODD(context—>ckHdr.ckSize) ) ; 
CheckIFFP(); 


/* Set up to read the new header. */ ; 
context—>ckHdr.ckID = BAD_IFF; /* Until we know it's okay, mark it BAD.*/ 
context—>subtype = NULL CHUNK; 

context—>bytesSoFar = 0; 





/7* Generate a psuedo-chunk if at end-of-context. xf 

remaining = context—>bound — context->position; 

if (remaining == 0) [{ 
context—>ckHdr. ckSize 
context—>ckHdr.ckID 
) 


/* BAD_IFF if not enough bytes in the context for a ChunkHeader.*/ 
else if (sizeof(ChunkHeader) > remaining) { 


0; 
END MARK; 


1 oi 








oct - 1 


Nov 10 17:18 1988 IFF_source/iffr.c Page 3 


context—>ckHdr.ckSize = remaining; 


/* Read the chunk header (finally). */ 
else { 
switch ( 

GRead(context->file, (BYTE *)&context—>ckHdr, sizeof (ChunkHeader) ) 
rf 
case -l: return(context—>ckHdr.ckID = DOS_ERROR) ; 
case 0: return(context~>ckHdr.ckID = BAD_IFF); 

} 


/* Check: Top level chunk must be LIST or FORM or CAT. */ 
if (context->parent == NULL) 
switch(context—>ckHdr.ckID) { 
case FORM: case LIST: case CAT: break; 
default: return (context—>ckHdr.ckID = NOT_IFF); 
} 


/7* Update the context. */ 
context~>position += sizeof (ChunkHeader) ; 
remaining -= sizeof (ChunkHeader) ; 


/* Non-positive ID values are illegal and used for error codes.*/ 
/* We could check for other illegal IDs...*/ 
if (context->ckHdr.ckID <= 0) 

context—>ckHdr.ckID = BAD_IFF; 


/* Check: ckSize negative or larger than # bytes left in context? «f/f 
else if {context->ckHdr.ckSize <0 || 
context->ckHdr.ckSize > remaining) { 
context—>ckHdr.ckSize = remaining; 
context~>ckHdr.ckID = BAD_IFF; 
} 


/7* Butomatically read the LIST, FORM, PROP, or CAT subtype ID */ 
else switch (context—>ckHdr.ckID) f{ 
case LIST: case FORM: case PROP: 
iffp = IFFReadBytes(context, 
(BYTE *)&context—>subtype, 
sizeof (ID)); 
if (iffp != IFF_OKAY) 
context->ckHdr.ckID = iffp; 
break; } 


case CAT: { 


} 
return(context—>ckHdr.ckID); 


f* TT LBFREAUBYt CS */ 


IFFP IFFReadBytes(context, buffer, nBytes) 
GroupContext *context; BYTE *buffer; 
register IFFP iffp = IFF_OKAY; 


LONG nBytes; { 


if (nBytes < 0) 
iffp = CLIENT_ERROR; 
else if (nBytes > ChunkMoreBytes(context) ) 
iffp = SHORT_CHUNK; 
else if (nBytes > 0) 
switch ( GRead(context->file, buffer, nBytes) ) { 


case -1: {iffp = DOS_ERROR; break; } 
ease 0: {iffp = BAD_IFF; break; } 
default: { 


context->position += nBytes; 
context—>bytesSoFar += nBytes; 


Nov 10 17:18 1988 





LL 


/ 
IFFP SkipGroup(context) 


IFFP ReadIFF(file, clientFrame) 


IFF_source/iffr.c Page 4 





return(iffp); 
} 


PR ma SK PGL OU */ 
GroupContext *context; {[ 
} /* Nothing to do, thanks to GetChunkHdr */ 


oe Read BP —---—~—--- */ 
BPTR file; ClientFrame *clientFrame; { 
/*CompilerBug register*/ IFFP iffp; 

GroupContext context; 


iffp = OpenRIFF(file, &context) ; 
context.clientFrame = clientFrame; 


if (iffp == IFF_OKAY) 
switch (iffp = GetChunkHdr(é&context)) [ 


case FORM: { iffp = (*clientFrame—>getForm) (&context); break; } 
case LIST: { iffp = (*clientFrame—>getList) (&context); break; } 
case CAT : { iffp = (*clientFrame~>getCat )(&context); break; } 


/7* default: Includes IFF_DONE, BAD_IFF, NOT_IFF... */ 
} 


CloseRGroup (&context); 


if (iffp > 0) 

iffp = NOT_IFF; 
return(iffp); 
} 


/* Make sure we don't return an ID.*/ 
/7* GetChunkHdr should've caught this.*/ 


[Rm REAL LL Sr */ 
IFFP ReadiIList (parent, clientFrame) 


GroupContext *parent; ClientFrame *clientFrame; [{ 
GroupContext listContext; 

IFFP iffp; 

BOOL propOk = TRUE; 


iffp = OpenRGroup(parent, &listContext); 
CheckIFFP(); 


/* One special case test lets us handle CATs as well as LISTs.*/ 
if (parent—>ckHdr.ckID == CAT) 

propok = FALSE; 
else 

listContext.clientFrame = clientFrame; 


do { 
switch (iffp = GetChunkHdr(élistContext)) { 
case PROP: 
if (propok) 
iffp = (*clientFrame—>getProp) (&listContext) ; 
else 
iffp = BAD_IFF; 
break; 
} 
case FORM: { iffp = (*clientFrame—>getForm) (&listContext); break; } 
case LIST: { iffp = (*clientFrame—getList) (&listContext); break; } 
case CAT : { iffp = (*clientFrame—>getCat )(&listContext); break; } 


/* default: Includes END_MARK, IFF_DONE, BAD_IFF, NOT_IFF... */ 
} 


if (listContext.ckHdr.ckID != PROP) 
propok = FALSE; 7* No PROPs allowed after this point.*/ 
} while (iffp == IFF_OKAY); 


CloseRGroup (&listContext) ; 
if (iffp > 0) 


iffp = BAD_IFF; 
return(iffp == END_MARK ? IFF_OKAY 


7* Only chunk types above are allowed in a LIST/CAT.*/ 
: iffp); 





T€T - I 


a 
* 


Nov 10 17:18 1988 IFF_source/iffr.c Page 5 


fiw READ LCA rrr * 
/* By special arrangement with the ReadIList implement'n, this is trivial.*/ 
IFFP ReadICat(parent) GroupContext *parent; 

return( ReadIList(parent, NULL) ); 


ft GetFChunkHdr ------ rn rr */ 
ID GetFChunkHdr (context) GroupContext *context; [{ 
register ID id; 


id = GetChunkHdr(context) ; 
if (id == PROP) 

context—>ckHdr.ckID = id = BAD_IFF; 
return(id); 


{tT GetF1LChunkHdr -——— rr af 
ID GetF1lChunkHdr (context) GroupContext *context; [ 

register ID id; 

register ClientFrame *clientFrame = context~>clientFrame; 


switch (id = GetChunkHdr(context)) { 


case PROP: { id = BAD_IFF; break; } 

case FORM: { id = (*clientFrame—>getForm) (context); break; } 
case LIST: { id = (*clientFrame~>getList) (context); break; } 
case CAT : { id = (*clientFrame—>getCat )(context); break;, } 


/* Default: let the caller handle other chunks */ 
} 
return(context—>ckHdr.ckID = id); 
} 
+ GetPChunkHdr --- rn rn KY 


D GetPChunkHdr (context) GroupContext *context; f{ 
register ID id; 


HK 


id = GetChunkHdr(context) ; 
switch (id) [ 


case LIST: case FORM: case PROP: case CAT: { 
id = context—>ckHdr.ckID = BAD_IFF; 
break; } 


return(id); 





Nov 10 17:18 1988 IFF_source/iffw.c Page 1 


IFFW.C Support routines for writing IFF-85 files. 
(IFF is Interchange Format File.) 


1/23/86 


By Jerry Morrison and Steve Shaw, Electronic Arts. 
This software is in the public domain. 


This version for the Commodore-Amiga computer. 
#include "iff/iff.h" 
#include “iff/gio.h" 


% 4 OE 


[on TRB WL GOD me xf 


7* A macro to test if a chunk size is definite, i.e. not szNotYetKnown.*/ 
#define Known(size) ( (size) != szNotYetKnown ) 


/* Yet another weird macro to make the source code simpler...*/ 
#define IfIffp(expr) {if (iffp == IFF_OKAY) iffp = (expr);} 


[8 mom OPEN aa */ 
IFFP OpenWIFF(file, new0, limit) 


register GroupContext *new = new0; 
register IFFP iffp = IFF_OKAY; 


new->parent = NULL; 

new->clientFrame = NULL; 

new—>file = file; 

new—>position = 0; 

new >bound = limit; 

new—>ckHdr.ckID = NULL_CHUNK; /* indicates no current chunk */ 


new->ckHdr.ckSize = new->bytesSoFar = 0; 


if (0 > Seek(file, 0, OFFSET_BEGINNING) ) /* Go to start of the file 
iffp = DOS_ERROR; 

else if ( Known(limit) && IS_ODD(limit) ) 
iffp = CLIENT ERROR; 

return(iffp); 

} 


[eh -octe SEALE WG OUP rr or *f 
IFFP StartWGroup(parent, groupType, groupSize, subtype, new) 
GroupContext *parent, *new; ID groupType, subtype; LONG groupSize; 
register IFFP iffp; 


iffp = PutCkHdr(parent, groupType, groupSize); 

IfIffp( IFFWriteBytes(parent, (BYTE *)&subtype, sizeof(ID)) ); 
IfIffp( OpenWGroup(parent, new) ); 

return(iffp); 


{* ————~-—--— OpenWGroup ——----— a 
IFFP OpenWGroup(parent0, new0) GroupContext *parent0, *new0; { 

register GroupContext *parent = parent0; 

register GroupContext *new = new0; 

register LONG ckEnd; 


register IFFP iffp = IFF_OKAY; 


new—>parent 
new—>clientFrame 


parent; 
parent—>clientFrame; 


new—>file parent->file; 
new->position parent—>position; 
new->bound parent—>bound; 


new—>ckHdr. ckID 
new—>ckHdr.ckSize 


NULL_CHUNK ; 
new-—>bytesSoFar = 0; 


ang i pea d 


if ( Known(parent—>ckHdr.ckSize) ) [{ 
ckEnd = new->position + ChunkMoreBytes(parent) ; 


BPTR file; GroupContext *new0; LONG limit; { 


*f 


{ 





cet — 1 


Nov 10 17:18 1988 IFF_source/iffw.c Page 2 


if ( new->bound == szNotYetKnown | | new->bound > ckEnd ) 
new->bound = ckEnd; 


f 


if ( parent—>ckHdr.ckID == NULL_CHUNK || /* not currently writing a chunk*/ 
IS _ODD(new->position) | | 
(Known(new->bound) && IS_ODD(new—>bound)) ) 
iffp = CLIENT_ERROR; 
return(iffp); 


} 


[* -77--—-- «~CloseWGroup —~—— 
TFFP CloseWGroup(old0) GroupContext *old0; { 
register GroupContext *old = old0; 
IFFP iffp = IFF_OKAY; 





if, ( old->ckHdr.ckID != NULL_CHUNK ) 
iffp = CLIENT_ERROR; 

else if ( old->parent == NULL ) { 
if (GWriteFlush(old->file) < 0) 
} 

else [ /* update parent context */ 
old->parent—>bytesSoFar += old—>position — old->parent—>position; 
old->parent->position = old->position; 


/* didn't close the last chunk */ 


/* top level file context */ 
iffp = DOS_ERROR; 


he 
return(iffp); 


[Ra EndWGroup —-~~7~~~—— 

TFFP EndWGroup(old) GroupContext *old; [ 
register GroupContext *parent = old->parent ; 
register IFFP iffp; 


iffp = CloseWGroup(old) ; 
IfIffp( PutCkEnd(parent) ); 
return(iffp); 


fh -o PUCK a *f 
IFFP PutCk(context, ckID, ckSize, data) 
GroupContext *context; ID ckID; LONG ckSize; BYTE *data; [ 
register IFFP iffp = IFF_OKAY; 


if ( ckSize == szNotYetKnown ) 

iffp = CLIENT_ERROR; 
Iflffp( PutCkHdr(context, ckID, ckSize) ); 
IfIffp( IFFWriteBytes(context, data, ekSize) ); 
Ififfp( PutckEnd(context) ); 
return(iffp); 


[RO PUL CK oa I I */ 
TFFP PutCkHdr(context0, ckID, ckSize) 
GroupContext *context0; ID ckID; LONG ckSize; [ 
register GroupContext *context = context; 


LONG minPSize = sizeof(ChunkHeader); /* physical chunk >= minPSize bytes*/ 


/* CLIENT_ERROR if we're already inside a chunk or asked to write 

* other than one FORM, LIST, or CAT at the top level of a file */ 
/* Also, non-positive ID values are illegal and used for error codes.*/ 
7* (We could check for other illegal IDs. ..)*/ 


if ( context~>ckHdr.ckID != NULL_CHUNK [| ckID <= 0 ) 
return(CLIENT_ERROR) ; : 
else if (context—>parent == NULL) {[{ 
switch (ckID) { 
case FORM: case LIST: case CAT: break; 


@efault: return(CLIENT_ERROR); 


if (context—>position != 0) 


Nov 10 17:18 1988 IFF_source/iffw.c Page 3 


return (CLIENT_ERROR) ; 
} 


if ( Known(ckSize) ) { 
if ( ckSize < 0 ) 
return (CLIENT_ERROR) ; 
minPSize += ckSize; 
li 
if ( Known(context—>bound) && 
context->position + minPSize > context—>bound ) 
return (CLIENT_ERROR) ; 


context->ckHdr.ckID = ckID; 
context—>ckHdr.ckSize = ckSize; 
context—>bytesSoFar = 0; 


if (0 > 
GWrite(context->file, (BYTE *) &context—>ckHdr, sizeof (ChunkHeader) ) 
) 
return(DOS_ERROR) ; 

context->position += sizeof (ChunkHeader) ; 

return (IFF_OKAY) ; 


[ao LEE Wr LEB YS */ 
TFFP IFFWriteBytes(context0, data, nBytes) 
GroupContext *context0O; BYTE *data; LONG nBytes; { 
register GroupContext *xcontext = context0; 


if ( context->ckHdr.ckID == NULL_CHUNK {| 
nBytes <0 || /7* negative nBytes */ 
(Known(context—>bound) && /* overflow context */ 
context~>position + nBytes > context~>bound) 
(Known(context~>ckHdr.ckSize) && /* overflow chunk */ 
context—>bytesSoFfar + nBytes > context~>ckHdr.ckSize) ) 
return(CLIENT_ERROR) ; 


/7* not in a chunk */ 


if (0 > GWrite(context->file, data, nBytes)) 
return (DOS_ERROR) ; 


context—>bytesSoFar += nBytes; 
context->position += nBytes; 
return ( IFF_OKAY) ; 


Re PutckEnd --— 
LFFP PutCkEnd(context0) GroupContext *xcontexto; [ 
register GroupContext *xcontext = context0; 

WORD zero = 0; /7* padding source */ 





if ( context—>ckHdr.ckID == NULL_CHUNK ) /* not in a chunk */ 
return (CLIENT_ERROR) ; 


if ( context->ckHdr.ckSize == szNotYetKnown ) [ 
/* go back and set the chunk size to bytesSoFar */ 
if ( 0> 


GSeek(context->file, ~(context->bytesSoFar + sizeof(LONG)), OFFSET_CURRENT) | | 
0 > 

GWrite(context~>file, (BYTE *)acontext->bytesSoFar, sizeof (LONG) ) | 
0 > 


GSeek(context->file, context—>»bytesSoFar, OFFSET_CURRENT)  ) 
return (DOS_BRROR); 


} 
else { /* make sure the client wrote as many bytes as planned */ 
if ( context—>ckHdr.ckSize != context—>bytesSoFar ) 
return (CLIENT_ERROR) ; 
di 


/* Write a pad byte if needed to bring us up to an even boundary. 
Lo * Since the context end must be even, and since we haven't 





eect -— 1 





Nov 10 17:18 1988 IFF_source/iffw.c Page 4 


* overwritten the context, if we're on an odd position there must 
* be room for a pad byte. */ 
if ( IS_ODD(context—>bytesSoFar) ) [ 
if ( 0 > GWrite(context->file, (BYTE *)&zero, 1)-) 
return (DOS_ERROR); 
context~>position += 1; 
context—>ckHdr.ckID 


context~>ckHdr.ckSize 
return(IFF_OKAY) ; 
] 


NULL_CHUNK; 
context—>bytesSoFar = 0; 


oi 


Nov 10 17:18 1988 IFF_source/ilbmr.c Page 1 





GOR tn a * 


* ILBMR.C Support routines for reading ILBM files. 11/27/85 
* (IFF is Interchange Format File.) 

* 

* By Jerry Morrison and Steve Shaw, Electronic Arts. 

* This software is in the public domain. 

* 


* This version for the Commodore-Amiga computer. 

*-—-—--- we re */ 
#include "“iff/packer.h" 

#include "iff/ilbm.h" 








* —-----— GetCMAP —------~---- Fr */ 
/* pNColorRegs is passed in as a pointer to the number of ColorRegisters 
* caller has space to hold. GetCMAP sets to the number actually read.*/ 
IFFP GetCMAP(ilbmContext, colorMap, pNColorRegs) 
GroupContext *ilbmContext; WORD *colorMap; UBYTE *pNColorRegs; 


register int nColorRegs; 
register IFFP iffp; 
ColorRegister colorReg; 


nColorRegs = ilbmContext—>ckHdr.ckSize / sizeofColorRegister; 
if (*pNColorRegs < nColorRegs) nColorRegs = *pNColorRegs; 
*pNColorRegs = nColorRegs; /7* Set to the number actually there.*/ 


for (_; nColorRegs > 0; --nColorRegs) { 
iffp = IFFReadBytes(ilbmContext, (BYTE *)&colorReg,sizeofColorRegister) ; 
CheckIFFP( ) ; 
xcolorMapt+ = ( ( colorReg. red > 4) 8B) 
( ( colorReg.green >> 4 ) << 4 ) 
( ( colorReg.blue >> 4 ) i 


} 
return ( IFF_OKAY) ; 
} 





[*-—--------- GetBODY ~—~-~~~~-----~----—-----~--------- - + 
7* NOTE: This implementation could be a LOT faster if it used more of the 
* supplied buffer. It would make far fewer calls to IFFReadBytes (and 
* therefore to DOS Read) and to movemem. */ 
IFFP GetBODY(context, bitmap, mask, bmHdr, buffer, bufsize) 
GroupContext *context; struct BitMap *bitmap; BYTE *mask; 
BitMapHeader *bmHdr; BYTE *buffer; LONG bufsize; 
{ 
register IFFP iffp; 
UBYTE srcPlaneCnt = bmHdr->nPlanes; /7* Haven't counted for mask plane yet*/ 
WORD srcRowBytes = RowBytes(bmHdr->w) ; 
LONG bufRowBytes = MaxPackedSize(srcRowBytes) ; 
int nRows = bmHdr->h; 
Compression compression = bmHdr—>compression; 
register int iPlane, iRow, nEmpty; 
register WORD nFilled; 
BYTE *buf, *nullDest, *nullBuf, **pDest; 
BYTE *planes[MaxSrcPlanes]; /* array of ptrs to planes & mask */ 


if (compression > cmpByteRun1) 
return (CLIENT ERROR) ; 


/* Complain if client asked for a conversion GetBODY doesn't handle. */ 
if ( srcRowBytes != bitmap->BytesPerRow | | 
bufsize < bufRowBytes * 2 || 
srcPlaneCnt. > MaxSrePlanes ) 
return(CLIENT_ERROR) ; 


if (nRows > bitmap-—>Rows) 
nRows = bitmap—>Rows; 


/* Initialize array "planes" with bitmap ptrs; NULL in empty slots.*/ 





vet —1 





(Nov 10 17:18 1988 IFF_source/ilbmr.c Page 2 Nov 10 17:18 1988 IFF_source/ilbmr.c Page 3 


for (iPlane = 0; iplane < bitmap—>Depth; iPlanet+) if ( UnPackRow(&buf, pDest, nFilled, srcRowBytes) ) 
planes[iPlane}] = (BYTE *)bitmap—>Planes [iPlane] ; /* pSource, pDest, srcBytes, dstBytes *f 
for (; iPlane < MaxSrcPlanes; iPlanet+) return(BAD_FORM) ; 
planes[iPlane] = NULL; j 
J 
/* Copy any mask plane ptr into corresponding "planes" slot.*/ 
if (bmHdr—>masking == mskHasMask) { return (IFF_OKAY) ; 
if (mask != NULL) J 


planes[srePlaneCnt] = mask; /* If there are more srcPlanes than 
* dstPlanes, there will be NULL plane-pointers before this.*/ 
else 
planes[srePlaneCnt}] = NULL; /* In case more dstPlanes than sre. */ 
srcPlanecnt += 1; /* Include mask plane in count.*/ 


} 


/* Setup a sink for dummy destination of rows from unwanted planes. */ 
nullDest = buffer; 

buffer += srcRowBytes; 

bufsize -= srcRowBytes; 


/* Read the BODY contents into client's bitmap. 
* De-interleave planes and decompress rows. 
* MODIFIES: Last iteration modifies bufsize.*/ 
buf = buffer + bufsize; /* Buffer is currently empty.*/ 
for (iRow = nRows; iRow > 0; iRow——) { 
for (iPlane = 0; iPlane < srcPlaneCnt; iPlanet+) { 


pDest = &planes[iPlane] ; 


/* Establish a sink for any unwanted plane. */ 
if (*pDest == NULL) { 


nullBuf = nullDest; 

pDest = gnullBuf; 

} 
/* Read in at least enough bytes to uncompress next row.*/ 
n&mpty = buf — buffer; /* size of empty part of buffer.*/ 
nFilled = bufsize — nEmpty; 7* this part has data.*/ 


if (nFilled < bufRowBytes) [ 
/* Need to read more.*/ 





/* Move the existing data to the front of the buffer.*/ 
/* Now covers range buffer [0}..buffer[nPilled-1] .*/ 
movmem(buf, buffer, nFilled); /* Could be moving 0 bytes.*/ 





if (nEmpty > ChunkMoreBytes(context)) [ 
/* There aren't enough bytes left to fill the buffer.*/ 
nEmpty = ChunkMoreBytes(context) ; 
bufsize = nFilled + nEmpty; /* heh-heh */ 
} 
/* Append new data to the existing data.*/ 


iffp = IFFReadBytes (context, &buffer[nFilled], nEmpty); 
CheckIFFP(); 


buf = buffer; 
nFilled = bufsize; 
nEmpty = 0; 

} 


/* Copy uncompressed row to destination plane. */ 
if (compression == cmpNone) [ 
if (nFilled < srcRowBytes) return(BAD_FORM); 
movmem(buf, *pDest, srcRowBytes) ; 
buf += srcRowBytes; 
*xpDest += srcRowBytes; 


else 
/* Decompress row to destination plane.*/ 








Se€T —.I1 














Nov 10 17:18 1988 IFF_source/ilbmw.c Page 1 


[ Bom 


* ILBMW.C Support routines for writing ILBM files. 


* (IFF is Interchange Format File.) 
* 


1/23/86 


* By Jerry Morrison and Steve Shaw, Electronic Arts. 

* This software is in the public domain. 

* 

* This version for the Commodore-Amiga computer. 

Raa */ 
#include "iff/packer-h" 

#include "iff/ilbm.h" 


* 


/*--------—— _InitBMHdr -----~-------------------_-______-_____________—-+/ 
IFFP InitBMHdr(bmHdr0, bitmap, masking, compression, transparentColor, 
pageWidth, pageHeight) 

BitMapHeader *bmHdr0; struct BitMap *bitmap; 

WORD masking; /7* Masking */ 

WORD compression; /* Compression */ 

WORD transparentColor; /* UWORD */ 

WORD pageWidth, pageHeight; 

{ | 

register BitMapHeader *bmHdr = bmHdr0; 
register WORD rowBytes = bitmap—>BytesPerRow; 


bmidr—-—>w = rowBytes << 3; 

bmHdr->h = bitmap—>Rows; 

bmHdr->x = bmHdr->y = 0; /* Default position is (0,0).*/ 
bmHdr->nPlanes = bitmap—>Depth; 

bmHdr—->masking = masking; 

bmHdr—>compression = compression; 

bmHdr->padl = 0; 

bmHdr~>transparentColor = transparentColor; 


bmHdr—->xAspect = bmHdr->yAspect = 1; 
bmHdr—>pageWidth = pageWidth; 
bmHdr->pageHeight = pageHeight; 
if (pageWidth = 320) 
switch (pageHeight) { 
case 200: {bmHdr-—>xAspect = x320x200Aspect; 
bmHdr—->yAspect = y320x200Aspect; break; } 
case 400: {bmHdr->xAspect = x320x400Aspect; 
bmHdr—->yAspect = y320x400Aspect; break; } 
} 
else if (pageWidth = 640) 
switch (pageHeight) { 
case 200: {bmHdr->xAspect = x640x200Aspect ; 
bmHdr->yAspect. = y640x200Aspect; break; } 
case 400: {bmHdr-—>xAspect = x640x400Aspect; 
bmHdr->yAspect = y640x400Aspect; break; } 
} 
return( IS_ODD(rowBytes) ? CLIENT_ERROR : IFF_OKAY ); 
[Rm UE CMA 


IFFP PutCMAP(context, colorMap, depth) 
GroupContext *context; WORD *colorMap; UBYTE depth; 


register LONG nColorRegs; 
IFFP iffp; 
ColorRegister colorReg; 


if (depth > MaxAmDepth) 
nColorRegs = 1 <¢ depth; 


depth = MaxAmDepth; 


iffp = PutCkHdr(context, ID_CMAP, nColorRegs * sizeofColorRegister) ; 
CheckIFFP{); 


for { ; nColorRegs; --nColorRegs) [ 





Nov 10 17:18 1988 IFF_source/ilbmw.c Page 2 


colorReg. red = { *colorMap >> 4 ) & Oxf0; 

colorReg.green = ( *colorMap ) & Oxf0; 

colorReg.blue = ( *colorMap << 4 ) & Oxf0; 

iffp = IFFWriteBytes(context, (BYTE *)&colorReg; sizeofColorRegister) ; 
CheckIFFP(); 

++colorMap; 


iffp = PutCkEnd(context) ; 
return(iffp); 
] 


a on "7 


[t--- PutBODY —-~—~~------------~ = 
7* NOTE: This implementation could be a LOT faster if it used more of the 
* supplied buffer. It would make far fewer calls to IFFWriteBytes (and 

* therefore to DOS Write). */ 

IFFP PutBODY(context, bitmap, mask, bmHdr, buffer, bufsize) 
GroupContext *context; struct BitMap *bitmap; BYTE *mask; 
BitMapHeader *bmHdr; BYTE *buffer; LONG bufsize; 


IFFP iffp; 

LONG rowBytes = bitmap->BytesPerRow; 

int dstDepth = bmHdr->nPlanes; 

Compression compression = bmHdr—>compression; 

int planecnt; 7* number of bit planes including mask */ 
register int iPlane, iRow; 

register LONG packedRowBytes; 

BYTE *buf; 

BYTE *planes[MaxAmDepth + 1]; /* array of ptrs to planes & mask */ 


if ( bufsize < MaxPackedSize(rowBytes) | | /* Must buffer a comprsd row*/ 
compression > cmpByteRunl /* bad arg */ 
bitmap—>Rows != bmHdr->h /* inconsistent */ 
rowBytes != RowBytes(bmHdr—>w) | | * inconsistent*/ 
bitmap—>Depth ¢< dstDepth ia /* inconsistent */ 
dstDepth > MaxAmDepth ) /* too many for this routine*/ 


return (CLIENT_ERROR) ; 
planeCnt = dstDepth + (mask == NULL ? 0: 1); 


7* Copy the ptrs to bit & mask planes into local array "planes" */ 
for (iPlane = 0; iPlane < dstDepth; iPlanet++) 

planes[iPlane] = (BYTE *)bitmap—>Planes{iPlane] ; 
if (mask != NULL) 

planes[{dstDepth] = mask; 





7* Write out a BODY chunk header */ 
iffp = PutCkHdr(context, ID_BODY, szNotYetKnown) ; 
CheckIFFP (); 


/* Write out the BODY contents */ 
for (iRow = bmHdr->h; iRow > 0; iRow--) { 
for (iPlane = 0; iPlane < planeCnt; iPlanet+) { 


/* Write next row.*/ 

if (compression == cmpNone) { 
iffp = IFFWriteBytes(context, planes[iPlane], rowBytes); 
planes[{iPlane}] += rowBytes; 


/7* Compress and write next row.*/ 

else [ 
buf = buffer; 
packedRowBytes = PackRow(&planes[iPlane], &buf, rowBytes) ; 
iffp = IFFWriteBytes(context, buffer, packedRowBytes) ; 


} 
CheckIFFP(); 
} 















Nov 10 17:18 1988 





IFF_source/ilbmw.c Page 3 


Nov 10 17:18 1988 IFF_source/packer.c Page 1 


j i a RA a a 


, * packer.c Convert data to “ompByteRunl" run compression. 11/15/85 
/* Finish the chunk */ * 
iffp = PutCkEnd (context) ; * By Jerry Morrison and Steve Shaw, Electronic Arts. 
return (AEP); x This software is in the public domain. 
* 
* control bytes: 
* {O..127] : followed by n+l bytes of data. 
* [-1..-127} : followed by byte to be repeated (-n)+1 times. 
* -128 : NOOP. 


* 
* This version for the Commodore~Amiga computer. 


Ae nt AT at 


#include "iff/packer:h" 





#define DUMP 0 
#define RUN 1 


#tdefine MinRun 3 
#define MaxRun 128 
#define MaxDat 128 


LONG putSize; 
#define GetByte() (*sourcet++) 
#define PutByte(c) { *dest++ = (c); ++putSize; } 


char buf[256]; /* [TBD] should be 128? on stack?*/ 


BYTE *PutDump(dest, nn) BYTE *dest; int nn; [ 
int i; 


PutByte(nn-1) ; 
for(i = 0; ai < nn; i++) PutByte(buf[i]); 
return(dest); 


9€T — I 


BYTE *PutRun(dest, nn, cc) BYTE *dest; int nn, cc; [{ 
PutByte(—-(nn-1)); 
PutByte(cc) ; 
return(dest); 


#define OutDump (nn) dest = PutDump(dest, nn) 
#define OutRun(nn,cc) dest = PutRun(dest, nn, cc) 





[rman PACK ROW «xf 
/* Given POINTERS TO POINTERS, packs one row, updating the source and 
destination pointers. RETURNs count of packed bytes.*/ 
LONG PackRow(pSource, pDest, rowSize) 
BYTE **pSource, **pDest; LONG rowSize; [ 
BYTE *source, *dest; 
char c,laste = '\0'; 
BOOL mode = DUMP; 
short nbuf = 0; /7* number of chars in buffer */ 
short rstart = 0; /* buffer index current run starts xf 


source = *pSource; 
dest = *pDest; 


putSize = 0; 

buf[0] = laste = ¢ = GetByte(); /* so have valid lastc */ 
nbuf = 1; rowSsize—j; /* since one byte eaten.*/ 

for (; rowSize; --rowSize) { 


buf [nbuf++] = c = GetByte(); 
switch (mode) [{ 
case DUMP: 
L /* If. the buffer is full, write the length byte, 





then the data */ 










Let - 1 








Nov 10 17:18 1988 IFF_source/packer.c Page 2 


if (nbuf>MaxDat) { 
OutDump(nbuf-1); 
buf[0] = oc; 
nbuf = 1; rstart = 0; 
break; 


if (c == laste) { 
if (nbuf-rstart >= MinRun) { 
if (rstart > 0) OutDump(rstart); 
mode = RUN; 


} 

else if (rstart == 0) 
mode = RUN; 7* no dump in progress, 
so can't lose by making these 2 a run.*/ 


} 
else rstart = nbuf-l; 
break; 


/* first of run */ 


case RUN: if ( (c != laste)||{ ( nbuf-rstart > MaxRun)) { 
/7* output run */ 
OutRun(nbuf~1l-rstart, laste) ; 
buf [0] = c; 
nbuf = 1; rstart = 0; 
mode = DUMP; 
} 
break; 


} 


laste = c; 


switch (mode) [ 
case DUMP: OutDump(nbuf); break; 
gase RUN: OutRun(nbuf-rstart,lastc); break; 
*pSource = source; 
*pDest = dest; 
return(putSize); 




















Nov 10 17:18 1988 IFF_source/putpict.c Page 1 


[*k putpict.c REKEKRERREREEERRR EKER ERE KERR KKK KEKE KEKE KAERERK / 


/* PutPict(). Given a BitMap and a color map in RAM on the */ 
7* Amiga, outputs as an ILBM. See /iff/ilbm.h & /iff/ilbmw.c. */ 
/* 23-Jan-86 x/ 
/* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/* This software is in the public domain. */ 
/* x 
/* This version for the Commodore-Amiga computer. */ 
* xf 


DIGOIOIO CIID IIIIDISIITGIIOITIOIICI IIIT IOI IO IIIT IAAI. 
#include “iff/intuall.h" 

#include "iff/gio.h" 

#tinclude "iff/ilbm.h" 

#include "iff/putpict.h" 


#define MaxDepth 5 
static IFFP ifferror = 0; 


#define CkErr(expression) {if (ifferror == IFF_OKAY) ifferror = (expression) ;} 
[RRR RRR HIKER RIKKI R IER IIR IK IRAE RRR ARK RR IRKERIRIRIK ERIK RIOR IKI RIKER K / 
7* IffErr */ 
* xf 
/* Returns the iff error code and resets it to zero */ 
* * 


RRR KIK KERR ERK KR IR KERR KERIKERI KKK KKK HK KHER KR AK HR IER KRENEK KIER RRR IKK RIK RIK IRE 
IFFP IffErr() 

IFFP i; 

1 = ifferror; 


ifferror = 0; 
return(i); 


LI IR II TOI IIR II III IR IIR IKK IIR KIKI TK IIR IRI IRR RIK IR IRI IIR IIR IR IRI IKK / 


/* PutPict() */ 
[* */ 
/* Put a picture into an IFF file */ 
/* Pass in mask == NULL for no mask. . x/ 
f* */ 
/* Buffer should be big enough for one packed scan line */ 
/* Buffer used as temporary storage to speed-up writing. x/ 
/* A large buffer, say 8KB, is useful for minimizing Write and Seek calls. */ 
/* (See /iff/gio.h & /iff/gio.c). x/ 


[RRR RI RIKI IIR RRR RR IIHR IIIT RII IR IKK IKK IKI RRR IR IK IIR IRI KIER ERIR IKI KICK / 


BOOL PutPict(file, bm, pageW, pageH, colorMap, buffer, bufsize) 
LONG file; struct BitMap *bm; 
WORD pageW, pageH; 
WORD *colorMap; 
BYTE *buffer; LONG bufsize; 


{ 
BitMapHeader bmHdr; 
GroupContext fileContext, formContext; 


ifferror = InitBMHdr(&bmHdr, 
mskNone, 
cmpByteRun1 , 


pageW, 
pageH ); 


/* use buffered write for speedup, if it is big-enough for both 
* PutBODY's buffer and a gio buffer.*/ 
#define BODY_BUFSIZE 512 
if (ifferror == IFF_OKAY && bufsize > 2*BODY_BUFSIZE) { 
if (GWriteDeclare(file, buffer+BODY_BUFSIZE, bufsize-BODY BUFSIZE) < 0) 











get —I 








Nov 10 17:18 1988 IFF_source/putpict.c Page 2 


ifferror = DOS_ERROR; 
BODY_BUFSIZE; 


bufsize = 


} 


CkErr(OpenWIFF(file, sfileContext, szNotYetKnown) ); 
ckErr(StartwWGroup(&fileContext, FORM, szNotYetKnown, ID ILBM, &formContext) ); 


cCkErr(PutCk(&formContext, ID_BMHD, sizeof (BitMapHeader), (BYTE *)&bmHdr)); 
if (colorMap!=NULL) 

CkErr( PutCMAP(&formContext, colorMap, (UBYTE)bm->Depth) ); 
CkErr( PutBODY(&formContext, bm, NULL, «bmHdr, buffer, bufsize) ); 


ckErr( EndWGroup(&formContext) ); 
CkErr( CloseWGroup(&fileContext) ); 


if (GWriteUndeclare(file) < 0 && ifferror == IFF_OKAY) 
ifferror = DOS_ERROR; 
return( (BOOL)(ifferror != IFF_OKAY) ); 


} 


[Nov 10 17:18 1988 IFF_source/readpict.c Page 1 


/** ReadPict.c FOI GIGI ICICI IG III IOI IOI OI ICICI IOI RIOT IT IK IK IAAI II III 
* 

Read an ILBM raster image file. 23-Jan-86. 

By Jerry Morrison, Steve Shaw, and Steve Hayes, Electronic Arts. 

This software is in. the public domain. 


USE THIS AS AN EXAMPLE PROGRAM FOR AN IFF READER. 


The IFF reader portion is essentially a recursive-descent parser. 


* 
* 
* 
* 
* 
* 
* 
* 
SOIC ICI II GIGI ICICI IIIT CIOI OI ICI ICICI III IOS IITA IAI IIT III IT III ISI II SAI I III 


#define LOCAL static 


#include 


"iff/intuall.h" 
#include "libraries/dos.h”" 
#include "libraries/dosextens.h" 
finclude "“iff/ilbm.h" 
#include "iff/readpict.h" 


/* This example's max number of planes in-a bitmap. Could use MaxAmDepth. */ 
#define EXDepth 5 

#define maxColorReg (1<<EXDepth) 

#define MIN(a,b) ((a)<(b)?(a)=:(b)) 


#tdefine SafeFreeMem(p,q) {if£(p)FreeMem(p,q);} 


/* Define the size of a temporary buffer used in unscrambling the ILBM rows.*/ 
#tdefine bufSz 512 





[tO LLBM LAr mm «/ 
/* ILBMFrame is our "client frame" for reading FORMs ILBM in an IFF file. 
* We allocate one of these on the stack for every LIST or FORM encountered 
x in the file and use it to hold BMHD & CMAP properties. We also allocate 
* an initial one for the whole file. 
* We allocate a new GroupContext (and initialize it by OpenRIFF or 
* OpenRGroup) for every group (FORM, CAT, LIST, or PROP) encountered. It's 
* just a context for reading (nested) chunks. 
* 
* If we were to scan the entire example file outlined below: 
* reading proc(s) new new 
* 
* —-whole file-- ReadPicture+ReadIFF  GroupContext ILBMFrame 
* CAT ReadICat GroupContext 
* LIST GetLiILBM+tReadIList GroupContext ILBMFrame 
* PROP ILBM GetPriLBM GroupContext 
* CMAP GetCMAP 
* BMHD Get BMHD 
* FORM JLBM GetFoILBM GroupContext ILBMFrame 
* BODY Get BODY 
* FORM ITLBM Get FoILBM GroupContext ILBMFrame 
* BODY Get BODY 
* FORM ILBM Get FoILBM GroupContext ILBMFrame 
*/ 
/* NOTE: For a small version of this program, set Fancy to 0. 
* That'll compile a program that reads a single FORM ILBM in a file, which 
* is what DeluxePaint produces. It'll skip all LISTs and PROPs in the input 
* file. It will, however, look inside a CAT for a FORM ILBM. 
* That's suitable for 90% of the uses. 
* 
* For a fancier version that handles LISTs and PROPs, set Fancy to l. 
* That'll compile a program that dives into a LIST, if present, to read 
* the first FORM ILBM. E.g. a DeluxePrint library of images is a LIST of 
* FORMs ILBM. 
x 
* For an even fancier version, set Fancy to 2. That'll compile a program 
* that dives into non-ILBM FORMs, if present, looking for a nested FORM ILBM. 
* B.g. a DeluxeVideo C.S. animated object file is a FORM ANBM containing a 








6ET..~ I 





Nov 10 17:18 1988 
















IFF_source/readpict.c Page 2 


* FORM ILBM for each image frame. */ 
#define Fancy 0 


/* Giobal access to client-provided pointers.*/ 


LOCAL Allocator *gAllocator = NULL; 
LOCAL struct BitMap *gBM = NULL; 7* client's bitmap.*/ 
LOCAL ILBMFrame *giFrame = NULL; /7* "client frame".*/ 


[kt Get. FoILBM( ) HHRE KEK HK IIR IK KR RK IK KR IK IIH IK IRE K IKI KIT III III IIIA HEI IK IN 


* Called via ReadPicture to han@le every FORM encountered in an IFF file. 
* Reads FORMS ILBM and skips all others. 

* Inside a FORM ILBM, it stops once it reads a BODY. It complains if it 

* finds no BODY or if it has no BMHD to decode the BODY. 

* 
* 


Once we find a BODY chunk, we'll allocate the BitMap and read the image. 
* 


ZEIGE IOUIOICIOII IOC CICICICIOI IIIA TIOIGIIGOIGCIIIGCICGISGIOIOCI OCCT IIIT TT IIIA] 

LOCAL BYTE bodyBuffer [bufSz] ; 

IFFP GetFoILBM(parent) GroupContext *parent; { 
/*compilerBug register*/ IFFP iffp; 
GroupContext formContext; 
ILBMFrame ilbmFrame; 
register int i; 

LONG plsize; /* Plane size in bytes. */ 
int nPlanes; /* number of planes in our display image */ 


7* only used for non-clientFrame fields.*/ 


/* Handle a non-ILBM FORM. */ 
if (parent->subtype != ID_ILBM) [{ 
#if Fancy >= 2 
/7* Open a non-ILBM FORM and recursively scan it for ILBMs.*/ 
iffp = OpenRGroup(parent, &formContext) ; 
CheckIFFP(); 
do { 
iffp = GetFlchunkHdr( &fommContext) ; 
j] while (iffp >= IFF_OKAY); 
if (iffp == END_MARK) 
iffp = IFF_OKAY; 7* then continue scanning the file */ 
CloseRGroup ( &formContext) ; 
return(iffp); 


* 


#else 
return(IFF OKAY); /* Just skip this FORM and keep scanning the file.*/ 


} 
ilbmPrame *(ILBMFrame *)parent—>clientFrame; 


iffp = OpenRGroup(parent, &formContext) ; 
CheckIFFP (); 


#endif 


+ > HH He HH OH 


do switch (iffp = GetFChunkHdr(&formContext)) { 
case ID_BMHD: [{ 
ilbmFrame.foundBMHD = TRUE; 
iffp = GetBMHD(&formContext, &ilbmFrame. bmHdr) ; 
break; } 
case ID_CMAP: [ 
ilbmFrame.nColorRegs 
iffp = GetCMAP( 
&formContext, (WORD *)&ilbmFrame.colorMap[0] , &ilbmFrame.nColorRegs) ; 
/* was &ilbmFrame.colorMap, (fixed) robp. */ 


x 
* 
* 


maxColorReg; /* we have room for this many */ 


break; } 

case ID_BODY: { 

if (!ilbmFrame.foundBMHD) return (BAD_FORM) ; /* No BMHD chunk! */ 
nPlanes = MIN(ilbmFrame.bmHdr.nPlanes, EXDepth); 
InitBitMap( 

gBM, 

nPlanes, 

ilbmFrame.bmHdr.w, 


ilbmFrame.bmHdr.h) ; 





Nov 10 17:18 1988 





IFF_source/readpict.c Page 3 


plsize = RowBytes(ilbmFrame.bmHdr.w) * ilbmFrame.bmHdr-h; 
/* Allocate all planes contiguously. ‘Not really necessary, 
* but it avoids writing code to back-out if only enough memory 
* for some of the planes. 
* WARNING: Don't change this without changing the code that 
* Frees these planes. 
* 
if (gBM->Planes[0] = 
(PLANEPTR) (*gAllocator) (nPlanes * plsize)) 
{ 


for (i 1; i < nPlanes; i++) 
gBM->Planes[i] = (PLANEPTR) gBM~>Planes(0] + plsize*i; 
iffp = GetBODY( 


&formContext, 
gBM, 
NULL, 
&ilbmFrame.bmHdr, 
bodyBuffer, 
bufSz); 
if (iffp == IFF_OKAY) iffp = LFF_DONE; /* Eureka */ 
*giFrame = ilbmFrame; /* Copy fields to client's frame.*/ 
else 
iffp = CLIENT_ERROR; /7* not enough RAM for the bitmap */ 
break; } 


case END_MARK: { iffp = BAD_FORM; break; } /* No BODY chunk! */ 
} while (iffp >= IFF_OKAY); /* loop if valid ID of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors) .*/ 
if (iffp != IFF_DONE) return(iffp); 
/* If we get this far, there were no errors. */ 
CloseRGroup(&formContext) ; 
return(iffp); 
J 


/7** Notes on extending GetFoT LBM 074300 GGG III III III TO TIO IIE 


To read more kinds of chunks, just add clauses to the switch statement. 
To read more kinds of property chunks (GRAB, CAMG, etc.) add clauses to 
the switch statement in GetPriLBM, too. 


To read. a FORM type that contains a variable number of data 
a FORM FTXT with any number of CHRS chunks—-replace the ID 
an ID_CHRS case that doesn't set iffp = 
case do whatever cleanup you need. 


chunks——e.g. 
) BODY case with 
IFF_DONE, and make the END MARK 


TORIEIICIICICEISIOICICTCCIOISIOCIOCIITICCTCICCICCCICICCICIIOICIOCTCCIOICICT ICC IOICIICICCICTCCICIOCTO ICT IOI I IAI III 


[h* GetPrILBM() HK KKH RIK KKK IK RK KHIR IRR RIKI KEI IRI III I IIR I IKI AA IAAI III 
* 


Called via ReadPicture to handle every PROP encountered in an IFF file. 
Reads PROPs ILBM and skips all others. 


JAIRO IOC CIOICICICCICCICCICTOCICUICISITOICTCCCIIICIOICIICCTOI IO TOR TOO I II TIKI 
#if Fancy 
IFFP GetPriILBM(parent) 


GroupContext *parent; { 
/*compilerBug register*/ IFFP iffp; 

GroupContext propContext ; 

ILBMFrame *ilbmFrame (ILBMFrame *)parent—>clientFrame; 


if (parent—>subtype != ID_ILBM) 
return(IFF_OKAY); /* just continue scaning the file */ 


iffp = OpenRGroup(parent, &propContext ) ; 
CheckIFFP(); 


do switch (iffp = GetPChunkHdr(&propContext)) { 
case ID_BMHD: { 





| 












































Nov 10 17:18 1988 IFF_source/readpict.c Page 4 


ilbmFrame->foundBMHD = TRUE; 
iffp = GetBMHD(&propContext, &ilbmFrame->bmHdr) ; 
break; J 
case ID_CMAP: [ 
ilbmFrame—>nColorRegs = maxColorReg; /* we have room for this many */ 
iffp = GetCMAP( 
&propContext, (WORD *)&ilbmFrame—>colorMap, &ilbmFrame—>nColorRegs) ; 
break; } 
} while (iffp >= IFF_OKAY); /* loop if valid ID. of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors) .*/ 


CloseRGroup( &propContext) ; 
return(iffp == END_MARK ? IFF_OKAY : iffp); 
} 
#tendif 
[** GetLiILBM() FIO III OI OI TRI TI II II IITA I DAI ATK I IK ISAK IK IAI III 
* ‘ 
* Called via ReadPicture to handle every LIST encountered in an IFF file. 
* 
FOGG IIOI III OCICS IIIS III GIGI ICICI SII II ICTOII TOR IOI II IIIA TITS I IIIA I. 
#if Fancy 


IFFP GethLiILBM(parent) GroupContext *parent; { 
ILBMFrame newFrame; /* allocate a new Frame xf 


newFrame = *(ILBMFrame *)parent—>clientFrame; /* copy parent frame */ 
return( ReadIList(parent, (ClientFrame *)yanewFrame) ); 
tendif 


[** ReadPicture( ) FOCI IOI III IOI IOI IIIA TOI TO IOI TS IIA IO IRIS ITI IK 


4ITFFP ReadPicture(file, bm, iFrame, allocator) 
LONG file; 
struct BitMap *bm; 


ILBMFrame *iFrame; /* Top level "client frame".*/ 


OFT - 


/* ***#* ERROR IN SOURCE CODE, WAS jFrame, now iFrame */ 
/* fixed */ 


Allocator *allocator; 
IFFP iffp = IFF_OKAY; 


#if Fancy 


iFrame~>clientFrame.getList = GetLiILBM; 

iFrame—>clientFrame.getProp = GetPrILBM; 
#else 

iFrame—>clientFrame.getList = SkipGroup; 

iFrame->clientFrame.getProp = SkipGroup; 
#endif 

iFrame—>clientFrame.getForm = GetFoILBM; 

iFrame—>clientFrame.getCat = Readicat ; 


/* Initialize the top-level client frame's property settings to the 
* program-wide defaults. This example just records that we haven't read 
* any BMHD property or CMAP color registers yet.. For the color map, that 
* means the default is to leave the machine's color registers alone. 
* If you want to read a property like GRAB, init it here to (0, 0). */ 
iFrame->foundBMHD = FALSE; 
iFrame—>nColorRegs = 0; 


gAllocator = allocator; 

gBM = bm; 

giFrame = iFrame; 
/* Store a pointer to the client's frame in a global variable so that 
* GetFoILBM can update client's frame when done. Why do we have so 
* many frames & frame pointers floating around causing confusion? 
* Because IFF supports PROPs which apply to all FORMs in a LIST, 








Nov 10 17:18 1988 IFF_source/readpict.c Page 5 


* unless a given FORM overrides some property. 

* When you write code to read several FORMs, 

* it is ssential to maintain a frame at each level of the syntax 

* so that the properties for the LIST don't get overwritten by any 

* properties specified by individual FORMs. 

* We decided it was best to put that complexity into this one-FORM example, 
* go that those who need it later will have a useful starting place. 


iffp = ReadIFF(file, (ClientFrame *)iFrame) ; 
return(iffp); 
} 








tet — I 











Nov 10 17:18 1988 IFF_source/remalioc.c Page 1 


77% REMALIO€ . 6 003A OCI ICICI IOI CICIGIIGIGICICIIGICCI ICIS II TSI I TOISAS I I IIIS 


/* ChipAlloc(), ExtAlloc(),.RemAlloc(), RemFree(). */ 
/* ALLOCators which REMember the size allocated, for simpler freeing. */ 
/* */ 
/* Date Who Changes */ 
/* nn cr rn a A RR RS At xf 
/* 16-Jan-86 sss Created from DPaint/DAlloc.c */ 
/* 23-Jan-86 jhm Include Compiler.h, check for size > 0 in RemAlloc. */ 
/* 25-Jan-86 sss Added ChipNoClearAlloc,ExtNoClearAlloc */ 
[* */ 
/* By Jerry Morrison and Steve Shaw, Electronic Arts. */ 
/7* This software is in the public domain. */ 
/* */ 
/* This version for the Commodore-Amiga computer. : */ 
* * 


FOI III CISTI III IIIT TOSI IIIT ICI ITTOII TI TCT TOT OTIS CT IIT S TIT TO TOSI TIS I IIIA 
#ifndef COMPILER _H 

#include "iff/compiler.h" 

#endif 


#include "exec/nodes.h" 
#include "“exec/memory.h' 
#include "iff/remalloc.h" 


“Kk RemALloc RRR KKK RRR KHER ERK HER KEK IKI RK HK HERR EK KERR ER KARR ARERR / 
UBYTE *RemAlloc(size,flags) LONG size, flags; 

register LONG *p = NULL; /* {LONG *) for the sake of ptt, below */ 
register LONG asize = sizet4; 
if (size > 0) 

p = (LONG *)AllocMem(asize, flags) ; 
if (p != NULL) 

*pt+ = asize; 
return((UBYTE *)p); 
} 


7 ® CHU pA 100 0G III I ICICI TOTO II IIT I IIIA II TAI IIT TTA IIIA! 


UBYTE *ChipAlloc(size) LONG size; { 
return(RemAlloc(size, MEMF CLEAR |MEMF PUBLIC |MEMF_CHIP)); 
} 


/* post-bump p to point at clients area*/ 


7** Chi pNoC ea] lod 400g CGI III III III IIIT IIR IOC IR IAI SAS IAI | 


UBYTE *ChipNoClearAlloc(size) LONG size; [ 
return(RemAlloc(size, MEMF PUBLIC |MEMF_CHIP)); 
} 


(208 XC LOG 20 TOO III IRI III TO IOI IIT II IOI IIA III I IAI TAI ASIA I | 


UBYTE *ExtAlloc(size) LONG size; [{ 
return (RemAlloc(size, MEMF CLEAR |MEMF PUBLIC) ); 
} 


7®* EXtNOCLe ac A Loc 2G I IGOR IT OT SAI SISA | 


UBYTE *ExtNoClearAlloc(size) LONG size; { 
return(RemAlloc(size, MEMF_PUBLIC) ); 
} 


[tk RemFree HREKIR RIERA IRR IRE KERR KKK REI KK IRR ERK RRR RE K EKER EKER IRERE / 


UBYTE *RemPree(p) UBYTE *p; { 
if (p.'= NULL) { 


ps 4; 
FreeMem(p, *({LONG *)p)); 


return (NULL) ; 
} 











Nov 10 17:18 1988 IFF_source/unpacker.c Page 1 






* unpacker.c Convert data from "cmpByteRunl" run compression. 11/15/85 
* 

* By Jerry Morrison and Steve Shaw, Electronic Arts. 

This software is in the public domain. 






* 





control bytes: 


(0. .127} followed by ntl bytes of data. 
[-1. .-127] followed by byte to be repeated (-n)+1 times. 
-128 : NOOP. 


+ + 





* This version for the Commodore-Amiga computer. 






on tt 


#include "iff/packer.h" 


[t--- UD PACKROW So a a rr «f/f 


#tdefine UGetByte() 
#define UPutByte(c) 


(*source+t+) 
(*dest++ = (c)) 


/* Given POINTERS to POINTER variables, unpacks one row, updating the source 
* and destination pointers until it produces dstBytes bytes. */ 
BOOL UnPackRow(pSource, pDest, srcBytes0, dstBytes0) 
BYTE **pSource, **pDest; WORD srcBytes0, dstBytes0; [ 
register BYTE *source *pSource; 
register BYTE *dest *pDest ; 
register WORD n; 
register BYTE c; 
register WORD srceBytes = srcBytes0O, dstBytes = dstBytes0; 
BOOL error = TRUE; /* assume error until we make it through the loop */ 
WORD minusl128 = -128; /* get the compiler to generate a CMP.W */ 


while( dstBytes > 0) [{ 
if ( (srcBytes -= 1) ¢< 0 ) 
n = UGetByte(); 


goto ErrorExit; 


if (n >= 0) { 
nt+= 1; 


if ( (srceBytes -= n) <¢ 0) goto Errorfxit; 





if ( (dstBytes -=n) < 0) goto ErrorExit; 
do { UPutByte(UGetByte()); } while (--n >.0); 
} 
else if (n !* minusl]28) [{ 
n=-n+t+l; 
if ( (srceBytes -= 1) < 0) goto ErrorExit; 
if ( (dstBytes -= n) < 0) goto ErrorExit; 


ce = UGetByte(); 
do { UPutByte(c); 
} 


} 
error = FALSE; 


} while (--n > 0); 


/* success! */ 


ErrorExit: 
*pSource = source; 
return(error); 


*pDest = dest; 





Additional IFF Examples 


This section contains source code listings of additional IFF examples provided by Commo- 
dore and third parties. 


Display . ;Displays an ILBM graphic file in an Amiga screen 
PGTB ;The include file for use with PGTB 

ScreenSave.c ;Save the frontmost Amiga screen to a file 

apack.asm ;68000 version of the ILBM run length encoding routines 
cyevb.c ;Color cycling interrupt example 

Note: 


Source code examples for ANIM are available on the Byte Information Exchange (BIX) 
in amiga.dev/listings and on other bulletin boards, along with the modified IFF includes 
and modules required to compile and link the ANIM examples. Also, the Software Dis- 
tillery has provided a PGTB viewer and catcher with source which should be available 
shortly. 


* 
* 
* 
* 
* 
* 
x 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
Hl x 
I] x* 
pw] * 
mi) o* 
a x 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 1 


/* . 
* Display v1.06 - 11/88 Carolyn Scheppner CBM 


Read an ILBM file and display as a screen/window until closed. 
Simulated close gadget in upper left corner of window. 
Clicking below title bar area toggles screen bar for dragging. 
Handles normal and HAM ILBM's 

Now has options for backscreen, timer, cycling, printing 


Options: 


opt b means come up behind other screens 
c Means cycle colors 
Pp where P means dump to printer 
e default 6 planes to extra-halfbrite 
t=n where n = display time in seconds (without or after dump) 
By Carolyn Scheppner CBM 01/15/88 
Modified 09/02/86 ~- Only global frame is iFrame 
Use message->MouseX and Y 
Wait() for IDCMP 
For HAM 
Name changed from SeeILBM to ViewI LBM 
Revised for linkage with myreadpict.c 
For Astartup ... Amiga.lib, LC.lib linkage 
Added color cycling at request of Mimetics 
Tab toggles cycling 
Recognizes RNG_NORATE (36) as non-active DP CRNG 
Changed name to Display 
Accepts display time in seconds as 2nd CLI arg 
New command line options, now prints 
Mask troublesome flags from Viewmodes 


Modified 10/15/86 


Modified 11/01/86 
Modified 11/18/86 
Modified 12/12/86 
Modified 01/06/87 
Modified 03/03/87 


Modified 03/13/87 
Modified 01/15/88 
Modified 04/20/88 
Modified -05/06/88 
Modified 09/27/88 
Modified 11/08/88 


(v1.05) Use CAMG, CRNG, and CCRT defs in new ilbm.h 
(v1.06) Explicitly mask high word of CAMG 


Display supports cycling, timed display, printing, and backscreen. 
See usage lines. Type Display<RET> or double-click Display for help. 
If the command line opt c or picture tooltype CYCLE=TRUE are used, 
this viewer will cycle any ILBM that contains cycling chunks 

(CCRT or CRNG) which are marked as active and do not have a CRNG 
cycle rate of 36. (To DPaint, rate 36 = don't cycle). Note that 

by default, DPaint saves its pics with CRNG (cycling) chunks 
flagged as active and with a rate not equal to 36. 


Based on ShowILBM.c, readpict.c 1/86 
By Jerry Morrison, Steve Shaw, and Steve Hayes, Electronic Arts. 
This software is in the public domain. 


>>NOTE<<: This example must be linked with additional IFF rtn files. 
See linkage information below. 


The display portion is specific to the Commodore Amiga computer. 


Linkage Information: 
(NOTE: All modules including iff stuff compiled with ~-v on LC2) 


FROM LIB: AStartup.obj,Display.o,myreadpict.o,dump.o,iffmsgs.o* 
iffr.o,ilbmr.o,unpacker.o 

To Display 

LIBRARY LIB:Amiga.lib, LIB:LC.1lib 


* 
~N 


f#include <exec/types.h> 
#include <exec/memory .h> 
#include <exec/tasks.h> 
#include <libraries/dos.h> 


(v1.04) Add CTRL/D to exit returning failure, e flag 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 2 


#include <libraries/dosextens.h> 
<workbench/startup.h> 
<workbench/workbench.h> 
<intuition/intuition.h> 

#tinclude. <graphics/gfxbase.h> 


f#include "iff/ilbm.h" 
#include "myreadpict.h" 


MIN 
MIN(a,b) ((a)<(b)?(a):(b)) 
MIN 


TOUPPER (Cc) ((¢)>='a' &&(c)<='2Z'?(c)—'a'+'A':(c)) 
we must mask out of CAMG.Viewmodes */ : 
BADFLAGS (SPRITES|VP_HIDE|GENLOCK AUDIO |GENLOCK_VIDEO) 
FLAGMASK (~BADFLAGS) 

#define CAMGMASK (FLAGMASK & Ox0000FFFFL) 


/* The screendump routine */ 
extern int dump(); 


/* For wbStdio rtns */ 
extern LONG stdin, stdout, stderr; /* in Astartup.obj */ 


char conSpec[{] = "CON:0/40/640/140/"; 
BOOL wbhHasStdio = NULL; 


/* general usage pointers */ 

struct GfxBase *GfxBase; 
struct IntuitionBase *IntuitionBase; 
ULONG IconBase = 0; 


/* Globals for displaying an image */ 
Screen *xscreenl; 
Window *xwindowl; 
RastPort *rportl; 
ViewPort *vportl; 
BitMap tBitMap; /* Temp BitMap struct for small pics */ 
WorkBench startup */ 
struct WBStartup *WBenchMsg; 
FileLock *startLock, *newLock; 


7* Other globals */ 
FromWb, TBtoggle, Done; 
Cycle=FALSE, Print=FALSE, Timer=FALSE, Back=FALSE, EHB=FALSE; 
ul{) = "\nDISPLAY v1.06 C. Scheppner CBM 11/88\n"; 
"\nCLI Usage: Display ilbmfile [opt [b][c]fe]{p] [t=n]]\n"; 
" opts: b=backscreen c=cycle e=ehb p=print. t=seconds\n"; 


"\n WB Usage: Click this icon, SHIFT and DoubleClick on pic\n"; 
"ToolTypes: Display TIMER=n,PRINT=TRUE, BACK=TRUE\N"; 
" Picture CYCLE=TRUE, EHB=TRUE\n"; 


"\nClick toggles bar, Tab toggles cycling, P prints screen\n"; 
"Close upper left. or CTRL/C, or CTRL/D to break a script\n"; 


{ul,ulc,u2c,u2,u3,""}; 


*cliUsage[] 
{ul,ulw,u2w,u3w,u2,u3,""}; 


*xwbUsage []} 
/* Structures for new Screen, new Window */ 
TextFont = { 


struct TextAttr 





99T - I 






Nov 10 17:19 1988 additional_examples/Display/Display.c Page 3 


"topaz. font", /* Font Name */ 
TOPAZ EIGHTY, /7* Font Height .*/ 
FS NORMAL, /* Style xf 
FPF_ROMFONT, /7* Preferences */ 
i 

struct NewScreen ns = { 
0, 0, /* LeftEdge and TopEdge x/ 
0, 0, /* Width and Height */ 
0 /* Depth */ 
1, 0, 7* DetailPen and BlockPen */ 
NULL, /* Special display modes */ 
CUSTOMSCREEN , /* Screen Type */ 
&TextFont, 7* Use my font */ 
" <— Close here after clicking below", /* Title */ 
NULL, /* No gadgets yet x/ 
NULL, /* Ptr to CustomBitmap */ 
1; 

struct NewWindow nw = [{ 
0, 0, /* LeftEdge and TopEdge */ 
0, 0, /* Width and Height */ 
-i, -l1, /* DetailPen and BlockPen */ 
MOUSEBUTTONS | VANILLAKEY , /* IDCMP Flags */ 
BACKDROP 
| BORDERLESS, /* Flags */ 
NULL, NULL, /* Gadget and Image pointers */ 
NULL, /7* Title string */ 
NULL, /7* Put Screen ptr here */ 
NULL, /* SuperBitMap pointer */ 
0, 0, /* MinWidth and MinHeight */ 
0, 0, /* MaxWidth and MaxHeight */ 
CUSTOMSCREEN , /7* Type of window */ 


USHORT allBlack[maxColorReg] = {0}; 


/* For alloc to define new pointer */ 
#define PDATASZ 12 
UWORD *pdata; 


#ifndef MIN 
#define MIN(a,b) ((a)<(b)?(a):(b)) 
#fendif MIN 


extern char *IFFPMessages[]; 
ILBMFrame iFrame; /* my global frame */ 


/* Cycle Task stuff */ 
#define CYCLETIME 16384L 
#tdefine REVERSE 0x02 
#define ACTIVE 0x01 


extern VOID cycleTask(); 
char *cyTaskName =~*"CAS_D1.04cyTask"; 
struct Task *cyTask; 


/* Data shared with cycle/timer Task xf 
CRange *cyCrngs; 

struct ViewPort *cyVport; 

int cyRegs, cyCnt; 

USHORT cyMap[maxColorReg] ; 

LONG cyClocks [maxCycles] ; 

LONG cyRates[maxCycles] ; 

LONG dTimer ; 

BOOL TimerOn, CycleOn, PrepareToDie; 
struct Task *mainTask; 

LONG tSigNum = -1, retcode = RETURN_OK; 





Nov 10 17:19 1988 additional _examples/Display/Display.c Page 4 


ULONG tSig; 


/* 
* main 


*/ 


main(arge, argv) 


int argc; 

char **argv; 
ULONG signals, wSig; 
LONG file; 
IFFP iffp = NO_FIL8; 
struct, WBArg *arg; 
char *filename; 
int error; 


FromWb = (arge==0) ? TRUE : FALSE; 
TimerOn = FALSE; 


if ((FromWb) &&(WBenchMsg—>sm_NumArgs > 1)) 


/* Passed filename via Workbench */ 
arg = WBenchMsg->sm_ArgList; 


argt+; 
filename = (char *)arg->wa_Name; 
newLock = (struct FileLock *)arg—>wa_Lock ; 
startLock = (struct FileLock *)CurrentDir(newLock) ; 
/* Get ToolTypes */ 
getWbOpts (WBenchMsg) ; 

else if((!FromWb)&&(argo>1)&a(*argv[1] != '?')) 


{ 
/* Passed filename via command line xf 
filename = argv{l]; 


if(arge>2) 
{ 


if (strEqu(argv[2],"opt")) getCliopts(arge,argv); 
else cleanexit("Bad args\n",RETURN_FAIL) ; 
j 
} 
else 
{ 
usage(); 
cleanexit(" '",RETURN_OK); /* Space forces wait for keypress if WB */ 


if(!(GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",0))) 





cleanexit("Can't open graphics",RETURN_FAIL) ; 


if(!(IntuitionBase= 
(struct IntuitionBase *)OpenLibrary(“intuition. library",0))) 
cleanexit("Can't open intuition" ,RETURN_FAIL); 


if(! (file = Open(filename, MODE_OLDFILE) )) 
cleanexit("Picture file not found" ,RETURN_WARN) ; 


iffp = myReadPicture( file, &iFrame) ; 
Close( file); 


if (!(iffp == IFF_DONE)) 
cleanexit("Not an IFF ILBM",RETURN_WARN) ; 


error = DisplayPic(&iFrame) ; 
if(error) cleanexit("Can't open screen or window" , RETURN_WARN) ; 








Z4tT — I 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 5 


if(pdata = (UWORD *)AllocMem(PDATASZ ,MEMF_CHIP|MEMF_CLEAR) ) 


{ 

pdata[2}] = 0x8000; /* 1 pixel */ 
SetPointer(windowl,pdata,1,16,0,0); 
} 


/* Set up cycle/timer task */ 


mainTask = (struct Task *)FindTask(NULL); 
if((tSigNum = AllocSignal(-l)) == -1) 

cleanexit ("Can't alloc timerSig",RETURN_FAIL) ; 
tsig = 1 << tSigNum; 
wSig = 1<<windowl—>UserPort—>mp_SigBit; 


initCycle(&iFrame,vport1) ; 
cyTask = (struct Task *)CreateTask(cyTaskName,0,cycleTask , 4000); 
if(!cyTask) cleanexit("Can't create timimg task",RETURN_FAIL); 


7* Dump screen if requested before starting timer */ 
if(Print) dump(screenl); 


if(Timer) TimerOn = TRUE; 
if(Cycle) CycleOn = TRUE; 


TBtoggle 


= FALSE; /* Title bar toggle */ 
Done = FALSE; 


/* Close flag *f 
while (!Done) 
{ 


signals = Wait(SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_C|wSig|tSig); 
if(signals & wSig) chkmsg(); 

if(signals & tSig) Done = TRUE; 

if(signals & SIGBREAKF_CTRL_C) Done = TRUE; 


if(signals & SIGBREAKF_CTRL_D) Done = TRUE, retcode=RETURN_FAIL; 


cleanexit("",retcode) ; 


getC1liopts(arge,argv) 
int arge; 
char **argv; 


int k,i; 
UBYTE C; 


for(k=3; k<arge; k++) 


e = argv[k] [0] | 0x20; 
switch(c) 
{ 
case 't': 
i=0; 
while((argv(k] [i] )&&(argv[k] [i] != '=')) i++; 
i++; 
adTimer = 60 * atoi(ésargv[k] [i]l); 
Timer = TRUE; 
break; 
default: 
for(i=0; argv[k] [i]; i++) 


ce = argv[k] [i] | 0x20; 
switch(c) 


case 'b': 
Back = TRUE; 
break; 

case 'p': 
Print = TRUE; 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 6 


break; 
case ‘c!': 
Cycle = TRUE; 
break; 
case ‘e': 
EHB = TRUE; 
break; 
default: 
break; 
} 


getWbOpts (wbhMsg) 
struct WBStartup *wbMsg; 


( 
struct WBArg *wbArg; 
struct DiskObject *diskobj; 
char **toolarray; 
char *s; 
if((IconBase = OpenLibrary("icon.library", 0))) 
/* First get ToolTypes from Display.info */ 
wbArg = wbMsg—>sm_ArgList; 
diskobj=(struct DiskObject *)GetDiskObject (wbArg—>wa_Name) ; 
if(diskobj) 
{ 
toolarray = (char **)diskobj—>do_ToolTypes; 
if(s=(char *)FindToolType(toolarray,"PRINT") ) 
{ 
if(strEqu(s,"TRUE")) Print = TRUE; 
} 
if(s=(char *)FindToolType(toolarray, BACK") ) 
if(strEqu(s,"TRUE")) Back = TRUE; 
if(s=(char *)FindToolType(toolarray,'"TIMER") ) 
{ 


Timer = TRUE; 
dTimer = 60 * atoi(s); 


} 
FreeDiskObject (diskob}) ; 
} 


if (wbMsg-—>sm_NumArgs > 1) 
whArgt+ ; 


diskobj=(struct DiskObject *)GetDiskObject (wbArg->wa_Name) ; 
if (diskobj) 
{ 


toolarray = (char **)diskobj—>do_ToolTypes; 

if(s=(char *)FindToolType(toolarray,"CYCLE") ) 
|e tstrequis, “TRUE")) Cycle = TRUE; 

if(s=(char *)FindToolType(toolarray,"EHB") ) 
if(strEqu(s,"TRUE")) EHB = TRUE; 


FreeDiskObject (diskobj) ; 





87T - I 








Nov 10 17:19 1988 additional_examples/Display/Display.c Page 7 































} 


CloseLibrary(IconBase) ; 
} 
} 


initCycle(ptFrame,vp) 
ILBMFrame *ptFrame; 
struct ViewPort *vp; 
{ 
int k; 


CycleOn = FALSE; 
PrepareToDie = FALSE; 


eyCrngs = ptFrame->crngChunks; 
cyVport = vp; 

cyRegs = ptFrame—>nColorRegs; 
eyCnt = ptFrame->cycleCnt; 


for(k=0; k<cyRegs; k++) 
{ 
cyMap[k] = ptFrame—>colorMap[k] ; 
} 
7* Init Rates and Clocks */ 
for(k=0; k<cyCnt; k++) 


{ 
/* In DPaint CRNG, rate = RNG_NORATE (36) means don't cycle */ 
if (cyCrngs[k] .rate == RNG_NORATE) 


cyCrngs[k].rate = 0; — 
cycrngsik} active &= “ACTIVE; 
if((cyCrngs[k] .active & ACTIVE) &&(cyCrngs[k] .rate)) 
cyRates[k] = cyCrngs[k] .rate; 
else 
crates tk] = 0; /* Means don't cycle to my cycleTask */ 
eyclocks (x = 0; 


VOID cycleTask() 
{ 


int k, i, 3; 
UBYTE low, high; 
USHORT cyTmp; 
BOOL Cycled; 


while( !PrepareToDie) 


WaitTOF(); 
if (Cycleon) 
t 





Cycled = FALSE; 
for(k=0; k<eyCnt; k++) 


{ 
if(cyRates[{k]) /* cyRate 0 = inactive */ 





eyClocks[k] += cyRates[k]; 
if(cyClocks[k] >= CYCLETIME) 






Cycled = TRUE; 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 8 


cyClocks{k] -= CYCLETIME; 

low = cyCrngs[k] .low; 

high= cyCrngs[k] -high; 

if(cyCrngs{k].active & REVERSE) /* Reverse cycle */ 
{ 


cyTmp = cyMap[low]; 
for(i=low,j=lowtl; i < high; i++,j++) 


{ 
cyMap[i] = cyMap[j]; 
cyMap [high] = cyTmp; 
] 
else /* Forward cycle */ 


cyTmp = cyMap[high}; 
for(i=high,j=high-1; i > low; i--,j—-) 


cyMap[i] = cyMap[j]; 
cyMap[low] = cyTmp; 
} 


} 
} 
if(Cycled) 


LoadRGB4 (cyVport , cyMap, cyRegs) ; 
} 


} 
if (Timeron) 


if(--dTimer <= 0) Signal (mainTask,tSig) ; 


} 
PrepareToDie = FALSE; 
Wait(OL); /* Wait to die */ 
} 


chkmsg() 


struct IntuiMessage *msg; 
ULONG class, code; 
SHORT mouseX, mouseY; 


while(msg=(struct IntuiMessage *)GetMsg(windowl->UserPort ) ) 


class = msg—>Class; 
code = msg—>Code; 

mouseX = msg—>MousexX; 
mouseY = msg—->MouseY; 


ReplyMsg (msg) ; 
switch(class) 


{ 
case MOUSEBUTTONS : 
if ((code == SELECTDOWN) && 
(mouseX < 10)&&(mouseY<10) ) 





( 
Done = TRUE; 


] 
else if ((code == SELECTDOWN) && 
( (mouseY>10) | | (mouseX>10) ) && 
(TBtoggle==FALSE) ) 







{ 

TBtoggle = TRUE; 
ShowTitle(screenl , TRUE) ; 
ClearPointer (window) ; 








Nov 10 17:19 1988 additional_examples/Display/Display.c Page 9 


else if ((code == SELECTDOWN) && 
(mouseY>10) &&(TBtoggle==TRUE) ) 
{ 


TBtoggle = FALSE; 
ShowTitle(screenl, FALSE) ; 
SetPointer(windowl ,pdata,1,16,0,0); 


break; 
case VANILLAKEY: 
switch(code) 


{ 

case 0x03: /* CTRL/C */ 
Done = TRUE; 
break; 

case 0x04: /* CTRL/D */ 
Done = TRUE; 
retcode = RETURN_FAIL; 
break; 

case 'p': case 'P': 
dump (screenl) ; 
break; 

case 0x09: /7/* Tab toggles Cycle */ 
if(Cycleon) 

{ 


CycleOn = FALSE; 

WaitTOF(); /* Make sure cyTask saw FALSE */ 
WaitBOVP (vport1) ; 

YOaGRGB4 (vport) , iFrame. colorMap,maxColorReg) ; 


else 


{ 
initCycle(&iFrame,vport1) ; 
CycleOn = TRUE; 


break; 
default: 

break; 
} 


break ; 


default: 
break; 


usage()} 


char **ulines; 
int k; 


if ((FromWb)&&(! wbHasStdio)) whHasStdio = openStdio(conSpec) ; 
if(( {FromwWb) | | (woHasStdio) ) 
{ 


ulines'= FromWb. ? wbUsage : cliUsage; 
for(k=0; ulines[k] [0]; k++) 


Write(stdout,ulines[(k] ,strlen(ulines[k])); 


cleanexit(s,rceode) 
char *s; 
LONG rcode; 

( 

if(*s) 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 10 


{ 
if((FromWb)&&(!wbHasStdio)) wbhHasStdio = openStdio(conSpec) ; 
if((!Fromwb) | | (wbHasStdio) ) 

{ 


Write(stdout,s,strlen(s)); 
Write(stdout,"\n",1); 


} 
if (wbHasStdio) 
( 


Write(stdout,"\nPRESS RETURN TO EXIT\n", 22); 
while (getchar() != '\n'); 
} 


cleanup({); 
if(wbHasStdio) closeStdio(); 
exit(reode); 


cleanup( ) 
struct IntuiMessage *msg; 
if (cyTask) . 
Cycleon = FALSE; 
PrepareToDie = TRUE; 


while(PrepareToDie) Delay(10); 
DeleteTask(cyTask) ; 
} 


Free timer signal */ 
(tSsigNum > -1) FreeSignal(tSigNum); 


Note - tBitMap planes were deallocated in DisplayPic() */ 
(windowl1) 


{ 

while(msg=(struct IntuiMessage *)GetMsg(windowl-—>UserPort) ) 
{ 
ReplyMsg(msq) ; 
J 

CloseWindow(window1) ; 

(screenl) CloseScreen(screenl); 

(pdata) FreeMem(pdata,PDATASZ); 

(IntuitionBase) CloseLibrary( IntuitionBase) ; 


(GfxBase) CloseLibrary (Gf£xBase) ; 
(newLock != startLock) CurrentDir(startLock) ; 


while(*st+) i++; 
return(i); 


7 GetB DM ap () 0 GIGI ISIS III IOC TOTO IIIT I IIA TOK 
* 


* Open screen or temp bitmap. 
* Returns ptr destBitMap or 0 = error 
* 


RIK IRI K IKI RRR KK IKK IKK KR REIKI K EERE IRR IKK ERIKA KINI / 


struct BitMap *getBitMap(ptilbmFrame) 





osT — I 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 11 


ILBMFrame *ptilbmFrame; 


int i, nPlanes, plsize; 
SHORT sWidth, sHeight, dWidth, dHeight; 
struct BitMap *destBitMap; 


sWidth = ptilbmFrame~>bmHdr.w; 

sHeight = ptilbmFrame—>bmHdr.h; 

daWidth = ptilbmFrame->bmHdr.pageWidth; 

dHeight = ptilbmFrame—>bmHdr.pageHeight ; 

nPlanes = MIN(ptilbmFrame~>bmHdr.nPlanes, EXDepth); 
ns.Width = dWidth; 

ns.Height = dHeight; 

ns.Depth = nPlanes; 


if (ptilbmFrame—>foundCAMG) 


{ 
ns.ViewModes = ptilbmFrame—>camgChunk.ViewModes & CAMGMASK; 
] 


else 
{ 
if (ptilbmFrame—>bmHdr.pageWidth >= 640) 
ns.ViewModes = HIRES; 
else 
ns.ViewModes = 0; 


if (ptilbmFrame—>bmHdr.pageHeight >. 400) 
ns.ViewModes |= LACE; 


/* EHB is kludgey flag for ExtraHalbrite ILBMs with no CAMG */ 
if(ns.Depth == 6) 


if(EHB) ns.ViewModes |= EXTRA_HALFBRITE; 


else ns.ViewModes [= HAM; 
} 


if(Back) ns.Type |= SCREENBEHIND; 
if ((sereenl = (struct Screen *)OpenScreen(&ns) )--NULL) return(0); 


vportl = &screenl->ViewPort; 
LoadRGB4(vportl, &«allBlack{0], MIN(1<<ns.Depth,maxColorReg) ); 


if((ns.ViewModes)&(HAM)) . setHam(screenl, FALSE) ; 


nw.Width = dWidth; 
nw.Height = dHeight; 
nw.Screen = screenl; 


if(!Back) nw.Flags |= ACTIVATE; 

if ((windowl = (struct Window * )OpenWindow( &nw) )==NULL) 
CloseScreen(screenl); 
screen] = NULL; 
return(0); 

ShowTitle(screenl, FALSE); 

if ((sWidth == @Width) && (sHeight == @Height) ) 
destBitMap = (struct BitMap *)screen]—>RastPort . BitMap; 


else 


f 





Nov 10 17:19 1988 additional_examples/Display/Display.c Page 12 


InitBitMap( &tBitMap, 
nPlanes, 
sWidth, 
sHeight); 


plsize = RowBytes(ptilbmFrame~>bmHdr.w) * ptilbmFrame->bmHdr .h; 
if (tBitMap.Planes[0] = 
(PLANEPTR)AllocMem(nPlanes * plsize, MEMF_CHIP)) 
( 


for (i = 1; i <¢ mPlanes; it+) 

tBitMap.Planes[i] = (PLANEPTR)tBitMap.Planes[0] + plsize*i; 
destBitMap = &tBitMap; 
} 


else 


CloseWindow(window] ) ; 

windowl = NULL; 

CloseScreen(screenl); 

screenl = NULL; 

peturn (0); 7* can't allocate temp BitMap */ 


} 
return(destBitMap) ; /* GestBitMap allocated */ 
} 


[**® DisplayPic() KI III IK IIIS IIA ISI IIIA RI SIRI IIIA IAS IIIA KIA ASKER EERE 
* 


* Display loaded bitmap. If tBitMap, first transfer to screen. 
* 


ROI OOOO II II IO OOO IOI IO SII TOT IOI IATA IAAI IK | 
DisplayPic(ptilbmFrame) 
ILBMFrame *ptilbmFrame; 
{ 
int i, row, byte, nrows, nbytes; 
struct BitMap *tbp, *sbp; /* temp and screen BitMap ptrs */ 
UBYTE *tpp, *spp; /7* temp and screen plane ptrs */ 


if (tBitMap.Planes[0]) /* transfer from tBitMap if nec. */ 
{ 
tbp = &tBitMap; 
sbp = screenl—>RastPort.BitMap; 
nrows = MIN(tbp—>Rows, sbp->Rows) ; 
= MIN(tbp->BytesPerRow, sbp—>BytesPerRow) ; 


= 0; i < sbp->Depth; i++) 


t+ 
° 
8 
a 
Pp. 
tt 


tpp = (UBYTE *)tbp->Planes [i]; 
spp = (UBYTE *)sbp->Planes[i]; 
for (row = 0; row ¢ nrows; rowtt) 


tpp = tbp->Planes[i] + (row * tbp—>BytesPerRow) ; 
spp = sbp—>Planes[i] + (row * sbp->BytesPerRow) ; 
for (byte = 0; byte < nbytes; byte++) 
{ 
*sppt+ = *tppt+; 
} ] 
/7* Can now deallocate the temp BitMap */ 


FreeMem(tBitMap.Planes [0], 
tBitMap.BytesPerRow * tBitMap.Rows * tBitMap.Depth); 
} 


vportl = &screenl—>ViewPort; 
LoadRGB4(vportl, ptilbmFrame—>colorMap, ptilbmFrame—>nColorRegs) ; 





if((ns.ViewModes)&(HAM)) setHam(screenl, TRUE) ; 


return(0); 








Ist - 1 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 13 


/* setHam ——- For toggling HAM so HAM pic invisible while loading */ 
setHam(scr, toggle) 
struct Screen *scr; 
BOOL toggle; 
{ 
struct ViewPort *vp; 
struct View *V; 


vp = &(scer—->ViewPort) ; 
v = (struct View *)ViewAddress(); 
Forbid(); 
if (toggle) 
{ 


v—>Modes 
vp~>Modes 
} 


else 


{ 
v->Modes 6&= “HAM; 
vp->Modes &= “HAM; 


MakeScreen(scr) ; 
RethinkDisplay( ); 
Permit(); 


strEqu(p, q) 
TEXT *p, *q; 


while(TOUPPER(*p) ==. TOUPPER(*q)) 
{ 


if (*(ptHt+) == 0) return(TRUE); 
Hq; 


return (FALSE) ; 
} 


/* wbStdio.c -—- Open an Amiga stdio window under workbench 
For use with AStartup.obj 
*/ 


openStdio(conspec) 
char *conspec; 


{ 

LONG wfile; 

struct Process *proc; 
struct FileHandle *thandle; 


if (wbHasStdio) return(1); 


if (!(wfile = Open(conspec,MODE _NEWFILE))) . return(0); 
stdin = wfile; 

stdout = wfile; 

stderr = wfile; 

handle = (struct FileHandle *)(wfile << 2); 

proc = (struct Process *)FindTask (NULL) ; 


proc—>pr_ConsoleTask = (APTR) (handle->fh_ Type); 
proc~>pr_CIS = (BPTR)stdin; 

proc->pr_COS = (BPTR)stdout ; 

return({1); 


closeStdio() 
f 


struct Process 


Nov 10 17:19 1988 additional_examples/Display/Display.c Page 14 


struct FileHandle *handle; 
if (! wbHasStdio) return(0); 


if (stdin > 0) Close(stdin); 
stdin -1; 

stdout 
stderr = -1; 

handle (struct FileHandle *)(stdin << 2); 
proc = (struct Process *)FindTask(NULL) ; 
proc->pr_ConsoleTask = NULL; 

proc->pr_CIS = NULL; 

proc—>pr_ COS = NULL; 

whHasStdio = NULL; 

} 


-1; 


aud 





ést — 1 





Nov 10 17:19 1988 additional_examples/Display/dump.c Page 





* 


* dump.c 
* 


*/ 


- routine to dump rastport 


#include "exec/types.h" 
#include "intuition/intuition.h" 
#include “devices/printer.h" 


extern struct IODRPReq 
extern struct MsgPort 


*CreateExtIO(); 
*CreatePort(); 


dump (screen) 
struct Screen *screen; 


struct IODRPReq *iodrp; 
struct MsgPort *printerPort; 
struct ViewPort *vp; 

int error 1; 


if(printerPort = CreatePort("CAS_ddmp", 0) ) 
if (iodrp=CreateExtIO(printerPort,sizeof(struct IODRPReq))) 
{ 
if(! (error=OpenDevice("printer.device",0,iodrp,0))) 
{ 


vp = &screen—>ViewPort ; 

iodrp->io_ Command = PRD_DUMPRPORT; 
iodrp—>io_RastPort = &screen—>RastPort; 
jodrp—>io_ColorMap = vp~>ColorMap; 
iodrp-—>io_Modes (ULONG ) vp— >Modes ; 


7*  iodrp— io Srex = 0; MEMF CLEAR zeroed this */ 
7*  iodrp->io_SreY = 0; MEMF CLEAR zeroed this */ 
iodrp->io_SreWidth = ‘screen—>Width; 
iodrp->io SrcHeight = screen—>Height; 
/*  iodrp->io _DestCols = 0; MEMF_CLEAR zeroed this */ 
/* iodrp—>io DestRows = 0; MEMF_CLEAR zeroed this. */ 


iodrp—>io_Special = SPECIAL FULLCOLS | SPECIAL_ASPECT; 


error = DolIO(iodrp); 
CloseDevice(iodrp) ; 
} 


DeleteExtlO(iodrp, sizeof(struct IODRPReq) ); 
} 
DeletePort(printerPort) ; 


return(error) ; 




















Nov 10 17:19 1988 additional_examples/Display/iffmsgs.c Page 1 


/* iffmsgs.c -—— The IFF error msgs indexed by iffp 
* Use: extern char *IFFPMessages[]; in application to access 
*/ 


#ifndef IFF_H 
#include "iff/iff.h" 
#endif 


/* Message strings for IFFP codes. */ 


char MsgOkay {] = {"(IFF_OKAY) No FORM of correct type in file." ]; 
char MsgEndMark[] = {"(END_MARK) How did you get this message?" J; 
char MsgDone[] = {"(IFF_DONE) All done."}; 

char MsgDos[] = {"(DOS_ ERROR) The DOS returned an error." J; 
char MsgNot [] = {"(NOT_IFF) Not an IFF file." }; 

char MsgNoFile[] = {"(NO_FILE) No such file found." J; 

char MsgClientError[] = {"(CLIENT_ERROR) Probably insufficient RAM."}; 
char MsgForm{] = {"(BAD_FORM) File contains a malformed FORM." }; 
char MsgShort {] = {"(SHORT_CHUNK) File contains a short Chunk." }; 
char MsgBad[] = {"(BAD IFF) A mangled IFF file." }; 


/* THESE MUST APPEAR IN 

char *IFFPMessages [{—-LAST_ERROR+1] 
/*LFF_OKAY*/ MsgOkay, 
/*END_MARK*/ MsgEndMark, 
/*IFF_DONE*/ MsgDone, 
/*DOS_ERROR*/ Msgbos , 
7*NOT_IFF*/ = MsgNot, 
/*NO_FILE*/ MsgNoFile, 
/*CLIENT_ERROR*/ MsgClientError, 
/*BAD_FORM*/ MsgForm, 
/*SHORT_CHUNK*/ MsgShort, 
/*BAD_IFF*/ MsgBad 
he 


RIGHT ORDER!! */ 
={ 











Nov 10 17:19 1988 


/* 
* 
* 


* 
* 


* 
x 
* 
* 
* 
* 
* 
* 
* 
*x 
* 
* 
* 
x 
* 
* 
* 


#d 


#1 
#i 
#1 
#1 
#1 


/* 
“Tid 


4 + + HH FH HH HH HH HHH HHH 


* 


* 


et t+ 4 HH HOF 


additional_examples/Display/myreadpict.c Page 1 


* myReadPict.c RHR K EKER REE KKK KEE RE KR E RK EEREEEEKERERKKKHEERKEKKEKEREREKEEEKEEE 


Read an ILBM raster image file. 23-Jan~86. 

Modified. version of ReadPict.c 
by Jerry Morrison, Steve Shaw, and Steve Hayes, Electronic Arts. 
This software is in the public domain. 


Modified by C. Scheppner 11/86 

Handles CAMG chunks for HAM, etc. 

Calls user defined routine getBitMap(ilbmFramePtr) when it 
reaches the BODY. 

getBitMap() can open a screen of the correct size using 
information this rtn places in the ilbmFrame, and returns 
a pointer to a BitMap structure. The BitMap structure 
tells myReadPicture where it should load the bit planes. 


Modified by C. Scheppner 12/86 
Loads in CCRT or CRNG chunks. (converts CCRT to CRNG) 
Modified 11-88 to use CCRT, CAMG defs and macros added to ilbm.h 
and existing CRange (not CrngChunk) def in ilbm.h 


FIO III IIIT TORII IIR IOI III IOI IA TI II IR III TTI IS AIA ARIA III I AIK IIA. 


lefine LOCAL static 
nclude “intuition/intuition.h" 
nelude “libraries/dos.h" 
nelude "libraries/dosextens.h" 
nclude “iff/ilbm.h" 

/* cs */ 


nclude "myreadpict.h" 
Define size of a temporary buffer used in unscrambling the ILBM rows.*/ 
efine bufSz 512 





Se ILBM reader —————--~--9 
ILBMFrame is our “client frame" for reading FORMS ILBM in an IFF file. 
We allocate one of these on the stack for every LIST or FORM encountered 
in the file and use it to hold BMHD & CMAP properties. We also allocate 
an initial one for the whole file. 
We allocate a new GroupContext (and initialize it by OpenRIFF or 
OpenRGroup) for every group (FORM, CAT, LIST, or PROP) encountered. It's 
just a context for reading (nested) chunks. 


If we were to scan the entire example file outlined below: 
reading proc(s) new new 
myReadPicturetReadIFF GroupContext ILBMFrame 
GroupContext 
GroupContext 
GroupContext 


--whole file-- 
CAT ReadIcat 
LIST GetLiILBM+ReadIList 
PROP ILBM GetPrILBM 
CMAP GetCMAP 
BMHD GetBMHD 
FORM ILBM Get FoI LBM 
BODY Get BODY 
FORM ILBM GetFoILBM - 
BODY Get BODY 
FORM ILBM GetFoI LBM 


ILBMFrame 


GroupContext ILBMFrame 


GroupContext ILBMFrame 


GroupContext ILBMFrame 


/ 


NOTE: For a small version of this program, set Fancy to 0. 

That'll compile a program that reads a single FORM ILBM in a file, which 
is what DeluxePaint produces. It'll skip all LISTs and PROPs in the input 
file. It will, however, look inside a CAT for a FORM ILBM. 

That's suitable for 90% of the uses. 


For a fancier version that handles LISTs and PROPs, set Fancy to l. 
That'11 compile a program that dives into a LIST, if present, to read 
the first FORM ILBM. E.g. a DeluxePrint library of images is a LIST of 
FORMs ILBM. 


Nov 10 17:19 1988 additional_examples/Display/myreadpict.c Page 2 


For an even fancier version, set Fancy to 2. That'll compile a program 


that dives into non-ILBM FORMs, if present, looking for a nested FORM ILBM. 


E.g. a DeluxeVideo C.S. animated object file is a FORM ANBM containing a 
* FORM ILBM for each image frame. */ 
#define Fancy 0 


7* Global access to client-provided pointers.*/ 
LOCAL ILBMFrame *giFrame = NULL; 7* “client frame".*/ 


IFFP handleCAMG(context, frame) 
GroupContext *context; 
ILBMFrame *frame; 


( 
IFFP iffp = IFF_OKAY; 


frame—>foundCAMG = TRUE; 

iffp = GetCAMG(context, &frame—>camgChunk) ; 
return(iffp); 

} 


IFFP handleCRNG(context , frame) 
GroupContext *context; 
ILBMFrame *xframe; 


{ 
IFFP iffp = IFF_OKAY; 
if(frame->cycleCnt < maxCycles) 


iffp = GetCRNG(context, &(frame~>crngChunks [frame—>cycleCnt])); 
frame—>cycleCnt++; ne 
} 


return(iffp); 
} 


IFFP handleCCRT( context, frame) 
GroupContext *context; 
ILBMFrame *frame; 


( 

CertChunk ccrtTmp; 
CcRange *ptCrng; 

IFFP iffp = IFF_OKAY; 


if(frame—>cycleCnt < maxCycles) 


iffp = GetCCRT(context, &ccrtTmp) ; 

ptCrng = &(frame—>crngChunks [frame—>cycleCnt] ); 
if(certTmp.direction) ccrtTmp.direction = ~ccrtTImp.direction; 
ptCrng—>active = ccrtTmp.direction & 0x03; 

ptCrng->low = certTmp.start; 

ptCrng->high = ccrtTmp.end; 


Convert CCRT secs/msecs to CRNG timimg 

0x4000 = max CRNG rate (cycle every 1 60th sec) 

This must be divided by # 60th's between cycles 

seconds to 60th's is easy 

msecs to 60th's requires division by 16667 

this is int math so I add 8334 (half 16667) first for rounding 
x/ 
ptCrng—>rate = 0x4000 / 

((certTmp.seconds * 60)+((ccrtTmp.microseconds+8334)/16667)); 
frame—>cycleCnt++; 


} 
return(iffp); 
} 


PST - I 





Nov 10 17:19 1988 additional_examples/Display/myreadpict.c Page 3 






























[** Get FoILBM(} HOR III IKK IK IK IK KK II KE III IKK ITER IK KK RRR IKK RIK KEE KERR KER 
* 

Called via myReadPictureto handle every FORM encountered in an IFF file. 
Reads FORMs ILBM and skips all others. 

Inside a FORM ILBM, it stops once it reads a BODY. It complains if it 
finds no BODY or if it has no BMHD to decode the BODY. 


Once we find a BODY chunk, we'll call user rtn getBitMap() to 
allocate the bitmap and planes (or screen) and then read 
the BODY into the planes. 


+ + HH HOF 


* 

FORO IO III II ITO TOSI IIR IA IOI IA IR RII IORI IIIA RATA IAAT BR IIASA IS IH ERIK 
LOCAL BYTE bodyBuffer {bufSz] ; 

IFFP GetFoILBM(parent) GroupContext *parent,; 


{ 

/*xcompilerBug register*/ IFFP iffp; 
GroupContext formContext; 
ILBMFrame ilbmFrame; 
struct BitMap *destBitMap; 


/* only used for non-clientFrame fields.*/ 


/* cs */ 


/7* Handle a non-ILBM FORM. */ 
if (parent—>subtype != ID_ILBM) 


#if Fancy >= 2 
/7* Open a non-ILBM FORM and recursively scan it for TLBMs.*/ 
iffp = OpenRGroup(parent, &formContext); 
CheckIiFFP(); 
do { 
iffp = GetFlChunkHdr(&formContext) ; 
} while (iffp >= IFF_OKAY); 
if (iffp == END_MARK) 


iffp = IFF_OKAY; /* then continue scanning the file */ 
} 
CloseRGroup ( &formContext ) ; 
return(iffp); 
#telse 


return(IFF_OKAY); /* Just skip this FORM and keep scanning the file.*/ 
#endif 
} 


ilbmFrame = *(ILBMFrame *)parent—>clientFrame; 
iffp = OpenRGroup(parent, &formContext) ; 
CheckIFFP(); 


do switch (iffp = GetFChunkHdr(&formContext)) [ 
case ID_BMHD: [{ 
ilbmFrame.foundBMHD = TRUE; 
iffp = GetBMHD( &formContext, &ilbmFrame.bmHdr) ; 
break; ] 
case ID_CAMG: [{ /* cs * 
iffp = handlecamMG(sformContext, &ilbmFrame) ; 
break; } 
case ID_CRNG: /* cs */ 
iffp = handleCRNG(&formContext, silbmFrame) ; 
break; } 
case ID_CCRT: [{ J* cs */ 
iffp = handleccrT(&formcontext, &ilbmFrame) ; 
break; } 
case ID_CMAP: { 
ilbmFrame.nColorRegs = maxColorReg; /* room for this many */ 
iffp = GetCMAP(&formContext, (WORD *)ilbmFrame.colorMap, 
&ilbmFrame.nColorRegs) ; 
break; } 


case ID_BODY: { /* cs */ 
if (!ilbmFrame. foundBMHD) 


iffp = BAD_FORM; /* No BMHD chunk! */ 











Nov 10 17:19 1988 additional examples/Display/myreadpict.c Page 4 


} 


else 
{ . 
if (destBitMap=(struct BitMap *)getBitMap( &ilbmFrame) ) 


iffp = GetBODY( &formContext, 

destBitMap, 

NULL, 

&ilbmFrame.bmHdr, 

bodyBuffer, 

bufSz); 
if (iffp = IFF_OKAY) iffp = IFF_DONE; /* Eureka */ 
*giFrame = ilbmFrame; /* copy fields to client frame */ 
} 


else 


{ 
iffp = CLIENT _ERROR; /7* not. enough RAM for the bitmap */ 
] 


} 
break; } 


case END MARK: [ 
iffp = BAD_FORM; 
break; } 


} while (iffp >= IFF_OKAY); 
/* loop if valid ID of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors).*/ 
if (iffp != IFF_DONE) return(iffp); 
CloseRGroup( &formContext) ; 
return(iffp); 
} 


xk ON XE in Fo RKTT RIOR IK III IR IIR RIK IKI KEK RIK HERE EKER 
/ lotes on extending GetFoILBM 
* 
To read more kinds of chunks, just add clauses to the switch statement. 
To read more kinds of property chunks (GRAB, CAMG, etc.) add clauses to 
the switch statement in GetPrILBM, too. 





a FORM FTXT with amy number of CHRS chunks——-replace the ID_BODY case with 
an ID_CHRS case that doesn't set iffp = IFF_DONE, and make the END_MARK 


* 
* 
* 
* 
* To read a FORM type that contains a variable number of data chunks-——e.g. 
* 
* 
* case do whatever cleanup you need. 

* 

* 


GOO ICO IGIOI IOI OI ICICI III OAR ITO I IAI IAAT TIAA TIA I IIIT RI 


[tk GetPrILBM() KIKI IR RIK IO IRI TORII IAAI IIA IIIA RIAA IAI IRIE IIA KIKI AIRE IAI 
* 
* Called via myReadPicture to handle every PROP encountered in an IFF file. 
* Reads PROPS ILBM and skips all others. 
* 


GEIR III IO III IOI A IR TI I AOI I TAT RI AI AI II IIIT IIA ARITA IIA IAI IIASA I IIA IK 
#if Fancy 
IFFP GetPrILBM(parent) GroupContext *parent; { 

/*compilerBug register*/ IFFP iffp; 

GroupContext propContext; 

ILBMFrame *ilbmFrame = (ILBMFrame *)parent—>clientFrame; 


if (parent-—>subtype != ID_ILBM) 
return ( IFF_OKAY) ; /* just continue scaning the file */ 


iffp = OpenRGroup(parent, &propContext) ; 
CheckIFFP () ; 


do switch (iffp = GetPChunkHdr( &propContext) ) { 
case ID_BMHD: 








cst —I 





Nov 10 17:19 1988 


additional_examples/Display/myreadpict.c Page 5 


ilbmFrame—>foundBMHD = TRUE; 
iffp = GetBMHD({ &propContext, &ilbmFrame—>bmHdr) ; 
break;. } 

ease ID_CAMG: { f* cs */ 
iffp = handleCAMG(&propContext, ilbmFrame) ; 
break; } 

case ID_CRNG: [{ /* cs */ 
iffp = handleCRNG(&propContext, ilbmFrame) ; 


break; } 
case ID CCRT: [ f/* cs */ 
iffp = handlecCcrT(&propContext, ilbmFrame) ; 


break; } 
case ID_CMAP: { 
ilbmFrame->nColorRegs = maxColorReg; /* room for this many */ 
iffp = GetCMAP( &propContext, 
(WORD *)&ilbmFrame~>colorMap, 
&ilbmFrame->nColorRegs) ; 
break; } 
} while (iffp >= IFF_OKAY); 
/* loop if valid ID of ignored chunk or a 
* subroutine returned IFF_OKAY (no errors).*/ 


CloseRGroup( &propContext) ; 


return(iffp == END MARK ? IFF_OKAY : iffp); 


} 
#endif 


[tt GetLiILBM( ) RRR IK KK AIR KKK KKK IKK KK IKKE KEK KEKE KR KEKE KK ERR KK KEKE KKKEK 


*x 
* 
x 


FOI III III I IO III RII IK IITA ITT III IK ITI AIK IAA ATI III IA ITAA I TRIER K | 


Called via myReadPicture to handle every LIST encountered in an IFF file. 


#if Fancy 
IFFP GetLiILBM(parent) GroupContext *parent; {f{ 
ILBMFrame newFrame; /* allocate a new Frame */ 


newFrame = *(ILBMFrame *)parent—>clientFrame; /* copy parent frame */ 


return( ReadIList(parent, (ClientFramée *)&newFrame) ); 


} 
#endif 


72>) TyRea@ PS. C Ure () EOS ISIC IOI CIES III CICTIOIOITCTCITCII TOIT I I TTA SIO 7 


IFFP myReadPicture(file,iFrame) 


telse 


tif Fancy 
iFrame—>clientPrame.getList = GetLiILBM; 
iFrame—>clientFrame.getProp = GetPriILBM; 
iFrame~>clientFrame.getList = SkipGroup; 
iFPrame—>clientFrame.getProp = SkipGroup; 


#tendif 


LONG file; 


ILBMFrame *iFrame; 7/* Top level "client frame".*/ 


{ 
IFFP iffp = IFF_OKAY; 


iFrame—>clientFrame.getForm = GetFoILBM; 
iFrame—>clientFrame.getCat = ReadICat. ; 


/7* Initialize the top-level client frame's property settings to the 


* program-wide defaults. This example just records that we haven't read 
* any BMHD property or CMAP color registers yet. For the color map, that 
* means the default is to leave the machine's color registers alone. 
* If you want to read a property like GRAB, init it here to (0, 0). */ 
iFrame—>foundBMHD = FALSE; 
iFrame->nColorRegs = 0; 
iFrame—>foundCAMG = FALSE; {/* cs */ 
iFrame->cycleCnt = 0; /* cs */ 















Nov 10 17:19 1988 





additional_examples/Display/myreadpict.c Page 6 


giFrame = iFrame; 


NS 
* 


+ OF MO OOO 


Store a pointer to the client's frame in a global variable so that 
GetFoILBM can update client's frame when done. Why do we have so 
many frames & frame pointers floating around causing confusion? 
Because IFF supports PROPs which apply to all FORMs in a LIST, 
unless a given FORM overrides some property. 

When you write code to read several FORMs, 

it is ssential to maintain a frame at each level of the syntax 

so that the properties-fer the LIST don't get overwritten by any 
properties specified by individual FORMs. 

We decided it was best to put that complexity into this one-FORM example, 
so that those who need it later will have a useful starting place. 


*/ 

iffp = ReadIFF(file, (ClientFrame *)iFrame) ; 
return(iffp); 

} 








9ST -I 


il 


Nov 10 17:19 1988 additional_examples/Display/myreadpict.h Page 1 


/* myreadpict.h 
* Modified 12/88 ~ removed Camg, Cert, Crng defs (now in ilbm.h) 
*/ 


#ifndef MYREADPICT_H 
#define MYREADPICT_H 





#ifndef GRAPHICS GFX_H 
#include <graphics/gfx.h> 
#endif 


#ifndef ILBM_H 
#include <iff/ilbm.h> 
tendif 


#define EXDepth 6 /* Maximum depth (6=HAM) */ 

#define maxColorReg 32 

#define maxCycles 8 . 
#define RNG_NORATE 36 /* Dpaint uses this rate to mean non-active f/f 


typedef struct [ 
ClientFrame clientFrame; 
UBYTE foundBMHD; 
UBYTE nColorRegs; 
BitMapHeader bmHdr; 
Color4 colorMap [maxColorReg] ; 
/* If you want to read any other property chunks, e.g. GRAB or CAMG, add 
* fields to this record to store them. */ 
UBYTE foundCAMG; 
CamgChunk camgChunk ; 
UBYTE cycleCnt; . 
CRange crngChunks[maxCycles}]; /* I'll convert CCRT to this */ 
} ILBMPrame; 


typedef UBYTE *UBytePtr; 

#ifdef FDwAT 

extern IFFP myReadPicture(LONG, ILBMFrame *); 
extern struct BitMap *getBitMap(ILBMFrame *); 


extern IFFP myReadPicture(); 
extern struct BitMap *getBitMap(); 





#endif MYREADPICT_H 


46T — I 


Nov 10 17:19 1988 additional_examples/PGTB/td.h Page 1 Nov 10 17:19 1988 additional_examples/PGTB/td.h Page 2 


koe OR RR RR Oe Kk ROK RR RR RR Rk wR Rk eR RR OR Rk RR RR RR KOS struct tbtemplate { 
_o o|\\. The Software Distillery /* FAIL stuff */ 
oO. Made available for the Amiga development community long gotfail; found FAIL chunk 
author: BBS: / char *taskname; name from task block 
John Mainwaring (919 )-471-6436 ULONG environ, H/W environment 
vbfreq, Vertical Blank 
psfreq, Power Supply 
KOR RR KR RR OR RR ROR ROR wR RK OR OR ROR RR Rk RR KR RR RR ROR RRS starter, O = WB else CLI 
guru, /* defined in alerts.h 
/* global definitions for traceback dump utility */ segcount; /* longword count 
' struct segment *segments; /* seglist 
"“exec/types.h" /* REGS stuff */ 
“exec/memory .h" long gotregs; found REGS chunk 
"proto/exec.h" ULONG pc, program counter 
"stdio.h” ce, 7* condition code reg 
"string.h" dregs [8], DO~D7 
#include "stdlib.h" aregs[8]; AO-A7 
: /* VERS stuff */ 
#define FATAL 20 long gotvers; found VERS chunk 
ULONG ver, version of catch.o 
/* bit flags for dump options */ rev; /* revision of catch.o 
SYMFLG 1<<0 char *filename; name of catch.o 
FAILFLG 1<<1 /* FMEM stuff */ 
REGFLG 1<<2 long gotfmem; got FMEM chunk 
ENVELG 1<<3 ULONG memca, available chip 
STAKFLG 1<<4 memcem , max chip 
UDATFLG 1<<5 memcl, /* largest chip 
FMEMFLG 1<<6 /* available fast 
TRACEFLG 1<<7 max fast 
largest fast 
struct symbol_node [ /* STAK stuff (pointer to data chain) */ 
struct symbol_node * sn_next; ULONG staktop, /* top of stack 
long sn_memsize; stakptr,/* saved stack pointer 
ULONG sn_value; staklen, /* bottom of stack 
char sn_sym(4]; /* real length determined when allocated */ topseg, /* bool top present 
ie botseg, /* bool bot present 
seglen, * else entire size*/ 
struct line elem { stak [2048] ; /* stack data, 8K bytes 
ULONG le_line; /* UDAT stuff */ 
ULONG le_off; struct udata *udhead; 
1; 1; 


struct line_node { struct addrinfo [{ 
struct line_node * In_next; long hunknum; 
ULONG In_size; /* byte size of this block long offset; 
ULONG In_codesize; 7* byte size of this object file char *name; 
ULONG In_letabsize; /* number of line_elems for this object file char *objname; 
ULONG In_offset; /* offset into segment of this object file long line; 
ULONG In_nsize; 7* length of name (in longwords) long lineoff; 
char lin_name[4]; 7* name of object file lines belong to / il; 
/* a table of line_elem comes after full name 
}; /* templates for functions called from outside defining section */ 


/* element of table of seglist descriptors */ /7* defined in tdrutil.c */ 
struct segment [{ 
long addr; 
long size; void getblock(PILE *, ULONG *, long); 
struct symbol_node *symbols; void getbytes(FILE *, ULONG *, long); 
struct line_node *lines; ULONG getascii(FILE *, char **); 
}; void skiplong(FILE *, long); 
void skipbytes(FILE *, long); 
/* element of UDAT chain */ 
struct udata [ /* defined in tdread.h */ 
struct udata *udptr; int tdread(FILE *); 
long udsize; 
long. udat[1); /* actual length of array given by udsize */ /* defined in tdsym.h */ 
1; int readsym(FILE *); 





/* data structure to hold contents of PGTB traceback file */ /* defined in tdump.c */ 


Ih 





Nov 10 17:19 1988 additional_examples/PGTB/td.h Page 3 








void tdump(int); 


/* defined in tdwutil.c */ 

void hexdump(FILE *, unsigned char *, long, long); 
void longtoascii(ULONG, char *); 

int locaddr(ULONG, struct addrinfo *); 


sst - 1 





6ST — 1 


Nov 10 17:19 1988 additional_examples/ScreenSave.c Page 1] 


N 
* 


ScreenSave.c --— v1.06 Carolyn Scheppner CBM 
Saves front screen as ILBM file 
Saves a CAMG chunk for HAM, etc. 
Creates icon for ITLBM file 
Original 10/86 
Modified 9/88 — To mask out unwanted ViewMode bits in CAMG 
and use CAMG defs in new ilbm.h 


Uses IFF rtns by J.Morrison and S.Shaw of Electronic Arts 


(all C code including IFF modules compiled with -v on LC2) 
Linkage information: 
FROM AStartup.obj, ScreenSave.o, iffw.o, ilbmw.o, packer.o 
TO ScreenSave 
LIBRARY Amiga.lib, LC.lib 


+ + te Ot OO OO OO OO 


* 
~N 


#include <exec/types.h> 

#include <exec/memory .h> 
#include <libraries/dos.h> 
#include <libraries/dosextens.h> 
#include <graphics/gfxbase.h> 
#include <graphics/rastport.h> 
#include <graphics/gfx.h> 
#include <graphics/view.h> 


#include <intuition/intuition.h> 
#tinclude <intuition/intuitionbase.h> 
#include <workbench/workbench.h> 
#include <workbench/startup.h> 


#include "iff/ilbm.h" 


/* From AStartup — used to create stdio on WB startup */ 
extern LONG stdin, stdout, stderr; 


/* For masking unwanted Viewmodes bits */ 

#define BADFLAGS (SPRITES|VP_HIDE|GENLOCK_AUDIO |GENLOCK_VIDEO) 
#define FLAGMASK (~BADFLAGS) 

#define CAMGMASK (FLAGMASK & 0x0000FFFFL) 


/* Other Stuff */ 
#define bufSize 512 


struct IntuitionBase *IntuitionBase; 
struct GfxBase *GfxBase; 
ULONG IconBase; 


struct Screen *frontScreen; 


struct ViewPort *picViewPort; 
struct BitMap *picBitMap; 
WORD *picColorTable; 
ULONG picViewModes ; 
BOOL fromwWB, newStdio; 


#tdefine INBUFSZ 40 
char sbuf [INBUFSZ] ; 
char nbuf [INBUFSZ] ; 


char conSpec[] = "CON:0/40/639/160/ ScreenSave v1.06 "; 


/7* Definitions for ILBM Icon */ 
USHORT ILBMimagedata[] = { 
OxFFFF, OxFFFC, 
0xc000, Ox000C, 





Nov 10 17:19 1988 ‘additional_examples/ScreenSave.c Page 2 


0xc000, 0x000C, 
OxClE7, Ox9EOC, 
OxC1F8, Ox7EOC, 
0xc078, 0x780C, 
0xC187, Ox860C, 
0xC078, 0x780C, 
OxCl1F8, Ox7E0C, 
OxClE7, Ox9EOC, 
Oxco000d, 0x000C, 
Oxc000, Ox000C, 
OxFFFF, OxFFFC, 
0x0000, 0x0000, 
0x0000, 0x0000, 
[ttf 
OxFFFF, OxFFFC, 
OxFFFF, OxFFFC, 
OxF800, 0x007C, 
OxF9EO, OxlE7C, 
OxF980, Ox067C, 
OxF807, Ox807C, 
OxF81F, OxE07C, 
OxF807, Ox807C, 
OxF980, 0x067C, 
OxF9SEO, OxlE7C, 
OxF800, Ox007C, 
OxFFFF, OxFFFC, 
OXFFFF, OxFFFC, 
0x0000, 0x0000, 
0x0000, 0x0000, 


[**/ 
struct Image ILBMimage = [{ 
0,0, /* Leftedge, Topedge */ 
30,15, /7* Width Height */ 
2, 7* Depth */ 
&ILBMimagedata [0], /* Data for image */ 
3,0 /* PlanePick, Planeonoff */ 


je 

struct DiskObject ILBMobject = [ 
WB_DISKMAGIC, 
WB_DISKVERSION, 


/* Gadget Structure */ 


NULL, /* Ptr to next gadget */ 

0,0, 7* Leftedge, Topedge */ 

30,15, 7/* Width, Height */ 

GADGHBOX | GADGIMAGE , /* Flags */ 

RELVERIFY |GADGIMMEDIATE, /* Activation */ 

BOOLGADGET, /* Type */ 

(APTR) &ILBMimage, /* Render */ . 

NULL, /* Select Render */ 

NULL, /* Text */ 

NULL, NULL ,NULL, NULL, /* Exclude, Special, ID, UserData */ 
4, /* WBObject type */ 

":Display", /* Default tool */ 

NULL, /* Tool Types */ 
NO_ICON_POSITION, /* Current X */ 

NO_ICON POSITION, /* Current Y */ 

NULL, NULL, NULL, /* Drawer, ToolWindow, Stack */ 


Ie 


main(arge, argv) 
int argc; 
char **argv; 


{ 















Nov 10 17:19 1988 additional_examples/ScreenSave.c Page 









LONG file; 

IFFP iffp = NO_FILE; 
char *filename; 

int 1; 






newStdio = FALSE; 


fromWB = (arge==0) ? TRUE : FALSE; 








if((fromWB) && (!(newStdio = openStdio(&conSpec[0])))) 


return(0); 






if ((IntuitionBase = 
(struct IntuitionBase *)OpenLibrary("intuition. library" ,0))=-NULL) 
cleanexit ("Can't open intuition. library\n"); 
























if ((GfxBase = 
(struct GfxBase *)OpenLibrary("graphics.library",0))-=NULL) 
cleanexit("Can't open graphics. library\n"); 


if ((IconBase = OpenLibrary("icon.library",0))==NULL ) 
cleanexit("Can't open icon. library\n"); 


printf ("ScreenSave v 1.06 --- C. Scheppner CBM 9/88\n"); 

printf(" Saves the front screen as an IFF ILBM file\n"); 

printf(" A CAMG chunk is saved (for HAM pics, etc.)\n\n"); 

if(arge>1) /* Passed filename via command line */ 
{ . 

filename = argv[1]; 


else 





printf("Enter filename for save: 
1 = gets(é&nbuf[0]); 





"Yi 


o9t - Tt 


if(1==0) /* No filename — Exit */ 
cleanexit("\nScreen not saved, filename required\n"); 


else 








filename = é&nbuf[0]; 
} 
} 


if ('!(file = Open(filename, MODE_NEWFILE))) 
cleanexit("Can't open output file\n"); 








Write(file,"x",1); /* 1.1 so Seek to beginning works ? */ 
printf("Click here and press <RETURN> when ready: "); 
gets(&sbuf[0]); 

printf("Front screen will be saved in 10 seconds\n"); 
Delay(500); 












Forbid(); 
frontScreen = IntuitionBase—>FirstScreen; 
Permit(); 


picViewPort = &( frontScreen->ViewPort ); 
picBitMap = (struct BitMap*) picViewPort—>RasInfo—>BitMap; 
picColorTable = (WORD *)picViewPort—>ColorMap->ColorTable; 
picViewModes = (ULONG)picViewPort—>Modes; 












printf("\nSaving...\n"); 









iffp = PutPicture(file, picBitMap, picColorTable, picViewModes ) ; 





Nov 1O 17:19 1988 additional_examples/ScreenSave.c Page 4 


Close(file) ; 
if (iffp == IFF_OKAY) 
{ 


printf("Screen saved\n"); 
if(!(PutDiskobject (filename, sILBMobject) ) ) 


cleanexit("Error saving icon\n"); 
} 
printf("Icon saved\n"); 


} 
cleanexit("Done\n"); 


cleanexit(s) 


char *s; 


{ 

if(*s) printf(s); 
if ((fromWB)&&(*sS)) /* Wait so user can read messages */ 
{ 

printf ("\nPRESS RETURN TO EXIT\n"); 

gets(&sbuf[0]); 


cleanup(); 
exit(); 


cleanup() 


if (newStdio) closeStdio(); 

if (GfxBase) CloseLibrary(GfxBase) ; 

if (IntuitionBase) CloseLibrary(IntuitionBase) ; 
if (IconBase) CloseLibrary(IconBase) ; 


} 


openStdio(conspec) 
char *conspec; 


LONG wifile; 
struct Process *proc; 
struct FileHandle *handle; 


if (!(wfile = Open(conspec,MODE_NEWFILE))) return(0); 
stdin = wfile; 

stdout = wfile; 

stderr = wfile; 

handle = (struct FileHandle *)(wfile << 2); 


proc = (struct Process *)FindTask(NULL) ; 
proc—>pr_ConsoleTask = (APTR)(handle->fh_Type) ; 
proc->pr_CIS = (BPTR)stdin; 

proc->pr_COS (BPTR)stdout ; 

return(1); 


ok 


closeStdio() 
( 


struct Process *proc; 
struct FileHandle *handle; 


if (stdin > 0) Close(stdin); 


stdin = ; 
stdout = -1; 
stderr = -l; 
handle = (struct FileHandle *)(stdin << 2); 


proc = (struct Process *)FindTask (NULL) ; 
proc—>pr_ConsoleTask = NULL; 
proc->pr_CIS = NULL; 


T9T — I 





Nov 10 17:19 1988 additional_examples/ScreenSave.c Page 5 


proc—>pr_COS = NULL; 
] 


gets(s) 
char *s; 


{ 
int 1 = 0, max = INBUFSZ ~- 1; 


while (((*s = getchar()) !='\n' )&&(1 < max)) st+, 1++; 
*s = NULL; 
return(1l); 


/* String Functions */ 


strlen(s) 
char *s; 


int i = 0; 
while(*st+) i++; 
return(i); 


strepy (to, from) 
char *to, *from; 


do 
xtot+ = *from; 


} 
while(*fromt+) ; 


[** PutPicture() KR KKK IKE KICK KI HK K KKK KR KEKE KEK KEKE KKK KKK EKKKKKEKKKEKKKEKKKEKEKK 
* 

Put a picture into an IFF file. 

This procedure calls PutAnILBM, passing in an <x, y> location of <0, 0>, 
a NULL mask, and a locally-allocated buffer. It also assumes you want to 

write out all the bitplanes in the BitMap. 


* 
* 
* 
* 


* 
KIKI RK RIK RIK IKE IRR RRR IKK IIT IIR IK RIKER IK IKK IR KAI AK IK RIK EEK KER KERR E / 


Point2D nullPoint = {0, 0}; 


IFFP PutPicture(file, bitmap, colorMap, viewmodes) 
LONG file; struct BitMap *bitmap; 
WORD *colorMap; ULONG viewmodes; 


{ 

BYTE buffer[bufSize] ; 

return( PutAnILBM(file, bitmap, NULL, 
colorMap, bitmap-—>Depth, viewmodes, 
énullPoint, buffer, bufSize) ); 


[** PutAnILBM{ ) KKK IK EKER KKK AIK KKK KKK KEKE KEKE KEK KERR KEKE KEKEKR EKER RKKEKKEEK 
* 

Write an entire BitMap as a FORM ILBM in an IFF file. 

This version works for any display mode (C. Scheppner). 


Normal return result is IFF_OKAY. 


The utility program IFFCheck would print the following outline of the 
resulting file: 


FORM ILBM 
BMHD 


4 + te Ot 


#define CkErr(expression) 


Nov 10 17:19 1988 additional_examples/ScreenSave.c Page 6 


* CAMG 
* CMAP 
* BODY (compressed) 


* 
FOR IIR III RIK II IRI IRI IR IKI RII RR IIR RK IK BEA IOK KIKI RI IK IRI KIKI E ERE K EKER EK / 


{if (ifferr == IFF.OKAY) ifferr = (expression) ;} 


IFFP PutAnILBM(file, bitmap, mask, colorMap, depth, 


viewmodes, xy, buffer, bufsize) 


LONG file; 
struct BitMap *bitmap; 
BYTE *mask; WORD *colorMap; UBYTE depth; 


ULONG viewmodes ; 

Point2D *xy; BYTE *buffer; LONG bufsize; 
{ 

BitMapHeader bmHdr; 

CamgChunk camgChunk ; 

GroupContext fileContext, formContext; 

IFFP ifferr; 

WORD pageWidth, pageHeight; 


pageWidth 
pageHeight 


(bitmap->BytesPerRow) << 3; 
bitmap—>Rows ; 


uou 


ifferr = InitBMHdr(ébmHdr, bitmap, mskNone, 
cmpByteRunl, 0, pageWidth, pageHeight); 
/* You could write an uncompressed image by passing cmpNone instead 
* of cmpByteRunl to InitBMHdr. */ 
bmHdr.nPlanes = depth; /* This must be <= bitmap~>Depth */ 
if (mask != NULL) bmHdr.masking = mskHasMask; 
bmHdr.x = xy~>x; bmHdr.y = xy->y; 


camgChunk.ViewModes = viewmodes & CAMGMASK; /* Mask out unwanted bits! */ 


CkErr( OpenWIFF(file, &fileContext, szNotYetKnown) ); 
CkErr(StartWGroup(&fileContext, FORM, szNotYetKnown, ID_ILBM, &formContext) ); 


CkErr(. PutBMHD(&formContext, &bmHdr) ); 

CkErr( PutCAMG(&formContext, &camgChunk) )}; 

CkErr( PutCMAP(&formContext, colorMap, depth) ); 

CkErr( PutBODY(&formContext, bitmap, mask, é&bmHdr, buffer, bufsize) ); 
CkErr( EndWGroup(&formContext) ); 

CkErr( CloseWGroup(&fileContext) ); 


return( ifferr }; 


} 


cot —- 1 


Nov 10 17:19 1988 ad 


























#include <exec/types .h> 
#include <exec/interrupts .h> 
#include <graphics/view.h> 
#include <iff/compiler.h> 





tdefine MAXNCYCS 4 
#define NO FALSE 
#define YES TRUE 
#tdefine LOCAL static 


typedef struct [{ 
SHORT count; 
SHORT rate; 
SHORT flags; 
UBYTE low, high; /* bounds of range */ 
} Range; 


/* Range flags values */ 
#define RNG_ACTIVE 1 
#define RNG_REVERSE 2 


ditional_examples/cycvb.c Page 1 







* cyevb.c --- Dan Silva's DPaint color cycling interrupt code 
* 

* Use this as an example for interrupt driven color cycling 
* If compiled with Lattice, use —v flag on LC2 

* 


For an example of subtask cycling, see Display.c 


#define RNG_NORATE 36 /* if rate == NORATE, don't cycle */ 


/* eycling frame rates */ 
#define OnePerTick 16384 
#define OnePerSec OnePerTick/60 


extern Range cycles[]; 
extern BOOL eyeling[]; 
extern WORD cycols{]; 

extern struct ViewPort *vport; 
extern SHORT nColors; 


MyVBlank() { 
int i,j; 
LOCAL Range *cyc; 
LOCAL WORD temp; 
LOCAL BOOL anyChange; 


#ifdef IS_AZTEC 


#asm 
movem.1 a2—-a7/d2—-d7,—(sp) 
move.1 al ,a4 

#endasm 

#endif 


if: (cycling) [ 
anyChange = NO; 
for (i=0; i<MAXNCYCS; it+) [ 
eye = &cycles[i); 
if ( (cyce—>low == cyc—>high) [| 
((cyce->flags&RNG_ACTIVE) == 0) 
(cyc—>rate == RNG_NORATE) ) 
continue; 


eye—>count += cyc—>rate; 

if (cyc—>count >= OnePerTick) [ 
anyChange = YES; 
cye->count -= OnePerTick; 





| if (cyc—>flags&RNG_REVERSE) 


I 














Nov 10 17:19 1988 additional_examples/cycvb.c Page 2 


temp = cycols[cyc—>low] ; 

for (j=cyc—>low; j < cyc—>high; j++) 
cycols{j] = cycols[j+1]; 

cycols{cyc—>low] = temp; 


else { 
temp = cycols[cyc->high] ; 
for (j=cyc->high; j > cye->low; j—-) 
cycols[j] = cycols[j-1]; 
cycols[cyc—>low] = temp; 


; ] 
if (anyChange) LoadRGB4 (vport ,cycols,nColors) ; 
} 


#ifdef IS_AZTEC . 

; /* this is necessary */ 
#asm 

movem.1 (sp)+,a2-a7/d2-d7 
#endasm 
fendif 


return(0); /* interrupt routines have to do this */ 


} 


* 
* Code to install/remove cycling interrupt handler 


*/ 


LOCAL char myname[] = “MyVB"; /* Name of interrupt handler */ 
LOCAL struct Interrupt intServ; 


typedef void (*VoidFunc)(); 


StartVBlank() {[ 
#ifdef IS. AZTEC 
intServ.is_Data 
#else 
intServ.is Data = NULL; 
#tendif 
intServ.is_Code = (VoidFunc) 6MyVBlank; 


tt 


GETAZTEC(); /* returns contents of register a4 */ 


intServ.is Node.1n_Suce = NULL; 
intServ.is Node.1n_Pred = NULL; 
intServ.is_Nodé.1n_ Type = NT_INTERRUPT; 
intServ.is Node.1In Pri = 0; 

intServ.is Node.1n_Name = myname; 


AddIntServer(5,sintServ) ; 
} 


StopvBlank() { RemIntServer(5,&intServ) ; } 


[**/ 











€e9T - I 





Nov 10 17:19 1988 


additional_examples/apack.asm Page 1 


KHIR KKK HR KEK IKK KK IKE KIRK ERK IK IKI KIKI KIRKE KIKI KIKI KKK 


* 
* 
x 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
x 
* 
x 
* 
* 
* 
* 
* 
* 
* 
* 
x 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
* 
x 
* 
x 
* 
* 
* 


PT 
Ix 
IP 


OP 
FP 
SP 


Copyright 1988 by CREATIVE FOCUS. This code is freely 
distributable as long as this notice is retained and no 
other conditions are imposed upon its redistribution. 


APACK.ASM —— 
A fully compatible replacement for Electronic Arts! PACKER.C 
routine. Converts data according to the IFF ILBM cmpByteRunl 


compression protocol: 


control bytes: 


n= 0.. 127: followed by n+l bytes of data; 
n = -1..-127: followed by byte to be repeated ~n+l times; 
n= -128: don't do no nada. 


calling format: 


long PackRow(from, too, amt) 
char **from, /* pointer to source data pointer */ 
xktoo; /* pointer to destination data pointer */ 
long amt; 7* number of bytes to compress */ 


return(number of bytes written to destination) ; 
effects: 


xfrom = *from + amt, and *too = *too + return; 
return is "smart," that is,. not greater than 
MaxPackedSize = amt + ((amt+127) >> 7). 


By commenting out CHECK (below) you disable checking for runs 
exceeding 128 bytes. That CHECK is not needed if you are sure 
the amt to be compressed is always 128 or less. 


!!! DISCLAIMER !!! You use this code entirely at your own 
risk. I don't warrantee its fitness for any purpose. I 
can't even guarantee the accuracy of anything I've said 
about it, though I've tried my damndest to get it right. 

I may, in fact, be completely out of my tiny little mind :~). 


That being said, I can be reached for questions, comments, 
or concerns at: 


Dr. Gerald Hull 
CREATIVE FOCUS 
12 White Street 
Binghamton, N.Y. 
(607) 648-4082 


13901 


bix: ghull 
PLink: DRJERRY 


KKK KEKE KIRKE KEE KI KIRK ERIK EI KRI KKK ER KEKE EK KEK KEK KKK KE 


xdef _PackRow 

equr a0 -> beginning of replicate run (if any) 
equr al -> end+l of input line 

equr a2 —> beginning of literal run (if any) 
equr a3 -> endtl of lit and/or rep run (if any) 
equr a4 —> end+l of output line current pos 
equr a6 frame pointer 


equr a7 stack pointer 


Nov 10 17:19 1988 


RT equr dod 

MX equr dl 

AM equr d2 

CH equr 4d3 

REGS reg  AM/CH/IP/IQ/OP 

FRM equ 8 

Too equ 12 

AMT equ 16 

MAX equ 128 

* CHECK equ 1 

_ PackRow 

KKKEKEKKKKKKKKESK CASE QO: 

CASO 
link FP, #0 
movem.1 REGS,—(SP) 
movea.] FRM(FP),IP 
movea.l (IP),IP 
movea.l IP,IQ 
movea.l IQ,IX 
adda.1 AMT(FP),1IX 
movea.l1 TOO(FP),OP 
movea.] (OP),OP 

KEKKKKEKKEEEEAE CASE l: 

CAS1 
movea.l1 IQ,PT 
move.b (10Q)+,CH 
empa.1l IQ,1X 
beq.s CAS5 
ifd CHECK 
move.l I0Q,MX 
sub. 1 IP ,MX 
cmpi #MAX ,MX 
beq.s CAS6 
endc : 
cmp.b (1Q) ,CH 
bne.s cASL 

* 

KR Ka RK CASE 2: 

CAS2 
move.b  (1Q)+,CH 
cmpa.1 IQ,IX 
beq.s CAST 
ifd CHECK 
move.1 IQ,MX 
sub.1 IP ,MX 
empi #MAX ,MX 
beg.s CAS6 
endc 
cmp.b (1Q) ,CH 
bne.s CASL 


additional_examples/apack.asm Page 2 


return value 

check for maximum run = MAX 
amount 

character 


input line address 
output line address 
length of input line 


maximum encodable output run 
turns on maximum row checking 


GRAB PARAMS & INITIALIZE 


IP = *from 
IQ = IP 

IX = IP + amt 
OP = *too 
LITERAL RUN 


adjust PT (no replicates yet!) 
grab character 
if input is finished 

branch to case 5 


if run has reached MAX 
branch to case 6 


if next character != CH 
stay in case 1 


else fall into case 2 


AT LEAST 2 BYTE REPEAT 

grab character 

if input is finished 
branch to case 7 


if run has reached MAX 
branch to case 6 


if next character != CH 
branch to case 1 


else fall into case 3 





vot -— 1 





Nov 10 17:19 19 


KEKKKKKKEEKEKEK 
CAS3 
move.b 
cmpa.1 
beq.s 


ifd 
move.1 
- sub.t 


KEKKKEKKEKEKEREEK 
CAS4 
move.1 
sub.1 


beq.s 
subg 


move .b 


c40 = move.b 
dbra 


c41 = move. 1 
sub.1 
addq 
move .b 
move .b 
movea.1 
bra.s 





88 additional_examples/apack.asm Page 3 


CASE 3: 


(1Q)+,CH 
IQ,1X 
CAS7 


CHECK 
TQ, MX 
PT MX 
#MAX ,MX 
CAS4 


(1Q) ,CH 
CAS3 


CASE 4: 


PT, AM 
IP,AM 


c41 


#1,AM 
AM, (OP )+ 


(IP)+, (OP)+ 
AM,C40 


PT, AM 
1Q,AM 
#1,AM 
AM, (OP)+ 
CH, (OP)+ 
1Q,1P 
CAS1 


REKKEKKKKEKREKKE CASE 5: 
CAS5 

move.1 IQ,AM 

sub.1 IP,AM 

subg #1,AaM 

move.b AM, (OP)+ 
c50)=—s move..b (IP)+, (OP)+ 

dbra AM,C50 

bra.s CAS8 

ifd CHECK 
KEEKKKREKEKERERE CASE 6: 
CAS6 

move. 1 IQ,AM 

sub.1 IP,AM 

subg #1,AM 

move.b AM,(OP)+ 


C60) = move.b 


(IP)+,(OP)+ 
0 


7c 


bra CAS1 


REPLICATE RUN 


grab character 
if input is finished 
branch to case 7 


if run has reached MAX 
branch to case 4 


if next character = CH 
stay in case 3 


else fall into case 4 
LIT AND/OR REP DUMP & CONTINUE 


AM = PT ~ IP 
if no literal run 
branch to replicate run 


AM = AM - 1 
output literal control byte 


output literal run 


AM = PT — IQ (negative result!) 
AM = AM + 1 

output replicate control byte 
output repeated character 
reset IP 

branch to case 1 (not done) 


LITERAL DUMP & QUIT 


AM = IQ - IP (positive result > 0) 
AM = AM ~ 1 
output literal control byte 


output literal run 


branch to case 8 (done) 


LITERAL DUMP & CONTINUE 


AM = IQ - IP (positive result > 0) 
AM - 1 


AM 
output literal control byte 


ie 


output literal run 


branch to case 1 (not done) 





Nov 10 17:19 


KEK KERR IKE KKRER CASE 7: 
CAS7 
move.1 PT, AM 
sub.1 IP, AM 
* 
beq.s c71 
subg #1,AM 
move.b AM, (OP)+ 
C70 move.b (IP)+, (OP)+ 
dbra AM,C70 
c71 move.1 PT, AM 
sub.1 1Q,AM 
addq #1,AaM 
move.b AM, (OP)+ 
move.b CH, (OP)+ 


KKK 


CAS8 








endc 


movea.] FRM(FP),PT 
move.1 IQ, (PT) 
movea.1 -TOO(FP) ,PT 


move.1 oP ,RT 
sub.1 (PT) ,RT 
move.1 OP, (PT) 
movem.1 (SP)+,REGS 
UNLK FP 

rts 

end 


CASE 8: 





1988 additional _examples/apack.asm Page 4 


LIT AND/OR REP DUMP & FINISH 


AM = PT — IP (positive result > 0) 
if no literal run 
branch to replicate run 


AM = AM - 1 
output literal control byte 


output literal run 


AM = PT — IQ (negative result) 
AM = AM + 1 : 

output replicate control byte 
output repeated character 


fall into case 8 


ADJUST PARAMS & RETURN VALUE 
PT = **from 

*from = *from + amt 

PT = **too 
return = OP — *too 


*too = *too + return 








Section J 


Function Index 


This section contains an alphabetical listing of system functions. Use this when you 
know the name of a function, but not what system module the function is a part of. 


















CopyMem 
CopyMemQuick 
CopySBitMap 
CreateBehindLayer 
CreateDir 
CreateExtIO 
CreatePort 


CWAIT 
DateStamp 
dbf 
Deallocate 
Debug . 


DeviceProc 
Disable 
DisownBlitter 
DisplayAlert 
DisplayBeep 
DisposeFontContents 
DisposeLayerInfo 
DisposeRegion 
pocollision 

DoIO 

DoubleClick 


FattenLayerInfo 
FindConfigDev 
FindName 





parallel .device 
audio.device 
serial.device 
printer.device 
narrator.device 
parallel .device 
audio.device 
clipboard.device 
audio.device 
serial .device 
console.device 
printer.device 
narrator.device 
parallel .device 
clipboard.device 
graphics. library 
timer .device 
expansion. library 
expansion. library 
exec. library 
exec. Library 
graphics. library 
layers. library 
dos. library 
amiga. lib 

amiga. lib 

dos. library 
amiga.lib 

layers. library 
dos. library 
intuition. library 
graphics. library 
dos.library 
amiga. 1lib/math 
exec. Library 
exec. library 

dos. library 
amiga. lib 

dos. library 
layers. library 
amiga.1lib 

amiga. lib 

dos. library 

exec. library 
graphics. library 
intuition. library 
intuition. library 
diskfont. library 
layers. library 
graphics. library 
graphics. library 
exec. library 
intuition. library 
graphics. library 
intuition. library 
graphics. library 
graphics. library 
intuition. library 
dos. library 

exec. library 
intuition. library 
intuition. library 
layers. library 
exec. library 

dos. library 

dos. library 

dos. library 

dos. library 
amiga. lib 

layers. library 
expansion.library 
exec. library 






B-l 

B-58 
B-47 
B-36 
B-41 
B-l 

B-ll 
B-l 

B-58 
B-15 


‘B-47 


B-36 
B-41 
B-ll 
A-64 
B-66 
A-52 
A-52 


aA-4 
A-64 
A-166 
ae 
F-1 
F-l 
ke 
F-1 
A-166 
ae 
A-124 
A-64 
ee 
F-l 
A~4 
A-4 
*k 
F-1 
ae 
A-166 
F-1 
F-1 
ae 
aA-4 
A-64 
A-124 
A~124 
Al 
B-166 
B-64 
A-64 
a-4 
A-124 
A~64 
A-124 
B-64 
A~64 
A-124 
kK 
A-4 
A-124 
B-124 
A-166 
aA-4 
xk 

xk 

xk 

xk 
F-1 
A-166 
A-52 


FindSemaphore 
FindTask 
FindToolType 
Flood 

Forbid 

fpa 

fpbed 
FreeBoardMem 
FreeColorMap 
FreeConfigDev 
FreeCopList 
FreeCprList 
FreeDiskobject 
FreeEntry 
FreeExpansionMem 
FreeFreeList 
FreeGBuffers 
FreeMem 
FreePotBits 
FreeRaster 
FreeRemember 
FreeSignal 
FreeSprite 
FreeSysRequest 
FreeTrap 
FreeUnit 
FreevPortCopLists 
Getcc 
GetColorMap 
GetCurrentBinding 
GetDefPrefs 
GetDiskObject 
GetGBuffers 
GetMsg 
GetPrefs 
GetRGB4 
GetScreenData 
GetSprite 
GetUnit 
GetUnitID 
GiveUnit 
GPD_ASKCTYPE 
GPD_ASKTRIGGER 
GPD_READEVENT 
GPD_SETCTYPE 
GPD_SETTRIGGER 
IEEEDPAbs 
IEEEDPACcOS 
IEEEDPAdd 
JEEEDPAsin 
IEEEDPAtan 
JEEEDPCeil 
IEEEDPCmp 
IEEEDPCos 
IEEEDPCosh 
IEEEDPDiv 
IBEEDPEXp 
IEEEDPFieee 
IEEEDPFix 
IEEEDPFloor 
IEEEDPF1t 
IEEEDPLog 
JEEEDPLog10 
IEEEDPMul 
[EEEDPNeg 
IEEEDPPow 
IEEEDPSin 
IEEEDPSincos 
IEEEDPSinh 
TEEEDPSgrt 








A-4 





exec. library 
exec. Library 
exec. Library 
exec. Library 
icon. library 
graphics.library 
exec. library 
amiga. lib/math 
amiga. lib/math 
expansion. library 
graphics. library 
expansion. ]ibrary 
graphics.library 
graphics. library 
icon. library 
exec. Library 
expansion. library 
icon. library 
graphics. library 
exec. library 
potgo. resource 
graphics. library 
intuition. library 
exec. library 
graphics. library 
intuition. library 
exec. library 
disk. resource 
graphics. library 
exec, Library 
graphics.library 
expansion. library 
intuition. library 
icon. library 
graphics. library 
exec. library 
intuition. library 
graphics .library 
intuition. library 
graphics. library 
disk. resource 
disk .resource 
disk. resource 
gameport .device 
gameport .device 
gameport .device 
gameport .device 
gameport ..device 
mathieeedoubbas. library 


mathieeedoubtrans. library 


mathieeedoubbas. library 


mathieeedoubtrans. library 
mathieeedoubtrans. library 


mathieeedoubbas. library 
mathieeedoubbas. library 


mathieeedoubtrans. library 
mathieeedoubtrans. library 


mathieeedoubbas. library 


mathieeedoubtrans. library 
mathieeedoubtrans. library 


mathieeedoubbas. library 
mathieeedoubbas. library 
mathieeedoubbas. library 


mathieeedoubtrans. library 
mathieeedoubtrans. library 


mathieeedoubbas. library 
mathieeedoubbas. library 


mathieeedoubtrans. library 
mathieeedoubtrans. library 
mathieeedoubtrans. library 
mathieeedoubtrans. library 
mathieeedoubtrans. library 


A-4 
A-4 
A-4 
A-4 
A~-l19 
A-64 
A-4 
F-1 
F-l 
A~52 
A~64 
A-52 
A-64 
A-64 
A-119 
A-4 
A-52 
A-119 
A-64 
A~-4 
c-9 
A-64 
A-124 
A-4 
A~64 
A-124 
A-4 
c-4 
A-64 
A-A 
A-64 
A-52 
A-124 
a-119 
A-64 
a-4 
A-124 
A-64 
A-124 
A-64 
c-4 
c~4 
c-4 
B-22 
B-22 
B-22 
B-22 
B-22 
A-196 
A-193 
A-196 
A-193 
A-193 
A-196 
A-196 
A-193 
A-193 
A-196 
A-193 
A-193 
A-196 
A-196 
A-196 
A-193 
A-193 
A-196 
A-196 
A-193 
A-193 
A-193 
A-193 
A-193 


















IEEEDPSub 
IEEEDPTan 
IEEEDPTanh 
IEEEDPTieee 
IEEEDPTst 
Info 
InitArea 


InitRastPort 
InitRequester 
InitResident 
InitSemaphore 
InitStruct 
InitTmpRas 
InitView 


InstallClipRegion 
IntuiTextLength 
IoErr 

IsInteractive 
ItemAddress 
KBD_ADDRESETHANDER 
KBD_READEVENT 
KBD_READMATRIX 
KBD_REMRESETHANDLER 
KBD_RESETHANDLERDONE 


LockiBase 
LockLayer 
LockLayerInfo 


MakeFunctions 
MakeLibrary 
MakeScreen 
MakevPort 


MR_ALLOCMISCRESOURCE 
MR_FREEMISCRESOURCE 
NewFontContents 
NewLayerInfo 
NewList 

NewModi fyProp 
NewRegion 
ObtainConfigBinding 





mathieeedoubbas. 
mathieeedoubtrans. 
mathieeedoubtrans. 
mathieeedoubtrans. 
mathieeedoubbas. 
dos. 

graphics. 
graphics. 

exec. 

graphics. 
graphics. 

layers. 

graphics. 
graphics. 
intuition. 

exec. 

exec. 

exec. 

graphics. 
graphics. 
graphics. 

dos. 

exec. 

layers. 

intuition. 

dos. 

dos. 

intuition. 


library 
library 
library 
library 
library 
library 
library 
library 
Library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 


keyboard .device 
keyboard. device 
keyboard.device 
keyboard .device 
keyboard .device 
debug. 1ib 
debug. lib 
debug. lib 
debug.1lib 
debug.1lib 
debug. lib 
debug.lib 


graphics. 
dos. 
graphics. 
- library 
intuition. 
layers. 
layers. 
graphics. 
layers. 
expansion. 
exec. 
exec. 
intuition. 
graphics. 
icon. 
intuition. 
intuition. 
graphics. 
layers. 
layers. 
intuition. 
graphics. 
intuition. 
graphics. 


dos 


library 
library 
library 


library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 
library 


mise. resource 
misc. resource 


diskfont. 
layers. 


library 
library 


amiga.1lib 


intuition. 
graphics. 
expansion. 





library 
library 
library 


A-196 
A-193 
A-193 
A-193 
A-196 
ak 
A-64 
A-64 
A~4 
A-64 
A-64 
A-166 
A-64 
A-64 
A-124 
A-4 
A-4 
A-4 
A-64 
A-64 
A-64 
** 
A-4 
A-166 
A-124 
hk 

ak 
A~-124 
B-32 
B-32 
B-32 
B-32 
B-32 
F-15 
F-15 
F~-15 
F-15 
F-15 
F-15 
F-15 
A-64 
ak 
A-64 
ak 
A~124 
A-166 
A-166 
A-64 
A-166 
A-52 
A~4 
A-4 
A~-124 
A-64 
A-119 
A~124 
A-124 
A~64 
A-166 
A-166 
A-124 
A-64 
A-124 
A-64 
Cc-7 
Cc-7 
A-l 
A-166 
F-l1 
A~124 
A~-64 
A-52 





ObtainSemaphore 
ObtainSemaphoreList 
offGadget 

Of fMenu 
OldOpenLibrary 
OnGadget 
OnMenu 

Open 
OpenDevice 
OpenDevice 
OpenDevice 
OpenDevice 
OpenDevice 
OpenDevice 
OpenDiskFont 
OpenFont. 
OpenLibrary 
OpenResource 
OpenScreen 
OpenWindow 
OpenWorkBench 
OrRectRegion 
OrRegionRegion 
Output 
OwnBlitter 
ParentDir 
PDCMD_QUERY 
PDCMD_SETPARAMS 
Permit 
PolyDraw 
PRD_DUMPRPORT 
PRD_PRTCOMMAND 
PRD_QUERY 
PRD_RAWWRITE 
printf 
PrintIText 
Procure 
PutDiskObject 
PutMsg 

PWrite 

QBLit 

OBSBLit 
RangeRand 
RawDoFmt. 
RawKeyConvert 
Read 
ReadExpansionByte 
ReadExpansionRom 
ReadPixel 
RectFill 
RefreshGadgets 
RefreshGList 
RefreshWindowFrame 
ReleaseConfigBinding 
ReleaseSemaphore 
ReleaseSemaphoreList 
RemakeDisplay 
RemBob 
RemConfigDev 
RemDevice 
RemFont 
RemHandler 
RemHead 
RemIBob 
RemICRVector 
RemiIntServer 
RemLibrary 
Remove 
RemoveGadget. 
RemoveGList 
RemPort 
RemResource 


exec. Library 
exec. Library 
intuition. library 
intuition. library 
exec. library 
intuition. library 
intuition. library 
dos. library 
audio. device 
exec. Library 
serial.device 
console.device 
narrator.device 
parallel.device 
diskfont. library 
graphics. library 
exec. library 
exec. library 
intuition. library 
intuition. library 
intuition. library 
graphics. library 
graphics. library 
dos. library 
graphics. library 
dos. library 
parallel.device 
parallel .device 
exec. library 
graphics. library 
printer.device 
printer.device 
printer.device 
printer.device 


amiga.lib. 


intuition. library 
exec. library 
icon. library 
exec. library 
printer.device 
graphics. library 
graphics. library 
amiga.lib 

exec. library 
console. device 
dos. library 
expansion. library 
expansion. library 
graphics. library 
graphics.library 
intuition. library 
intuition. library 
intuition. library 
expansion. library 
exec. library 
exec. library 
intuition. library 
graphics. library 
expansion. library 
exec. library 
graphics. library 
input .device 
exec. Library 
graphics. library 
cla. resource 
exec, Library 
exec. library 
exec. library 
intuition. library 
intuition. library 
exec. library 
exec. library 


A-4 


A-124 
A-124 
A-4 
A-124 
A-124 
*k 
B-1 
A-4 
B-58 
B-15 
B~36 
B-41 
A-1 
A-64 
A-4 
A-4 
A-124 
A-124 
A-124 
A-64 
A-64 
xe 
A-64 
nk 
B-41 
B-41 
A-4 
A-64 
B-47 
B-47 
B-47 
B-47 


A-119 


B-47 
A-64 
A-64 
F-1 
A~4 
B-15 
x 
A-52 
A-52 
A-64 
A~-64 
A-124 
A-124 
A-124 
A-52 
A-4 
A-4 
A~124 
A-64 
A-52 
A-4 
A-64 
B-26 
A-4 
A-64 
c~-1 
A-4 
A-4 
A-4 
A-124 
A-124 
A-4 
An4 






RemVSprite 
Rename 
ReplyMsg 
ReportMouse 


RethinkDisplay 
ScreenToBack 
ScreenToFront 
ScrollLayer 
ScrollRaster 
SerollvPort 
SDCMD_QUERY 
SDCMD_SETPARAMS 
Seek 

SendIo 
SetAPen 
SetBPen 
SetCollision 
SetComment 
SetCurrentBinding 
SetDMRequest 
SetDrMd 
SetExcept 
SetFont 
SetPunction 
SetICR 
SetIintVector 
SetMenuStrip 
SetMPort 
SetMTrig 
SetMType 
SetOPen 
SetPeriod 
SetPointer 
SetPrefs 
SetProtection 


SetRGB4CM 
SetSignal 
Setsoftstyle 
SetsR 
SetTaskPri 
SetThresh 
SetWindowTitles 
ShowTitle 
Signal 
SizeLayer 
SizeWindow 
SortGList 
SPAbs 


exec. library sprintf 
exec. library A-4 spSin 
exec. library A-4 sPSincos 
amiga.lib F-l sPSinh 
graphics.library A~64 sPsqrt 
dos.library ** sPSub 
exec.library A-4 SPTan 
intuition.library A-124 |SPTanh 
intuition.library A-124 |SPTieee 
input.device B-26 jSPTst 
intuition.library A-124 |Start 
intuition.library A-124 |stdio 
intuition. library A-124 |SubTime 
layers.library A-166 |SumKickData 
graphics.library A-64 SumLibrary 
graphics.library A-64 |SuperState 
serial.device 8-58 |SwapBitsRastPortClipRect 
serial.device B-58 |SyncSBitMap 
dos.library ** TD_ADDCHANGEINT 
exec.library A-4 TD_CHANGENUM 
graphics.library A~64 TD _CHANGESTATE 
graphics.library A-64 |TD_FORMAT 
graphics.library A~64 |TD_GETDRIVETYPE 
dos.library ** TD_GETNUMTRACKS 
expansion.library A-52 |TD MOTOR 
intuition.library A-124 |'TD_PROTSTATUS 
graphics.library A-64 /TD_RAWREAD 
exec. library A-4 TD_RAWWRITE 
graphics.library A-64 TD_REMCHANGEINT 
exec.library A~4 TD_SEEK 
cia.resource C-l Text 
exec. library A-4 TextLength 
intuition.library A-124 |ThinLayerInfo 
input.device B-26 |Translate 
input.device B-26 |TR_ADDREQUEST 
input.device B-26 |TR_GETSYSTIME 
graphics.library A~64 TR_SETSYSTIME 
input.device B-26 |TypeOfMem 
intuition.library A-124 |UnLoadSeg 
intuition.library A-124 |UnLock 
dos.library ** UnlockIBase 
graphics.library A-64 UnlockLayer 
graphics.library A-~64 UnlockLayeriInfo 
graphics.library A-64 UnlockLayerRom 
exec. library A~4 UnlockLayers 
graphics.library A-64 |UpfrontLayer 
exec. library A~4 UserState 
exec.library A-4 Vacate 
input.device B-26 |VBeamPos 
intuition.library A-124 |ViewAddress 
intuition. library A-124 |[ViewPortAddress 
exec. library A-4 Wait 
layers.library A-166 WaitBlit 
intuition.library A-124 |WaitBOVP 
graphics.library A-64 WaitForChar 
mathffp.library A-197 |WaitIo 
mathtrans.library . A-202 |WaitPort 
mathffp. library A~197 |WaitTOF 
mathtrans. library A-202 |)WBerchToBack 
mathtrans. library A~202 |WBenchToFront 
mathffp. library A-197 |WhichLayer 
mathtrans. library A-202 |WindowLimits 
mathtrans. library A~202 |WindowToBack 
mathffp.library A-197 |WindowToi‘ront 
mathtrans.library A-202 |Write 
mathtrans.library A-202 |WriteEvent 
mathffp.library A-197 WriteExpansionByte 
mathtrans. library A-202 |WritePixel 
mathtrans. library A-202 |WritePotgo 
mathffp.library A-197 XorRectRegion 
mathffp.library A-197 figeRostontegion 
mathtrans.library A~202 |** dos. library is documented in the AmigaDOS Manual 
































































amiga. lib 
mathtrans. library 
mathtrans. library 
mathtrans. library 
mathtrans. library 
mathffp.library 
mathtrans. library 
mathtrans. library 
mathtrans. library 
mathffp.library 
input .device 
amiga. lib 

timer .device 
exec. library 
exec. Library 
exec. library 
layers. library 
graphics. library 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
trackdisk.device 
graphics. library 
graphics. library 
layers. library 
translator. library 
timer .device 
timer .device 
timer .device 
exec. library 

dos. library 

dos. library 
intuition. library 
layers.library 
layers. library 
graphics. library 
layers. library 
layers.library 
exec. library 
exec. Library 
graphics.library 
intuition. library 
intuition. library 
exec, library 
graphics.library 
graphics. library 
dos. library 

exec. Library 
exec. library 
graphics. library 
intuition. library 
intuition. library 
layers.library 
intuition. library 
intuition. library 
intuition. library 
dos. library 

input .device 
expansion. library 
graphics. library 
potgo. resource 
graphics. library 
graphics. library 


F-] 
A-202 
A-202 


A-202 
A-202 
A-197 
A-202 
A-202 
A~-202 
A-197 
B-26 
F-l 
B-66. 
A-4 
A-4 
A-4 
A-166 
A-64 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
B-70 
A-64 
A-64 
A-166 
A-211 
B-66 
B-66 
B-66 
A-4 
ak 
ae 
A-124 
A-166 
A-166 
A-64 
A-166 
A-166 
A-4 
A-4 
A-64 
A-124 
A-124 
A-4 
A-64 
A~64 
x 
A-4 
a-4 
A-64 
A-124 
A-124 
A-166 
A-124 
A-124 
A-124 
ak 
B-26 
A-52 
A-64 
c-9 
A-64 
A-64 





Amiga Programming > $32-95 FPT USA 


Amiga’ Technical Reference Series 


AMIGA ROM KERNEL 


REFERENCE MANUAL: - 
INCLUDES & AUTODOCS 
REVISED & UPDATED 


The Amiga computers are exciting high-performance microcomputers with superb graph- 
ics, Sound, multiwindow and multitasking capabilities. Their technologically advanced 
hardware is designed around the Motorola 68000 microprocessor family and sophisti- 
cated custom chips that control graphics, audio, peripherals, and input/output to other 
equipment. The Amiga’s unique operating system software provides programmers with 
unparalleled power, flexibility, and convenience in designing and creating programs. 


Written by the technical experts at Commodore-Amiga, Inc., who design the Amiga hard- 
ware and system software, the AMIGA ROM KERNEL REFERENCE MANUAL: 
INCLUDES AND AUTODOCS is the essential reference tool for all Amiga 
programmers. 


Based on the new version 1.3 of the system software, this revised and updated 
volume includes: 


autodocs for each Library, Device, and Resource call in the system 

the C and Assembly language Amiga Include Files 

documentation on “‘Amiga.lib” and example source code 

complete example source code for a library and a fast filing system compatible 
RAM-disk device 

examples showing how the information in each section is used 

_ numerous reference charts 

_ documentation on the Interchange File Format standard (IFF) 

_ alphabetical, detailed summaries of all Amiga system functions and structures. 


The revised Amiga Technical Reference Series includes two other volumes of vital 
information for Amiga programmers and developers: Amiga Hardware Reference Manual 
is updated with information on new Amiga computers and Amiga ROM Kernel Reference 
Manual: Libraries and Devices, a new, all-inclusive tutorial, covers all Amiga system libraries 
and devices, including Exec and Intuition. 


Cover design by Mike Fender 


35.29 5 
A 
vv 


Addison-Wesley Publishing Company, Inc. al lds 
ISBN 0-201-18177-0 


